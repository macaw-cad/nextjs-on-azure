_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["pages/[[...path]]"],{

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/components/ComponentPropsContext.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/components/ComponentPropsContext.js ***!
  \*****************************************************************************************************/
/*! exports provided: ComponentPropsReactContext, useComponentProps, ComponentPropsContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentPropsReactContext", function() { return ComponentPropsReactContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useComponentProps", function() { return useComponentProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentPropsContext", function() { return ComponentPropsContext; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Component props context which we are using in order to store data fetched on components level (getStaticProps/getServerSideProps)
 */
const ComponentPropsReactContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])({});
/**
 * Hook in order to get access to props related to specific component. Data comes from ComponentPropsContext.
 * @see ComponentPropsContext
 * @param {string} componentUid component uId
 * @returns {ComponentData} component props
 */
function useComponentProps(componentUid) {
    const data = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(ComponentPropsReactContext);
    return data[componentUid];
}
const ComponentPropsContext = ({ children, value, }) => (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(ComponentPropsReactContext.Provider, { value: value }, children));


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/components/Link.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/components/Link.js ***!
  \************************************************************************************/
/*! exports provided: Link */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return Link; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-react */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/index.js");
/* harmony import */ var _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3__);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const Link = (props) => {
    const { editable, internalLinkMatcher = /^\//g, showLinkTextWithChildrenPresent } = props, htmlLinkProps = __rest(props, ["editable", "internalLinkMatcher", "showLinkTextWithChildrenPresent"]);
    const value = (props.field.href
        ? props.field
        : props.field.value);
    const { href } = value;
    const isEditing = editable && props.field.editable;
    if (href && !isEditing) {
        const text = showLinkTextWithChildrenPresent || !props.children ? value.text || value.href : null;
        // determine if a link is a route or not.
        if (internalLinkMatcher.test(href)) {
            return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, { href: href, key: "link", locale: false },
                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", Object.assign({ title: value.title, target: value.target, className: value.class }, htmlLinkProps),
                    text,
                    props.children)));
        }
    }
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3__["Link"], Object.assign({}, props));
};
Link.defaultProps = {
    editable: true,
};
Link.displayName = 'NextLink';
Link.propTypes = Object.assign({ internalLinkMatcher: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.instanceOf(RegExp) }, _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3__["LinkPropTypes"]);


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/components/RichText.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/components/RichText.js ***!
  \****************************************************************************************/
/*! exports provided: RichText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RichText", function() { return RichText; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-react */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/index.js");
/* harmony import */ var _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3__);
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




const prefetched = {};
const RichText = (props) => {
    const { internalLinksSelector = 'a[href^="/"]' } = props, rest = __rest(props, ["internalLinksSelector"]);
    const hasText = props.field && props.field.value;
    const isEditing = props.editable && props.field && props.field.editable;
    const router = Object(next_router__WEBPACK_IMPORTED_MODULE_2__["useRouter"])();
    const richTextRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(() => {
        // NOT IN EXPERIENCE EDITOR
        if (hasText && !isEditing) {
            initializeLinks();
        }
    }, []);
    const routeHandler = (ev) => {
        if (!ev.target)
            return;
        ev.preventDefault();
        const pathname = ev.target.pathname;
        router.push(pathname, pathname, { locale: false });
    };
    const initializeLinks = () => {
        const node = richTextRef.current;
        // selects all links that start with '/'
        const internalLinks = node && node.querySelectorAll(internalLinksSelector);
        if (!internalLinks || !internalLinks.length)
            return;
        internalLinks.forEach((link) => {
            if (!prefetched[link.pathname]) {
                router.prefetch(link.pathname, undefined, { locale: false });
                prefetched[link.pathname] = true;
            }
            link.addEventListener('click', routeHandler, false);
        });
    };
    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3__["RichText"], Object.assign({ ref: richTextRef }, rest));
};
RichText.propTypes = Object.assign({ internalLinksSelector: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string }, _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_3__["RichTextPropTypes"]);
RichText.defaultProps = {
    tag: 'div',
    editable: true,
};
RichText.displayName = 'NextRichText';


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/constants.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/constants.js ***!
  \******************************************************************************/
/*! exports provided: JSS_MODE_CONNECTED, JSS_MODE_DISCONNECTED */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSS_MODE_CONNECTED", function() { return JSS_MODE_CONNECTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSS_MODE_DISCONNECTED", function() { return JSS_MODE_DISCONNECTED; });
const JSS_MODE_CONNECTED = 'connected';
const JSS_MODE_DISCONNECTED = 'disconnected';


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js ***!
  \**************************************************************************/
/*! exports provided: dataApi, mediaApi, AxiosDataFetcher, GraphQLRequestClient, GraphQLDictionaryService, RestDictionaryService, LayoutServicePageState, GraphQLLayoutService, RestLayoutService, isExperienceEditorActive, resetExperienceEditorChromes, getChildPlaceholder, getFieldValue, JSS_MODE_CONNECTED, JSS_MODE_DISCONNECTED, ComponentPropsService, DisconnectedSitemapService, GraphQLSitemapService, ComponentPropsReactContext, ComponentPropsContext, useComponentProps, handleExperienceEditorFastRefresh, isEditingData, EditingDataService, editingDataService, Link, RichText, Placeholder, Image, Text, DateField, File, VisitorIdentification, SitecoreContext, SitecoreContextReactContext, withSitecoreContext, useSitecoreContext, withExperienceEditorChromes, withPlaceholder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss */ "./node_modules/@sitecore-jss/sitecore-jss/dist/index.js");
/* harmony import */ var _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dataApi", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["dataApi"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mediaApi", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["mediaApi"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AxiosDataFetcher", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["AxiosDataFetcher"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GraphQLRequestClient", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["GraphQLRequestClient"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GraphQLDictionaryService", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["GraphQLDictionaryService"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RestDictionaryService", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["RestDictionaryService"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LayoutServicePageState", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["LayoutServicePageState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GraphQLLayoutService", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["GraphQLLayoutService"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RestLayoutService", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["RestLayoutService"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isExperienceEditorActive", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["isExperienceEditorActive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetExperienceEditorChromes", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["resetExperienceEditorChromes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getChildPlaceholder", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["getChildPlaceholder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFieldValue", function() { return _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["getFieldValue"]; });

/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSS_MODE_CONNECTED", function() { return _constants__WEBPACK_IMPORTED_MODULE_1__["JSS_MODE_CONNECTED"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JSS_MODE_DISCONNECTED", function() { return _constants__WEBPACK_IMPORTED_MODULE_1__["JSS_MODE_DISCONNECTED"]; });

/* harmony import */ var _services_component_props_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./services/component-props-service */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/component-props-service.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComponentPropsService", function() { return _services_component_props_service__WEBPACK_IMPORTED_MODULE_2__["ComponentPropsService"]; });

/* harmony import */ var _services_disconnected_sitemap_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./services/disconnected-sitemap-service */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/disconnected-sitemap-service.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DisconnectedSitemapService", function() { return _services_disconnected_sitemap_service__WEBPACK_IMPORTED_MODULE_3__["DisconnectedSitemapService"]; });

/* harmony import */ var _services_graphql_sitemap_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./services/graphql-sitemap-service */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/graphql-sitemap-service.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GraphQLSitemapService", function() { return _services_graphql_sitemap_service__WEBPACK_IMPORTED_MODULE_4__["GraphQLSitemapService"]; });

/* harmony import */ var _components_ComponentPropsContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/ComponentPropsContext */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/components/ComponentPropsContext.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComponentPropsReactContext", function() { return _components_ComponentPropsContext__WEBPACK_IMPORTED_MODULE_5__["ComponentPropsReactContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ComponentPropsContext", function() { return _components_ComponentPropsContext__WEBPACK_IMPORTED_MODULE_5__["ComponentPropsContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useComponentProps", function() { return _components_ComponentPropsContext__WEBPACK_IMPORTED_MODULE_5__["useComponentProps"]; });

/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "handleExperienceEditorFastRefresh", function() { return _utils__WEBPACK_IMPORTED_MODULE_6__["handleExperienceEditorFastRefresh"]; });

/* harmony import */ var _sharedTypes_editing_data__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sharedTypes/editing-data */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/sharedTypes/editing-data.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEditingData", function() { return _sharedTypes_editing_data__WEBPACK_IMPORTED_MODULE_7__["isEditingData"]; });

/* harmony import */ var _services_editing_data_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./services/editing-data-service */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/editing-data-service.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EditingDataService", function() { return _services_editing_data_service__WEBPACK_IMPORTED_MODULE_8__["EditingDataService"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "editingDataService", function() { return _services_editing_data_service__WEBPACK_IMPORTED_MODULE_8__["editingDataService"]; });

/* harmony import */ var _components_Link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/Link */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/components/Link.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return _components_Link__WEBPACK_IMPORTED_MODULE_9__["Link"]; });

/* harmony import */ var _components_RichText__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/RichText */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/components/RichText.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RichText", function() { return _components_RichText__WEBPACK_IMPORTED_MODULE_10__["RichText"]; });

/* harmony import */ var _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-react */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/index.js");
/* harmony import */ var _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Placeholder", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["Placeholder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["Image"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Text", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["Text"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateField", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["DateField"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "File", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["File"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VisitorIdentification", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["VisitorIdentification"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SitecoreContext", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["SitecoreContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SitecoreContextReactContext", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["SitecoreContextReactContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withSitecoreContext", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["withSitecoreContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useSitecoreContext", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["useSitecoreContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withExperienceEditorChromes", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["withExperienceEditorChromes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withPlaceholder", function() { return _sitecore_jss_sitecore_jss_react__WEBPACK_IMPORTED_MODULE_11__["withPlaceholder"]; });















/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/component-props-service.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/component-props-service.js ***!
  \*****************************************************************************************************/
/*! exports provided: ComponentPropsService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ComponentPropsService", function() { return ComponentPropsService; });
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chalk */ "./node_modules/chalk/index.js");
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(chalk__WEBPACK_IMPORTED_MODULE_0__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

class ComponentPropsService {
    /**
     * SSR mode
     * Fetch component props using getServerSideProps function
     * @param {FetchComponentPropsArguments<GetServerSidePropsContext>} params fetch params
     * @returns {Promise<ComponentPropsCollection>} props
     */
    fetchServerSideComponentProps(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { componentModule, layoutData, context } = params;
            const fetchFunctionFactory = (componentName) => {
                const module = componentModule(componentName);
                return module === null || module === void 0 ? void 0 : module.getServerSideProps;
            };
            return this.fetchComponentProps(fetchFunctionFactory, layoutData, context);
        });
    }
    /**
     * SSG mode
     * Fetch component props using getStaticProps function
     * @param {FetchComponentPropsArguments<GetStaticPropsContext>} params fetch arguments
     * @returns {Promise<ComponentPropsCollection>} props
     */
    fetchStaticComponentProps(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { componentModule, layoutData, context } = params;
            const fetchFunctionFactory = (componentName) => {
                const module = componentModule(componentName);
                return module === null || module === void 0 ? void 0 : module.getStaticProps;
            };
            return this.fetchComponentProps(fetchFunctionFactory, layoutData, context);
        });
    }
    /**
     * Traverse Layout Service data tree and call side effects on component level.
     * Side effect function can be: getStaticProps (SSG) or getServerSideProps (SSR)
     * @param {FetchFunctionFactory<NextContext>} fetchFunctionFactory fetch function factory
     * @param {LayoutServiceData} layoutData layout data
     * @param {NextContext} context next context
     * @returns {Promise<ComponentPropsCollection>} component props
     */
    fetchComponentProps(fetchFunctionFactory, layoutData, context) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Array of side effect functions
            const requests = this.collectRequests({
                placeholders: (_a = layoutData.sitecore.route) === null || _a === void 0 ? void 0 : _a.placeholders,
                fetchFunctionFactory,
                layoutData,
                context,
            });
            return yield this.execRequests(requests);
        });
    }
    /**
     * Go through layout service data, check all renderings using displayName, which should make some side effects.
     * Write result in requests variable
     * @param {Object} params params
     * @param {PlaceholdersData} [params.placeholders]
     * @param {FetchFunctionFactory<NextContext>} params.fetchFunctionFactory
     * @param {LayoutServiceData} params.layoutData
     * @param {NextContext} params.context
     * @param {ComponentPropsRequest<NextContext>[]} params.requests
     * @returns {ComponentPropsRequest<NextContext>[]} array of requests
     */
    collectRequests(params) {
        const { placeholders = {}, fetchFunctionFactory, layoutData, context } = params;
        // Will be called on first round
        if (!params.requests) {
            params.requests = [];
        }
        const renderings = this.flatRenderings(placeholders);
        renderings.map((r) => {
            const fetchFunc = fetchFunctionFactory(r.componentName);
            if (fetchFunc) {
                params.requests &&
                    params.requests.push({
                        fetch: fetchFunc,
                        rendering: r,
                        layoutData: layoutData,
                        context,
                    });
            }
            // If placeholders exist in current rendering
            if (r.placeholders) {
                this.collectRequests(Object.assign(Object.assign({}, params), { placeholders: r.placeholders }));
            }
        });
        return params.requests;
    }
    /**
     * Execute request for component props
     * @param {ComponentPropsRequest<NextContext>[]} requests requests
     * @returns {Promise<ComponentPropsCollection>} requests result
     */
    execRequests(requests) {
        return __awaiter(this, void 0, void 0, function* () {
            const componentProps = {};
            const promises = requests.map((req) => {
                const { uid } = req.rendering;
                if (!uid) {
                    console.log(`Component ${req.rendering.componentName} doesn't have uid, can't store data for this component`);
                    return;
                }

                console.error("req", JSON.stringify(req, null, 2));

                return req
                    .fetch(req.rendering, req.layoutData, req.context)
                    .then((result) => {
                    // Set component specific data in componentProps store
                    componentProps[uid] = result;
                })
                    .catch((error) => {
                    const errLog = `Error during preload data for component ${uid}: ${error.message ||
                        error}`;
                    console.error(chalk__WEBPACK_IMPORTED_MODULE_0___default.a.red(errLog));
                    componentProps[uid] = {
                        error: error.message || errLog,
                    };
                });
            });
            yield Promise.all(promises);
            return componentProps;
        });
    }
    /**
     * Take renderings from all placeholders and returns a flat array of renderings.
     * @example
     * const placeholders = {
     *    x1: [{ uid: 1 }, { uid: 2 }],
     *    x2: [{ uid: 11 }, { uid: 22 }]
     * }
     *
     * flatRenderings(placeholders);
     *
     * RESULT: [{ uid: 1 }, { uid: 2 }, { uid: 11 }, { uid: 22 }]
     *
     * @param {PlaceholdersData} placeholders placeholders
     * @returns {ComponentRendering[]} renderings
     */
    flatRenderings(placeholders) {
        const allComponentRenderings = [];
        const placeholdersArr = Object.values(placeholders);
        placeholdersArr.forEach((pl) => {
            const renderings = pl;
            allComponentRenderings.push(...renderings);
        });
        return allComponentRenderings;
    }
}


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/disconnected-sitemap-service.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/disconnected-sitemap-service.js ***!
  \**********************************************************************************************************/
/*! exports provided: DisconnectedSitemapService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisconnectedSitemapService", function() { return DisconnectedSitemapService; });
class DisconnectedSitemapService {
    /**
     * Provides ability to generate sitemap using manifest.
     * Sitemap can be used for `next export`
     * You can use `sitecore/manifest/sitecore-import.json` as manifest
     * @param {ManifestInstance} manifest manifest instance
     */
    constructor(manifest) {
        this.manifest = manifest;
    }
    /**
     * Generates sitemap which could be used for generation of static pages during `next export` in disconnected mode.
     * Since i18n is not supported, the output paths will not include a `locale` property.
     */
    fetchExportSitemap() {
        const sitemap = [];
        // Path is empty when we start from the root route
        const processRoutes = (routes, path) => {
            routes.forEach((route) => {
                var _a;
                const renderings = (_a = route.layout) === null || _a === void 0 ? void 0 : _a.renderings;
                const routePath = path ? path.concat(route.name) : [''];
                if (renderings && renderings.length) {
                    sitemap.push({
                        params: {
                            path: routePath,
                        },
                    });
                }
                if (route.children) {
                    // If we are in the root route, so next child should not contain paths in array
                    processRoutes(route.children, path ? routePath : []);
                }
            });
        };
        processRoutes(this.manifest.items.routes);
        return sitemap;
    }
}


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/editing-data-service.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/editing-data-service.js ***!
  \**************************************************************************************************/
/*! exports provided: QUERY_PARAM_EDITING_SECRET, EditingDataService, editingDataService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QUERY_PARAM_EDITING_SECRET", function() { return QUERY_PARAM_EDITING_SECRET; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditingDataService", function() { return EditingDataService; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "editingDataService", function() { return editingDataService; });
/* harmony import */ var _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss */ "./node_modules/@sitecore-jss/sitecore-jss/dist/index.js");
/* harmony import */ var _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/utils.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const QUERY_PARAM_EDITING_SECRET = 'secret';
/**
 * Service responsible for maintaining Sitecore Experience Editor data between requests
 */
class EditingDataService {
    /**
     * @param {EditingDataServiceConfig} [config] Editing data service config
     */
    constructor(config) {
        var _a, _b;
        this.apiRoute = (_a = config === null || config === void 0 ? void 0 : config.apiRoute) !== null && _a !== void 0 ? _a : '/api/editing/data/[key]';
        if (!this.apiRoute.includes('[key]')) {
            throw new Error(`The specified apiRoute '${this.apiRoute}' is missing '[key]'.`);
        }
        this.dataFetcher = (_b = config === null || config === void 0 ? void 0 : config.dataFetcher) !== null && _b !== void 0 ? _b : new _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["AxiosDataFetcher"]({ debugger: _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["debug"].experienceEditor });
    }
    /**
     * Stores Experience Editor payload data for later retrieval by key
     * @param {EditingData} data Editing data
     * @param {string} serverUrl The server url to use for subsequent data API requests
     * @returns {Promise} The {@link EditingPreviewData} containing the generated key and serverUrl to use for retrieval
     */
    setEditingData(data, serverUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.generateKey(data);
            const url = this.getUrl(serverUrl, key);
            const previewData = {
                key,
                serverUrl,
            };
            _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["debug"].experienceEditor('storing editing data for %o: %o', previewData, data);
            return this.dataFetcher.put(url, data).then(() => {
                return previewData;
            });
        });
    }
    /**
     * Retrieves Experience Editor payload data by key
     * @param {EditingPreviewData} previewData Editing preview data containing the key and serverUrl to use for retrieval
     * @returns {Promise} The {@link EditingData}
     */
    getEditingData(previewData) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.getUrl(previewData.serverUrl, previewData.key);
            _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["debug"].experienceEditor('fetching editing data for %o', previewData);
            return this.dataFetcher.get(url).then((response) => {
                return response.data;
            });
        });
    }
    generateKey(data) {
        var _a;
        // Need more than just the item GUID since requests are made "live" during editing in EE.
        // The suffix code will produce a random 10 character alpha-numeric (a-z 0-9) sequence, which is URI-safe.
        // Example generated key: 52961eea-bafd-5287-a532-a72e36bd8a36-qkb4e3fv5x
        const suffix = Math.random()
            .toString(36)
            .substring(2, 12);
        return `${(_a = data.layoutData.sitecore.route) === null || _a === void 0 ? void 0 : _a.itemId}-${suffix}`;
    }
    getUrl(serverUrl, key) {
        var _a;
        // Example URL format:
        //  http://localhost:3000/api/editing/data/52961eea-bafd-5287-a532-a72e36bd8a36-qkb4e3fv5x?secret=1234secret
        const apiRoute = (_a = this.apiRoute) === null || _a === void 0 ? void 0 : _a.replace('[key]', key);
        const url = new URL(apiRoute, serverUrl);
        url.searchParams.append(QUERY_PARAM_EDITING_SECRET, Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getJssEditingSecret"])());
        return url.toString();
    }
}
/** EditingDataService singleton (with default values) */
const editingDataService = new EditingDataService();


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/graphql-sitemap-service.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/services/graphql-sitemap-service.js ***!
  \*****************************************************************************************************/
/*! exports provided: queryError, languageError, GraphQLSitemapService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queryError", function() { return queryError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "languageError", function() { return languageError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GraphQLSitemapService", function() { return GraphQLSitemapService; });
/* harmony import */ var _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss */ "./node_modules/@sitecore-jss/sitecore-jss/dist/index.js");
/* harmony import */ var _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

/** @private */
const queryError = 'Valid value for rootItemId not provided and failed to auto-resolve app root item.';
/** @private */
const languageError = 'The list of languages cannot be empty';
// Even though _hasLayout should always be "true" in this query, using a variable is necessary for compatibility with Edge
const defaultQuery = /* GraphQL */ `
  query SitemapQuery(
    $rootItemId: String!
    $language: String!
    $pageSize: Int = 10
    $hasLayout: String = "true"
    $after: String
  ) {
    search(
      where: {
        AND: [
          { name: "_path", value: $rootItemId, operator: CONTAINS }
          { name: "_language", value: $language }
          { name: "_hasLayout", value: $hasLayout }
        ]
      }
      first: $pageSize
      after: $after
    ) {
      total
      pageInfo {
        endCursor
        hasNext
      }
      results {
        url {
          path
        }
      }
    }
  }
`;
/**
 * Service that fetches the list of site pages using Sitecore's GraphQL API.
 * This list is used for SSG and Export functionality.
 * @mixes SearchQueryService<PageListQueryResult>
 */
class GraphQLSitemapService {
    /**
     * Creates an instance of graphQL sitemap service with the provided options
     * @param {GraphQLSitemapServiceConfig} options instance
     */
    constructor(options) {
        this.options = options;
        this.graphQLClient = this.getGraphQLClient();
        this.searchService = new _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["SearchQueryService"](this.graphQLClient);
    }
    /**
     * Gets the default query used for fetching the list of site pages
     */
    get query() {
        return defaultQuery;
    }
    /**
     * Fetch sitemap which could be used for generation of static pages during `next export`.
     * The `locale` parameter will be used in the item query, but since i18n is not supported,
     * the output paths will not include a `language` property.
     * @param {string} locale which application supports
     * @returns an array of @see StaticPath objects
     */
    fetchExportSitemap(locale) {
        return __awaiter(this, void 0, void 0, function* () {
            const formatPath = (path) => ({
                params: {
                    path,
                },
            });
            return this.fetchSitemap([locale], formatPath);
        });
    }
    /**
     * Fetch sitemap which could be used for generation of static pages using SSG mode
     * @param {string[]} locales locales which application supports
     * @returns an array of @see StaticPath objects
     */
    fetchSSGSitemap(locales) {
        return __awaiter(this, void 0, void 0, function* () {
            const formatPath = (path, locale) => ({
                params: {
                    path,
                },
                locale,
            });
            return this.fetchSitemap(locales, formatPath);
        });
    }
    /**
     * Fetch a flat list of all pages that are descendants of the specified root item and have a
     * version in the specified language(s).
     * @param {string[]} languages Fetch pages that have versions in this language(s).
     * @param {Function} formatStaticPath Function for transforming the raw search results into (@see StaticPath) types.
     * @returns list of pages
     * @throws {RangeError} if the list of languages is empty.
     * @throws {Error} if the app root was not found for the specified site and language.
     */
    fetchSitemap(languages, formatStaticPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!languages.length) {
                throw new RangeError(languageError);
            }
            // If the caller does not specify a root item ID, then we try to figure it out
            const rootItemId = this.options.rootItemId ||
                (yield Object(_sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["getAppRootId"])(this.graphQLClient, this.options.siteName, languages[0]));
            if (!rootItemId) {
                throw new Error(queryError);
            }
            // Fetch paths using all locales
            const paths = yield Promise.all(languages.map((language) => {
                _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["debug"].sitemap('fetching sitemap data for %s', language);
                return this.searchService
                    .fetch(this.query, {
                    rootItemId,
                    language,
                    pageSize: this.options.pageSize,
                })
                    .then((results) => {
                    return results.map((item) => formatStaticPath(item.url.path.replace(/^\/|\/$/g, '').split('/'), language));
                });
            }));
            // merge promises results into single result
            return [].concat(...paths);
        });
    }
    /**
     * Gets a GraphQL client that can make requests to the API. Uses graphql-request as the default
     * library for fetching graphql data (@see GraphQLRequestClient). Override this method if you
     * want to use something else.
     * @returns {GraphQLClient} implementation
     */
    getGraphQLClient() {
        return new _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["GraphQLRequestClient"](this.options.endpoint, {
            apiKey: this.options.apiKey,
            debugger: _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["debug"].sitemap,
        });
    }
    /**
     * Gets a service that can perform GraphQL "search" queries to fetch @see PageListQueryResult
     * @returns {SearchQueryService<PageListQueryResult>} the search query service
     */
    getSearchService() {
        return new _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_0__["SearchQueryService"](this.graphQLClient);
    }
}


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/sharedTypes/editing-data.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/sharedTypes/editing-data.js ***!
  \*********************************************************************************************/
/*! exports provided: isEditingData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEditingData", function() { return isEditingData; });
/**
 * @param {EditingData} data
 */
function isEditingData(data) {
    return (data.path !== undefined &&
        data.language !== undefined &&
        data.layoutData !== undefined &&
        data.dictionary !== undefined);
}


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/utils.js ***!
  \**************************************************************************/
/*! exports provided: getPublicUrl, handleExperienceEditorFastRefresh, getJssEditingSecret */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPublicUrl", function() { return getPublicUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleExperienceEditorFastRefresh", function() { return handleExperienceEditorFastRefresh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getJssEditingSecret", function() { return getJssEditingSecret; });
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chalk */ "./node_modules/chalk/index.js");
/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(chalk__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss */ "./node_modules/@sitecore-jss/sitecore-jss/dist/index.js");
/* harmony import */ var _sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_1__);


const getPublicUrl = () => {
    let url = "http://localhost:3000";
    if (url === undefined) {
        console.warn(`${chalk__WEBPACK_IMPORTED_MODULE_0___default.a.yellow.bold('Warning:')} An PUBLIC_URL environment variable is not defined. Falling back to http://localhost:3000.`);
        url = 'http://localhost:3000';
    }
    else {
        try {
            new URL(url);
        }
        catch (error) {
            throw new Error(`The PUBLIC_URL environment variable '${url}' is not a valid URL.`);
        }
    }
    // Ensure no trailing slash
    return url.toString().replace(/\/$/, '');
};
/**
 * Since Experience Editor does not support Fast Refresh:
 * 1. Subscribe on events provided by webpack.
 * 2. Reset experience editor chromes when build is finished
 * @param {boolean} [forceReload] force page reload instead of reset chromes
 * @default forceReload false
 */
const handleExperienceEditorFastRefresh = (forceReload = false) => {
    if ( false || !Object(_sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_1__["isExperienceEditorActive"])()) {
        // Only run if development mode and Experience Editor is active
        return;
    }
    const eventSource = new window.EventSource(`${getPublicUrl()}/_next/webpack-hmr`);
    window.addEventListener('beforeunload', () => eventSource.close());
    eventSource.onopen = () => console.log('[Experience Editor Fast Refresh Listener] Online');
    eventSource.onmessage = (event) => {
        if (event.data.indexOf('{') === -1)
            return; // heartbeat
        const payload = JSON.parse(event.data);
        console.debug(`[Experience Editor Fast Refresh Listener] Saw event: ${JSON.stringify(payload)}`);
        if (payload.action !== 'built')
            return;
        if (forceReload)
            return window.location.reload();
        setTimeout(() => {
            console.log('[Experience Editor HMR Listener] Experience Editor does not support Fast Refresh, reloading chromes...');
            Object(_sitecore_jss_sitecore_jss__WEBPACK_IMPORTED_MODULE_1__["resetExperienceEditorChromes"])();
        }, 500);
    };
};
const getJssEditingSecret = () => {
    const secret = process.env.JSS_EDITING_SECRET;
    if (!secret || secret.length === 0) {
        throw new Error('The JSS_EDITING_SECRET environment variable is missing or invalid.');
    }
    return secret;
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Date.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Date.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));
exports.DateField = function (_a) {
    var field = _a.field, tag = _a.tag, editable = _a.editable, render = _a.render, otherProps = __rest(_a, ["field", "tag", "editable", "render"]);
    if (!field || (!field.editable && !field.value)) {
        return null;
    }
    var children;
    var htmlProps = __assign({}, otherProps);
    if (field.editable && editable) {
        htmlProps.dangerouslySetInnerHTML = {
            __html: field.editable,
        };
    }
    else if (render) {
        children = render(field.value ? new Date(field.value) : null);
    }
    else {
        children = field.value;
    }
    if (tag || (field.editable && editable)) {
        return react_1.default.createElement(tag || 'span', htmlProps, children);
    }
    else {
        return react_1.default.createElement(react_1.default.Fragment, null, children);
    }
};
exports.DateField.propTypes = {
    field: prop_types_1.default.shape({
        value: prop_types_1.default.any,
        editable: prop_types_1.default.string,
    }).isRequired,
    tag: prop_types_1.default.string,
    editable: prop_types_1.default.bool,
    render: prop_types_1.default.func,
};
exports.DateField.defaultProps = {
    editable: true,
};
exports.DateField.displayName = 'Date';


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/File.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/File.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.File = function (_a) {
    /*
      File fields cannot be managed via the EE. We never output "editable."
    */
    var field = _a.field, children = _a.children, otherProps = __rest(_a, ["field", "children"]);
    var dynamicField = field;
    if (!field || (!dynamicField.value && !dynamicField.src)) {
        return null;
    }
    // handle link directly on field for forgetful devs
    var file = (dynamicField.src
        ? field
        : dynamicField.value);
    if (!file) {
        return null;
    }
    var linkText = !children ? file.title || file.displayName : null;
    var anchorAttrs = {
        href: file.src,
    };
    return react_1.default.createElement('a', __assign(__assign({}, anchorAttrs), otherProps), linkText, children);
};
exports.File.propTypes = {
    field: prop_types_1.default.oneOfType([
        prop_types_1.default.shape({
            src: prop_types_1.default.string,
        }),
        prop_types_1.default.shape({
            value: prop_types_1.default.object,
        }),
    ]).isRequired,
    children: prop_types_1.default.node,
};
exports.File.displayName = 'File';


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Image.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Image.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var sitecore_jss_1 = __webpack_require__(/*! @sitecore-jss/sitecore-jss */ "./node_modules/@sitecore-jss/sitecore-jss/dist/index.js");
var prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var server_1 = __importDefault(__webpack_require__(/*! react-dom/server */ "./node_modules/react-dom/server.browser.js"));
var utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/utils.js");
var getEditableWrapper = function (editableMarkup) {
    var otherProps = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        otherProps[_i - 1] = arguments[_i];
    }
    return (
    // create an inline wrapper and use dangerouslySetInnerHTML.
    // if we try to parse the EE value, the parser will strip invalid or disallowed attributes from html elements - and EE uses several
    react_1.default.createElement("span", __assign({ className: "sc-image-wrapper" }, otherProps, { dangerouslySetInnerHTML: { __html: editableMarkup } })));
};
var getImageAttrs = function (_a, imageParams, mediaUrlPrefix) {
    var src = _a.src, srcSet = _a.srcSet, otherAttrs = __rest(_a, ["src", "srcSet"]);
    if (!src) {
        return null;
    }
    var newAttrs = __assign({}, otherAttrs);
    // update image URL for jss handler and image rendering params
    var resolvedSrc = sitecore_jss_1.mediaApi.updateImageUrl(src, imageParams, mediaUrlPrefix);
    if (srcSet) {
        // replace with HTML-formatted srcset, including updated image URLs
        newAttrs.srcSet = sitecore_jss_1.mediaApi.getSrcSet(resolvedSrc, srcSet, imageParams, mediaUrlPrefix);
    }
    // always output original src as fallback for older browsers
    newAttrs.src = resolvedSrc;
    return newAttrs;
};
exports.Image = function (_a) {
    var media = _a.media, editable = _a.editable, imageParams = _a.imageParams, field = _a.field, mediaUrlPrefix = _a.mediaUrlPrefix, otherProps = __rest(_a, ["media", "editable", "imageParams", "field", "mediaUrlPrefix"]);
    // allows the mistake of using 'field' prop instead of 'media' (consistent with other helpers)
    if (field && !media) {
        media = field;
    }
    var dynamicMedia = media;
    if (!media ||
        (!dynamicMedia.editable && !dynamicMedia.value && !dynamicMedia.src)) {
        return null;
    }
    var imageField = dynamicMedia;
    // we likely have an experience editor value, should be a string
    if (editable && imageField.editable) {
        var foundImg = sitecore_jss_1.mediaApi.findEditorImageTag(imageField.editable);
        if (!foundImg) {
            return getEditableWrapper(imageField.editable);
        }
        var foundImgProps = utils_1.convertAttributesToReactProps(foundImg.attrs);
        // Note: otherProps may override values from foundImgProps, e.g. `style`, `className` prop
        // We do not attempt to merge.
        var imgAttrs = getImageAttrs(__assign(__assign({}, foundImgProps), otherProps), imageParams, mediaUrlPrefix);
        if (!imgAttrs) {
            return getEditableWrapper(imageField.editable);
        }
        var imgHtml = server_1.default.renderToStaticMarkup(react_1.default.createElement("img", __assign({}, imgAttrs)));
        var editableMarkup = imageField.editable.replace(foundImg.imgTag, imgHtml);
        return getEditableWrapper(editableMarkup);
    }
    // some wise-guy/gal is passing in a 'raw' image object value
    var img = dynamicMedia.src
        ? media
        : dynamicMedia.value;
    if (!img) {
        return null;
    }
    var attrs = getImageAttrs(__assign(__assign({}, img), otherProps), imageParams, mediaUrlPrefix);
    if (attrs) {
        return react_1.default.createElement("img", __assign({}, attrs));
    }
    return null; // we can't handle the truth
};
exports.Image.propTypes = {
    media: prop_types_1.default.oneOfType([
        prop_types_1.default.shape({
            src: prop_types_1.default.string,
        }),
        prop_types_1.default.shape({
            value: prop_types_1.default.object,
            editable: prop_types_1.default.string,
        }),
    ]),
    field: prop_types_1.default.oneOfType([
        prop_types_1.default.shape({
            src: prop_types_1.default.string,
        }),
        prop_types_1.default.shape({
            value: prop_types_1.default.object,
            editable: prop_types_1.default.string,
        }),
    ]),
    editable: prop_types_1.default.bool,
    mediaUrlPrefix: prop_types_1.default.instanceOf(RegExp),
    imageParams: prop_types_1.default.objectOf(prop_types_1.default.oneOfType([prop_types_1.default.number.isRequired, prop_types_1.default.string.isRequired]).isRequired),
};
exports.Image.defaultProps = {
    editable: true,
};
exports.Image.displayName = 'Image';


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Link.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Link.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));
exports.Link = function (_a) {
    var field = _a.field, editable = _a.editable, children = _a.children, showLinkTextWithChildrenPresent = _a.showLinkTextWithChildrenPresent, otherProps = __rest(_a, ["field", "editable", "children", "showLinkTextWithChildrenPresent"]);
    var dynamicField = field;
    if (!field ||
        (!dynamicField.editableFirstPart &&
            !dynamicField.value &&
            !dynamicField.href)) {
        return null;
    }
    var resultTags = [];
    // EXPERIENCE EDITOR RENDERING
    if (editable && dynamicField.editableFirstPart) {
        var markup = dynamicField.editableFirstPart + dynamicField.editableLastPart;
        // in an ideal world, we'd pre-render React children here and inject them between editableFirstPart and editableLastPart.
        // However, we cannot combine arbitrary unparsed HTML (innerHTML) based components with actual vDOM components (the children)
        // because the innerHTML is not parsed - it'd make a discontinuous vDOM. So, we'll go for the next best compromise of rendering the link field and children separately
        // as siblings. Should be "good enough" for most cases - and write your own helper if it isn't. Or bring xEditor out of 2006.
        var htmlProps = __assign(__assign({ className: 'sc-link-wrapper', dangerouslySetInnerHTML: {
                __html: markup,
            } }, otherProps), { key: 'editable' });
        resultTags.push(react_1.default.createElement("span", __assign({}, htmlProps)));
        // don't render normal link tag when editing, if no children exist
        // this preserves normal-ish behavior if not using a link body (no hacks required)
        if (!children) {
            return resultTags[0];
        }
    }
    // handle link directly on field for forgetful devs
    var link = dynamicField.href
        ? field
        : dynamicField.value;
    if (!link) {
        return null;
    }
    var anchorAttrs = {
        href: link.href,
        className: link.class,
        title: link.title,
        target: link.target,
    };
    if (anchorAttrs.target === '_blank' && !anchorAttrs.rel) {
        // information disclosure attack prevention keeps target blank site from getting ref to window.opener
        anchorAttrs.rel = 'noopener noreferrer';
    }
    var linkText = showLinkTextWithChildrenPresent || !children ? link.text || link.href : null;
    resultTags.push(react_1.default.createElement('a', __assign(__assign(__assign({}, anchorAttrs), otherProps), { key: 'link' }), linkText, children));
    return react_1.default.createElement(react_1.default.Fragment, null, resultTags);
};
exports.LinkPropTypes = {
    field: prop_types_1.default.oneOfType([
        prop_types_1.default.shape({
            href: prop_types_1.default.string,
        }),
        prop_types_1.default.shape({
            value: prop_types_1.default.object,
            editableFirstPart: prop_types_1.default.string,
            editableLastPart: prop_types_1.default.string,
        }),
    ]).isRequired,
    editable: prop_types_1.default.bool,
    children: prop_types_1.default.node,
    showLinkTextWithChildrenPresent: prop_types_1.default.bool,
};
exports.Link.propTypes = exports.LinkPropTypes;
exports.Link.defaultProps = {
    editable: true,
};
exports.Link.displayName = 'Link';


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/MissingComponent.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/MissingComponent.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.MissingComponent = function (props) {
    var componentName = props.rendering && props.rendering.componentName
        ? props.rendering.componentName
        : 'Unnamed Component';
    console.log("Component props for unimplemented '" + componentName + "' component", props);
    return (react_1.default.createElement("div", { style: {
            background: 'darkorange',
            outline: '5px solid orange',
            padding: '10px',
            color: 'white',
            maxWidth: '500px',
        } },
        react_1.default.createElement("h2", null, componentName),
        react_1.default.createElement("p", null, "JSS component is missing React implementation. See the developer console for more information.")));
};
exports.MissingComponent.propTypes = {
    rendering: prop_types_1.default.shape({
        componentName: prop_types_1.default.string,
    }),
};
exports.MissingComponent.displayName = 'MissingComponent';


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Placeholder.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Placeholder.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var PlaceholderCommon_1 = __webpack_require__(/*! ./PlaceholderCommon */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/PlaceholderCommon.js");
var withComponentFactory_1 = __webpack_require__(/*! ../enhancers/withComponentFactory */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withComponentFactory.js");
/**
 * @param {HtmlElementRendering | ComponentRendering} rendering
 */
function isRawRendering(rendering) {
    return (!rendering.componentName &&
        rendering.name !== undefined);
}
var PlaceholderComponent = /** @class */ (function (_super) {
    __extends(PlaceholderComponent, _super);
    function PlaceholderComponent(props) {
        return _super.call(this, props) || this;
    }
    PlaceholderComponent.prototype.render = function () {
        var childProps = __assign({}, this.props);
        delete childProps.componentFactory;
        if (this.state.error) {
            if (childProps.errorComponent) {
                return react_1.default.createElement(childProps.errorComponent, { error: this.state.error });
            }
            return (react_1.default.createElement("div", { className: "sc-jss-placeholder-error" },
                "A rendering error occurred: ",
                this.state.error.message,
                "."));
        }
        var renderingData = childProps.rendering;
        var placeholderData = PlaceholderCommon_1.PlaceholderCommon.getPlaceholderDataFromRenderingData(renderingData, this.props.name);
        var components = this.getComponentsForRenderingData(placeholderData);
        if (this.props.renderEmpty &&
            placeholderData.every(function (rendering) {
                return isRawRendering(rendering);
            })) {
            return this.props.renderEmpty(components);
        }
        else if (this.props.render) {
            return this.props.render(components, placeholderData, childProps);
        }
        else if (this.props.renderEach) {
            var renderEach_1 = this.props.renderEach;
            return components.map(function (component, index) {
                if (component && component.props && component.props.type === 'text/sitecore') {
                    return component;
                }
                return renderEach_1(component, index);
            });
        }
        else {
            return components;
        }
    };
    PlaceholderComponent.propTypes = PlaceholderCommon_1.PlaceholderCommon.propTypes;
    return PlaceholderComponent;
}(PlaceholderCommon_1.PlaceholderCommon));
exports.Placeholder = withComponentFactory_1.withComponentFactory(PlaceholderComponent);


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/PlaceholderCommon.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/PlaceholderCommon.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));
var MissingComponent_1 = __webpack_require__(/*! ../components/MissingComponent */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/MissingComponent.js");
var utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/utils.js");
var PlaceholderCommon = /** @class */ (function (_super) {
    __extends(PlaceholderCommon, _super);
    function PlaceholderCommon(props) {
        var _this = _super.call(this, props) || this;
        _this.nodeRefs = [];
        _this.state = {};
        _this.addRef = _this.addRef.bind(_this);
        _this.updateKeyAttributes = _this.updateKeyAttributes.bind(_this);
        _this.createRawElement = _this.createRawElement.bind(_this);
        return _this;
    }
    PlaceholderCommon.getPlaceholderDataFromRenderingData = function (rendering, name) {
        var result;
        if (rendering && rendering.placeholders && Object.keys(rendering.placeholders).length > 0) {
            result = rendering.placeholders[name];
        }
        else {
            result = null;
        }
        if (!result) {
            console.warn("Placeholder '" + name + "' was not found in the current rendering data", JSON.stringify(rendering, null, 2));
            return [];
        }
        return result;
    };
    PlaceholderCommon.prototype.componentDidMount = function () {
        this.updateKeyAttributes();
    };
    PlaceholderCommon.prototype.componentDidUpdate = function () {
        this.updateKeyAttributes();
    };
    PlaceholderCommon.prototype.componentDidCatch = function (error) {
        this.setState({ error: error });
    };
    PlaceholderCommon.prototype.getComponentsForRenderingData = function (placeholderData) {
        var _this = this;
        var _a = this.props, name = _a.name, placeholderFields = _a.fields, placeholderParams = _a.params, missingComponentComponent = _a.missingComponentComponent, placeholderProps = __rest(_a, ["name", "fields", "params", "missingComponentComponent"]);
        return placeholderData
            .map(function (rendering, index) {
            var key = rendering.uid
                ? rendering.uid
                : "component-" + index;
            var commonProps = { key: key };
            // if the element is not a 'component rendering', render it 'raw'
            if (!rendering.componentName &&
                rendering.name) {
                return _this.createRawElement(rendering, commonProps);
            }
            var componentRendering = rendering;
            var component = _this.getComponentForRendering(componentRendering);
            if (!component) {
                console.error("Placeholder " + name + " contains unknown component " + componentRendering.componentName + ". Ensure that a React component exists for it, and that it is registered in your componentFactory.js.");
                component = (missingComponentComponent !== null && missingComponentComponent !== void 0 ? missingComponentComponent : MissingComponent_1.MissingComponent);
            }
            var finalProps = __assign(__assign(__assign(__assign(__assign({}, commonProps), placeholderProps), ((placeholderFields || componentRendering.fields) && {
                fields: __assign(__assign({}, placeholderFields), componentRendering.fields),
            })), ((placeholderParams || componentRendering.params) && {
                params: __assign(__assign({}, placeholderParams), componentRendering.params),
            })), { rendering: componentRendering });
            return react_1.default.createElement(component, finalProps);
        })
            .filter(function (element) { return element; }); // remove nulls
    };
    PlaceholderCommon.prototype.getComponentForRendering = function (renderingDefinition) {
        var componentFactory = this.props.componentFactory;
        if (!componentFactory || typeof componentFactory !== 'function') {
            console.warn("No componentFactory was available to service request for component " + renderingDefinition);
            return null;
        }
        return componentFactory(renderingDefinition.componentName);
    };
    PlaceholderCommon.prototype.addRef = function (nodeRef) {
        this.nodeRefs.push(nodeRef);
    };
    PlaceholderCommon.prototype.createRawElement = function (elem, baseProps) {
        if (!elem.name) {
            console.error('"elem.name" is undefined in "createRawElement". Something is likely wrong with your component data. Ensure that your components have a name.');
            return null;
        }
        var attributes = utils_1.convertAttributesToReactProps(elem.attributes);
        var props = __assign(__assign(__assign({}, baseProps), attributes), { dangerouslySetInnerHTML: { __html: elem.contents } });
        /* Since we can't set the "key" attribute via React, stash it
         * so we can set in the DOM after render.
         */
        if (!Array.isArray(attributes) && attributes && attributes.chrometype === 'placeholder') {
            props.phkey = elem.attributes.key; // props that get rendered as dom attribute names need to be lowercase, otherwise React complains.
            props.ref = this.addRef; // only need ref for placeholder containers, trying to add it to other components (e.g. stateless components) may result in a warning.
        }
        return react_1.default.createElement(elem.name, props);
    };
    PlaceholderCommon.prototype.updateKeyAttributes = function () {
        if (!this.nodeRefs) {
            return;
        }
        this.nodeRefs.forEach(function (ref) {
            if (ref && ref.getAttribute) {
                // ref might be a wrapped component, so check for existence of getAttribute method
                var key = ref.getAttribute('phkey');
                if (key) {
                    // need to manually set the 'key' attribute after component mount because
                    // 'key' is a reserved attribute/prop in React. so it will never be rendered
                    // as an html attribute.
                    ref.setAttribute('key', key);
                }
            }
        });
    };
    PlaceholderCommon.propTypes = {
        rendering: prop_types_1.default.oneOfType([
            prop_types_1.default.object,
            prop_types_1.default.object,
        ]).isRequired,
        fields: prop_types_1.default.objectOf(prop_types_1.default.oneOfType([
            prop_types_1.default.object,
            prop_types_1.default.object,
        ]).isRequired),
        params: prop_types_1.default.objectOf(prop_types_1.default.string.isRequired),
        missingComponentComponent: prop_types_1.default.oneOfType([
            prop_types_1.default.object,
            prop_types_1.default.func,
        ]),
        errorComponent: prop_types_1.default.oneOfType([
            prop_types_1.default.object,
            prop_types_1.default.func,
        ]),
    };
    return PlaceholderCommon;
}(react_1.default.Component));
exports.PlaceholderCommon = PlaceholderCommon;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/RichText.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/RichText.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));
exports.RichText = react_1.forwardRef(function (_a, ref) {
    var field = _a.field, tag = _a.tag, editable = _a.editable, otherProps = __rest(_a, ["field", "tag", "editable"]);
    if (!field || (!field.editable && !field.value)) {
        return null;
    }
    var htmlProps = __assign({ dangerouslySetInnerHTML: {
            __html: field.editable && editable ? field.editable : field.value,
        }, ref: ref }, otherProps);
    return react_1.default.createElement(tag || 'div', htmlProps);
});
exports.RichTextPropTypes = {
    field: prop_types_1.default.shape({
        value: prop_types_1.default.string,
        editable: prop_types_1.default.string,
    }),
    tag: prop_types_1.default.string,
    editable: prop_types_1.default.bool,
};
exports.RichText.propTypes = exports.RichTextPropTypes;
exports.RichText.defaultProps = {
    tag: 'div',
    editable: true,
};
exports.RichText.displayName = 'RichText';


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/SitecoreContext.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/SitecoreContext.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));
exports.SitecoreContextReactContext = react_1.default.createContext({});
exports.ComponentFactoryReactContext = react_1.default.createContext({});
var SitecoreContext = /** @class */ (function (_super) {
    __extends(SitecoreContext, _super);
    function SitecoreContext(props) {
        var _this = _super.call(this, props) || this;
        _this.setContext = function (value) {
            _this.setState({
                context: value,
            });
        };
        var context = {
            pageEditing: false,
        };
        if (props.context) {
            context = props.context;
        }
        if (props.context === null) {
            context = null;
        }
        _this.state = {
            context: context,
            setContext: _this.setContext,
        };
        return _this;
    }
    SitecoreContext.prototype.render = function () {
        return (react_1.default.createElement(exports.ComponentFactoryReactContext.Provider, { value: this.props.componentFactory },
            react_1.default.createElement(exports.SitecoreContextReactContext.Provider, { value: this.state }, this.props.children)));
    };
    SitecoreContext.propTypes = {
        children: prop_types_1.default.any.isRequired,
        componentFactory: prop_types_1.default.func,
        context: prop_types_1.default.any,
    };
    SitecoreContext.displayName = 'SitecoreContext';
    return SitecoreContext;
}(react_1.default.Component));
exports.SitecoreContext = SitecoreContext;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Text.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Text.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var prop_types_1 = __importDefault(__webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js"));
exports.Text = function (_a) {
    var field = _a.field, tag = _a.tag, editable = _a.editable, encode = _a.encode, otherProps = __rest(_a, ["field", "tag", "editable", "encode"]);
    if (!field || (!field.editable && (field.value === undefined || field.value === ''))) {
        return null;
    }
    // can't use editable value if we want to output unencoded
    if (!encode) {
        // eslint-disable-next-line no-param-reassign
        editable = false;
    }
    var isEditable = field.editable && editable;
    var output = isEditable
        ? field.editable || ''
        : field.value === undefined
            ? ''
            : field.value;
    // when string value isn't formatted, we should format line breaks
    if (!field.editable && typeof output === 'string') {
        var splitted_1 = String(output).split('\n');
        if (splitted_1.length) {
            var formatted_1 = [];
            splitted_1.forEach(function (str, i) {
                var isLast = i === splitted_1.length - 1;
                formatted_1.push(str);
                if (!isLast) {
                    formatted_1.push(react_1.default.createElement("br", { key: i }));
                }
            });
            output = formatted_1;
        }
    }
    var setDangerously = isEditable || !encode;
    var children = null;
    var htmlProps = __assign({}, otherProps);
    if (setDangerously) {
        htmlProps.dangerouslySetInnerHTML = {
            __html: output,
        };
    }
    else {
        children = output;
    }
    if (tag || setDangerously) {
        return react_1.default.createElement(tag || 'span', htmlProps, children);
    }
    else {
        return react_1.default.createElement(react_1.default.Fragment, null, children);
    }
};
exports.Text.propTypes = {
    field: prop_types_1.default.shape({
        value: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.number]),
        editable: prop_types_1.default.string,
    }),
    tag: prop_types_1.default.string,
    editable: prop_types_1.default.bool,
    encode: prop_types_1.default.bool,
};
exports.Text.defaultProps = {
    editable: true,
    encode: true,
};
exports.Text.displayName = 'Text';


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/VisitorIdentification.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/VisitorIdentification.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var withSitecoreContext_1 = __webpack_require__(/*! ../enhancers/withSitecoreContext */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withSitecoreContext.js");
var emittedVI = false;
var VIComponent = function (_a) {
    var sitecoreContext = _a.sitecoreContext;
    if (emittedVI ||
        typeof document === 'undefined' ||
        !sitecoreContext.visitorIdentificationTimestamp) {
        // Don't emit VI script and meta tag if we've already done so,
        // aren't rendering client-side, or don't have a VI timestamp.
        return null;
    }
    emittedVI = true;
    var script = document.createElement('script');
    script.src = '/layouts/system/VisitorIdentification.js';
    script.type = 'text/javascript';
    var meta = document.createElement('meta');
    meta.name = 'VIcurrentDateTime';
    meta.content = sitecoreContext.visitorIdentificationTimestamp;
    var head = document.querySelector('head');
    head && head.appendChild(script);
    head && head.appendChild(meta);
    return null;
};
VIComponent.displayName = 'VisitorIdentification';
exports.VisitorIdentification = withSitecoreContext_1.withSitecoreContext()(VIComponent);


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withComponentFactory.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withComponentFactory.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var SitecoreContext_1 = __webpack_require__(/*! ../components/SitecoreContext */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/SitecoreContext.js");
/**
 * @param {React.ComponentClass<T> | React.SFC<T>} Component
 */
function withComponentFactory(Component) {
    return function WithComponentFactory(props) {
        return (react_1.default.createElement(SitecoreContext_1.ComponentFactoryReactContext.Consumer, null, function (context) { return react_1.default.createElement(Component, __assign({}, props, { componentFactory: props.componentFactory || context })); }));
    };
}
exports.withComponentFactory = withComponentFactory;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withExperienceEditorChromes.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withExperienceEditorChromes.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var __1 = __webpack_require__(/*! ../ */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/index.js");
exports.withExperienceEditorChromes = function (WrappedComponent) {
    var Enhancer = /** @class */ (function (_super) {
        __extends(Enhancer, _super);
        function Enhancer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
            return _this;
        }
        Enhancer.prototype.componentDidUpdate = function () {
            __1.resetExperienceEditorChromes();
        };
        Enhancer.prototype.render = function () {
            return react_1.default.createElement(WrappedComponent, __assign({}, this.props));
        };
        return Enhancer;
    }(react_1.default.Component));
    return Enhancer;
};


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withPlaceholder.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withPlaceholder.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var PlaceholderCommon_1 = __webpack_require__(/*! ../components/PlaceholderCommon */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/PlaceholderCommon.js");
var withComponentFactory_1 = __webpack_require__(/*! ./withComponentFactory */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withComponentFactory.js");
/**
 * @param {WithPlaceholderSpec} placeholders
 * @param {WithPlaceholderOptions} [options]
 */
function withPlaceholder(placeholders, options) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return function (WrappedComponent) {
        var WithPlaceholder = /** @class */ (function (_super) {
            __extends(WithPlaceholder, _super);
            function WithPlaceholder(props) {
                return _super.call(this, props) || this;
            }
            WithPlaceholder.prototype.render = function () {
                var _this = this;
                var childProps = __assign({}, this.props);
                delete childProps.componentFactory;
                if (options && options.propsTransformer) {
                    childProps = options.propsTransformer(childProps);
                }
                if (this.state.error) {
                    if (childProps.errorComponent) {
                        return react_1.default.createElement(childProps.errorComponent, { error: this.state.error });
                    }
                    return (react_1.default.createElement("div", { className: "sc-jss-placeholder-error" },
                        "A rendering error occurred: ",
                        this.state.error.message,
                        "."));
                }
                var renderingData = options && options.resolvePlaceholderDataFromProps
                    ? options.resolvePlaceholderDataFromProps(childProps)
                    : childProps.rendering;
                var definitelyArrayPlacholders = !Array.isArray(placeholders)
                    ? [placeholders]
                    : placeholders;
                definitelyArrayPlacholders.forEach(function (placeholder) {
                    var placeholderData;
                    if (typeof placeholder !== 'string' && placeholder.placeholder && placeholder.prop) {
                        placeholderData = PlaceholderCommon_1.PlaceholderCommon.getPlaceholderDataFromRenderingData(renderingData, placeholder.placeholder);
                        if (placeholderData) {
                            childProps[placeholder.prop] = _this.getComponentsForRenderingData(placeholderData);
                        }
                    }
                    else {
                        placeholderData = PlaceholderCommon_1.PlaceholderCommon.getPlaceholderDataFromRenderingData(renderingData, placeholder);
                        if (placeholderData) {
                            childProps[placeholder] = _this.getComponentsForRenderingData(placeholderData);
                        }
                    }
                });
                return react_1.default.createElement(WrappedComponent, __assign({}, childProps));
            };
            WithPlaceholder.propTypes = PlaceholderCommon_1.PlaceholderCommon.propTypes;
            return WithPlaceholder;
        }(PlaceholderCommon_1.PlaceholderCommon));
        return withComponentFactory_1.withComponentFactory(WithPlaceholder);
    };
}
exports.withPlaceholder = withPlaceholder;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withSitecoreContext.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withSitecoreContext.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var SitecoreContext_1 = __webpack_require__(/*! ../components/SitecoreContext */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/SitecoreContext.js");
/**
 * @param {WithSitecoreContextOptions} [options]
 */
function withSitecoreContext(options) {
    return function withSitecoreContextHoc(Component) {
        return function WithSitecoreContext(props) {
            return (react_1.default.createElement(SitecoreContext_1.SitecoreContextReactContext.Consumer, null, function (context) { return (react_1.default.createElement(Component, __assign({}, props, { sitecoreContext: context.context, updateSitecoreContext: options && options.updatable && context.setContext }))); }));
        };
    };
}
exports.withSitecoreContext = withSitecoreContext;
/**
 * This hook grants acess to the current SiteCore page context
 * by default JSS includes the following properties in this context:
 * - pageEditing - Provided by Layout Service, a boolean indicating whether the route is being accessed via the Experience Editor.
 * - pageState - Like pageEditing, but a string: normal, preview or edit.
 * - site - Provided by Layout Service, an object containing the name of the current Sitecore site context.
 *
 * @see https://jss.sitecore.com/docs/techniques/extending-layout-service/layoutservice-extending-context
 *
 * @param {WithSitecoreContextOptions} [options] hook options
 *
 * @example
 * const EditMode = () => {
 *    const { sitecoreContext } = useSitecoreContext();
 *    return <span>Edit Mode is {sitecoreContext.pageEditing ? 'active' : 'inactive'}</span>
 * }
 *
 * @example
 * const EditMode = () => {
 *    const { sitecoreContext, updateSitecoreContext } = useSitecoreContext({ updatable: true });
 *    const onClick = () => updateSitecoreContext({ pageEditing: true });
 *    return <span onClick={onClick}>Edit Mode is {sitecoreContext.pageEditing ? 'active' : 'inactive'}</span>
 * }
 * @returns {Object} { sitecoreContext, updateSitecoreContext }
 */
function useSitecoreContext(options) {
    var _a;
    var reactContext = react_1.default.useContext(SitecoreContext_1.SitecoreContextReactContext);
    var updatable = (_a = options) === null || _a === void 0 ? void 0 : _a.updatable;
    return {
        sitecoreContext: reactContext.context,
        updateSitecoreContext: updatable ? reactContext.setContext : undefined,
    };
}
exports.useSitecoreContext = useSitecoreContext;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sitecore_jss_1 = __webpack_require__(/*! @sitecore-jss/sitecore-jss */ "./node_modules/@sitecore-jss/sitecore-jss/dist/index.js");
exports.dataApi = sitecore_jss_1.dataApi;
exports.mediaApi = sitecore_jss_1.mediaApi;
exports.isExperienceEditorActive = sitecore_jss_1.isExperienceEditorActive;
exports.resetExperienceEditorChromes = sitecore_jss_1.resetExperienceEditorChromes;
exports.LayoutServicePageState = sitecore_jss_1.LayoutServicePageState;
exports.getChildPlaceholder = sitecore_jss_1.getChildPlaceholder;
exports.getFieldValue = sitecore_jss_1.getFieldValue;
var Placeholder_1 = __webpack_require__(/*! ./components/Placeholder */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Placeholder.js");
exports.Placeholder = Placeholder_1.Placeholder;
var Image_1 = __webpack_require__(/*! ./components/Image */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Image.js");
exports.Image = Image_1.Image;
var RichText_1 = __webpack_require__(/*! ./components/RichText */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/RichText.js");
exports.RichText = RichText_1.RichText;
exports.RichTextPropTypes = RichText_1.RichTextPropTypes;
var Text_1 = __webpack_require__(/*! ./components/Text */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Text.js");
exports.Text = Text_1.Text;
var Date_1 = __webpack_require__(/*! ./components/Date */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Date.js");
exports.DateField = Date_1.DateField;
var Link_1 = __webpack_require__(/*! ./components/Link */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/Link.js");
exports.Link = Link_1.Link;
exports.LinkPropTypes = Link_1.LinkPropTypes;
var File_1 = __webpack_require__(/*! ./components/File */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/File.js");
exports.File = File_1.File;
var VisitorIdentification_1 = __webpack_require__(/*! ./components/VisitorIdentification */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/VisitorIdentification.js");
exports.VisitorIdentification = VisitorIdentification_1.VisitorIdentification;
var SitecoreContext_1 = __webpack_require__(/*! ./components/SitecoreContext */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/components/SitecoreContext.js");
exports.SitecoreContext = SitecoreContext_1.SitecoreContext;
exports.SitecoreContextReactContext = SitecoreContext_1.SitecoreContextReactContext;
var withSitecoreContext_1 = __webpack_require__(/*! ./enhancers/withSitecoreContext */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withSitecoreContext.js");
exports.withSitecoreContext = withSitecoreContext_1.withSitecoreContext;
exports.useSitecoreContext = withSitecoreContext_1.useSitecoreContext;
var withExperienceEditorChromes_1 = __webpack_require__(/*! ./enhancers/withExperienceEditorChromes */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withExperienceEditorChromes.js");
exports.withExperienceEditorChromes = withExperienceEditorChromes_1.withExperienceEditorChromes;
var withPlaceholder_1 = __webpack_require__(/*! ./enhancers/withPlaceholder */ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/enhancers/withPlaceholder.js");
exports.withPlaceholder = withPlaceholder_1.withPlaceholder;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-react/dist/utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-react/dist/utils.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var style_attr_1 = __webpack_require__(/*! style-attr */ "./node_modules/style-attr/lib/index.js");
// https://stackoverflow.com/a/10426674/9324
exports.convertKebabCasetoCamelCase = function (str) {
    return str.replace(/^.|-./g, function (letter, index) {
        return index === 0 ? letter.toLowerCase() : letter.substr(1).toUpperCase();
    });
};
/**
 * https://facebook.github.io/react/docs/dom-elements.html
 * We are only concerned with style at the moment, which needs to be converted from string to object to satisfy React.
 * We don't need to convert any other attributes (that we know of), because the placeholder renders them "as-is" by using the special "is" React prop.
 * For whatever reason though, the "style" prop is still validated as needing to be an object when using the "is" prop, which is why we need to convert from string to object.
 * @param {string} [style] style
 * @returns {Array} converted attributes
 */
exports.convertStyleAttribute = function (style) {
    if (style === void 0) { style = ''; }
    // styleParse converts a style attribute string into an object format
    var parsedStyle = style_attr_1.parse(style, { preserveNumbers: true });
    return Object.keys(parsedStyle).reduce(function (initialResult, styleKey) {
        var result = initialResult;
        var convertedKey = exports.convertKebabCasetoCamelCase(styleKey);
        result[convertedKey] = parsedStyle[styleKey];
        return result;
    }, {});
};
exports.convertAttributesToReactProps = function (attributes) {
    if (!attributes) {
        return [];
    }
    return Object.keys(attributes).reduce(function (initialResult, attrName) {
        var result = initialResult;
        switch (attrName) {
            case 'class': {
                result.className = attributes.class;
                break;
            }
            case 'style': {
                result.style = exports.convertStyleAttribute(attributes.style);
                break;
            }
            default: {
                result[attrName] = attributes[attrName];
                break;
            }
        }
        return result;
    }, {});
};


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-tracking/dist/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-tracking/dist/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var trackingApi = __importStar(__webpack_require__(/*! ./trackingApi */ "./node_modules/@sitecore-jss/sitecore-jss-tracking/dist/trackingApi.js"));
exports.trackingApi = trackingApi;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss-tracking/dist/trackingApi.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss-tracking/dist/trackingApi.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var sitecore_jss_1 = __webpack_require__(/*! @sitecore-jss/sitecore-jss */ "./node_modules/@sitecore-jss/sitecore-jss/dist/index.js");
var ResponseError = /** @class */ (function (_super) {
    __extends(ResponseError, _super);
    function ResponseError(message, response) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, ResponseError.prototype);
        _this.response = response;
        return _this;
    }
    return ResponseError;
}(Error));
/**
 * @param {HttpResponse<unknown>} response
 */
function checkStatus(response) {
    if (response.status >= 200 && response.status < 300) {
        return response;
    }
    var error = new ResponseError(response.statusText, response);
    throw error;
}
/**
 * Note: axios needs to use `withCredentials: true` in order for Sitecore cookies to be included in CORS requests
 * which is necessary for analytics and such
 * @param {string} url
 * @param {any} data
 * @param {HttpDataFetcher<T>} fetcher
 * @param {Object} params
 */
function fetchData(url, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
data, fetcher, params) {
    if (params === void 0) { params = {}; }
    return fetcher(sitecore_jss_1.resolveUrl(url, params), data)
        .then(checkStatus)
        .then(function (response) {
        // axios auto-parses JSON responses, don't need to JSON.parse
        return response.data;
    });
}
/**
 * @param {TrackingRequestOptions} options
 */
function resolveTrackingUrl(options) {
    var _a = options.host, host = _a === void 0 ? '' : _a, _b = options.serviceUrl, serviceUrl = _b === void 0 ? '/sitecore/api/jss/track' : _b, _c = options.action, action = _c === void 0 ? 'event' : _c;
    return "" + host + serviceUrl + "/" + action;
}
/**
 * Makes a request to Sitecore Layout Service for the specified route item path.
 * @param {Array<EventInstance | GoalInstance | OutcomeInstance | CampaignInstance | PageViewInstance>} events
 * @param {TrackingRequestOptions} options
 * @returns {Promise<void>} void
 */
function trackEvent(events, options) {
    var querystringParams = options.querystringParams;
    if (!options.test && sitecore_jss_1.isServer()) {
        // do nothing for SSR, only track events when a browser requests it
        return Promise.resolve();
    }
    if (!Array.isArray(events)) {
        events = [events];
    }
    var fetchUrl = resolveTrackingUrl(options);
    return fetchData(fetchUrl, events, options.fetcher, querystringParams);
}
exports.trackEvent = trackEvent;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/axios-fetcher.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/axios-fetcher.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
var debug_1 = __importDefault(__webpack_require__(/*! ./debug */ "./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js"));
/**
 * Determines whether error is AxiosError
 * @param {unknown} error
 */
var isAxiosError = function (error) {
    return error.isAxiosError !== undefined;
};
var AxiosDataFetcher = /** @class */ (function () {
    /**
     * @param {AxiosDataFetcherConfig} dataFetcherConfig Axios data fetcher configuration.
     * Note `withCredentials` is set to `true` by default in order for Sitecore cookies to
     * be included in CORS requests (which is necessary for analytics and such).
     */
    function AxiosDataFetcher(dataFetcherConfig) {
        if (dataFetcherConfig === void 0) { dataFetcherConfig = {}; }
        var onReq = dataFetcherConfig.onReq, onRes = dataFetcherConfig.onRes, onReqError = dataFetcherConfig.onReqError, onResError = dataFetcherConfig.onResError, axiosConfig = __rest(dataFetcherConfig, ["onReq", "onRes", "onReqError", "onResError"]);
        if (axiosConfig.withCredentials === undefined) {
            axiosConfig.withCredentials = true;
        }
        this.instance = axios_1.default.create(axiosConfig);
        var debug = dataFetcherConfig.debugger || debug_1.default.http;
        // Note Axios response interceptors are applied in registered order;
        // however, request interceptors are REVERSED (https://github.com/axios/axios/issues/1663).
        // Hence, we're adding our request debug logging first (since we want that performed after any onReq)
        // and our response debug logging second (since we want that performed after any onRes).
        if (debug.enabled) {
            this.instance.interceptors.request.use(function (config) {
                debug('request: %o', config);
                return config;
            }, function (error) {
                debug('request error: %o', isAxiosError(error) ? error.toJSON() : error);
                return Promise.reject(error);
            });
        }
        if (onReq) {
            this.instance.interceptors.request.use(onReq, onReqError);
        }
        if (onRes) {
            this.instance.interceptors.response.use(onRes, onResError);
        }
        if (debug.enabled) {
            this.instance.interceptors.response.use(function (response) {
                // Note we're removing redundant properties (already part of request log above) to trim down log entry
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                var request = response.request, config = response.config, rest = __rest(response, ["request", "config"]);
                debug('response: %o', rest);
                return response;
            }, function (error) {
                debug('response error: %o', isAxiosError(error) ? error.toJSON() : error);
                return Promise.reject(error);
            });
        }
    }
    /**
     * Implements a data fetcher. @see HttpDataFetcher<T> type for implementation details/notes.
     * @param {string} url The URL to request; may include query string
     * @param {any} [data] Optional data to POST with the request.
     * @returns {Promise<AxiosResponse<T>>} response
     */
    AxiosDataFetcher.prototype.fetch = function (url, data) {
        return this.instance.request({
            url: url,
            method: data ? 'POST' : 'GET',
            data: data,
        });
    };
    /**
     * Perform a GET request
     * @param {string} url The URL to request; may include query string
     * @param {AxiosRequestConfig} [config] Axios config
     * @returns {Promise<AxiosResponse<T>>} response
     */
    AxiosDataFetcher.prototype.get = function (url, config) {
        return this.instance.get(url, config);
    };
    /**
     * Perform a HEAD request
     * @param {string} url The URL to request; may include query string
     * @param {AxiosRequestConfig} [config] Axios config
     * @returns {Promise<AxiosResponse>} response
     */
    AxiosDataFetcher.prototype.head = function (url, config) {
        return this.instance.head(url, config);
    };
    /**
     * Perform a POST request
     * @param {string} url The URL to request; may include query string
     * @param {any} [data] Data to POST with the request.
     * @param {AxiosRequestConfig} [config] Axios config
     * @returns {Promise<AxiosResponse>} response
     */
    AxiosDataFetcher.prototype.post = function (url, data, config) {
        return this.instance.post(url, data, config);
    };
    /**
     * Perform a PUT request
     * @param {string} url The URL to request; may include query string
     * @param {any} [data] Data to PUT with the request.
     * @param {AxiosRequestConfig} [config] Axios config
     * @returns {Promise<AxiosResponse>} response
     */
    AxiosDataFetcher.prototype.put = function (url, data, config) {
        return this.instance.put(url, data, config);
    };
    /**
     * Perform a DELETE request
     * @param {string} url The URL to request; may include query string
     * @param {AxiosRequestConfig} [config] Axios config
     * @returns {Promise<AxiosResponse>} response
     */
    AxiosDataFetcher.prototype.delete = function (url, config) {
        return this.instance.delete(url, config);
    };
    return AxiosDataFetcher;
}());
exports.AxiosDataFetcher = AxiosDataFetcher;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/cache-client.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/cache-client.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var memory_cache_1 = __webpack_require__(/*! memory-cache */ "./node_modules/memory-cache/index.js");
/**
 * Default cache configuration
 */
var DEFAULTS = Object.freeze({
    cacheTimeout: 60,
    cacheEnabled: true,
});
/**
 * A cache client that uses the 'memory-cache' library (https://github.com/ptarjan/node-cache).
 * This class is meant to be extended or used as a mixin; it's not meant to be used directly.
 * @template T The type of data being cached.
 * @mixin
 */
var MemoryCacheClient = /** @class */ (function () {
    /**
     * Initializes a new instance of @see MemoryCacheClient using the provided @see CacheOptions
     * @param {CacheOptions} options Configuration options
     */
    function MemoryCacheClient(options) {
        var _a;
        this.options = options;
        this.cache = new memory_cache_1.Cache();
        this.options.cacheTimeout = (_a = this.options.cacheTimeout, (_a !== null && _a !== void 0 ? _a : DEFAULTS.cacheTimeout)) * 1000;
        if (this.options.cacheEnabled === undefined) {
            this.options.cacheEnabled = DEFAULTS.cacheEnabled;
        }
    }
    /**
     * Retrieves a value from the cache.
     * @template T The type of data being cached.
     * @param {string} key The cache key.
     * @returns The cache value as {T}, or null if the specified key is not found in the cache.
     */
    MemoryCacheClient.prototype.getCacheValue = function (key) {
        return this.options.cacheEnabled ? this.cache.get(key) : null;
    };
    /**
     * Adds a value to the cache for the specified cache key.
     * @template T The type of data being cached.
     * @param {string} key The cache key.
     * @param {T} value The value to cache.
     * @returns The value added to the cache.
     */
    MemoryCacheClient.prototype.setCacheValue = function (key, value) {
        return this.options.cacheEnabled
            ? this.cache.put(key, value, this.options.cacheTimeout)
            : value;
    };
    return MemoryCacheClient;
}());
exports.MemoryCacheClient = MemoryCacheClient;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/constants.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var SitecoreTemplateId;
(function (SitecoreTemplateId) {
    // /sitecore/templates/Foundation/JavaScript Services/App
    SitecoreTemplateId["JssApp"] = "061cba1554744b918a0617903b102b82";
    // /sitecore/templates/System/Dictionary/Dictionary entry
    SitecoreTemplateId["DictionaryEntry"] = "6d1cd89719364a3aa511289a94c2a7b1";
})(SitecoreTemplateId = exports.SitecoreTemplateId || (exports.SitecoreTemplateId = {}));


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/data-fetcher.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/data-fetcher.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var resolve_url_1 = __importDefault(__webpack_require__(/*! ./utils/resolve-url */ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/resolve-url.js"));
var ResponseError = /** @class */ (function (_super) {
    __extends(ResponseError, _super);
    function ResponseError(message, response) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, ResponseError.prototype);
        _this.response = response;
        return _this;
    }
    return ResponseError;
}(Error));
/**
 * @param {HttpResponse<T>} response
 * @throws {ResponseError} if response code is not ok
 */
function checkStatus(response) {
    if (response.status >= 200 && response.status < 300) {
        return response;
    }
    var error = new ResponseError(response.statusText, response);
    throw error;
}
/**
 * @param {string} url
 * @param {HttpDataFetcher} fetcher
 * @param {Object} params
 */
function fetchData(url, fetcher, params) {
    if (params === void 0) { params = {}; }
    return fetcher(resolve_url_1.default(url, params))
        .then(checkStatus)
        .then(function (response) {
        // axios auto-parses JSON responses, don't need to JSON.parse
        return response.data;
    });
}
exports.fetchData = fetchData;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js":
/*!***************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
var is_server_1 = __importDefault(__webpack_require__(/*! ./utils/is-server */ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/is-server.js"));
var rootNamespace = 'sitecore-jss';
// On server/node side, allow switching from the built-in
// `%o` (pretty-print single line) and `%O` (pretty-print multiple line)
// with a `DEBUG_MULTILINE` environment variable.
if (is_server_1.default() &&
    ((_b = (_a = process) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.DEBUG_MULTILINE) === 'true' &&
    debug_1.default.formatters.o &&
    debug_1.default.formatters.O) {
    debug_1.default.formatters.o = debug_1.default.formatters.O;
}
/**
 * Default Sitecore JSS 'debug' module debuggers. Uses namespace prefix 'sitecore-jss:'.
 * See {@link https://www.npmjs.com/package/debug} for details.
 */
exports.default = Object.freeze({
    http: debug_1.default(rootNamespace + ":http"),
    layout: debug_1.default(rootNamespace + ":layout"),
    dictionary: debug_1.default(rootNamespace + ":dictionary"),
    experienceEditor: debug_1.default(rootNamespace + ":editing"),
    sitemap: debug_1.default(rootNamespace + ":sitemap"),
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql-request-client.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/graphql-request-client.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_request_1 = __webpack_require__(/*! graphql-request */ "./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/index.js");
var debug_1 = __importDefault(__webpack_require__(/*! ./debug */ "./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js"));
/**
 * A GraphQL client for Sitecore APIs that uses the 'graphql-request' library.
 * https://github.com/prisma-labs/graphql-request
 */
var GraphQLRequestClient = /** @class */ (function () {
    /**
     * Provides ability to execute graphql query using given `endpoint`
     * @param {string} endpoint The Graphql endpoint
     * @param {GraphQLRequestClientConfig} [clientConfig] GraphQL request client configuration.
     */
    function GraphQLRequestClient(endpoint, clientConfig) {
        if (clientConfig === void 0) { clientConfig = {}; }
        this.endpoint = endpoint;
        this.headers = {};
        if (clientConfig.apiKey) {
            this.headers.sc_apikey = clientConfig.apiKey;
        }
        this.client = new graphql_request_1.GraphQLClient(endpoint, { headers: this.headers });
        this.debug = clientConfig.debugger || debug_1.default.http;
    }
    /**
     * Execute graphql request
     * @param {string | DocumentNode} query graphql query
     * @param {Object} variables graphql variables
     */
    GraphQLRequestClient.prototype.request = function (query, variables) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        // Note we don't have access to raw request/response with graphql-request
                        // (or nice hooks like we have with Axios), but we should log whatever we have.
                        _this.debug('request: %o', {
                            url: _this.endpoint,
                            headers: _this.headers,
                            query: query,
                            variables: variables,
                        });
                        _this.client
                            .request(query, variables)
                            .then(function (data) {
                            _this.debug('response: %o', data);
                            resolve(data);
                        })
                            .catch(function (error) {
                            _this.debug('response error: %o', error.response);
                            return reject(error);
                        });
                    })];
            });
        });
    };
    return GraphQLRequestClient;
}());
exports.GraphQLRequestClient = GraphQLRequestClient;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/app-root-query.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/app-root-query.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/@sitecore-jss/sitecore-jss/dist/constants.js");
var debug_1 = __importDefault(__webpack_require__(/*! ../debug */ "./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js"));
/** @private */
exports.siteNameError = 'The site name must be a non-empty string';
/** @private */
exports.languageError = 'The language must be a non-empty string';
/*
 * GraphQL query that returns the ID of the root item of the specified site and language
 */
var appRootQuery = /* GraphQL */ "\n  query AppRootQuery($jssAppTemplateId: String!, $siteName: String!, $language: String!) {\n    layout(site: $siteName, routePath: \"/\", language: $language) {\n      homePage: item {\n        rootItem: ancestors(includeTemplateIDs: [$jssAppTemplateId]) {\n          id\n        }\n      }\n    }\n  }\n";
/**
 * Gets the ID of the JSS App root item for the specified site and language.
 * @param {GraphQLClient} client that fetches data from a GraphQL endpoint.
 * @param {string} siteName the name of the Sitecore site.
 * @param {string} language the item language version.
 * @param {string} jssAppTemplateId optional template ID of the app root item. If not
 * specified, the ID of the "/sitecore/templates/Foundation/JavaScript Services/App"
 * item is used.
 * @returns the root item ID of the JSS App in Sitecore. Returns null if the app root item is not found.
 * @throws {RangeError} if a valid site name value is not provided.
 * @throws {RangeError} if a valid language value is not provided.
 * This function intentionally avoids throwing an error if a root item is not found,
 * leaving that decision up to implementations.
 */
function getAppRootId(client, siteName, language, jssAppTemplateId) {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function () {
        var fetchResponse;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    if (!siteName) {
                        throw new RangeError(exports.siteNameError);
                    }
                    if (!language) {
                        throw new RangeError(exports.languageError);
                    }
                    debug_1.default.dictionary('fetching site root for %s %s', language, siteName);
                    return [4 /*yield*/, client.request(appRootQuery, {
                            jssAppTemplateId: jssAppTemplateId || constants_1.SitecoreTemplateId.JssApp,
                            siteName: siteName,
                            language: language,
                        })];
                case 1:
                    fetchResponse = _e.sent();
                    if (!((_d = (_c = (_b = (_a = fetchResponse) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.homePage) === null || _c === void 0 ? void 0 : _c.rootItem) === null || _d === void 0 ? void 0 : _d.length)) {
                        return [2 /*return*/, null];
                    }
                    return [2 /*return*/, fetchResponse.layout.homePage.rootItem[0].id];
            }
        });
    });
}
exports.getAppRootId = getAppRootId;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var app_root_query_1 = __webpack_require__(/*! ./app-root-query */ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/app-root-query.js");
exports.getAppRootId = app_root_query_1.getAppRootId;
var search_service_1 = __webpack_require__(/*! ./search-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/search-service.js");
exports.SearchQueryService = search_service_1.SearchQueryService;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/search-service.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/search-service.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Provides functionality for performing GraphQL 'search' operations, including handling pagination.
 * This class is meant to be extended or used as a mixin; it's not meant to be used directly.
 * @template T The type of objects being requested.
 * @mixin
 */
var SearchQueryService = /** @class */ (function () {
    /**
     * Creates an instance of search query service.
     * @param {GraphQLClient} client that fetches data from a GraphQL endpoint.
     */
    function SearchQueryService(client) {
        this.client = client;
    }
    /**
     * 1. Validates mandatory search query arguments
     * 2. Executes search query with pagination
     * 3. Aggregates pagination results into a single result-set.
     * @template T The type of objects being requested.
     * @param {string | DocumentNode} query the search query.
     * @param {SearchQueryVariables} args search query arguments.
     * @returns {T[]} array of result objects.
     * @throws {RangeError} if a valid root item ID is not provided.
     * @throws {RangeError} if the provided language(s) is(are) not valid.
     */
    SearchQueryService.prototype.fetch = function (query, args) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var results, hasNext, after, fetchResponse;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!args.rootItemId) {
                            throw new RangeError('"rootItemId" and "language" must be non-empty strings');
                        }
                        if (!args.language) {
                            throw new RangeError('"rootItemId" and "language" must be non-empty strings');
                        }
                        results = [];
                        hasNext = true;
                        after = '';
                        _c.label = 1;
                    case 1:
                        if (!hasNext) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.client.request(query, __assign(__assign({}, args), { after: after }))];
                    case 2:
                        fetchResponse = _c.sent();
                        results = results.concat((_b = (_a = fetchResponse) === null || _a === void 0 ? void 0 : _a.search) === null || _b === void 0 ? void 0 : _b.results);
                        hasNext = fetchResponse.search.pageInfo.hasNext;
                        after = fetchResponse.search.pageInfo.endCursor;
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/, results];
                }
            });
        });
    };
    return SearchQueryService;
}());
exports.SearchQueryService = SearchQueryService;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/dictionary-service.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/dictionary-service.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var cache_client_1 = __webpack_require__(/*! ../cache-client */ "./node_modules/@sitecore-jss/sitecore-jss/dist/cache-client.js");
/**
 * Base implementation of @see DictionaryService that handles caching dictionary values
 */
var DictionaryServiceBase = /** @class */ (function () {
    /**
     * Initializes a new instance of @see DictionaryService using the provided @see CacheOptions
     * @param {CacheOptions} options Configuration options
     */
    function DictionaryServiceBase(options) {
        this.options = options;
        this.cache = this.getCacheClient();
    }
    /**
     * Caches a @see DictionaryPhrases value for the specified cache key.
     * @param {string} key The cache key.
     * @param {DictionaryPhrases} value The value to cache.
     * @returns The value added to the cache.
     * @mixes CacheClient<DictionaryPhrases>
     */
    DictionaryServiceBase.prototype.setCacheValue = function (key, value) {
        return this.cache.setCacheValue(key, value);
    };
    /**
     * Retrieves a @see DictionaryPhrases value from the cache.
     * @param {string} key The cache key.
     * @returns The @see DictionaryPhrases value, or null if the specified key is not found in the cache.
     */
    DictionaryServiceBase.prototype.getCacheValue = function (key) {
        return this.cache.getCacheValue(key);
    };
    /**
     * Gets a cache client that can cache data. Uses memory-cache as the default
     * library for caching (@see MemoryCacheClient). Override this method if you
     * want to use something else.
     * @returns {CacheClient} implementation
     */
    DictionaryServiceBase.prototype.getCacheClient = function () {
        return new cache_client_1.MemoryCacheClient(this.options);
    };
    return DictionaryServiceBase;
}());
exports.DictionaryServiceBase = DictionaryServiceBase;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/graphql-dictionary-service.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/graphql-dictionary-service.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_request_client_1 = __webpack_require__(/*! ../graphql-request-client */ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql-request-client.js");
var constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/@sitecore-jss/sitecore-jss/dist/constants.js");
var dictionary_service_1 = __webpack_require__(/*! ./dictionary-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/dictionary-service.js");
var graphql_1 = __webpack_require__(/*! ../graphql */ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/index.js");
var debug_1 = __importDefault(__webpack_require__(/*! ../debug */ "./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js"));
/** @private */
exports.queryError = 'Valid value for rootItemId not provided and failed to auto-resolve app root item.';
var query = /* GraphQL */ "\n  query DictionarySearch(\n    $rootItemId: String!\n    $language: String!\n    $templates: String!\n    $pageSize: Int = 10\n    $after: String\n  ) {\n    search(\n      where: {\n        AND: [\n          { name: \"_path\", value: $rootItemId, operator: CONTAINS }\n          { name: \"_language\", value: $language }\n          { name: \"_templates\", value: $templates, operator: CONTAINS }\n        ]\n      }\n      first: $pageSize\n      after: $after\n    ) {\n      total\n      pageInfo {\n        endCursor\n        hasNext\n      }\n      results {\n        key: field(name: \"Key\") {\n          value\n        }\n        phrase: field(name: \"Phrase\") {\n          value\n        }\n      }\n    }\n  }\n";
/**
 * Service that fetch dictionary data using Sitecore's GraphQL API.
 * @augments DictionaryServiceBase
 * @mixes SearchQueryService<DictionaryQueryResult>
 */
var GraphQLDictionaryService = /** @class */ (function (_super) {
    __extends(GraphQLDictionaryService, _super);
    /**
     * Creates an instance of graphQL dictionary service with the provided options
     * @param {GraphQLDictionaryService} options instance
     */
    function GraphQLDictionaryService(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        _this.graphQLClient = _this.getGraphQLClient();
        _this.searchService = new graphql_1.SearchQueryService(_this.graphQLClient);
        return _this;
    }
    /**
     * Fetches dictionary data for internalization.
     * @param {string} language the language to fetch
     * @default query (@see query)
     * @returns dictionary phrases
     * @throws {Error} if the app root was not found for the specified site and language.
     */
    GraphQLDictionaryService.prototype.fetchDictionaryData = function (language) {
        return __awaiter(this, void 0, void 0, function () {
            var cacheKey, cachedValue, rootItemId, _a, phrases;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        cacheKey = this.options.siteName + language;
                        cachedValue = this.getCacheValue(cacheKey);
                        if (cachedValue) {
                            debug_1.default.dictionary('using cached dictionary data for %s %s', language, this.options.siteName);
                            return [2 /*return*/, cachedValue];
                        }
                        _a = this.options.rootItemId;
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, graphql_1.getAppRootId(this.graphQLClient, this.options.siteName, language)];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        rootItemId = _a;
                        if (!rootItemId) {
                            throw new Error(exports.queryError);
                        }
                        debug_1.default.dictionary('fetching dictionary data for %s %s', language, this.options.siteName);
                        phrases = {};
                        return [4 /*yield*/, this.searchService
                                .fetch(query, {
                                rootItemId: rootItemId,
                                language: language,
                                templates: this.options.dictionaryEntryTemplateId || constants_1.SitecoreTemplateId.DictionaryEntry,
                                pageSize: this.options.pageSize,
                            })
                                .then(function (results) {
                                results.forEach(function (item) { return (phrases[item.key.value] = item.phrase.value); });
                            })];
                    case 3:
                        _b.sent();
                        this.setCacheValue(cacheKey, phrases);
                        return [2 /*return*/, phrases];
                }
            });
        });
    };
    /**
     * Gets a GraphQL client that can make requests to the API. Uses graphql-request as the default
     * library for fetching graphql data (@see GraphQLRequestClient). Override this method if you
     * want to use something else.
     * @returns {GraphQLClient} implementation
     */
    GraphQLDictionaryService.prototype.getGraphQLClient = function () {
        return new graphql_request_client_1.GraphQLRequestClient(this.options.endpoint, {
            apiKey: this.options.apiKey,
            debugger: debug_1.default.dictionary,
        });
    };
    return GraphQLDictionaryService;
}(dictionary_service_1.DictionaryServiceBase));
exports.GraphQLDictionaryService = GraphQLDictionaryService;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var dictionary_service_1 = __webpack_require__(/*! ./dictionary-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/dictionary-service.js");
exports.DictionaryServiceBase = dictionary_service_1.DictionaryServiceBase;
var graphql_dictionary_service_1 = __webpack_require__(/*! ./graphql-dictionary-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/graphql-dictionary-service.js");
exports.GraphQLDictionaryService = graphql_dictionary_service_1.GraphQLDictionaryService;
var rest_dictionary_service_1 = __webpack_require__(/*! ./rest-dictionary-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/rest-dictionary-service.js");
exports.RestDictionaryService = rest_dictionary_service_1.RestDictionaryService;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/rest-dictionary-service.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/rest-dictionary-service.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var axios_fetcher_1 = __webpack_require__(/*! ../axios-fetcher */ "./node_modules/@sitecore-jss/sitecore-jss/dist/axios-fetcher.js");
var data_fetcher_1 = __webpack_require__(/*! ../data-fetcher */ "./node_modules/@sitecore-jss/sitecore-jss/dist/data-fetcher.js");
var dictionary_service_1 = __webpack_require__(/*! ./dictionary-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/dictionary-service.js");
var debug_1 = __importDefault(__webpack_require__(/*! ../debug */ "./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js"));
/**
 * Fetch dictionary data using the Sitecore Dictionary Service REST API.
 * Uses Axios as the default data fetcher (@see AxiosDataFetcher).
 */
var RestDictionaryService = /** @class */ (function (_super) {
    __extends(RestDictionaryService, _super);
    function RestDictionaryService(options) {
        var _this = _super.call(this, options) || this;
        _this.options = options;
        return _this;
    }
    Object.defineProperty(RestDictionaryService.prototype, "defaultFetcher", {
        /**
         * Provides default @see AxiosDataFetcher data fetcher
         */
        get: function () {
            var dataFetcher = new axios_fetcher_1.AxiosDataFetcher({ debugger: debug_1.default.dictionary });
            return function (url) { return dataFetcher.fetch(url); };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Fetch dictionary data for a language.
     * @param {string} language
     */
    RestDictionaryService.prototype.fetchDictionaryData = function (language) {
        return __awaiter(this, void 0, void 0, function () {
            var endpoint, cachedValue, fetcher, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        endpoint = this.getUrl(language);
                        cachedValue = this.getCacheValue(endpoint);
                        if (cachedValue) {
                            debug_1.default.dictionary('using cached dictionary data for %s %s', language, this.options.siteName);
                            return [2 /*return*/, cachedValue];
                        }
                        debug_1.default.dictionary('fetching dictionary data for %s %s', language, this.options.siteName);
                        fetcher = this.options.dataFetcher || this.defaultFetcher;
                        return [4 /*yield*/, data_fetcher_1.fetchData(endpoint, fetcher, {
                                sc_apikey: this.options.apiKey,
                            })];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, this.setCacheValue(endpoint, response.phrases)];
                }
            });
        });
    };
    /**
     * Generate dictionary service url
     * @param {string} language
     */
    RestDictionaryService.prototype.getUrl = function (language) {
        return this.options.apiHost + "/sitecore/api/jss/dictionary/" + this.options.siteName + "/" + language;
    };
    return RestDictionaryService;
}(dictionary_service_1.DictionaryServiceBase));
exports.RestDictionaryService = RestDictionaryService;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mediaApi = __importStar(__webpack_require__(/*! ./media-api */ "./node_modules/@sitecore-jss/sitecore-jss/dist/media-api.js"));
exports.mediaApi = mediaApi;
var constants = __importStar(__webpack_require__(/*! ./constants */ "./node_modules/@sitecore-jss/sitecore-jss/dist/constants.js"));
exports.constants = constants;
__export(__webpack_require__(/*! ./utils */ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/index.js"));
__export(__webpack_require__(/*! ./graphql */ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql/index.js"));
var debug_1 = __webpack_require__(/*! ./debug */ "./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js");
exports.debug = debug_1.default;
var data_fetcher_1 = __webpack_require__(/*! ./data-fetcher */ "./node_modules/@sitecore-jss/sitecore-jss/dist/data-fetcher.js");
exports.fetchData = data_fetcher_1.fetchData;
__export(__webpack_require__(/*! ./graphql-request-client */ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql-request-client.js"));
__export(__webpack_require__(/*! ./axios-fetcher */ "./node_modules/@sitecore-jss/sitecore-jss/dist/axios-fetcher.js"));
__export(__webpack_require__(/*! ./cache-client */ "./node_modules/@sitecore-jss/sitecore-jss/dist/cache-client.js"));
__export(__webpack_require__(/*! ./i18n */ "./node_modules/@sitecore-jss/sitecore-jss/dist/i18n/index.js"));
// layout
var models_1 = __webpack_require__(/*! ./layout/models */ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/models.js");
exports.LayoutServicePageState = models_1.LayoutServicePageState;
var utils_1 = __webpack_require__(/*! ./layout/utils */ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/utils.js");
exports.getFieldValue = utils_1.getFieldValue;
exports.getChildPlaceholder = utils_1.getChildPlaceholder;
var rest_layout_service_1 = __webpack_require__(/*! ./layout/rest-layout-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/rest-layout-service.js");
exports.RestLayoutService = rest_layout_service_1.RestLayoutService;
var graphql_layout_service_1 = __webpack_require__(/*! ./layout/graphql-layout-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/graphql-layout-service.js");
exports.GraphQLLayoutService = graphql_layout_service_1.GraphQLLayoutService;
// TODO: these are deprecated and we should stop exporting them
var rest_layout_service_2 = __webpack_require__(/*! ./layout/rest-layout-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/rest-layout-service.js");
var dataApi = { fetchRouteData: rest_layout_service_2.fetchRouteData, fetchPlaceholderData: rest_layout_service_2.fetchPlaceholderData };
exports.dataApi = dataApi;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/graphql-layout-service.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/layout/graphql-layout-service.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var layout_service_1 = __webpack_require__(/*! ./layout-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/layout-service.js");
var graphql_request_client_1 = __webpack_require__(/*! ../graphql-request-client */ "./node_modules/@sitecore-jss/sitecore-jss/dist/graphql-request-client.js");
var debug_1 = __importDefault(__webpack_require__(/*! ../debug */ "./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js"));
var GraphQLLayoutService = /** @class */ (function (_super) {
    __extends(GraphQLLayoutService, _super);
    /**
     * Fetch layout data using the Sitecore GraphQL endpoint.
     * @param {GraphQLLayoutServiceConfig} serviceConfig
     */
    function GraphQLLayoutService(serviceConfig) {
        var _this = _super.call(this) || this;
        _this.serviceConfig = serviceConfig;
        _this.graphQLClient = _this.getGraphQLClient();
        return _this;
    }
    /**
     * Fetch layout data for an item.
     * @param {string} itemPath
     * @param {string} [language]
     * @returns {Promise<LayoutServiceData>} layout service data
     */
    GraphQLLayoutService.prototype.fetchLayoutData = function (itemPath, language) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var query, data;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        query = this.getLayoutQuery(itemPath, language);
                        debug_1.default.layout('fetching layout data for %s %s %s', itemPath, language, this.serviceConfig.siteName);
                        return [4 /*yield*/, this.graphQLClient.request(query)];
                    case 1:
                        data = _c.sent();
                        // If `rendered` is empty -> not found
                        return [2 /*return*/, (((_b = (_a = data) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.item.rendered) || {
                                sitecore: { context: { pageEditing: false, language: language }, route: null },
                            })];
                }
            });
        });
    };
    /**
     * Gets a GraphQL client that can make requests to the API. Uses graphql-request as the default
     * library for fetching graphql data (@see GraphQLRequestClient). Override this method if you
     * want to use something else.
     * @returns {GraphQLClient} implementation
     */
    GraphQLLayoutService.prototype.getGraphQLClient = function () {
        return new graphql_request_client_1.GraphQLRequestClient(this.serviceConfig.endpoint, {
            apiKey: this.serviceConfig.apiKey,
            debugger: debug_1.default.layout,
        });
    };
    /**
     * Returns GraphQL Layout query
     * @param {string} itemPath page route
     * @param {string} [language] language
     */
    GraphQLLayoutService.prototype.getLayoutQuery = function (itemPath, language) {
        var languageVariable = language ? ", language:\"" + language + "\"" : '';
        var layoutQuery = this.serviceConfig.formatLayoutQuery
            ? this.serviceConfig.formatLayoutQuery(this.serviceConfig.siteName, itemPath, language)
            : "layout(site:\"" + this.serviceConfig.siteName + "\", routePath:\"" + itemPath + "\"" + languageVariable + ")";
        return "query {\n      " + layoutQuery + "{\n        item {\n          rendered\n        }\n      }\n    }";
    };
    return GraphQLLayoutService;
}(layout_service_1.LayoutServiceBase));
exports.GraphQLLayoutService = GraphQLLayoutService;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/layout-service.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/layout/layout-service.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LayoutServiceBase = /** @class */ (function () {
    function LayoutServiceBase() {
    }
    return LayoutServiceBase;
}());
exports.LayoutServiceBase = LayoutServiceBase;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/models.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/layout/models.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Layout Service page state enum
 */
var LayoutServicePageState;
(function (LayoutServicePageState) {
    LayoutServicePageState["Preview"] = "preview";
    LayoutServicePageState["Edit"] = "edit";
    LayoutServicePageState["Normal"] = "normal";
})(LayoutServicePageState = exports.LayoutServicePageState || (exports.LayoutServicePageState = {}));


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/rest-layout-service.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/layout/rest-layout-service.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var layout_service_1 = __webpack_require__(/*! ./layout-service */ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/layout-service.js");
var axios_fetcher_1 = __webpack_require__(/*! ../axios-fetcher */ "./node_modules/@sitecore-jss/sitecore-jss/dist/axios-fetcher.js");
var data_fetcher_1 = __webpack_require__(/*! ../data-fetcher */ "./node_modules/@sitecore-jss/sitecore-jss/dist/data-fetcher.js");
var debug_1 = __importDefault(__webpack_require__(/*! ../debug */ "./node_modules/@sitecore-jss/sitecore-jss/dist/debug.js"));
/**
 * Resolves layout service url
 * @param {LayoutServiceConfig} [options] layout service options
 * @param {string} apiType which layout service API to call ('render' or 'placeholder')
 * @returns the layout service url
 */
function resolveLayoutServiceUrl(options, apiType) {
    if (options === void 0) { options = {}; }
    var _a = options.host, host = _a === void 0 ? '' : _a, _b = options.configurationName, configurationName = _b === void 0 ? 'jss' : _b, serviceUrl = options.serviceUrl;
    if (serviceUrl) {
        return serviceUrl;
    }
    return host + "/sitecore/api/layout/" + apiType + "/" + configurationName;
}
exports.resolveLayoutServiceUrl = resolveLayoutServiceUrl;
/**
 * Makes a request to Sitecore Layout Service for the specified route item path.
 * @deprecated Will be removed in a future release. Please use LayoutService.fetchLayoutData instead,
 * @see {LayoutService} - fetchLayoutData
 * @param {string} itemPath
 * @param {LayoutServiceRequestOptions<LayoutServiceData>} options
 * @returns {Promise<LayoutServiceData>} layout data
 */
function fetchRouteData(itemPath, options) {
    var querystringParams = options.querystringParams, layoutServiceConfig = options.layoutServiceConfig;
    var fetchUrl = resolveLayoutServiceUrl(layoutServiceConfig, 'render');
    return data_fetcher_1.fetchData(fetchUrl, options.fetcher, __assign({ item: itemPath }, querystringParams));
}
exports.fetchRouteData = fetchRouteData;
/**
 * Makes a request to Sitecore Layout Service for the specified placeholder in
 * a specific route item. Allows you to retrieve rendered data for individual placeholders instead of entire routes.
 * @deprecated Will be removed in a future release. Please use LayoutService.fetchPlaceholderData instead,
 * @see {LayoutService} - fetchPlaceholderData
 * @param {string} placeholderName
 * @param {string} itemPath
 * @param {LayoutServiceRequestOptions<PlaceholderData>} options
 * @returns {Promise<PlaceholderData>} placeholder data
 */
function fetchPlaceholderData(placeholderName, itemPath, options) {
    var querystringParams = options.querystringParams, layoutServiceConfig = options.layoutServiceConfig;
    var fetchUrl = resolveLayoutServiceUrl(layoutServiceConfig, 'placeholder');
    return data_fetcher_1.fetchData(fetchUrl, options.fetcher, __assign({ placeholderName: placeholderName, item: itemPath }, querystringParams));
}
exports.fetchPlaceholderData = fetchPlaceholderData;
/**
 * Fetch layout data using the Sitecore Layout Service REST API.
 * Uses Axios as the default data fetcher (@see AxiosDataFetcher).
 */
var RestLayoutService = /** @class */ (function (_super) {
    __extends(RestLayoutService, _super);
    function RestLayoutService(serviceConfig) {
        var _this = _super.call(this) || this;
        _this.serviceConfig = serviceConfig;
        /**
         * Provides fetch options in order to fetch data
         * @param {string} [language] language will be applied to `sc_lang` param
         * @returns {FetchOptions} fetch options
         */
        _this.getFetchOptions = function (language) {
            var _a;
            var params = {
                sc_apikey: _this.serviceConfig.apiKey,
                sc_site: _this.serviceConfig.siteName,
                sc_lang: language || '',
                tracking: (_a = _this.serviceConfig.tracking, (_a !== null && _a !== void 0 ? _a : true)),
            };
            return {
                layoutServiceConfig: {
                    host: _this.serviceConfig.apiHost,
                    configurationName: _this.serviceConfig.configurationName,
                },
                querystringParams: __assign({}, params),
            };
        };
        /**
         * Provides default @see AxiosDataFetcher data fetcher
         * @param {IncomingMessage} [req] Request instance
         * @param {ServerResponse} [res] Response instance
         * @returns default fetcher
         */
        _this.getDefaultFetcher = function (req, res) {
            var config = {
                debugger: debug_1.default.layout,
            };
            if (req && res) {
                config.onReq = _this.setupReqHeaders(req);
                config.onRes = _this.setupResHeaders(res);
            }
            var axiosFetcher = new axios_fetcher_1.AxiosDataFetcher(config);
            var fetcher = function (url, data) {
                return axiosFetcher.fetch(url, data);
            };
            return fetcher;
        };
        return _this;
    }
    /**
     * Fetch layout data for an item.
     * @param {string} itemPath
     * @param {string} [language]
     * @param {IncomingMessage} [req] Request instance
     * @param {ServerResponse} [res] Response instance
     * @returns {Promise<LayoutServiceData>} layout service data
     */
    RestLayoutService.prototype.fetchLayoutData = function (itemPath, language, req, res) {
        var fetchOptions = this.getFetchOptions(language);
        debug_1.default.layout('fetching layout data for %s %s %s', itemPath, language, this.serviceConfig.siteName);
        var fetcher = this.serviceConfig.dataFetcherResolver
            ? this.serviceConfig.dataFetcherResolver(req, res)
            : this.getDefaultFetcher(req, res);
        return fetchRouteData(itemPath, __assign({ fetcher: fetcher }, fetchOptions)).catch(function (error) {
            var _a;
            if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {
                // Aligned with response of GraphQL Layout Service in case if layout is not found.
                // When 404 Rest Layout Service returns
                // {
                //   sitecore: {
                //     context: {
                //       pageEditing: false,
                //       language
                //     },
                //     route: null
                //   },
                // }
                //
                return error.response.data;
            }
            throw error;
        });
    };
    /**
     * Fetch layout data for a particular placeholder.
     * Makes a request to Sitecore Layout Service for the specified placeholder in
     * a specific route item. Allows you to retrieve rendered data for individual placeholders instead of entire routes.
     * @param {string} placeholderName
     * @param {string} itemPath
     * @param {string} [language]
     * @param {IncomingMessage} [req] Request instance
     * @param {ServerResponse} [res] Response instance
     * @returns {Promise<PlaceholderData>} placeholder data
     */
    RestLayoutService.prototype.fetchPlaceholderData = function (placeholderName, itemPath, language, req, res) {
        var fetchOptions = this.getFetchOptions(language);
        debug_1.default.layout('fetching placeholder data for %s %s %s %s', placeholderName, itemPath, language, this.serviceConfig.siteName);
        var fetcher = this.serviceConfig.dataFetcherResolver
            ? this.serviceConfig.dataFetcherResolver(req, res)
            : this.getDefaultFetcher(req, res);
        return fetchPlaceholderData(placeholderName, itemPath, __assign({ fetcher: fetcher }, fetchOptions));
    };
    /**
     * Setup request headers
     * @param {IncomingMessage} req
     * @returns {AxiosRequestConfig} axios request config
     */
    RestLayoutService.prototype.setupReqHeaders = function (req) {
        return function (reqConfig) {
            debug_1.default.layout('performing request header passing');
            reqConfig.headers.common = __assign(__assign(__assign(__assign(__assign({}, reqConfig.headers.common), (req.headers.cookie && { cookie: req.headers.cookie })), (req.headers.referer && { referer: req.headers.referer })), (req.headers['user-agent'] && { 'user-agent': req.headers['user-agent'] })), (req.connection.remoteAddress && { 'X-Forwarded-For': req.connection.remoteAddress }));
            return reqConfig;
        };
    };
    /**
     * Setup response headers based on response from layout service
     * @param {ServerResponse} res
     * @returns {AxiosResponse} response
     */
    RestLayoutService.prototype.setupResHeaders = function (res) {
        return function (serverRes) {
            debug_1.default.layout('performing response header passing');
            serverRes.headers['set-cookie'] &&
                res.setHeader('set-cookie', serverRes.headers['set-cookie']);
            return serverRes;
        };
    };
    return RestLayoutService;
}(layout_service_1.LayoutServiceBase));
exports.RestLayoutService = RestLayoutService;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/layout/utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/layout/utils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @param {ComponentRendering | Fields} renderingOrFields
 * @param {string} fieldName
 * @param {T} [defaultValue]
 */
function getFieldValue(renderingOrFields, fieldName, defaultValue) {
    if (!renderingOrFields || !fieldName) {
        return defaultValue;
    }
    var fields = renderingOrFields;
    var field = fields[fieldName];
    if (field && typeof field.value !== 'undefined') {
        return field.value;
    }
    var rendering = renderingOrFields;
    if (!rendering.fields ||
        !rendering.fields[fieldName] ||
        typeof rendering.fields[fieldName].value === 'undefined') {
        return defaultValue;
    }
    return rendering.fields[fieldName].value;
}
exports.getFieldValue = getFieldValue;
/**
 * Gets rendering definitions in a given child placeholder under a current rendering.
 * @param {ComponentRendering} rendering
 * @param {string} placeholderName
 * @returns {Array<ComponentRendering | HtmlElementRendering>} child placeholder
 */
function getChildPlaceholder(rendering, placeholderName) {
    if (!rendering ||
        !placeholderName ||
        !rendering.placeholders ||
        !rendering.placeholders[placeholderName]) {
        return [];
    }
    return rendering.placeholders[placeholderName];
}
exports.getChildPlaceholder = getChildPlaceholder;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/media-api.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/media-api.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// what is `import x = require('x');`? great question: https://github.com/Microsoft/TypeScript/issues/5073
var unescape = __webpack_require__(/*! lodash.unescape */ "./node_modules/lodash.unescape/index.js");
var URL = __webpack_require__(/*! url-parse */ "./node_modules/url-parse/index.js");
// finds an img tag with HTML attributes
var imgTagRegex = /<img([^>]+)\/>/i;
// finds all the HTML attributes in a string
var htmlAttrsRegex = /([^=\s]+)(="([^"]*)")?/gi;
// finds the Sitecore media URL prefix
var mediaUrlPrefixRegex = /\/([-~]{1})\/media\//i;
/**
 * Makes a request to Sitecore Content Service for the specified item path.
 * @param {string} editorMarkup
 * @returns {Object | null} found image tag
 */
exports.findEditorImageTag = function (editorMarkup) {
    // match the tag
    var tagMatch = editorMarkup.match(imgTagRegex);
    if (!tagMatch || tagMatch.length < 2) {
        return null;
    }
    // find the attrs and turn them into a Map
    var attrs = {};
    var match = htmlAttrsRegex.exec(tagMatch[1]);
    while (match !== null) {
        attrs[match[1]] = unescape(match[3]);
        match = htmlAttrsRegex.exec(tagMatch[1]);
    }
    return {
        imgTag: tagMatch[0],
        attrs: attrs,
    };
};
/**
 * Get required query string params which should be merged with user params
 * @param {object} qs layout service parsed query string
 * @returns {object} requiredParams
 */
exports.getRequiredParams = function (qs) {
    var rev = qs.rev, db = qs.db, la = qs.la, vs = qs.vs, ts = qs.ts;
    return { rev: rev, db: db, la: la, vs: vs, ts: ts };
};
/**
 * Prepares a Sitecore media URL with `params` for use by the JSS media handler.
 * This is done by replacing `/~/media` or `/-/media` with `/~/jssmedia` or `/-/jssmedia`, respectively.
 * Provided `params` are used as the querystring parameters for the media URL.
 * Can use `mediaUrlPrefix` in order to use a custom prefix.
 * If no `params` are sent, the original media URL is returned.
 * @param {string} url
 * @param {Object} [params]
 * @param {RegExp} [mediaUrlPrefix=mediaUrlPrefixRegex]
 * @returns {string} url
 */
exports.updateImageUrl = function (url, params, mediaUrlPrefix) {
    if (mediaUrlPrefix === void 0) { mediaUrlPrefix = mediaUrlPrefixRegex; }
    if (!params || Object.keys(params).length === 0) {
        // if params aren't supplied, no need to run it through JSS media handler
        return url;
    }
    // polyfill node `global` in browser to workaround https://github.com/unshiftio/url-parse/issues/150
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (typeof window !== 'undefined' && !window.global) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        window.global = {};
    }
    var parsed = URL(url, {}, true);
    var requiredParams = exports.getRequiredParams(parsed.query);
    var query = __assign({}, params);
    Object.entries(requiredParams).forEach(function (_a) {
        var key = _a[0], param = _a[1];
        if (param) {
            query[key] = param;
        }
    });
    parsed.set('query', query);
    var match = mediaUrlPrefix.exec(parsed.pathname);
    if (match && match.length > 1) {
        // regex will provide us with /-/ or /~/ type
        parsed.set('pathname', parsed.pathname.replace(mediaUrlPrefix, "/" + match[1] + "/jssmedia/"));
    }
    return parsed.toString();
};
/**
 * Receives an array of `srcSet` parameters that are iterated and used as parameters to generate
 * a corresponding set of updated Sitecore media URLs via @see updateImageUrl. The result is a comma-delimited
 * list of media URLs with respective dimension parameters.
 *
 * @example
 * // returns '/ipsum.jpg?h=1000&w=1000 1000w, /ipsum.jpg?mh=250&mw=250 250w'
 * getSrcSet('/ipsum.jpg', [{ h: 1000, w: 1000 }, { mh: 250, mw: 250 } ])
 *
 * More information about `srcSet`: {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img}
 *
 * @param {string} url
 * @param {Array} srcSet
 * @param {Object} [imageParams]
 * @param {RegExp} [mediaUrlPrefix]
 * @returns {string} src set
 */
exports.getSrcSet = function (url, srcSet, imageParams, mediaUrlPrefix) {
    return srcSet
        .map(function (params) {
        var newParams = __assign(__assign({}, imageParams), params);
        var imageWidth = newParams.w || newParams.mw;
        if (!imageWidth) {
            return null;
        }
        return exports.updateImageUrl(url, newParams, mediaUrlPrefix) + " " + imageWidth + "w";
    })
        .filter(function (value) { return value; })
        .join(', ');
};


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/experience-editor.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/utils/experience-editor.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var is_server_1 = __importDefault(__webpack_require__(/*! ./is-server */ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/is-server.js"));
exports.isExperienceEditorActive = function () {
    if (is_server_1.default()) {
        return false;
    }
    // eslint-disable-next-line
    var sc = window.Sitecore;
    return Boolean(sc && sc.PageModes && sc.PageModes.ChromeManager);
};
exports.resetExperienceEditorChromes = function () {
    if (exports.isExperienceEditorActive()) {
        // eslint-disable-next-line
        window.Sitecore.PageModes.ChromeManager.resetChromes();
    }
};


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/utils/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var is_server_1 = __importDefault(__webpack_require__(/*! ./is-server */ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/is-server.js"));
exports.isServer = is_server_1.default;
var resolve_url_1 = __importDefault(__webpack_require__(/*! ./resolve-url */ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/resolve-url.js"));
exports.resolveUrl = resolve_url_1.default;
var experience_editor_1 = __webpack_require__(/*! ./experience-editor */ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/experience-editor.js");
exports.isExperienceEditorActive = experience_editor_1.isExperienceEditorActive;
exports.resetExperienceEditorChromes = experience_editor_1.resetExperienceEditorChromes;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/is-server.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/utils/is-server.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Determines whether the current execution context is server-side
 * @returns true if executing server-side
 */
function isServer() {
    return !(typeof window !== 'undefined' && window.document);
}
exports.default = isServer;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/resolve-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/dist/utils/resolve-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var is_server_1 = __importDefault(__webpack_require__(/*! ./is-server */ "./node_modules/@sitecore-jss/sitecore-jss/dist/utils/is-server.js"));
/**
 * note: encodeURIComponent is available via browser (window) or natively in node.js
 * if you use another js engine for server-side rendering you may not have native encodeURIComponent
 * and would then need to install a package for that functionality
 * @param {Object} params
 */
function getQueryString(params) {
    return Object.keys(params)
        .map(function (k) { return encodeURIComponent(k) + "=" + encodeURIComponent(String(params[k])); })
        .join('&');
}
/**
 * Resolves a base URL that may contain query string parameters and an additional set of query
 * string parameters into a unified string representation.
 * @param {string} urlBase the base URL that may contain query string parameters
 * @param {Object} params query string parameters
 * @returns a URL string
 * @throws {RangeError} if the provided url is an empty string
 */
function resolveUrl(urlBase, params) {
    if (params === void 0) { params = {}; }
    if (!urlBase) {
        throw new RangeError('url must be a non-empty string');
    }
    // This is a better way to work with URLs since it handles different user input
    // edge cases. This works in Node and all browser except IE11.
    // https://developer.mozilla.org/en-US/docs/Web/API/URL
    // TODO: Verify our browser support requirements.
    if (is_server_1.default()) {
        var url = new URL(urlBase);
        for (var key in params) {
            if ({}.hasOwnProperty.call(params, key)) {
                url.searchParams.append(key, String(params[key]));
            }
        }
        var result_1 = url.toString();
        return result_1;
    }
    var qs = getQueryString(params);
    var result = urlBase.indexOf('?') !== -1 ? urlBase + "&" + qs : urlBase + "?" + qs;
    return result;
}
exports.default = resolveUrl;


/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/createRequestBody.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/createRequestBody.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var extract_files_1 = __webpack_require__(/*! extract-files */ "./node_modules/extract-files/public/index.mjs");
var form_data_1 = __importDefault(__webpack_require__(/*! form-data */ "./node_modules/form-data/lib/browser.js"));
/**
 * Duck type if NodeJS stream
 * https://github.com/sindresorhus/is-stream/blob/3750505b0727f6df54324784fe369365ef78841e/index.js#L3
 */
var isExtractableFileEnhanced = function (value) {
    return extract_files_1.isExtractableFile(value) ||
        (value !== null && typeof value === 'object' && typeof value.pipe === 'function');
};
/**
 * Returns Multipart Form if body contains files
 * (https://github.com/jaydenseric/graphql-multipart-request-spec)
 * Otherwise returns JSON
 */
function createRequestBody(query, variables, operationName) {
    var _a = extract_files_1.extractFiles({ query: query, variables: variables, operationName: operationName }, '', isExtractableFileEnhanced), clone = _a.clone, files = _a.files;
    if (files.size === 0) {
        return JSON.stringify(clone);
    }
    var Form = typeof FormData === 'undefined' ? form_data_1.default : FormData;
    var form = new Form();
    form.append('operations', JSON.stringify(clone));
    var map = {};
    var i = 0;
    files.forEach(function (paths) {
        map[++i] = paths;
    });
    form.append('map', JSON.stringify(map));
    i = 0;
    files.forEach(function (paths, file) {
        form.append("" + ++i, file);
    });
    return form;
}
exports.default = createRequestBody;
//# sourceMappingURL=createRequestBody.js.map

/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/index.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gql = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;
var cross_fetch_1 = __importStar(__webpack_require__(/*! cross-fetch */ "./node_modules/cross-fetch/dist/browser-ponyfill.js")), CrossFetch = cross_fetch_1;
var printer_1 = __webpack_require__(/*! graphql/language/printer */ "./node_modules/graphql/language/printer.mjs");
var createRequestBody_1 = __importDefault(__webpack_require__(/*! ./createRequestBody */ "./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/createRequestBody.js"));
var types_1 = __webpack_require__(/*! ./types */ "./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/types.js");
var types_2 = __webpack_require__(/*! ./types */ "./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/types.js");
Object.defineProperty(exports, "ClientError", { enumerable: true, get: function () { return types_2.ClientError; } });
/**
 * Convert the given headers configuration into a plain object.
 */
var resolveHeaders = function (headers) {
    var oHeaders = {};
    if (headers) {
        if ((typeof Headers !== 'undefined' && headers instanceof Headers) ||
            headers instanceof CrossFetch.Headers) {
            oHeaders = HeadersInstanceToPlainObject(headers);
        }
        else if (Array.isArray(headers)) {
            headers.forEach(function (_a) {
                var name = _a[0], value = _a[1];
                oHeaders[name] = value;
            });
        }
        else {
            oHeaders = headers;
        }
    }
    return oHeaders;
};
/**
 * Fetch data using POST method
 */
var post = function (_a) {
    var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch = _a.fetch, fetchOptions = _a.fetchOptions;
    return __awaiter(void 0, void 0, void 0, function () {
        var body;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    body = createRequestBody_1.default(query, variables, operationName);
                    return [4 /*yield*/, fetch(url, __assign({ method: 'POST', headers: __assign(__assign({}, (typeof body === 'string' ? { 'Content-Type': 'application/json' } : {})), headers), body: body }, fetchOptions))];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
};
/**
 * Fetch data using GET method
 */
var get = function (_a) {
    var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch = _a.fetch, fetchOptions = _a.fetchOptions;
    return __awaiter(void 0, void 0, void 0, function () {
        var search;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    search = ["query=" + encodeURIComponent(query.replace(/([\s,]|#[^\n\r]+)+/g, ' ').trim())];
                    if (variables) {
                        search.push("variables=" + encodeURIComponent(JSON.stringify(variables)));
                    }
                    if (operationName) {
                        search.push("operationName=" + encodeURIComponent(operationName));
                    }
                    return [4 /*yield*/, fetch(url + "?" + search.join('&'), __assign({ method: 'GET', headers: headers }, fetchOptions))];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
};
/**
 * todo
 */
var GraphQLClient = /** @class */ (function () {
    function GraphQLClient(url, options) {
        this.url = url;
        this.options = options || {};
    }
    GraphQLClient.prototype.rawRequest = function (query, variables, requestHeaders) {
        var _a = this.options, headers = _a.headers, _b = _a.fetch, fetch = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? 'POST' : _c, fetchOptions = __rest(_a, ["headers", "fetch", "method"]);
        var url = this.url;
        return makeRequest({
            url: url,
            query: query,
            variables: variables,
            headers: __assign(__assign({}, resolveHeaders(headers)), resolveHeaders(requestHeaders)),
            operationName: undefined,
            fetch: fetch,
            method: method,
            fetchOptions: fetchOptions,
        });
    };
    /**
     * Send a GraphQL document to the server.
     */
    GraphQLClient.prototype.request = function (document, variables, requestHeaders) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, _b, fetch, _c, method, fetchOptions, url, _d, query, operationName, data;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _a = this.options, headers = _a.headers, _b = _a.fetch, fetch = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? 'POST' : _c, fetchOptions = __rest(_a, ["headers", "fetch", "method"]);
                        url = this.url;
                        _d = resolveRequestDocument(document), query = _d.query, operationName = _d.operationName;
                        return [4 /*yield*/, makeRequest({
                                url: url,
                                query: query,
                                variables: variables,
                                headers: __assign(__assign({}, resolveHeaders(headers)), resolveHeaders(requestHeaders)),
                                operationName: operationName,
                                fetch: fetch,
                                method: method,
                                fetchOptions: fetchOptions,
                            })];
                    case 1:
                        data = (_e.sent()).data;
                        return [2 /*return*/, data];
                }
            });
        });
    };
    GraphQLClient.prototype.setHeaders = function (headers) {
        this.options.headers = headers;
        return this;
    };
    /**
     * Attach a header to the client. All subsequent requests will have this header.
     */
    GraphQLClient.prototype.setHeader = function (key, value) {
        var _a;
        var headers = this.options.headers;
        if (headers) {
            // todo what if headers is in nested array form... ?
            //@ts-ignore
            headers[key] = value;
        }
        else {
            this.options.headers = (_a = {}, _a[key] = value, _a);
        }
        return this;
    };
    return GraphQLClient;
}());
exports.GraphQLClient = GraphQLClient;
function makeRequest(_a) {
    var url = _a.url, query = _a.query, variables = _a.variables, headers = _a.headers, operationName = _a.operationName, fetch = _a.fetch, _b = _a.method, method = _b === void 0 ? 'POST' : _b, fetchOptions = _a.fetchOptions;
    return __awaiter(this, void 0, void 0, function () {
        var fetcher, response, result, headers_1, status_1, errorResult;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    fetcher = method.toUpperCase() === 'POST' ? post : get;
                    return [4 /*yield*/, fetcher({
                            url: url,
                            query: query,
                            variables: variables,
                            operationName: operationName,
                            headers: headers,
                            fetch: fetch,
                            fetchOptions: fetchOptions,
                        })];
                case 1:
                    response = _c.sent();
                    return [4 /*yield*/, getResult(response)];
                case 2:
                    result = _c.sent();
                    if (response.ok && !result.errors && result.data) {
                        headers_1 = response.headers, status_1 = response.status;
                        return [2 /*return*/, __assign(__assign({}, result), { headers: headers_1, status: status_1 })];
                    }
                    else {
                        errorResult = typeof result === 'string' ? { error: result } : result;
                        throw new types_1.ClientError(__assign(__assign({}, errorResult), { status: response.status, headers: response.headers }), { query: query, variables: variables });
                    }
                    return [2 /*return*/];
            }
        });
    });
}
/**
 * todo
 */
function rawRequest(url, query, variables, requestHeaders) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = new GraphQLClient(url);
            return [2 /*return*/, client.rawRequest(query, variables, requestHeaders)];
        });
    });
}
exports.rawRequest = rawRequest;
/**
 * Send a GraphQL Document to the GraphQL server for exectuion.
 *
 * @example
 *
 * ```ts
 * // You can pass a raw string
 *
 * await request('https://foo.bar/graphql', `
 *   {
 *     query {
 *       users
 *     }
 *   }
 * `)
 *
 * // You can also pass a GraphQL DocumentNode. Convenient if you
 * // are using graphql-tag package.
 *
 * import gql from 'graphql-tag'
 *
 * await request('https://foo.bar/graphql', gql`...`)
 *
 * // If you don't actually care about using DocumentNode but just
 * // want the tooling support for gql template tag like IDE syntax
 * // coloring and prettier autoformat then note you can use the
 * // passthrough gql tag shipped with graphql-request to save a bit
 * // of performance and not have to install another dep into your project.
 *
 * import { gql } from 'graphql-request'
 *
 * await request('https://foo.bar/graphql', gql`...`)
 * ```
 */
function request(url, document, variables, requestHeaders) {
    return __awaiter(this, void 0, void 0, function () {
        var client;
        return __generator(this, function (_a) {
            client = new GraphQLClient(url);
            return [2 /*return*/, client.request(document, variables, requestHeaders)];
        });
    });
}
exports.request = request;
exports.default = request;
/**
 * todo
 */
function getResult(response) {
    var contentType = response.headers.get('Content-Type');
    if (contentType && contentType.startsWith('application/json')) {
        return response.json();
    }
    else {
        return response.text();
    }
}
/**
 * helpers
 */
function resolveRequestDocument(document) {
    var _a;
    if (typeof document === 'string')
        return { query: document };
    var operationName = undefined;
    var operationDefinitions = document.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; });
    if (operationDefinitions.length === 1) {
        operationName = (_a = operationDefinitions[0].name) === null || _a === void 0 ? void 0 : _a.value;
    }
    return { query: printer_1.print(document), operationName: operationName };
}
/**
 * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.
 *
 * @example
 *
 * import { gql } from 'graphql-request'
 *
 * await request('https://foo.bar/graphql', gql`...`)
 *
 * @remarks
 *
 * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named "gql". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.
 */
function gql(chunks) {
    var variables = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        variables[_i - 1] = arguments[_i];
    }
    return chunks.reduce(function (accumulator, chunk, index) { return "" + accumulator + chunk + (index in variables ? variables[index] : ''); }, '');
}
exports.gql = gql;
/**
 * Convert Headers instance into regular object
 */
function HeadersInstanceToPlainObject(headers) {
    var o = {};
    headers.forEach(function (v, k) {
        o[k] = v;
    });
    return o;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/types.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@sitecore-jss/sitecore-jss/node_modules/graphql-request/dist/types.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientError = void 0;
var ClientError = /** @class */ (function (_super) {
    __extends(ClientError, _super);
    function ClientError(response, request) {
        var _this = this;
        var message = ClientError.extractMessage(response) + ": " + JSON.stringify({
            response: response,
            request: request,
        });
        _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, ClientError.prototype);
        _this.response = response;
        _this.request = request;
        // this is needed as Safari doesn't support .captureStackTrace
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(_this, ClientError);
        }
        return _this;
    }
    ClientError.extractMessage = function (response) {
        try {
            return response.errors[0].message;
        }
        catch (e) {
            return "GraphQL Error (Code: " + response.status + ")";
        }
    };
    return ClientError;
}(Error));
exports.ClientError = ClientError;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/ansi-styles/index.js":
/*!*******************************************!*\
  !*** ./node_modules/ansi-styles/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
const colorConvert = __webpack_require__(/*! color-convert */ "./node_modules/color-convert/index.js");

const wrapAnsi16 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function () {
	const rgb = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39],

			// Bright color
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Fix humans
	styles.color.grey = styles.color.gray;

	for (const groupName of Object.keys(styles)) {
		const group = styles[groupName];

		for (const styleName of Object.keys(group)) {
			const style = group[styleName];

			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});

		Object.defineProperty(styles, 'codes', {
			value: codes,
			enumerable: false
		});
	}

	const ansi2ansi = n => n;
	const rgb2rgb = (r, g, b) => [r, g, b];

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 0)
	};
	styles.color.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 0)
	};
	styles.color.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 0)
	};

	styles.bgColor.ansi = {
		ansi: wrapAnsi16(ansi2ansi, 10)
	};
	styles.bgColor.ansi256 = {
		ansi256: wrapAnsi256(ansi2ansi, 10)
	};
	styles.bgColor.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 10)
	};

	for (let key of Object.keys(colorConvert)) {
		if (typeof colorConvert[key] !== 'object') {
			continue;
		}

		const suite = colorConvert[key];

		if (key === 'ansi16') {
			key = 'ansi';
		}

		if ('ansi16' in suite) {
			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
		}

		if ('ansi256' in suite) {
			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
		}

		if ('rgb' in suite) {
			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
		}
	}

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./node_modules/chalk/index.js":
/*!*************************************!*\
  !*** ./node_modules/chalk/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
const escapeStringRegexp = __webpack_require__(/*! escape-string-regexp */ "./node_modules/escape-string-regexp/index.js");
const ansiStyles = __webpack_require__(/*! ansi-styles */ "./node_modules/ansi-styles/index.js");
const stdoutColor = __webpack_require__(/*! supports-color */ "./node_modules/chalk/node_modules/supports-color/browser.js").stdout;

const template = __webpack_require__(/*! ./templates.js */ "./node_modules/chalk/templates.js");

const isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];

// `color-convert` models to exclude from the Chalk API due to conflicts and such
const skipModels = new Set(['gray']);

const styles = Object.create(null);

function applyOptions(obj, options) {
	options = options || {};

	// Detect level if not set manually
	const scLevel = stdoutColor ? stdoutColor.level : 0;
	obj.level = options.level === undefined ? scLevel : options.level;
	obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
}

function Chalk(options) {
	// We check for this.template here since calling `chalk.constructor()`
	// by itself will have a `this` of a previously constructed chalk object
	if (!this || !(this instanceof Chalk) || this.template) {
		const chalk = {};
		applyOptions(chalk, options);

		chalk.template = function () {
			const args = [].slice.call(arguments);
			return chalkTag.apply(null, [chalk.template].concat(args));
		};

		Object.setPrototypeOf(chalk, Chalk.prototype);
		Object.setPrototypeOf(chalk.template, chalk);

		chalk.template.constructor = Chalk;

		return chalk.template;
	}

	applyOptions(this, options);
}

// Use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001B[94m';
}

for (const key of Object.keys(ansiStyles)) {
	ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

	styles[key] = {
		get() {
			const codes = ansiStyles[key];
			return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
		}
	};
}

styles.visible = {
	get() {
		return build.call(this, this._styles || [], true, 'visible');
	}
};

ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');
for (const model of Object.keys(ansiStyles.color.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	styles[model] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.color.close,
					closeRe: ansiStyles.color.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');
for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
	if (skipModels.has(model)) {
		continue;
	}

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const level = this.level;
			return function () {
				const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
				const codes = {
					open,
					close: ansiStyles.bgColor.close,
					closeRe: ansiStyles.bgColor.closeRe
				};
				return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, styles);

function build(_styles, _empty, key) {
	const builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder._empty = _empty;

	const self = this;

	Object.defineProperty(builder, 'level', {
		enumerable: true,
		get() {
			return self.level;
		},
		set(level) {
			self.level = level;
		}
	});

	Object.defineProperty(builder, 'enabled', {
		enumerable: true,
		get() {
			return self.enabled;
		},
		set(enabled) {
			self.enabled = enabled;
		}
	});

	// See below for fix regarding invisible grey/dim combination on Windows
	builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	return builder;
}

function applyStyle() {
	// Support varags, but simply cast to string in case there's only one arg
	const args = arguments;
	const argsLen = args.length;
	let str = String(arguments[0]);

	if (argsLen === 0) {
		return '';
	}

	if (argsLen > 1) {
		// Don't slice `arguments`, it prevents V8 optimizations
		for (let a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || this.level <= 0 || !str) {
		return this._empty ? '' : str;
	}

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	const originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && this.hasGrey) {
		ansiStyles.dim.open = '';
	}

	for (const code of this._styles.slice().reverse()) {
		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;

		// Close the styling before a linebreak and reopen
		// after next line to fix a bleed issue on macOS
		// https://github.com/chalk/chalk/pull/92
		str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
	}

	// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
	ansiStyles.dim.open = originalDim;

	return str;
}

function chalkTag(chalk, strings) {
	if (!Array.isArray(strings)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return [].slice.call(arguments, 1).join(' ');
	}

	const args = [].slice.call(arguments, 2);
	const parts = [strings.raw[0]];

	for (let i = 1; i < strings.length; i++) {
		parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
		parts.push(String(strings.raw[i]));
	}

	return template(chalk, parts.join(''));
}

Object.defineProperties(Chalk.prototype, styles);

module.exports = Chalk(); // eslint-disable-line new-cap
module.exports.supportsColor = stdoutColor;
module.exports.default = module.exports; // For TypeScript

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/chalk/node_modules/supports-color/browser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chalk/node_modules/supports-color/browser.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {
	stdout: false,
	stderr: false
};


/***/ }),

/***/ "./node_modules/chalk/templates.js":
/*!*****************************************!*\
  !*** ./node_modules/chalk/templates.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, args) {
	const results = [];
	const chunks = args.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		if (!isNaN(chunk)) {
			results.push(Number(chunk));
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const styleName of Object.keys(enabled)) {
		if (Array.isArray(enabled[styleName])) {
			if (!(styleName in current)) {
				throw new Error(`Unknown Chalk style: ${styleName}`);
			}

			if (enabled[styleName].length > 0) {
				current = current[styleName].apply(current, enabled[styleName]);
			} else {
				current = current[styleName];
			}
		}
	}

	return current;
}

module.exports = (chalk, tmp) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
		if (escapeChar) {
			chunk.push(unescape(escapeChar));
		} else if (style) {
			const str = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(chr);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};


/***/ }),

/***/ "./node_modules/color-convert/conversions.js":
/*!***************************************************!*\
  !*** ./node_modules/color-convert/conversions.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* MIT license */
var cssKeywords = __webpack_require__(/*! color-name */ "./node_modules/color-name/index.js");

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};


/***/ }),

/***/ "./node_modules/color-convert/index.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");
var route = __webpack_require__(/*! ./route */ "./node_modules/color-convert/route.js");

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;


/***/ }),

/***/ "./node_modules/color-convert/route.js":
/*!*********************************************!*\
  !*** ./node_modules/color-convert/route.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var conversions = __webpack_require__(/*! ./conversions */ "./node_modules/color-convert/conversions.js");

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};



/***/ }),

/***/ "./node_modules/color-name/index.js":
/*!******************************************!*\
  !*** ./node_modules/color-name/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ "./node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var __self__ = (function (root) {
function F() {
this.fetch = false;
this.DOMException = root.DOMException
}
F.prototype = root;
return new F();
})(typeof self !== 'undefined' ? self : this);
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  return exports;

}({}));
})(__self__);
delete __self__.fetch.polyfill
exports = __self__.fetch // To enable: import fetch from 'cross-fetch'
exports.default = __self__.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = __self__.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = __self__.Headers
exports.Request = __self__.Request
exports.Response = __self__.Response
module.exports = exports


/***/ }),

/***/ "./node_modules/debug/node_modules/ms/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/debug/node_modules/ms/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/debug/node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/dlv/dist/dlv.umd.js":
/*!******************************************!*\
  !*** ./node_modules/dlv/dist/dlv.umd.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,n){ true?module.exports=function(t,n,e,i,o){for(n=n.split?n.split("."):n,i=0;i<n.length;i++)t=t?t[n[i]]:o;return t===o?e:t}:undefined}(this);
//# sourceMappingURL=dlv.umd.js.map


/***/ }),

/***/ "./node_modules/escape-string-regexp/index.js":
/*!****************************************************!*\
  !*** ./node_modules/escape-string-regexp/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

module.exports = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};


/***/ }),

/***/ "./node_modules/extract-files/public/ReactNativeFile.js":
/*!**************************************************************!*\
  !*** ./node_modules/extract-files/public/ReactNativeFile.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function ReactNativeFile(_ref) {
  var uri = _ref.uri,
    name = _ref.name,
    type = _ref.type;
  this.uri = uri;
  this.name = name;
  this.type = type;
};


/***/ }),

/***/ "./node_modules/extract-files/public/extractFiles.js":
/*!***********************************************************!*\
  !*** ./node_modules/extract-files/public/extractFiles.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaultIsExtractableFile = __webpack_require__(/*! ./isExtractableFile */ "./node_modules/extract-files/public/isExtractableFile.js");

module.exports = function extractFiles(value, path, isExtractableFile) {
  if (path === void 0) {
    path = '';
  }

  if (isExtractableFile === void 0) {
    isExtractableFile = defaultIsExtractableFile;
  }

  var clone;
  var files = new Map();

  function addFile(paths, file) {
    var storedPaths = files.get(file);
    if (storedPaths) storedPaths.push.apply(storedPaths, paths);
    else files.set(file, paths);
  }

  if (isExtractableFile(value)) {
    clone = null;
    addFile([path], value);
  } else {
    var prefix = path ? path + '.' : '';
    if (typeof FileList !== 'undefined' && value instanceof FileList)
      clone = Array.prototype.map.call(value, function (file, i) {
        addFile(['' + prefix + i], file);
        return null;
      });
    else if (Array.isArray(value))
      clone = value.map(function (child, i) {
        var result = extractFiles(child, '' + prefix + i, isExtractableFile);
        result.files.forEach(addFile);
        return result.clone;
      });
    else if (value && value.constructor === Object) {
      clone = {};

      for (var i in value) {
        var result = extractFiles(value[i], '' + prefix + i, isExtractableFile);
        result.files.forEach(addFile);
        clone[i] = result.clone;
      }
    } else clone = value;
  }

  return {
    clone: clone,
    files: files,
  };
};


/***/ }),

/***/ "./node_modules/extract-files/public/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/extract-files/public/index.mjs ***!
  \*****************************************************/
/*! exports provided: ReactNativeFile, extractFiles, isExtractableFile */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ReactNativeFile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReactNativeFile.js */ "./node_modules/extract-files/public/ReactNativeFile.js");
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "ReactNativeFile", function() { return _ReactNativeFile_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _extractFiles_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extractFiles.js */ "./node_modules/extract-files/public/extractFiles.js");
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "extractFiles", function() { return _extractFiles_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _isExtractableFile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isExtractableFile.js */ "./node_modules/extract-files/public/isExtractableFile.js");
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "isExtractableFile", function() { return _isExtractableFile_js__WEBPACK_IMPORTED_MODULE_2__; });





/***/ }),

/***/ "./node_modules/extract-files/public/isExtractableFile.js":
/*!****************************************************************!*\
  !*** ./node_modules/extract-files/public/isExtractableFile.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ReactNativeFile = __webpack_require__(/*! ./ReactNativeFile */ "./node_modules/extract-files/public/ReactNativeFile.js");

module.exports = function isExtractableFile(value) {
  return (
    (typeof File !== 'undefined' && value instanceof File) ||
    (typeof Blob !== 'undefined' && value instanceof Blob) ||
    value instanceof ReactNativeFile
  );
};


/***/ }),

/***/ "./node_modules/form-data/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* eslint-env browser */
module.exports = typeof self == 'object' ? self.FormData : window.FormData;


/***/ }),

/***/ "./node_modules/graphql/jsutils/defineInspect.mjs":
/*!********************************************************!*\
  !*** ./node_modules/graphql/jsutils/defineInspect.mjs ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return defineInspect; });
/* harmony import */ var _invariant_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invariant.mjs */ "./node_modules/graphql/jsutils/invariant.mjs");
/* harmony import */ var _nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodejsCustomInspectSymbol.mjs */ "./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs");


/**
 * The `defineInspect()` function defines `inspect()` prototype method as alias of `toJSON`
 */

function defineInspect(classObject) {
  var fn = classObject.prototype.toJSON;
  typeof fn === 'function' || Object(_invariant_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(0);
  classObject.prototype.inspect = fn; // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2317')

  if (_nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    classObject.prototype[_nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]] = fn;
  }
}


/***/ }),

/***/ "./node_modules/graphql/jsutils/inspect.mjs":
/*!**************************************************!*\
  !*** ./node_modules/graphql/jsutils/inspect.mjs ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return inspect; });
/* harmony import */ var _nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nodejsCustomInspectSymbol.mjs */ "./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable flowtype/no-weak-types */

var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
/**
 * Used to print values in error messages.
 */

function inspect(value) {
  return formatValue(value, []);
}

function formatValue(value, seenValues) {
  switch (_typeof(value)) {
    case 'string':
      return JSON.stringify(value);

    case 'function':
      return value.name ? "[function ".concat(value.name, "]") : '[function]';

    case 'object':
      if (value === null) {
        return 'null';
      }

      return formatObjectValue(value, seenValues);

    default:
      return String(value);
  }
}

function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return '[Circular]';
  }

  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);

  if (customInspectFn !== undefined) {
    var customValue = customInspectFn.call(value); // check for infinite recursion

    if (customValue !== value) {
      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }

  return formatObject(value, seenValues);
}

function formatObject(object, seenValues) {
  var keys = Object.keys(object);

  if (keys.length === 0) {
    return '{}';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[' + getObjectTag(object) + ']';
  }

  var properties = keys.map(function (key) {
    var value = formatValue(object[key], seenValues);
    return key + ': ' + value;
  });
  return '{ ' + properties.join(', ') + ' }';
}

function formatArray(array, seenValues) {
  if (array.length === 0) {
    return '[]';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[Array]';
  }

  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];

  for (var i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }

  if (remaining === 1) {
    items.push('... 1 more item');
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }

  return '[' + items.join(', ') + ']';
}

function getCustomFn(object) {
  var customInspectFn = object[String(_nodejsCustomInspectSymbol_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])];

  if (typeof customInspectFn === 'function') {
    return customInspectFn;
  }

  if (typeof object.inspect === 'function') {
    return object.inspect;
  }
}

function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/]$/, '');

  if (tag === 'Object' && typeof object.constructor === 'function') {
    var name = object.constructor.name;

    if (typeof name === 'string' && name !== '') {
      return name;
    }
  }

  return tag;
}


/***/ }),

/***/ "./node_modules/graphql/jsutils/invariant.mjs":
/*!****************************************************!*\
  !*** ./node_modules/graphql/jsutils/invariant.mjs ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return invariant; });
function invariant(condition, message) {
  var booleanCondition = Boolean(condition); // istanbul ignore else (See transformation done in './resources/inlineInvariant.js')

  if (!booleanCondition) {
    throw new Error(message != null ? message : 'Unexpected invariant triggered.');
  }
}


/***/ }),

/***/ "./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;
/* harmony default export */ __webpack_exports__["default"] = (nodejsCustomInspectSymbol);


/***/ }),

/***/ "./node_modules/graphql/language/ast.mjs":
/*!***********************************************!*\
  !*** ./node_modules/graphql/language/ast.mjs ***!
  \***********************************************/
/*! exports provided: Location, Token, isNode */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Location", function() { return Location; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNode", function() { return isNode; });
/* harmony import */ var _jsutils_defineInspect_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jsutils/defineInspect.mjs */ "./node_modules/graphql/jsutils/defineInspect.mjs");


/**
 * Contains a range of UTF-8 character offsets and token references that
 * identify the region of the source from which the AST derived.
 */
var Location = /*#__PURE__*/function () {
  /**
   * The character offset at which this Node begins.
   */

  /**
   * The character offset at which this Node ends.
   */

  /**
   * The Token at which this Node begins.
   */

  /**
   * The Token at which this Node ends.
   */

  /**
   * The Source document the AST represents.
   */
  function Location(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }

  var _proto = Location.prototype;

  _proto.toJSON = function toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  };

  return Location;
}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.

Object(_jsutils_defineInspect_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(Location);
/**
 * Represents a range of characters represented by a lexical token
 * within a Source.
 */

var Token = /*#__PURE__*/function () {
  /**
   * The kind of Token.
   */

  /**
   * The character offset at which this Node begins.
   */

  /**
   * The character offset at which this Node ends.
   */

  /**
   * The 1-indexed line number on which this Token appears.
   */

  /**
   * The 1-indexed column number at which this Token begins.
   */

  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   */

  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  function Token(kind, start, end, line, column, prev, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = prev;
    this.next = null;
  }

  var _proto2 = Token.prototype;

  _proto2.toJSON = function toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  };

  return Token;
}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.

Object(_jsutils_defineInspect_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(Token);
/**
 * @internal
 */

function isNode(maybeNode) {
  return maybeNode != null && typeof maybeNode.kind === 'string';
}
/**
 * The list of all possible AST node types.
 */


/***/ }),

/***/ "./node_modules/graphql/language/blockString.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/graphql/language/blockString.mjs ***!
  \*******************************************************/
/*! exports provided: dedentBlockStringValue, getBlockStringIndentation, printBlockString */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dedentBlockStringValue", function() { return dedentBlockStringValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlockStringIndentation", function() { return getBlockStringIndentation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "printBlockString", function() { return printBlockString; });
/**
 * Produces the value of a block string from its parsed raw value, similar to
 * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
 *
 * This implements the GraphQL spec's BlockStringValue() static algorithm.
 *
 * @internal
 */
function dedentBlockStringValue(rawString) {
  // Expand a block string's raw value into independent lines.
  var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

  var commonIndent = getBlockStringIndentation(rawString);

  if (commonIndent !== 0) {
    for (var i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  } // Remove leading and trailing blank lines.


  var startLine = 0;

  while (startLine < lines.length && isBlank(lines[startLine])) {
    ++startLine;
  }

  var endLine = lines.length;

  while (endLine > startLine && isBlank(lines[endLine - 1])) {
    --endLine;
  } // Return a string of the lines joined with U+000A.


  return lines.slice(startLine, endLine).join('\n');
}

function isBlank(str) {
  for (var i = 0; i < str.length; ++i) {
    if (str[i] !== ' ' && str[i] !== '\t') {
      return false;
    }
  }

  return true;
}
/**
 * @internal
 */


function getBlockStringIndentation(value) {
  var _commonIndent;

  var isFirstLine = true;
  var isEmptyLine = true;
  var indent = 0;
  var commonIndent = null;

  for (var i = 0; i < value.length; ++i) {
    switch (value.charCodeAt(i)) {
      case 13:
        //  \r
        if (value.charCodeAt(i + 1) === 10) {
          ++i; // skip \r\n as one symbol
        }

      // falls through

      case 10:
        //  \n
        isFirstLine = false;
        isEmptyLine = true;
        indent = 0;
        break;

      case 9: //   \t

      case 32:
        //  <space>
        ++indent;
        break;

      default:
        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {
          commonIndent = indent;
        }

        isEmptyLine = false;
    }
  }

  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
}
/**
 * Print a block string in the indented block form by adding a leading and
 * trailing blank line. However, if a block string starts with whitespace and is
 * a single-line, adding a leading blank line would strip that whitespace.
 *
 * @internal
 */

function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isSingleLine = value.indexOf('\n') === -1;
  var hasLeadingSpace = value[0] === ' ' || value[0] === '\t';
  var hasTrailingQuote = value[value.length - 1] === '"';
  var hasTrailingSlash = value[value.length - 1] === '\\';
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
  var result = ''; // Format a multi-line block quote to account for leading space.

  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += '\n' + indentation;
  }

  result += indentation ? value.replace(/\n/g, '\n' + indentation) : value;

  if (printAsMultipleLines) {
    result += '\n';
  }

  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}


/***/ }),

/***/ "./node_modules/graphql/language/printer.mjs":
/*!***************************************************!*\
  !*** ./node_modules/graphql/language/printer.mjs ***!
  \***************************************************/
/*! exports provided: print */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return print; });
/* harmony import */ var _visitor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./visitor.mjs */ "./node_modules/graphql/language/visitor.mjs");
/* harmony import */ var _blockString_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./blockString.mjs */ "./node_modules/graphql/language/blockString.mjs");


/**
 * Converts an AST into a string, using one set of reasonable
 * formatting rules.
 */

function print(ast) {
  return Object(_visitor_mjs__WEBPACK_IMPORTED_MODULE_0__["visit"])(ast, {
    leave: printDocASTReducer
  });
}
var MAX_LINE_LENGTH = 80; // TODO: provide better type coverage in future

var printDocASTReducer = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return '$' + node.name;
  },
  // Document
  Document: function Document(node) {
    return join(node.definitions, '\n\n') + '\n';
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name = node.name;
    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');
    var directives = join(node.directives, ' ');
    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
    // the query short form.

    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable,
        type = _ref.type,
        defaultValue = _ref.defaultValue,
        directives = _ref.directives;
    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias,
        name = _ref3.name,
        args = _ref3.arguments,
        directives = _ref3.directives,
        selectionSet = _ref3.selectionSet;
    var prefix = wrap('', alias, ': ') + name;
    var argsLine = prefix + wrap('(', join(args, ', '), ')');

    if (argsLine.length > MAX_LINE_LENGTH) {
      argsLine = prefix + wrap('(\n', indent(join(args, '\n')), '\n)');
    }

    return join([argsLine, join(directives, ' '), selectionSet], ' ');
  },
  Argument: function Argument(_ref4) {
    var name = _ref4.name,
        value = _ref4.value;
    return name + ': ' + value;
  },
  // Fragments
  FragmentSpread: function FragmentSpread(_ref5) {
    var name = _ref5.name,
        directives = _ref5.directives;
    return '...' + name + wrap(' ', join(directives, ' '));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition,
        directives = _ref6.directives,
        selectionSet = _ref6.selectionSet;
    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name = _ref7.name,
        typeCondition = _ref7.typeCondition,
        variableDefinitions = _ref7.variableDefinitions,
        directives = _ref7.directives,
        selectionSet = _ref7.selectionSet;
    return (// Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), " ") + "on ".concat(typeCondition, " ").concat(wrap('', join(directives, ' '), ' ')) + selectionSet
    );
  },
  // Value
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key) {
    var value = _ref10.value,
        isBlockString = _ref10.block;
    return isBlockString ? Object(_blockString_mjs__WEBPACK_IMPORTED_MODULE_1__["printBlockString"])(value, key === 'description' ? '' : '  ') : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? 'true' : 'false';
  },
  NullValue: function NullValue() {
    return 'null';
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return '[' + join(values, ', ') + ']';
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return '{' + join(fields, ', ') + '}';
  },
  ObjectField: function ObjectField(_ref15) {
    var name = _ref15.name,
        value = _ref15.value;
    return name + ': ' + value;
  },
  // Directive
  Directive: function Directive(_ref16) {
    var name = _ref16.name,
        args = _ref16.arguments;
    return '@' + name + wrap('(', join(args, ', '), ')');
  },
  // Type
  NamedType: function NamedType(_ref17) {
    var name = _ref17.name;
    return name;
  },
  ListType: function ListType(_ref18) {
    var type = _ref18.type;
    return '[' + type + ']';
  },
  NonNullType: function NonNullType(_ref19) {
    var type = _ref19.type;
    return type + '!';
  },
  // Type System Definitions
  SchemaDefinition: addDescription(function (_ref20) {
    var directives = _ref20.directives,
        operationTypes = _ref20.operationTypes;
    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
  }),
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation,
        type = _ref21.type;
    return operation + ': ' + type;
  },
  ScalarTypeDefinition: addDescription(function (_ref22) {
    var name = _ref22.name,
        directives = _ref22.directives;
    return join(['scalar', name, join(directives, ' ')], ' ');
  }),
  ObjectTypeDefinition: addDescription(function (_ref23) {
    var name = _ref23.name,
        interfaces = _ref23.interfaces,
        directives = _ref23.directives,
        fields = _ref23.fields;
    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  }),
  FieldDefinition: addDescription(function (_ref24) {
    var name = _ref24.name,
        args = _ref24.arguments,
        type = _ref24.type,
        directives = _ref24.directives;
    return name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));
  }),
  InputValueDefinition: addDescription(function (_ref25) {
    var name = _ref25.name,
        type = _ref25.type,
        defaultValue = _ref25.defaultValue,
        directives = _ref25.directives;
    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');
  }),
  InterfaceTypeDefinition: addDescription(function (_ref26) {
    var name = _ref26.name,
        interfaces = _ref26.interfaces,
        directives = _ref26.directives,
        fields = _ref26.fields;
    return join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  }),
  UnionTypeDefinition: addDescription(function (_ref27) {
    var name = _ref27.name,
        directives = _ref27.directives,
        types = _ref27.types;
    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  }),
  EnumTypeDefinition: addDescription(function (_ref28) {
    var name = _ref28.name,
        directives = _ref28.directives,
        values = _ref28.values;
    return join(['enum', name, join(directives, ' '), block(values)], ' ');
  }),
  EnumValueDefinition: addDescription(function (_ref29) {
    var name = _ref29.name,
        directives = _ref29.directives;
    return join([name, join(directives, ' ')], ' ');
  }),
  InputObjectTypeDefinition: addDescription(function (_ref30) {
    var name = _ref30.name,
        directives = _ref30.directives,
        fields = _ref30.fields;
    return join(['input', name, join(directives, ' '), block(fields)], ' ');
  }),
  DirectiveDefinition: addDescription(function (_ref31) {
    var name = _ref31.name,
        args = _ref31.arguments,
        repeatable = _ref31.repeatable,
        locations = _ref31.locations;
    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives,
        operationTypes = _ref32.operationTypes;
    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name = _ref33.name,
        directives = _ref33.directives;
    return join(['extend scalar', name, join(directives, ' ')], ' ');
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name = _ref34.name,
        interfaces = _ref34.interfaces,
        directives = _ref34.directives,
        fields = _ref34.fields;
    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name = _ref35.name,
        interfaces = _ref35.interfaces,
        directives = _ref35.directives,
        fields = _ref35.fields;
    return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name = _ref36.name,
        directives = _ref36.directives,
        types = _ref36.types;
    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name = _ref37.name,
        directives = _ref37.directives,
        values = _ref37.values;
    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name = _ref38.name,
        directives = _ref38.directives,
        fields = _ref38.fields;
    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');
  }
};

function addDescription(cb) {
  return function (node) {
    return join([node.description, cb(node)], '\n');
  };
}
/**
 * Given maybeArray, print an empty string if it is null or empty, otherwise
 * print all items together separated by separator if provided
 */


function join(maybeArray) {
  var _maybeArray$filter$jo;

  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function (x) {
    return x;
  }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : '';
}
/**
 * Given array, print each item on its own line, wrapped in an
 * indented "{ }" block.
 */


function block(array) {
  return wrap('{\n', indent(join(array, '\n')), '\n}');
}
/**
 * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.
 */


function wrap(start, maybeString) {
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return maybeString != null && maybeString !== '' ? start + maybeString + end : '';
}

function indent(str) {
  return wrap('  ', str.replace(/\n/g, '\n  '));
}

function isMultiline(str) {
  return str.indexOf('\n') !== -1;
}

function hasMultilineItems(maybeArray) {
  return maybeArray != null && maybeArray.some(isMultiline);
}


/***/ }),

/***/ "./node_modules/graphql/language/visitor.mjs":
/*!***************************************************!*\
  !*** ./node_modules/graphql/language/visitor.mjs ***!
  \***************************************************/
/*! exports provided: QueryDocumentKeys, BREAK, visit, visitInParallel, getVisitFn */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QueryDocumentKeys", function() { return QueryDocumentKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BREAK", function() { return BREAK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visit", function() { return visit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visitInParallel", function() { return visitInParallel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVisitFn", function() { return getVisitFn; });
/* harmony import */ var _jsutils_inspect_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jsutils/inspect.mjs */ "./node_modules/graphql/jsutils/inspect.mjs");
/* harmony import */ var _ast_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ast.mjs */ "./node_modules/graphql/language/ast.mjs");


/**
 * A visitor is provided to visit, it contains the collection of
 * relevant functions to be called during the visitor's traversal.
 */

var QueryDocumentKeys = {
  Name: [],
  Document: ['definitions'],
  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
  Variable: ['name'],
  SelectionSet: ['selections'],
  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
  Argument: ['name', 'value'],
  FragmentSpread: ['name', 'directives'],
  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed
  // or removed in the future.
  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ['values'],
  ObjectValue: ['fields'],
  ObjectField: ['name', 'value'],
  Directive: ['name', 'arguments'],
  NamedType: ['name'],
  ListType: ['type'],
  NonNullType: ['type'],
  SchemaDefinition: ['description', 'directives', 'operationTypes'],
  OperationTypeDefinition: ['type'],
  ScalarTypeDefinition: ['description', 'name', 'directives'],
  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
  InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
  EnumValueDefinition: ['description', 'name', 'directives'],
  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
  SchemaExtension: ['directives', 'operationTypes'],
  ScalarTypeExtension: ['name', 'directives'],
  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
  UnionTypeExtension: ['name', 'directives', 'types'],
  EnumTypeExtension: ['name', 'directives', 'values'],
  InputObjectTypeExtension: ['name', 'directives', 'fields']
};
var BREAK = Object.freeze({});
/**
 * visit() will walk through an AST using a depth-first traversal, calling
 * the visitor's enter function at each node in the traversal, and calling the
 * leave function after visiting that node and all of its child nodes.
 *
 * By returning different values from the enter and leave functions, the
 * behavior of the visitor can be altered, including skipping over a sub-tree of
 * the AST (by returning false), editing the AST by returning a value or null
 * to remove the value, or to stop the whole traversal by returning BREAK.
 *
 * When using visit() to edit an AST, the original AST will not be modified, and
 * a new version of the AST with the changes applied will be returned from the
 * visit function.
 *
 *     const editedAST = visit(ast, {
 *       enter(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: skip visiting this node
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       },
 *       leave(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: no action
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       }
 *     });
 *
 * Alternatively to providing enter() and leave() functions, a visitor can
 * instead provide functions named the same as the kinds of AST nodes, or
 * enter/leave visitors at a named key, leading to four permutations of the
 * visitor API:
 *
 * 1) Named visitors triggered when entering a node of a specific kind.
 *
 *     visit(ast, {
 *       Kind(node) {
 *         // enter the "Kind" node
 *       }
 *     })
 *
 * 2) Named visitors that trigger upon entering and leaving a node of
 *    a specific kind.
 *
 *     visit(ast, {
 *       Kind: {
 *         enter(node) {
 *           // enter the "Kind" node
 *         }
 *         leave(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 *
 * 3) Generic visitors that trigger upon entering and leaving any node.
 *
 *     visit(ast, {
 *       enter(node) {
 *         // enter any node
 *       },
 *       leave(node) {
 *         // leave any node
 *       }
 *     })
 *
 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
 *
 *     visit(ast, {
 *       enter: {
 *         Kind(node) {
 *           // enter the "Kind" node
 *         }
 *       },
 *       leave: {
 *         Kind(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 */

function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;

  /* eslint-disable no-undef-init */
  var stack = undefined;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index = -1;
  var edits = [];
  var node = undefined;
  var key = undefined;
  var parent = undefined;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  /* eslint-enable no-undef-init */

  do {
    index++;
    var isLeaving = index === keys.length;
    var isEdited = isLeaving && edits.length !== 0;

    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();

      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};

          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            clone[k] = node[k];
          }

          node = clone;
        }

        var editOffset = 0;

        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];

          if (inArray) {
            editKey -= editOffset;
          }

          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }

      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys[index] : undefined;
      node = parent ? parent[key] : newRoot;

      if (node === null || node === undefined) {
        continue;
      }

      if (parent) {
        path.push(key);
      }
    }

    var result = void 0;

    if (!Array.isArray(node)) {
      if (!Object(_ast_mjs__WEBPACK_IMPORTED_MODULE_1__["isNode"])(node)) {
        throw new Error("Invalid AST Node: ".concat(Object(_jsutils_inspect_mjs__WEBPACK_IMPORTED_MODULE_0__["default"])(node), "."));
      }

      var visitFn = getVisitFn(visitor, node.kind, isLeaving);

      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);

        if (result === BREAK) {
          break;
        }

        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);

          if (!isLeaving) {
            if (Object(_ast_mjs__WEBPACK_IMPORTED_MODULE_1__["isNode"])(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }

    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }

    if (isLeaving) {
      path.pop();
    } else {
      var _visitorKeys$node$kin;

      stack = {
        inArray: inArray,
        index: index,
        keys: keys,
        edits: edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
      index = -1;
      edits = [];

      if (parent) {
        ancestors.push(parent);
      }

      parent = node;
    }
  } while (stack !== undefined);

  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }

  return newRoot;
}
/**
 * Creates a new visitor instance which delegates to many visitors to run in
 * parallel. Each visitor will be visited for each node before moving on.
 *
 * If a prior visitor edits a node, no following visitors will see that node.
 */

function visitInParallel(visitors) {
  var skipping = new Array(visitors.length);
  return {
    enter: function enter(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (skipping[i] == null) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          false);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      }
    },
    leave: function leave(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (skipping[i] == null) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          true);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          }
        } else if (skipping[i] === node) {
          skipping[i] = null;
        }
      }
    }
  };
}
/**
 * Given a visitor instance, if it is leaving or not, and a node kind, return
 * the function the visitor runtime should call.
 */

function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];

  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === 'function') {
      // { Kind() {} }
      return kindVisitor;
    }

    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;

    if (typeof kindSpecificVisitor === 'function') {
      // { Kind: { enter() {}, leave() {} } }
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

    if (specificVisitor) {
      if (typeof specificVisitor === 'function') {
        // { enter() {}, leave() {} }
        return specificVisitor;
      }

      var specificKindVisitor = specificVisitor[kind];

      if (typeof specificKindVisitor === 'function') {
        // { enter: { Kind() {} }, leave: { Kind() {} } }
        return specificKindVisitor;
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/lodash.unescape/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.unescape/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match HTML entities and HTML characters. */
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
    reHasEscapedHtml = RegExp(reEscapedHtml.source);

/** Used to map HTML entities to characters. */
var htmlUnescapes = {
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&#39;': "'",
  '&#96;': '`'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.unescape` to convert HTML entities to characters.
 *
 * @private
 * @param {string} chr The matched character to unescape.
 * @returns {string} Returns the unescaped character.
 */
var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * The inverse of `_.escape`; this method converts the HTML entities
 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to
 * their corresponding characters.
 *
 * **Note:** No other HTML entities are unescaped. To unescape additional
 * HTML entities use a third-party library like [_he_](https://mths.be/he).
 *
 * @static
 * @memberOf _
 * @since 0.6.0
 * @category String
 * @param {string} [string=''] The string to unescape.
 * @returns {string} Returns the unescaped string.
 * @example
 *
 * _.unescape('fred, barney, &amp; pebbles');
 * // => 'fred, barney, & pebbles'
 */
function unescape(string) {
  string = toString(string);
  return (string && reHasEscapedHtml.test(string))
    ? string.replace(reEscapedHtml, unescapeHtmlChar)
    : string;
}

module.exports = unescape;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/memory-cache/index.js":
/*!********************************************!*\
  !*** ./node_modules/memory-cache/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function Cache () {
  var _cache = Object.create(null);
  var _hitCount = 0;
  var _missCount = 0;
  var _size = 0;
  var _debug = false;

  this.put = function(key, value, time, timeoutCallback) {
    if (_debug) {
      console.log('caching: %s = %j (@%s)', key, value, time);
    }

    if (typeof time !== 'undefined' && (typeof time !== 'number' || isNaN(time) || time <= 0)) {
      throw new Error('Cache timeout must be a positive number');
    } else if (typeof timeoutCallback !== 'undefined' && typeof timeoutCallback !== 'function') {
      throw new Error('Cache timeout callback must be a function');
    }

    var oldRecord = _cache[key];
    if (oldRecord) {
      clearTimeout(oldRecord.timeout);
    } else {
      _size++;
    }

    var record = {
      value: value,
      expire: time + Date.now()
    };

    if (!isNaN(record.expire)) {
      record.timeout = setTimeout(function() {
        _del(key);
        if (timeoutCallback) {
          timeoutCallback(key, value);
        }
      }.bind(this), time);
    }

    _cache[key] = record;

    return value;
  };

  this.del = function(key) {
    var canDelete = true;

    var oldRecord = _cache[key];
    if (oldRecord) {
      clearTimeout(oldRecord.timeout);
      if (!isNaN(oldRecord.expire) && oldRecord.expire < Date.now()) {
        canDelete = false;
      }
    } else {
      canDelete = false;
    }

    if (canDelete) {
      _del(key);
    }

    return canDelete;
  };

  function _del(key){
    _size--;
    delete _cache[key];
  }

  this.clear = function() {
    for (var key in _cache) {
      clearTimeout(_cache[key].timeout);
    }
    _size = 0;
    _cache = Object.create(null);
    if (_debug) {
      _hitCount = 0;
      _missCount = 0;
    }
  };

  this.get = function(key) {
    var data = _cache[key];
    if (typeof data != "undefined") {
      if (isNaN(data.expire) || data.expire >= Date.now()) {
        if (_debug) _hitCount++;
        return data.value;
      } else {
        // free some space
        if (_debug) _missCount++;
        _size--;
        delete _cache[key];
      }
    } else if (_debug) {
      _missCount++;
    }
    return null;
  };

  this.size = function() {
    return _size;
  };

  this.memsize = function() {
    var size = 0,
      key;
    for (key in _cache) {
      size++;
    }
    return size;
  };

  this.debug = function(bool) {
    _debug = bool;
  };

  this.hits = function() {
    return _hitCount;
  };

  this.misses = function() {
    return _missCount;
  };

  this.keys = function() {
    return Object.keys(_cache);
  };

  this.exportJson = function() {
    var plainJsCache = {};

    // Discard the `timeout` property.
    // Note: JSON doesn't support `NaN`, so convert it to `'NaN'`.
    for (var key in _cache) {
      var record = _cache[key];
      plainJsCache[key] = {
        value: record.value,
        expire: record.expire || 'NaN',
      };
    }

    return JSON.stringify(plainJsCache);
  };

  this.importJson = function(jsonToImport, options) {
    var cacheToImport = JSON.parse(jsonToImport);
    var currTime = Date.now();

    var skipDuplicates = options && options.skipDuplicates;

    for (var key in cacheToImport) {
      if (cacheToImport.hasOwnProperty(key)) {
        if (skipDuplicates) {
          var existingRecord = _cache[key];
          if (existingRecord) {
            if (_debug) {
              console.log('Skipping duplicate imported key \'%s\'', key);
            }
            continue;
          }
        }

        var record = cacheToImport[key];

        // record.expire could be `'NaN'` if no expiry was set.
        // Try to subtract from it; a string minus a number is `NaN`, which is perfectly fine here.
        var remainingTime = record.expire - currTime;

        if (remainingTime <= 0) {
          // Delete any record that might exist with the same key, since this key is expired.
          this.del(key);
          continue;
        }

        // Remaining time must now be either positive or `NaN`,
        // but `put` will throw an error if we try to give it `NaN`.
        remainingTime = remainingTime > 0 ? remainingTime : undefined;

        this.put(key, record.value, remainingTime);
      }
    }

    return this.size();
  };
}

module.exports = new Cache();
module.exports.Cache = Cache;


/***/ }),

/***/ "./node_modules/next-localization/dist/index.modern.js":
/*!*************************************************************!*\
  !*** ./node_modules/next-localization/dist/index.modern.js ***!
  \*************************************************************/
/*! exports provided: I18n, I18nProvider, useI18n */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I18n", function() { return I18n; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I18nProvider", function() { return I18nProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useI18n", function() { return useI18n; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var rosetta__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rosetta */ "./node_modules/rosetta/dist/index.mjs");



function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var I18nContext = Object(react__WEBPACK_IMPORTED_MODULE_0__["createContext"])();
var I18n = function I18n(rosettaOpts) {
  var r = Object(rosetta__WEBPACK_IMPORTED_MODULE_1__["default"])(rosettaOpts);
  return {
    /**
     * Triggers a render cycle
     */
    _onUpdate: function _onUpdate() {},

    /**
     * Retrieve a translation segment for the active language
     */
    t: r.t,

    /**
     * Get the table of translations for a language
     */
    table: r.table,

    /**
     * Define or extend the language table
     */
    set: r.set,

    /**
     * Set a locale or returns the active locale
     */
    locale: function locale(_locale) {
      if (_locale === undefined) {
        return r.locale();
      }

      var activelocale = r.locale(_locale);

      this._onUpdate();

      return activelocale;
    },

    /**
     * Returns an i18n instance that treats number values as pluralization
     */
    withPlural: function withPlural(pluralRulesOptions) {
      var _this = this;

      if (pluralRulesOptions === void 0) {
        pluralRulesOptions = {
          type: 'ordinal'
        };
      }

      var PR = new Intl.PluralRules(r.locale(), pluralRulesOptions);
      return function (key, params) {
        Object.keys(params).map(function (k) {
          if (typeof params[k] === 'number') {
            var pkey = PR.select(params[k]);
            params[k] = _this.t(k + "." + pkey);
          }
        });
        return _this.t.apply(_this, [key, params].concat([].slice.call(arguments, 2)));
      };
    }
  };
};
function I18nProvider(_ref) {
  var children = _ref.children,
      _ref$locale = _ref.locale,
      locale = _ref$locale === void 0 ? 'en' : _ref$locale,
      lngDict = _ref.lngDict,
      i18nInstance = _ref.i18nInstance;

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(0),
      setTick = _useState[1];

  var i18n = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    var instance = i18nInstance != null ? i18nInstance : I18n();

    instance._onUpdate = function () {
      return setTick(function (tick) {
        return tick + 1;
      });
    };

    instance.set(locale, lngDict);
    instance.locale(locale);
    return instance; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [i18nInstance]);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    i18n.set(locale, lngDict);
    i18n.locale(locale); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [locale, lngDict]);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(I18nContext.Provider, {
    value: _extends({}, i18n)
  }, children);
}

function useI18n() {
  var i18n = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(I18nContext);
  return i18n;
}




/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);module.exports=assign;module.exports.default=module.exports;
//# sourceMappingURL=object-assign.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F%5B%5B...path%5D%5D&absolutePagePath=D%3A%5Cprojects%5Cjss%5Cnextjsonazure%5Cpackages%5Cjss-nextjs-app%5Csrc%5Cpages%5C%5B%5B...path%5D%5D.tsx!./":
/*!*****************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F%5B%5B...path%5D%5D&absolutePagePath=D%3A%5Cprojects%5Cjss%5Cnextjsonazure%5Cpackages%5Cjss-nextjs-app%5Csrc%5Cpages%5C%5B%5B...path%5D%5D.tsx ***!
  \*****************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/[[...path]]",
      function () {
        return __webpack_require__(/*! ./src/pages/[[...path]].tsx */ "./src/pages/[[...path]].tsx");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "./node_modules/next/dist/client/use-intersection.js");

var prefetched = {};

function prefetch(router, href, as, options) {
  if (false) {}
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options)["catch"](function (err) {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  });
  var curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character

  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;
}

function isModifiedEvent(event) {
  var target = event.currentTarget.target;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  var nodeName = e.currentTarget.nodeName;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browsers default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null) {
    scroll = as.indexOf('#') < 0;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow: shallow,
    locale: locale
  }).then(function (success) {
    if (!success) return;

    if (scroll) {
      window.scrollTo(0, 0);
      document.body.focus();
    }
  });
}

function Link(props) {
  _s();

  if (true) {
    var createPropError = function createPropError(args) {
      return new Error("Failed prop type: The prop `".concat(args.key, "` expects a ").concat(args.expected, " in `<Link>`, but got `").concat(args.actual, "` instead.") + (true ? "\nOpen your browser's console to view the Component stack trace." : undefined));
    }; // TypeScript trick for type-guarding:


    var requiredPropsGuard = {
      href: true
    };
    var requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(function (key) {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // TypeScript trick for type-guarding:

    var optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    var optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(function (key) {
      var valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key: key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key: key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    var hasWarned = _react["default"].useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
    }
  }

  var p = props.prefetch !== false;
  var router = (0, _router2.useRouter)();
  var pathname = router && router.pathname || '/';

  var _react$default$useMem = _react["default"].useMemo(function () {
    var _ref = (0, _router.resolveHref)(pathname, props.href, true),
        _ref2 = _slicedToArray(_ref, 2),
        resolvedHref = _ref2[0],
        resolvedAs = _ref2[1];

    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref
    };
  }, [pathname, props.href, props.as]),
      href = _react$default$useMem.href,
      as = _react$default$useMem.as;

  var children = props.children,
      replace = props.replace,
      shallow = props.shallow,
      scroll = props.scroll,
      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react["default"].createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  var child = _react.Children.only(children);

  var childRef = child && typeof child === 'object' && child.ref;

  var _ref3 = (0, _useIntersection.useIntersection)({
    rootMargin: '200px'
  }),
      _ref4 = _slicedToArray(_ref3, 2),
      setIntersectionRef = _ref4[0],
      isVisible = _ref4[1];

  var setRef = _react["default"].useCallback(function (el) {
    setIntersectionRef(el);

    if (childRef) {
      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {
        childRef.current = el;
      }
    }
  }, [childRef, setIntersectionRef]);

  (0, _react.useEffect)(function () {
    var shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);
    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    var isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];

    if (shouldPrefetch && !isPrefetched) {
      prefetch(router, href, as, {
        locale: curLocale
      });
    }
  }, [as, href, isVisible, locale, p, router]);
  var childProps = {
    ref: setRef,
    onClick: function onClick(e) {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  childProps.onMouseEnter = function (e) {
    if (!(0, _router.isLocalURL)(href)) return;

    if (child.props && typeof child.props.onMouseEnter === 'function') {
      child.props.onMouseEnter(e);
    }

    prefetch(router, href, as, {
      priority: true
    });
  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    childProps.href = (0, _router.addBasePath)((0, _router.addLocale)(as, typeof locale !== 'undefined' ? locale : router && router.locale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react["default"].cloneElement(child, childProps);
}

_s(Link, "7cX92ILFgstKFyzTMH+g73G4t5k=");

_c = Link;
var _default = Link;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


var normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;

var requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

var _default = requestIdleCallback;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/regenerator */ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js");

var _slicedToArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports["default"] = void 0;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js")); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


var MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  var entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  var resolver;
  var prom = new Promise(function (resolve) {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? // eslint-disable-next-line no-sequences
  generator().then(function (value) {
    return resolver(value), value;
  }) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (_unused) {
    return false;
  }
}

var canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise(function (res, rej) {
    if (document.querySelector("link[rel=\"prefetch\"][href^=\"".concat(href, "\"]"))) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = "prefetch";
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

var ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise(function (resolve, reject) {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = function () {
      return reject(markAssetError(new Error("Failed to load script: ".concat(src))));
    }; // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
}

function idleTimeout(ms, err) {
  return new Promise(function (_resolve, reject) {
    return (0, _requestIdleCallback["default"])(function () {
      return setTimeout(function () {
        return reject(err);
      }, ms);
    });
  });
} // TODO: stop exporting or cache the failure
// It'd be best to stop exporting this. It's an implementation detail. We're
// only exporting it for backwards compatibilty with the `page-loader`.
// Only cache this response as a last resort if we cannot eliminate all other
// code branches that use the Build Manifest Callback and push them through
// the Route Loader interface.


function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  var onBuildManifest = new Promise(function (resolve) {
    // Mandatory because this is not concurrent safe:
    var cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = function () {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return Promise.race([onBuildManifest, idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')))]);
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute["default"])(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(function (manifest) {
    if (!(route in manifest)) {
      throw markAssetError(new Error("Failed to lookup route: ".concat(route)));
    }

    var allFiles = manifest[route].map(function (entry) {
      return assetPrefix + '/_next/' + encodeURI(entry);
    });
    return {
      scripts: allFiles.filter(function (v) {
        return v.endsWith('.js');
      }),
      css: allFiles.filter(function (v) {
        return v.endsWith('.css');
      })
    };
  });
}

function createRouteLoader(assetPrefix) {
  var entrypoints = new Map();
  var loadedScripts = new Map();
  var styleSheets = new Map();
  var routes = new Map();

  function maybeExecuteScript(src) {
    var prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector("script[src^=\"".concat(src, "\"]"))) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    var prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(function (res) {
      if (!res.ok) {
        throw new Error("Failed to load stylesheet: ".concat(href));
      }

      return res.text().then(function (text) {
        return {
          href: href,
          content: text
        };
      });
    })["catch"](function (err) {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint: function whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },
    onEntrypoint: function onEntrypoint(route, execute) {
      Promise.resolve(execute).then(function (fn) {
        return fn();
      }).then(function (exports) {
        return {
          component: exports && exports["default"] || exports,
          exports: exports
        };
      }, function (err) {
        return {
          error: err
        };
      }).then(function (input) {
        var old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },
    loadRoute: function loadRoute(route) {
      var _this = this;

      return withFuture(route, routes, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _yield$getFilesForRou, scripts, css, _yield$Promise$all, _yield$Promise$all2, styles, entrypoint, res;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return getFilesForRoute(assetPrefix, route);

              case 3:
                _yield$getFilesForRou = _context.sent;
                scripts = _yield$getFilesForRou.scripts;
                css = _yield$getFilesForRou.css;
                _context.next = 8;
                return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);

              case 8:
                _yield$Promise$all = _context.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                styles = _yield$Promise$all2[1];
                _context.next = 13;
                return Promise.race([_this.whenEntrypoint(route), idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: ".concat(route))))]);

              case 13:
                entrypoint = _context.sent;
                res = Object.assign({
                  styles: styles
                }, entrypoint);
                return _context.abrupt("return", 'error' in entrypoint ? entrypoint : res);

              case 18:
                _context.prev = 18;
                _context.t0 = _context["catch"](0);
                return _context.abrupt("return", {
                  error: _context.t0
                });

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 18]]);
      })));
    },
    prefetch: function prefetch(route) {
      var _this2 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(function (output) {
        return Promise.all(canPrefetch ? output.scripts.map(function (script) {
          return prefetchViaDom(script, 'script');
        }) : []);
      }).then(function () {
        (0, _requestIdleCallback["default"])(function () {
          return _this2.loadRoute(route);
        });
      })["catch"]( // swallow prefetch errors
      function () {});
    }
  };
}

var _default = createRouteLoader;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/construct */ "./node_modules/next/node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useIntersection = useIntersection;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js"));

var hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';

function useIntersection(_ref) {
  var rootMargin = _ref.rootMargin,
      disabled = _ref.disabled;
  var isDisabled = disabled || !hasIntersectionObserver;
  var unobserve = (0, _react.useRef)();

  var _ref2 = (0, _react.useState)(false),
      _ref3 = _slicedToArray(_ref2, 2),
      visible = _ref3[0],
      setVisible = _ref3[1];

  var setRef = (0, _react.useCallback)(function (el) {
    if (unobserve.current) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (isDisabled || visible) return;

    if (el && el.tagName) {
      unobserve.current = observe(el, function (isVisible) {
        return isVisible && setVisible(isVisible);
      }, {
        rootMargin: rootMargin
      });
    }
  }, [isDisabled, rootMargin, visible]);
  (0, _react.useEffect)(function () {
    if (!hasIntersectionObserver) {
      if (!visible) (0, _requestIdleCallback["default"])(function () {
        return setVisible(true);
      });
    }
  }, [visible]);
  return [setRef, visible];
}

function observe(element, callback, options) {
  var _createObserver = createObserver(options),
      id = _createObserver.id,
      observer = _createObserver.observer,
      elements = _createObserver.elements;

  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers["delete"](id);
    }
  };
}

var observers = new Map();

function createObserver(options) {
  var id = options.rootMargin || '';
  var instance = observers.get(id);

  if (instance) {
    return instance;
  }

  var elements = new Map();
  var observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      var callback = elements.get(entry.target);
      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  observers.set(id, instance = {
    id: id,
    observer: observer,
    elements: elements
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var AmpStateContext = /*#__PURE__*/_react["default"].createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isInAmpMode() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ampFirst = _ref.ampFirst,
      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,
      _ref$hybrid = _ref.hybrid,
      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,
      _ref$hasQuery = _ref.hasQuery,
      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;

  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react["default"].useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var HeadManagerContext = /*#__PURE__*/_react["default"].createContext({});

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultHead() {
  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var head = [/*#__PURE__*/_react["default"].createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react["default"].createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react["default"].Fragment) {
    return list.concat(_react["default"].Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

var METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  var keys = new Set();
  var tags = new Set();
  var metaTypes = new Set();
  var metaCategories = {};
  return function (h) {
    var isUnique = true;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      var key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (var i = 0, len = METATYPES.length; i < len; i++) {
          var metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            var category = h.props[metatype];
            var categories = metaCategories[metatype] || new Set();

            if (categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce(function (list, headElement) {
    var headElementChildren = _react["default"].Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {
    var key = c.key || i;

    if (false) { var newProps; }

    return /*#__PURE__*/_react["default"].cloneElement(c, {
      key: key
    });
  });
}
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/


function Head(_ref) {
  var children = _ref.children;
  var ampState = (0, _react.useContext)(_ampContext.AmpStateContext);
  var headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);
  return /*#__PURE__*/_react["default"].createElement(_sideEffect["default"], {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, _amp.isInAmpMode)(ampState)
  }, children);
} // TODO: Remove in the next major release


_c = Head;

Head.rewind = function () {};

var _default = Head;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.normalizeLocalePath = normalizeLocalePath;

function normalizeLocalePath(pathname, locales) {
  var detectedLocale; // first item will be empty string from splitting at first char

  var pathnameParts = pathname.split('/');
  (locales || []).some(function (locale) {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join('/') || '/';
      return true;
    }

    return false;
  });
  return {
    pathname: pathname,
    detectedLocale: detectedLocale
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = /*#__PURE__*/_react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/regenerator */ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck */ "./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/createClass */ "./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js");

exports.__esModule = true;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports["default"] = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "./node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _escapePathDelimiters = _interopRequireDefault(__webpack_require__(/*! ./utils/escape-path-delimiters */ "./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js"));

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(path) : path;
}

function addLocale(path, locale, defaultLocale) {
  if (true) {
    return locale && locale !== defaultLocale && !path.startsWith('/' + locale + '/') && path !== '/' + locale ? addPathPrefix(path, '/' + locale) : path;
  }

  return path;
}

function delLocale(path, locale) {
  if (true) {
    return locale && (path.startsWith('/' + locale + '/') || path === '/' + locale) ? path.substr(locale.length + 1) || '/' : path;
  }

  return path;
}

function hasBasePath(path) {
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  return path.slice(basePath.length) || '/';
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, _utils.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  var interpolatedRoute = '';
  var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  var dynamicGroups = dynamicRegex.groups;
  var dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  var params = Object.keys(dynamicGroups);

  if (!params.every(function (param) {
    var value = dynamicMatches[param] || '';
    var _dynamicGroups$param = dynamicGroups[param],
        repeat = _dynamicGroups$param.repeat,
        optional = _dynamicGroups$param.optional; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(_escapePathDelimiters["default"]).join('/') : (0, _escapePathDelimiters["default"])(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params: params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  var filteredQuery = {};
  Object.keys(query).forEach(function (key) {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  var base = new URL(currentPath, 'http://n');
  var urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router

  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    var interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);

      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),
          result = _interpolateAs.result,
          params = _interpolateAs.params;

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  return {
    url: addBasePath(resolveHref(router.pathname, url)),
    as: as ? addBasePath(resolveHref(router.pathname, as)) : as
  };
}

var manualScrollRestoration =  false && false;
var SSG_DATA_NOT_FOUND_ERROR = 'SSG Data NOT_FOUND';

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` wont send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        // TODO: handle reloading in development from fallback returning 200
        // to on-demand-entry-handler causing it to reload periodically
        throw new Error(SSG_DATA_NOT_FOUND_ERROR);
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader.markAssetError)(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  function Router(_pathname, _query, _as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback,
        locale = _ref.locale,
        locales = _ref.locales,
        defaultLocale = _ref.defaultLocale;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname2 = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname2),
          query: query
        }), (0, _utils.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var url = state.url,
          as = state.as,
          options = state.options;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow,
        locale: options.locale || _this.defaultLocale
      }));
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        initial: true,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (true) {
      this.locale = locale;
      this.locales = locales;
      this.defaultLocale = defaultLocale;
    }

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)(), {
          locale: locale
        });
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) { var debouncedScrollSave, scrollDebounceTimeout; }
    }
  }

  _createClass(Router, [{
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs = prepareUrlAs(this, url, as);

      url = _prepareUrlAs.url;
      as = _prepareUrlAs.as;
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs2 = prepareUrlAs(this, url, as);

      url = _prepareUrlAs2.url;
      as = _prepareUrlAs2.as;
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function () {
      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options) {
        var _this2 = this;

        var localeChange, _this$locales, _require, normalizeLocalePath, parsedAs, localePathResult, cleanedAs, parsed, _parsed, pathname, query, pages, rewrites, _yield, route, _options$shallow, shallow, resolvedAs, potentialHref, _parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, appComp;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isLocalURL(url)) {
                  _context.next = 3;
                  break;
                }

                window.location.href = url;
                return _context.abrupt("return", false);

              case 3:
                localeChange = options.locale !== this.locale;

                if (false) {}

                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;

                if (typeof options.locale === 'undefined') {
                  options.locale = this.locale;
                }

                _require = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js"), normalizeLocalePath = _require.normalizeLocalePath;
                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(hasBasePath(as) ? delBasePath(as) : as);
                localePathResult = normalizeLocalePath(parsedAs.pathname, this.locales);

                if (localePathResult.detectedLocale) {
                  this.locale = localePathResult.detectedLocale;
                  url = addBasePath(localePathResult.pathname);
                } // if the locale isn't configured hard navigate to show 404 page


                if ((_this$locales = this.locales) == null ? void 0 : _this$locales.includes(this.locale)) {
                  _context.next = 15;
                  break;
                }

                parsedAs.pathname = addLocale(parsedAs.pathname, this.locale);
                window.location.href = (0, _utils.formatWithValidation)(parsedAs);
                return _context.abrupt("return", new Promise(function () {}));

              case 15:
                if (!options._h) {
                  this.isSsr = false;
                } // marking route changes as a navigation start entry


                if (_utils.ST) {
                  performance.mark('routeChange');
                }

                if (this._inFlightRoute) {
                  this.abortComponentLoad(this._inFlightRoute);
                }

                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
                this._inFlightRoute = as; // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.
                // WARNING: `_h` is an internal option for handing Next.js client-side
                // hydration. Your app should _never_ use this property. It may change at
                // any time without notice.

                if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                  _context.next = 29;
                  break;
                }

                this.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as); // TODO: do we need the resolved href when only a hash change?

                this.changeState(method, url, as, options);
                this.scrollToHash(cleanedAs);
                this.notify(this.components[this.route]);
                Router.events.emit('hashChangeComplete', as);
                return _context.abrupt("return", true);

              case 29:
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed = parsed, pathname = _parsed.pathname, query = _parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages
                // get their query parameters to allow ensuring they can be parsed properly
                // when rewritten to

                _context.prev = 31;
                _context.next = 34;
                return this.pageLoader.getPageList();

              case 34:
                pages = _context.sent;
                _context.next = 37;
                return (0, _routeLoader.getClientBuildManifest)();

              case 37:
                _yield = _context.sent;
                rewrites = _yield.__rewrites;
                _context.next = 45;
                break;

              case 41:
                _context.prev = 41;
                _context.t0 = _context["catch"](31);
                // If we fail to resolve the page list or client-build manifest, we must
                // do a server-side transition:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 45:
                parsed = this._resolveHref(parsed, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // url and as should always be prefixed with basePath by this
                // point by either next/link or router.push/replace so strip the
                // basePath from the pathname to match the pages dir 1-to-1


                pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                // We should compare the new asPath to the current asPath, not the url

                if (!this.urlIsNew(cleanedAs) && !localeChange) {
                  method = 'replaceState';
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow; // we need to resolve the as value using rewrites for dynamic SSG
                // pages to allow building the data URL correctly

                resolvedAs = as;

                if (true) {
                  resolvedAs = (0, _resolveRewrites["default"])((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname, pages, basePath, rewrites, query, function (p) {
                    return _this2._resolveHref({
                      pathname: p
                    }, pages).pathname;
                  });

                  if (resolvedAs !== as) {
                    potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {
                      pathname: resolvedAs
                    }), pages, false).pathname); // if this directly matches a page we need to update the href to
                    // allow the correct page chunk to be loaded

                    if (pages.includes(potentialHref)) {
                      route = potentialHref;
                      pathname = potentialHref;
                      parsed.pathname = pathname;
                      url = (0, _utils.formatWithValidation)(parsed);
                    }
                  }
                }

                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

                if (!(0, _isDynamic.isDynamicRoute)(route)) {
                  _context.next = 69;
                  break;
                }

                _parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
                asPathname = _parsedAs.pathname;
                routeRegex = (0, _routeRegex.getRouteRegex)(route);
                routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
                shouldInterpolate = route === asPathname;
                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {
                  _context.next = 68;
                  break;
                }

                missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                  return !query[param];
                });

                if (!(missingParams.length > 0)) {
                  _context.next = 66;
                  break;
                }

                if (true) {
                  console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                }

                throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://err.sh/vercel/next.js/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));

              case 66:
                _context.next = 69;
                break;

              case 68:
                if (shouldInterpolate) {
                  as = (0, _utils.formatWithValidation)(Object.assign({}, _parsedAs, {
                    pathname: interpolatedAs.result,
                    query: omitParmsFromQuery(query, interpolatedAs.params)
                  }));
                } else {
                  // Merge params into `query`, overwriting any specified in search
                  Object.assign(query, routeMatch);
                }

              case 69:
                Router.events.emit('routeChangeStart', as);
                _context.prev = 70;
                _context.next = 73;
                return this.getRouteInfo(route, pathname, query, as, shallow);

              case 73:
                routeInfo = _context.sent;
                error = routeInfo.error, props = routeInfo.props, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP; // handle redirect on client-transition

                if (!((__N_SSG || __N_SSP) && props && props.pageProps && props.pageProps.__N_REDIRECT)) {
                  _context.next = 85;
                  break;
                }

                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
                // client-navigation if it is falling back to hard navigation if
                // it's not

                if (!destination.startsWith('/')) {
                  _context.next = 83;
                  break;
                }

                parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);

                this._resolveHref(parsedHref, pages, false);

                if (!pages.includes(parsedHref.pathname)) {
                  _context.next = 83;
                  break;
                }

                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;
                return _context.abrupt("return", this.change(method, newUrl, newAs, options));

              case 83:
                window.location.href = destination;
                return _context.abrupt("return", new Promise(function () {}));

              case 85:
                Router.events.emit('beforeHistoryChange', as);
                this.changeState(method, url, as, options);

                if (true) {
                  appComp = this.components['/_app'].Component;
                  window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
                }

                _context.next = 90;
                return this.set(route, pathname, query, cleanedAs, routeInfo)["catch"](function (e) {
                  if (e.cancelled) error = error || e;else throw e;
                });

              case 90:
                if (!error) {
                  _context.next = 93;
                  break;
                }

                Router.events.emit('routeChangeError', error, cleanedAs);
                throw error;

              case 93:
                if (false) {}

                if (true) {
                  if (this.locale) {
                    document.documentElement.lang = this.locale;
                  }
                }

                Router.events.emit('routeChangeComplete', as);
                return _context.abrupt("return", true);

              case 99:
                _context.prev = 99;
                _context.t1 = _context["catch"](70);

                if (!_context.t1.cancelled) {
                  _context.next = 103;
                  break;
                }

                return _context.abrupt("return", false);

              case 103:
                throw _context.t1;

              case 104:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[31, 41], [70, 99]]);
      }));

      function change(_x, _x2, _x3, _x4) {
        return _change.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        this._shallow = options.shallow;
        window.history[method]({
          url: url,
          as: as,
          options: options,
          __N: true
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "handleRouteInfoError",
    value: function () {
      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, loadErrorFail) {
        var Component, styleSheets, props, ssg404, mod, _yield$this$fetchComp, _yield$this$fetchComp2, routeInfo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!err.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw err;

              case 2:
                if (!((0, _routeLoader.isAssetError)(err) || loadErrorFail)) {
                  _context2.next = 6;
                  break;
                }

                Router.events.emit('routeChangeError', err, as); // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.

                window.location.href = as; // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.

                throw buildCancellationError();

              case 6:
                _context2.prev = 6;
                ssg404 = err.message === SSG_DATA_NOT_FOUND_ERROR;

                if (!ssg404) {
                  _context2.next = 24;
                  break;
                }

                _context2.prev = 9;
                _context2.next = 12;
                return this.fetchComponent('/404');

              case 12:
                _yield$this$fetchComp = _context2.sent;
                Component = _yield$this$fetchComp.page;
                styleSheets = _yield$this$fetchComp.styleSheets;
                mod = _yield$this$fetchComp.mod;

                if (!(mod && mod.__N_SSG)) {
                  _context2.next = 20;
                  break;
                }

                _context2.next = 19;
                return this._getStaticData(this.pageLoader.getDataHref('/404', '/404', true, this.locale));

              case 19:
                props = _context2.sent;

              case 20:
                _context2.next = 24;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](9);

              case 24:
                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {
                  _context2.next = 31;
                  break;
                }

                ;
                _context2.next = 28;
                return this.fetchComponent('/_error');

              case 28:
                _yield$this$fetchComp2 = _context2.sent;
                Component = _yield$this$fetchComp2.page;
                styleSheets = _yield$this$fetchComp2.styleSheets;

              case 31:
                routeInfo = {
                  props: props,
                  Component: Component,
                  styleSheets: styleSheets,
                  err: ssg404 ? undefined : err,
                  error: ssg404 ? undefined : err
                };

                if (routeInfo.props) {
                  _context2.next = 43;
                  break;
                }

                _context2.prev = 33;
                _context2.next = 36;
                return this.getInitialProps(Component, {
                  err: err,
                  pathname: pathname,
                  query: query
                });

              case 36:
                routeInfo.props = _context2.sent;
                _context2.next = 43;
                break;

              case 39:
                _context2.prev = 39;
                _context2.t1 = _context2["catch"](33);
                console.error('Error in error page `getInitialProps`: ', _context2.t1);
                routeInfo.props = {};

              case 43:
                return _context2.abrupt("return", routeInfo);

              case 46:
                _context2.prev = 46;
                _context2.t2 = _context2["catch"](6);
                return _context2.abrupt("return", this.handleRouteInfoError(_context2.t2, pathname, query, as, true));

              case 49:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 46], [9, 22], [33, 39]]);
      }));

      function handleRouteInfoError(_x5, _x6, _x7, _x8, _x9) {
        return _handleRouteInfoError.apply(this, arguments);
      }

      return handleRouteInfoError;
    }()
  }, {
    key: "getRouteInfo",
    value: function () {
      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as) {
        var _this3 = this;

        var shallow,
            existingRouteInfo,
            cachedRouteInfo,
            routeInfo,
            Component,
            __N_SSG,
            __N_SSP,
            _require2,
            isValidElementType,
            dataHref,
            props,
            _args3 = arguments;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                shallow = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : false;
                _context3.prev = 1;
                existingRouteInfo = this.components[route];

                if (!(shallow && existingRouteInfo && this.route === route)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", existingRouteInfo);

              case 5:
                cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;

                if (!cachedRouteInfo) {
                  _context3.next = 10;
                  break;
                }

                _context3.t0 = cachedRouteInfo;
                _context3.next = 13;
                break;

              case 10:
                _context3.next = 12;
                return this.fetchComponent(route).then(function (res) {
                  return {
                    Component: res.page,
                    styleSheets: res.styleSheets,
                    __N_SSG: res.mod.__N_SSG,
                    __N_SSP: res.mod.__N_SSP
                  };
                });

              case 12:
                _context3.t0 = _context3.sent;

              case 13:
                routeInfo = _context3.t0;
                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

                if (false) {}

                _require2 = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require2.isValidElementType;

                if (isValidElementType(Component)) {
                  _context3.next = 19;
                  break;
                }

                throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

              case 19:
                if (__N_SSG || __N_SSP) {
                  dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                    pathname: pathname,
                    query: query
                  }), delBasePath(as), __N_SSG, this.locale);
                }

                _context3.next = 22;
                return this._getData(function () {
                  return __N_SSG ? _this3._getStaticData(dataHref) : __N_SSP ? _this3._getServerData(dataHref) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
                  {
                    pathname: pathname,
                    query: query,
                    asPath: as
                  });
                });

              case 22:
                props = _context3.sent;
                routeInfo.props = props;
                this.components[route] = routeInfo;
                return _context3.abrupt("return", routeInfo);

              case 28:
                _context3.prev = 28;
                _context3.t1 = _context3["catch"](1);
                return _context3.abrupt("return", this.handleRouteInfoError(_context3.t1, pathname, query, as));

              case 31:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[1, 28]]);
      }));

      function getRouteInfo(_x10, _x11, _x12, _x13) {
        return _getRouteInfo.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
  }, {
    key: "_resolveHref",
    value: function _resolveHref(parsedHref, pages) {
      var applyBasePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var pathname = parsedHref.pathname;
      var cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

      if (cleanPathname === '/404' || cleanPathname === '/_error') {
        return parsedHref;
      } // handle resolving href for dynamic routes


      if (!pages.includes(cleanPathname)) {
        // eslint-disable-next-line array-callback-return
        pages.some(function (page) {
          if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
            parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
            return true;
          }
        });
      }

      return parsedHref;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function () {
      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var _this4 = this;

        var asPath,
            options,
            parsed,
            _parsed2,
            pathname,
            normalizeLocalePath,
            parsedAs,
            localePathResult,
            pages,
            route,
            _args4 = arguments;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;
                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed2 = parsed, pathname = _parsed2.pathname;

                if (true) {
                  normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js").normalizeLocalePath;

                  if (options.locale === false) {
                    pathname = normalizeLocalePath(pathname, this.locales).pathname;
                    parsed.pathname = pathname;
                    url = (0, _utils.formatWithValidation)(parsed);
                    parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(asPath);
                    localePathResult = normalizeLocalePath(parsedAs.pathname, this.locales);
                    parsedAs.pathname = localePathResult.pathname;
                    options.locale = localePathResult.detectedLocale || this.defaultLocale;
                    asPath = (0, _utils.formatWithValidation)(parsedAs);
                  }
                }

                _context4.next = 7;
                return this.pageLoader.getPageList();

              case 7:
                pages = _context4.sent;
                parsed = this._resolveHref(parsed, pages, false);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // Prefetch is not supported in development mode because it would trigger on-demand-entries


                if (false) {}

                return _context4.abrupt("return");

              case 12:
                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _context4.next = 15;
                return Promise.all([this.pageLoader._isSsg(url).then(function (isSsg) {
                  return isSsg ? _this4._getStaticData(_this4.pageLoader.getDataHref(url, asPath, true, typeof options.locale !== 'undefined' ? options.locale : _this4.locale)) : false;
                }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function prefetch(_x14) {
        return _prefetch.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                _context5.next = 4;
                return this.pageLoader.loadPage(route);

              case 4:
                componentResult = _context5.sent;

                if (!cancelled) {
                  _context5.next = 9;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 9:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context5.abrupt("return", componentResult);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function fetchComponent(_x15) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this5 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this5.clc) {
          _this5.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "_getStaticData",
    value: function _getStaticData(dataHref) {
      var _this6 = this;

      var _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

      if (false) {}

      return fetchNextData(dataHref, this.isSsr).then(function (data) {
        _this6.sdc[cacheKey] = data;
        return data;
      });
    }
  }, {
    key: "_getServerData",
    value: function _getServerData(dataHref) {
      return fetchNextData(dataHref, this.isSsr);
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as) {
      if (this.clc) {
        Router.events.emit('routeChangeError', buildCancellationError(), as);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data) {
      return this.sub(data, this.components['/_app'].Component);
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = escapePathDelimiters; // escape delimiters used by path-to-regexp

function escapePathDelimiters(segment) {
  return segment.replace(/[/#?]/g, function (_char) {
    return encodeURIComponent(_char);
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || '';
  var pathname = urlObj.pathname || '';
  var hash = urlObj.hash || '';
  var query = urlObj.query || '';
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = getAssetPathFromRoute; // Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...

function getAssetPathFromRoute(route) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : "".concat(route);
  return path + ext;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/


function parseRelativeUrl(url, base) {
  var globalBase = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
  var resolvedBase = base ? new URL(base, globalBase) : globalBase;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin;

  if (origin !== globalBase.origin) {
    throw new Error('invariant: invalid relative URL');
  }

  return {
    pathname: pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search: search,
    hash: hash,
    href: href.slice(globalBase.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.pathToRegexp = exports["default"] = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

exports.pathToRegexp = pathToRegexp;

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var matcherOptions = {
  sensitive: false,
  delimiter: '/'
};
exports.matcherOptions = matcherOptions;

var customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {
  strict: true
});

exports.customRouteMatcherOptions = customRouteMatcherOptions;

var _default = function _default() {
  var customRoute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function (path) {
    var keys = [];
    var matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);
    var matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);
    return function (pathname, params) {
      var res = pathname == null ? false : matcher(pathname);

      if (!res) {
        return false;
      }

      if (customRoute) {
        var _iterator = _createForOfIteratorHelper(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;

            // unnamed params should be removed as they
            // are not allowed to be used in the destination
            if (typeof key.name === 'number') {
              delete res.params[key.name];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return _objectSpread(_objectSpread({}, params), res.params);
    };
  };
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js");

var _slicedToArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports.compileNonPath = compileNonPath;
exports["default"] = prepareDestination;

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function compileNonPath(value, params) {
  if (!value.includes(':')) {
    return value;
  }

  for (var _i = 0, _Object$keys = Object.keys(params); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (value.includes(":".concat(key))) {
      value = value.replace(new RegExp(":".concat(key, "\\*"), 'g'), ":".concat(key, "--ESCAPED_PARAM_ASTERISKS")).replace(new RegExp(":".concat(key, "\\?"), 'g'), ":".concat(key, "--ESCAPED_PARAM_QUESTION")).replace(new RegExp(":".concat(key, "\\+"), 'g'), ":".concat(key, "--ESCAPED_PARAM_PLUS")).replace(new RegExp(":".concat(key, "(?!\\w)"), 'g'), "--ESCAPED_PARAM_COLON".concat(key));
    }
  }

  value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, '\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled
  // correctly

  return pathToRegexp.compile("/".concat(value), {
    validate: false
  })(params).substr(1);
}

function prepareDestination(destination, params, query, appendParamsToQuery, basePath) {
  var parsedDestination = {}; // clone query so we don't modify the original

  query = Object.assign({}, query);
  var hadLocale = query.__nextLocale;
  delete query.__nextLocale;
  delete query.__nextDefaultLocale;

  if (destination.startsWith('/')) {
    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
  } else {
    var _URL = new URL(destination),
        pathname = _URL.pathname,
        searchParams = _URL.searchParams,
        hash = _URL.hash,
        hostname = _URL.hostname,
        port = _URL.port,
        protocol = _URL.protocol,
        search = _URL.search,
        href = _URL.href;

    parsedDestination = {
      pathname: pathname,
      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
      hash: hash,
      protocol: protocol,
      hostname: hostname,
      port: port,
      search: search,
      href: href
    };
  }

  var destQuery = parsedDestination.query;
  var destPath = "".concat(parsedDestination.pathname).concat(parsedDestination.hash || '');
  var destPathParamKeys = [];
  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);
  var destPathParams = destPathParamKeys.map(function (key) {
    return key.name;
  });
  var destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should
  // have already validated before we got to this point and validating
  // breaks compiling destinations with named pattern params from the source
  // e.g. /something:hello(.*) -> /another/:hello is broken with validation
  // since compile validation is meant for reversing and not for inserting
  // params from a separate path-regex into another
  {
    validate: false
  });
  var newUrl; // update any params in query values

  for (var _i2 = 0, _Object$entries = Object.entries(destQuery); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        strOrArray = _Object$entries$_i[1];

    var value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;

    if (value) {
      // the value needs to start with a forward-slash to be compiled
      // correctly
      value = compileNonPath(value, params);
    }

    destQuery[key] = value;
  } // add path params to query if it's not a redirect and not
  // already defined in destination query or path


  var paramKeys = Object.keys(params); // remove internal param for i18n

  if (hadLocale) {
    paramKeys = paramKeys.filter(function (name) {
      return name !== 'nextInternalLocale';
    });
  }

  if (appendParamsToQuery && !paramKeys.some(function (key) {
    return destPathParams.includes(key);
  })) {
    var _iterator = _createForOfIteratorHelper(paramKeys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;

        if (!(_key in destQuery)) {
          destQuery[_key] = params[_key];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  var shouldAddBasePath = destination.startsWith('/') && basePath;

  try {
    newUrl = "".concat(shouldAddBasePath ? basePath : '').concat(destinationCompiler(params));

    var _newUrl$split = newUrl.split('#'),
        _newUrl$split2 = _slicedToArray(_newUrl$split, 2),
        _pathname = _newUrl$split2[0],
        _hash = _newUrl$split2[1];

    parsedDestination.pathname = _pathname;
    parsedDestination.hash = "".concat(_hash ? '#' : '').concat(_hash || '');
    delete parsedDestination.search;
  } catch (err) {
    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
      throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match");
    }

    throw err;
  } // Query merge order lowest priority to highest
  // 1. initial URL query values
  // 2. path segment values
  // 3. destination specified query values


  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);
  return {
    newUrl: newUrl,
    parsedDestination: parsedDestination
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, stringifyUrlQueryParam(item));
      });
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    });
    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports["default"] = resolveRewrites;

var _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js"));

var _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js"));

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var customRouteMatcher = (0, _pathMatch["default"])(true);

function resolveRewrites(asPath, pages, basePath, rewrites, query, resolveHref) {
  if (!pages.includes(asPath)) {
    var _iterator = _createForOfIteratorHelper(rewrites),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var rewrite = _step.value;
        var matcher = customRouteMatcher(rewrite.source);
        var params = matcher(asPath);

        if (params) {
          if (!rewrite.destination) {
            // this is a proxied rewrite which isn't handled on the client
            break;
          }

          var destRes = (0, _prepareDestination["default"])(rewrite.destination, params, query, true, rewrite.basePath === false ? '' : basePath);
          asPath = destRes.parsedDestination.pathname;
          Object.assign(query, destRes.parsedDestination.query);

          if (pages.includes((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath))) {
            // check if we now match a page as this means we are done
            // resolving the rewrites
            break;
          } // check if we match a dynamic-route, if so we break the rewrites chain


          var resolvedHref = resolveHref(asPath);

          if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
            break;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return asPath;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  var optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups: groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _toConsumableArray = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/toConsumableArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _classCallCheck = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck */ "./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/createClass */ "./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js");

var _assertThisInitialized = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized */ "./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized.js");

var _inherits = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/inherits */ "./node_modules/next/node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf */ "./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

exports.__esModule = true;
exports["default"] = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var isServer = false;

var _default = /*#__PURE__*/function (_react$Component) {
  _inherits(_default, _react$Component);

  var _super = _createSuper(_default);

  function _default(props) {
    var _this;

    _classCallCheck(this, _default);

    _this = _super.call(this, props);
    _this._hasHeadManager = void 0;

    _this.emitChange = function () {
      if (_this._hasHeadManager) {
        _this.props.headManager.updateHead(_this.props.reduceComponentsToState(_toConsumableArray(_this.props.headManager.mountedInstances), _this.props));
      }
    };

    _this._hasHeadManager = _this.props.headManager && _this.props.headManager.mountedInstances;

    if (isServer && _this._hasHeadManager) {
      _this.props.headManager.mountedInstances.add(_assertThisInitialized(_this));

      _this.emitChange();
    }

    return _this;
  }

  _createClass(_default, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances.add(this);
      }

      this.emitChange();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.emitChange();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances["delete"](this);
      }

      this.emitChange();
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return _default;
}(_react.Component);

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/regenerator */ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator */ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) == null ? void 0 : _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/construct.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/construct.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/next/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/createClass.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayLikeToArray; });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithoutHoles; });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return Object(_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(arr);
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _asyncToGenerator; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _getPrototypeOf; });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inherits; });
/* harmony import */ var _babel_runtime_helpers_esm_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/setPrototypeOf */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object(_babel_runtime_helpers_esm_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArray; });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableSpread; });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _possibleConstructorReturn; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && (Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function")) {
    return call;
  }

  return Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _setPrototypeOf; });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toConsumableArray; });
/* harmony import */ var _babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayWithoutHoles */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/iterableToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/unsupportedIterableToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/nonIterableSpread */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return Object(_babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || Object(_babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || Object(_babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _typeof; });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _unsupportedIterableToArray; });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return Object(_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Object(_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
}

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/inherits.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/inherits.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/next/node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/next/node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/typeof.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/node_modules/@babel/runtime/regenerator/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/querystringify/index.js":
/*!**********************************************!*\
  !*** ./node_modules/querystringify/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom-server.browser.development.js":
/*!****************************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-server.browser.development.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// Do not require this module directly! Use normal `invariant` calls with
// template literal strings. The messages will be replaced with error codes
// during build.
function formatProdErrorMessage(code) {
  var url = 'https://reactjs.org/docs/error-decoder.html?invariant=' + code;

  for (var i = 1; i < arguments.length; i++) {
    url += '&args[]=' + encodeURIComponent(arguments[i]);
  }

  return "Minified React error #" + code + "; visit " + url + " for the full message or " + 'use the non-minified dev environment for full errors and additional ' + 'helpful warnings.';
}

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableSuspenseServerRenderer = false;

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var didWarnAboutInvalidateContextType;

{
  didWarnAboutInvalidateContextType = new Set();
}

var emptyObject = {};

{
  Object.freeze(emptyObject);
}

function maskContext(type, context) {
  var contextTypes = type.contextTypes;

  if (!contextTypes) {
    return emptyObject;
  }

  var maskedContext = {};

  for (var contextName in contextTypes) {
    maskedContext[contextName] = context[contextName];
  }

  return maskedContext;
}

function checkContextTypes(typeSpecs, values, location) {
  {
    checkPropTypes(typeSpecs, values, location, 'Component');
  }
}

function validateContextBounds(context, threadID) {
  // If we don't have enough slots in this context to store this threadID,
  // fill it in without leaving any holes to ensure that the VM optimizes
  // this as non-holey index properties.
  // (Note: If `react` package is < 16.6, _threadCount is undefined.)
  for (var i = context._threadCount | 0; i <= threadID; i++) {
    // We assume that this is the same as the defaultValue which might not be
    // true if we're rendering inside a secondary renderer but they are
    // secondary because these use cases are very rare.
    context[i] = context._currentValue2;
    context._threadCount = i + 1;
  }
}
function processContext(type, context, threadID, isClass) {
  if (isClass) {
    var contextType = type.contextType;

    {
      if ('contextType' in type) {
        var isValid = // Allow null for conditional declaration
        contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>

        if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
          didWarnAboutInvalidateContextType.add(type);
          var addendum = '';

          if (contextType === undefined) {
            addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
          } else if (typeof contextType !== 'object') {
            addendum = ' However, it is set to a ' + typeof contextType + '.';
          } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
            addendum = ' Did you accidentally pass the Context.Provider instead?';
          } else if (contextType._context !== undefined) {
            // <Context.Consumer>
            addendum = ' Did you accidentally pass the Context.Consumer instead?';
          } else {
            addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
          }

          error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(type) || 'Component', addendum);
        }
      }
    }

    if (typeof contextType === 'object' && contextType !== null) {
      validateContextBounds(contextType, threadID);
      return contextType[threadID];
    }

    {
      var maskedContext = maskContext(type, context);

      {
        if (type.contextTypes) {
          checkContextTypes(type.contextTypes, maskedContext, 'context');
        }
      }

      return maskedContext;
    }
  } else {
    {
      var _maskedContext = maskContext(type, context);

      {
        if (type.contextTypes) {
          checkContextTypes(type.contextTypes, _maskedContext, 'context');
        }
      }

      return _maskedContext;
    }
  }
}

var nextAvailableThreadIDs = new Uint16Array(16);

for (var i = 0; i < 15; i++) {
  nextAvailableThreadIDs[i] = i + 1;
}

nextAvailableThreadIDs[15] = 0;

function growThreadCountAndReturnNextAvailable() {
  var oldArray = nextAvailableThreadIDs;
  var oldSize = oldArray.length;
  var newSize = oldSize * 2;

  if (!(newSize <= 0x10000)) {
    {
      throw Error( "Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic." );
    }
  }

  var newArray = new Uint16Array(newSize);
  newArray.set(oldArray);
  nextAvailableThreadIDs = newArray;
  nextAvailableThreadIDs[0] = oldSize + 1;

  for (var _i = oldSize; _i < newSize - 1; _i++) {
    nextAvailableThreadIDs[_i] = _i + 1;
  }

  nextAvailableThreadIDs[newSize - 1] = 0;
  return oldSize;
}

function allocThreadID() {
  var nextID = nextAvailableThreadIDs[0];

  if (nextID === 0) {
    return growThreadCountAndReturnNextAvailable();
  }

  nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
  return nextID;
}
function freeThreadID(id) {
  nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
  nextAvailableThreadIDs[0] = id;
}

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.

var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.

var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.

var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.

var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.

var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.

var POSITIVE_NUMERIC = 6;

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */

var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty = Object.prototype.hasOwnProperty;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }

  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }

  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }

  illegalAttributeNameCache[attributeName] = true;

  {
    error('Invalid attribute name: `%s`', attributeName);
  }

  return false;
}
function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return true;
  }

  return false;
}
function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }

  switch (typeof value) {
    case 'function': // $FlowIssue symbol is perfectly valid here

    case 'symbol':
      // eslint-disable-line
      return true;

    case 'boolean':
      {
        if (isCustomComponentTag) {
          return false;
        }

        if (propertyInfo !== null) {
          return !propertyInfo.acceptsBooleans;
        } else {
          var prefix = name.toLowerCase().slice(0, 5);
          return prefix !== 'data-' && prefix !== 'aria-';
        }
      }

    default:
      return false;
  }
}
function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
  if (value === null || typeof value === 'undefined') {
    return true;
  }

  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (propertyInfo !== null) {

    switch (propertyInfo.type) {
      case BOOLEAN:
        return !value;

      case OVERLOADED_BOOLEAN:
        return value === false;

      case NUMERIC:
        return isNaN(value);

      case POSITIVE_NUMERIC:
        return isNaN(value) || value < 1;
    }
  }

  return false;
}
function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
  this.sanitizeURL = sanitizeURL;
  this.removeEmptyString = removeEmptyString;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.


var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.

var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
reservedProps.forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.

[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var name = _ref[0],
      attributeName = _ref[1];
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).

['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.

['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML boolean attributes.

['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.

['checked', // Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.

['capture', 'download' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be positive numbers.

['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be numbers.

['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
});
var CAMELIZE = /[\-\:]([a-z])/g;

var capitalize = function (token) {
  return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.


['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // String SVG attributes with the xlink namespace.

['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
  false);
}); // String SVG attributes with the xml namespace.

['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
  false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.

['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.

var xlinkHref = 'xlinkHref';
properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
false);
['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  true, // sanitizeURL
  true);
});

// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space

/* eslint-disable max-len */

var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
var didWarn = false;

function sanitizeURL(url) {
  {
    if (!didWarn && isJavaScriptProtocol.test(url)) {
      didWarn = true;

      error('A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));
    }
  }
}

// code copied and modified from escape-html

/**
 * Module variables.
 * @private
 */
var matchHtmlRegExp = /["'&<>]/;
/**
 * Escapes special characters and HTML entities in a given html string.
 *
 * @param  {string} string HTML string to escape for later insertion
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;

      case 38:
        // &
        escape = '&amp;';
        break;

      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'

        break;

      case 60:
        // <
        escape = '&lt;';
        break;

      case 62:
        // >
        escape = '&gt;';
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
} // end code copied and modified from escape-html

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */


function escapeTextForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }

  return escapeHtml(text);
}

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */

function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextForBrowser(value) + '"';
}

function createMarkupForRoot() {
  return ROOT_ATTRIBUTE_NAME + '=""';
}
/**
 * Creates markup for a property.
 *
 * @param {string} name
 * @param {*} value
 * @return {?string} Markup string, or null if the property was invalid.
 */

function createMarkupForProperty(name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (name !== 'style' && shouldIgnoreAttribute(name, propertyInfo, false)) {
    return '';
  }

  if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
    return '';
  }

  if (propertyInfo !== null) {
    var attributeName = propertyInfo.attributeName;
    var type = propertyInfo.type;

    if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
      return attributeName + '=""';
    } else {
      if (propertyInfo.sanitizeURL) {
        value = '' + value;
        sanitizeURL(value);
      }

      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    }
  } else if (isAttributeNameSafe(name)) {
    return name + '=' + quoteAttributeValueForBrowser(value);
  }

  return '';
}
/**
 * Creates markup for a custom property.
 *
 * @param {string} name
 * @param {*} value
 * @return {string} Markup string, or empty string if the property was invalid.
 */

function createMarkupForCustomAttribute(name, value) {
  if (!isAttributeNameSafe(name) || value == null) {
    return '';
  }

  return name + '=' + quoteAttributeValueForBrowser(value);
}

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = typeof Object.is === 'function' ? Object.is : is;

var currentlyRenderingComponent = null;
var firstWorkInProgressHook = null;
var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook

var isReRender = false; // Whether an update was scheduled during the currently executing render pass.

var didScheduleRenderPhaseUpdate = false; // Lazily created map of render-phase updates

var renderPhaseUpdates = null; // Counter to prevent infinite loops.

var numberOfReRenders = 0;
var RE_RENDER_LIMIT = 25;
var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook

var currentHookNameInDev;

function resolveCurrentlyRenderingComponent() {
  if (!(currentlyRenderingComponent !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  {
    if (isInHookUserCodeInDev) {
      error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');
    }
  }

  return currentlyRenderingComponent;
}

function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null) {
    {
      error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
    }

    return false;
  }

  {
    // Don't bother comparing lengths in prod because these arrays should be
    // passed inline.
    if (nextDeps.length !== prevDeps.length) {
      error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + nextDeps.join(', ') + "]", "[" + prevDeps.join(', ') + "]");
    }
  }

  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (objectIs(nextDeps[i], prevDeps[i])) {
      continue;
    }

    return false;
  }

  return true;
}

function createHook() {
  if (numberOfReRenders > 0) {
    {
      {
        throw Error( "Rendered more hooks than during the previous render" );
      }
    }
  }

  return {
    memoizedState: null,
    queue: null,
    next: null
  };
}

function createWorkInProgressHook() {
  if (workInProgressHook === null) {
    // This is the first hook in the list
    if (firstWorkInProgressHook === null) {
      isReRender = false;
      firstWorkInProgressHook = workInProgressHook = createHook();
    } else {
      // There's already a work-in-progress. Reuse it.
      isReRender = true;
      workInProgressHook = firstWorkInProgressHook;
    }
  } else {
    if (workInProgressHook.next === null) {
      isReRender = false; // Append to the end of the list

      workInProgressHook = workInProgressHook.next = createHook();
    } else {
      // There's already a work-in-progress. Reuse it.
      isReRender = true;
      workInProgressHook = workInProgressHook.next;
    }
  }

  return workInProgressHook;
}

function prepareToUseHooks(componentIdentity) {
  currentlyRenderingComponent = componentIdentity;

  {
    isInHookUserCodeInDev = false;
  } // The following should have already been reset
  // didScheduleRenderPhaseUpdate = false;
  // firstWorkInProgressHook = null;
  // numberOfReRenders = 0;
  // renderPhaseUpdates = null;
  // workInProgressHook = null;

}
function finishHooks(Component, props, children, refOrContext) {
  // This must be called after every function component to prevent hooks from
  // being used in classes.
  while (didScheduleRenderPhaseUpdate) {
    // Updates were scheduled during the render phase. They are stored in
    // the `renderPhaseUpdates` map. Call the component again, reusing the
    // work-in-progress hooks and applying the additional updates on top. Keep
    // restarting until no more updates are scheduled.
    didScheduleRenderPhaseUpdate = false;
    numberOfReRenders += 1; // Start over from the beginning of the list

    workInProgressHook = null;
    children = Component(props, refOrContext);
  }

  resetHooksState();
  return children;
} // Reset the internal hooks state if an error occurs while rendering a component

function resetHooksState() {
  {
    isInHookUserCodeInDev = false;
  }

  currentlyRenderingComponent = null;
  didScheduleRenderPhaseUpdate = false;
  firstWorkInProgressHook = null;
  numberOfReRenders = 0;
  renderPhaseUpdates = null;
  workInProgressHook = null;
}

function readContext(context, observedBits) {
  var threadID = currentPartialRenderer.threadID;
  validateContextBounds(context, threadID);

  {
    if (isInHookUserCodeInDev) {
      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
    }
  }

  return context[threadID];
}

function useContext(context, observedBits) {
  {
    currentHookNameInDev = 'useContext';
  }

  resolveCurrentlyRenderingComponent();
  var threadID = currentPartialRenderer.threadID;
  validateContextBounds(context, threadID);
  return context[threadID];
}

function basicStateReducer(state, action) {
  // $FlowFixMe: Flow doesn't like mixed types
  return typeof action === 'function' ? action(state) : action;
}

function useState(initialState) {
  {
    currentHookNameInDev = 'useState';
  }

  return useReducer(basicStateReducer, // useReducer has a special case to support lazy useState initializers
  initialState);
}
function useReducer(reducer, initialArg, init) {
  {
    if (reducer !== basicStateReducer) {
      currentHookNameInDev = 'useReducer';
    }
  }

  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();

  if (isReRender) {
    // This is a re-render. Apply the new render phase updates to the previous
    // current hook.
    var queue = workInProgressHook.queue;
    var dispatch = queue.dispatch;

    if (renderPhaseUpdates !== null) {
      // Render phase updates are stored in a map of queue -> linked list
      var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

      if (firstRenderPhaseUpdate !== undefined) {
        renderPhaseUpdates.delete(queue);
        var newState = workInProgressHook.memoizedState;
        var update = firstRenderPhaseUpdate;

        do {
          // Process this render phase update. We don't have to check the
          // priority because it will always be the same as the current
          // render's.
          var action = update.action;

          {
            isInHookUserCodeInDev = true;
          }

          newState = reducer(newState, action);

          {
            isInHookUserCodeInDev = false;
          }

          update = update.next;
        } while (update !== null);

        workInProgressHook.memoizedState = newState;
        return [newState, dispatch];
      }
    }

    return [workInProgressHook.memoizedState, dispatch];
  } else {
    {
      isInHookUserCodeInDev = true;
    }

    var initialState;

    if (reducer === basicStateReducer) {
      // Special case for `useState`.
      initialState = typeof initialArg === 'function' ? initialArg() : initialArg;
    } else {
      initialState = init !== undefined ? init(initialArg) : initialArg;
    }

    {
      isInHookUserCodeInDev = false;
    }

    workInProgressHook.memoizedState = initialState;

    var _queue = workInProgressHook.queue = {
      last: null,
      dispatch: null
    };

    var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);

    return [workInProgressHook.memoizedState, _dispatch];
  }
}

function useMemo(nextCreate, deps) {
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;

  if (workInProgressHook !== null) {
    var prevState = workInProgressHook.memoizedState;

    if (prevState !== null) {
      if (nextDeps !== null) {
        var prevDeps = prevState[1];

        if (areHookInputsEqual(nextDeps, prevDeps)) {
          return prevState[0];
        }
      }
    }
  }

  {
    isInHookUserCodeInDev = true;
  }

  var nextValue = nextCreate();

  {
    isInHookUserCodeInDev = false;
  }

  workInProgressHook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function useRef(initialValue) {
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  var previousRef = workInProgressHook.memoizedState;

  if (previousRef === null) {
    var ref = {
      current: initialValue
    };

    {
      Object.seal(ref);
    }

    workInProgressHook.memoizedState = ref;
    return ref;
  } else {
    return previousRef;
  }
}

function useLayoutEffect(create, inputs) {
  {
    currentHookNameInDev = 'useLayoutEffect';

    error('useLayoutEffect does nothing on the server, because its effect cannot ' + "be encoded into the server renderer's output format. This will lead " + 'to a mismatch between the initial, non-hydrated UI and the intended ' + 'UI. To avoid this, useLayoutEffect should only be used in ' + 'components that render exclusively on the client. ' + 'See https://reactjs.org/link/uselayouteffect-ssr for common fixes.');
  }
}

function dispatchAction(componentIdentity, queue, action) {
  if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
    {
      throw Error( "Too many re-renders. React limits the number of renders to prevent an infinite loop." );
    }
  }

  if (componentIdentity === currentlyRenderingComponent) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdate = true;
    var update = {
      action: action,
      next: null
    };

    if (renderPhaseUpdates === null) {
      renderPhaseUpdates = new Map();
    }

    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

    if (firstRenderPhaseUpdate === undefined) {
      renderPhaseUpdates.set(queue, update);
    } else {
      // Append the update to the end of the list.
      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;

      while (lastRenderPhaseUpdate.next !== null) {
        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      }

      lastRenderPhaseUpdate.next = update;
    }
  }
}

function useCallback(callback, deps) {
  return useMemo(function () {
    return callback;
  }, deps);
} // TODO Decide on how to implement this hook for server rendering.
// If a mutation occurs during render, consider triggering a Suspense boundary
// and falling back to client rendering.

function useMutableSource(source, getSnapshot, subscribe) {
  resolveCurrentlyRenderingComponent();
  return getSnapshot(source._source);
}

function useDeferredValue(value) {
  resolveCurrentlyRenderingComponent();
  return value;
}

function useTransition() {
  resolveCurrentlyRenderingComponent();

  var startTransition = function (callback) {
    callback();
  };

  return [startTransition, false];
}

function useOpaqueIdentifier() {
  return (currentPartialRenderer.identifierPrefix || '') + 'R:' + (currentPartialRenderer.uniqueID++).toString(36);
}

function noop() {}

var currentPartialRenderer = null;
function setCurrentPartialRenderer(renderer) {
  currentPartialRenderer = renderer;
}
var Dispatcher = {
  readContext: readContext,
  useContext: useContext,
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: useRef,
  useState: useState,
  useLayoutEffect: useLayoutEffect,
  useCallback: useCallback,
  // useImperativeHandle is not run in the server environment
  useImperativeHandle: noop,
  // Effects are not run in the server environment.
  useEffect: noop,
  // Debugging effect
  useDebugValue: noop,
  useDeferredValue: useDeferredValue,
  useTransition: useTransition,
  useOpaqueIdentifier: useOpaqueIdentifier,
  // Subscriptions are not setup in a server environment.
  useMutableSource: useMutableSource
};

var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
var Namespaces = {
  html: HTML_NAMESPACE,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
}; // Assumes there is no parent namespace.

function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;

    case 'math':
      return MATH_NAMESPACE;

    default:
      return HTML_NAMESPACE;
  }
}
function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }

  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE;
  } // By default, pass namespace below.


  return parentNamespace;
}

var hasReadOnlyValue = {
  button: true,
  checkbox: true,
  image: true,
  hidden: true,
  radio: true,
  reset: true,
  submit: true
};
function checkControlledValueProps(tagName, props) {
  {
    if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
      error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }

    if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
      error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a list for
// those special-case tags.
var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.

};

// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML = '__html';

function assertValidProps(tag, props) {
  if (!props) {
    return;
  } // Note the use of `==` which checks for null or undefined.


  if (voidElementTags[tag]) {
    if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
      {
        throw Error( tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`." );
      }
    }
  }

  if (props.dangerouslySetInnerHTML != null) {
    if (!(props.children == null)) {
      {
        throw Error( "Can only set one of `children` or `props.dangerouslySetInnerHTML`." );
      }
    }

    if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) {
      {
        throw Error( "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information." );
      }
    }
  }

  {
    if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
      error('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');
    }
  }

  if (!(props.style == null || typeof props.style === 'object')) {
    {
      throw Error( "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX." );
    }
  }
}

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */

function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */


var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.

Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */

function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty = value == null || typeof value === 'boolean' || value === '';

  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;
/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */

function hyphenateStyleName(name) {
  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }

  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this list too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;

    default:
      return true;
  }
}

var warnValidStyle = function () {};

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  var msPattern$1 = /^-ms-/;
  var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon

  var badStyleValueWithSemicolonPattern = /;\s*$/;
  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var camelize = function (string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  };

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported style property %s. Did you mean %s?', name, // As Andi Smith suggests
    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
    // is converted to lowercase `ms`.
    camelize(name.replace(msPattern$1, 'ms-')));
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;

    error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function (name, value) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;

    error('`NaN` is an invalid value for the `%s` css style property.', name);
  };

  var warnStyleValueIsInfinity = function (name, value) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;

    error('`Infinity` is an invalid value for the `%s` css style property.', name);
  };

  warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

var ariaProperties = {
  'aria-current': 0,
  // state
  'aria-details': 0,
  'aria-disabled': 0,
  // state
  'aria-hidden': 0,
  // state
  'aria-invalid': 0,
  // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function validateProperty(tagName, name) {
  {
    if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
      return true;
    }

    if (rARIACamel.test(name)) {
      var ariaName = 'aria-' + name.slice(4).toLowerCase();
      var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (correctName == null) {
        error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);

        warnedProperties[name] = true;
        return true;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== correctName) {
        error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);

        warnedProperties[name] = true;
        return true;
      }
    }

    if (rARIA.test(name)) {
      var lowerCasedName = name.toLowerCase();
      var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (standardName == null) {
        warnedProperties[name] = true;
        return false;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== standardName) {
        error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties[name] = true;
        return true;
      }
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  {
    var invalidProps = [];

    for (var key in props) {
      var isValid = validateProperty(type, key);

      if (!isValid) {
        invalidProps.push(key);
      }
    }

    var unknownPropString = invalidProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (invalidProps.length === 1) {
      error('Invalid aria prop %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    } else if (invalidProps.length > 1) {
      error('Invalid aria props %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    }
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;
function validateProperties$1(type, props) {
  {
    if (type !== 'input' && type !== 'textarea' && type !== 'select') {
      return;
    }

    if (props != null && props.value === null && !didWarnValueNull) {
      didWarnValueNull = true;

      if (type === 'select' && props.multiple) {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
      } else {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
      }
    }
  }
}

// When adding attributes to the HTML or SVG allowed attribute list, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  default: 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  disablepictureinpicture: 'disablePictureInPicture',
  disableremoteplayback: 'disableRemotePlayback',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  enterkeyhint: 'enterKeyHint',
  for: 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nomodule: 'noModule',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',
  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  in: 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  typeof: 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

var validateProperty$1 = function () {};

{
  var warnedProperties$1 = {};
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  validateProperty$1 = function (tagName, name, value, eventRegistry) {
    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();

    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');

      warnedProperties$1[name] = true;
      return true;
    } // We can't rely on the event system being injected on the server.


    if (eventRegistry != null) {
      var registrationNameDependencies = eventRegistry.registrationNameDependencies,
          possibleRegistrationNames = eventRegistry.possibleRegistrationNames;

      if (registrationNameDependencies.hasOwnProperty(name)) {
        return true;
      }

      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;

      if (registrationName != null) {
        error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);

        warnedProperties$1[name] = true;
        return true;
      }

      if (EVENT_NAME_REGEX.test(name)) {
        error('Unknown event handler property `%s`. It will be ignored.', name);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        error('Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Let the ARIA attribute hook validate ARIA attributes


    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      error('Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      error('The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      error('Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      error('Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);

      warnedProperties$1[name] = true;
      return true;
    }

    var propertyInfo = getPropertyInfo(name);
    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.

    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];

      if (standardName !== name) {
        error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      error('React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      if (value) {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
      } else {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Now that we've validated casing, do not validate
    // data types for reserved props


    if (isReserved) {
      return true;
    } // Warn when a known attribute is a bad type


    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      warnedProperties$1[name] = true;
      return false;
    } // Warn when passing the strings 'false' or 'true' into a boolean prop


    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
      error('Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);

      warnedProperties$1[name] = true;
      return true;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, eventRegistry) {
  {
    var unknownProps = [];

    for (var key in props) {
      var isValid = validateProperty$1(type, key, props[key], eventRegistry);

      if (!isValid) {
        unknownProps.push(key);
      }
    }

    var unknownPropString = unknownProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (unknownProps.length === 1) {
      error('Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    } else if (unknownProps.length > 1) {
      error('Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    }
  }
};

function validateProperties$2(type, props, eventRegistry) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnUnknownProperties(type, props, eventRegistry);
}

var toArray = React.Children.toArray; // This is only used in DEV.
// Each entry is `this.stack` from a currently executing renderer instance.
// (There may be more than one because ReactDOMServer is reentrant).
// Each stack is an array of frames which may contain nested stacks of elements.

var currentDebugStacks = [];
var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var ReactDebugCurrentFrame$1;
var prevGetCurrentStackImpl = null;

var getCurrentServerStackImpl = function () {
  return '';
};

var describeStackFrame = function (element) {
  return '';
};

var validatePropertiesInDevelopment = function (type, props) {};

var pushCurrentDebugStack = function (stack) {};

var pushElementToDebugStack = function (element) {};

var popCurrentDebugStack = function () {};

var hasWarnedAboutUsingContextAsConsumer = false;

{
  ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

  validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, null);
  };

  describeStackFrame = function (element) {
    return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
  };

  pushCurrentDebugStack = function (stack) {
    currentDebugStacks.push(stack);

    if (currentDebugStacks.length === 1) {
      // We are entering a server renderer.
      // Remember the previous (e.g. client) global stack implementation.
      prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
      ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl;
    }
  };

  pushElementToDebugStack = function (element) {
    // For the innermost executing ReactDOMServer call,
    var stack = currentDebugStacks[currentDebugStacks.length - 1]; // Take the innermost executing frame (e.g. <Foo>),

    var frame = stack[stack.length - 1]; // and record that it has one more element associated with it.

    frame.debugElementStack.push(element); // We only need this because we tail-optimize single-element
    // children and directly handle them in an inner loop instead of
    // creating separate frames for them.
  };

  popCurrentDebugStack = function () {
    currentDebugStacks.pop();

    if (currentDebugStacks.length === 0) {
      // We are exiting the server renderer.
      // Restore the previous (e.g. client) global stack implementation.
      ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
      prevGetCurrentStackImpl = null;
    }
  };

  getCurrentServerStackImpl = function () {
    if (currentDebugStacks.length === 0) {
      // Nothing is currently rendering.
      return '';
    } // ReactDOMServer is reentrant so there may be multiple calls at the same time.
    // Take the frames from the innermost call which is the last in the array.


    var frames = currentDebugStacks[currentDebugStacks.length - 1];
    var stack = ''; // Go through every frame in the stack from the innermost one.

    for (var i = frames.length - 1; i >= 0; i--) {
      var frame = frames[i]; // Every frame might have more than one debug element stack entry associated with it.
      // This is because single-child nesting doesn't create materialized frames.
      // Instead it would push them through `pushElementToDebugStack()`.

      var debugElementStack = frame.debugElementStack;

      for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
        stack += describeStackFrame(debugElementStack[ii]);
      }
    }

    return stack;
  };
}

var didWarnDefaultInputValue = false;
var didWarnDefaultChecked = false;
var didWarnDefaultSelectValue = false;
var didWarnDefaultTextareaValue = false;
var didWarnInvalidOptionChildren = false;
var didWarnAboutNoopUpdateForComponent = {};
var didWarnAboutBadClass = {};
var didWarnAboutModulePatternComponent = {};
var didWarnAboutDeprecatedWillMount = {};
var didWarnAboutUndefinedDerivedState = {};
var didWarnAboutUninitializedState = {};
var valuePropNames = ['value', 'defaultValue'];
var newlineEatingTags = {
  listing: true,
  pre: true,
  textarea: true
}; // We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset

var validatedTagCache = {};

function validateDangerousTag(tag) {
  if (!validatedTagCache.hasOwnProperty(tag)) {
    if (!VALID_TAG_REGEX.test(tag)) {
      {
        throw Error( "Invalid tag: " + tag );
      }
    }

    validatedTagCache[tag] = true;
  }
}

var styleNameCache = {};

var processStyleName = function (styleName) {
  if (styleNameCache.hasOwnProperty(styleName)) {
    return styleNameCache[styleName];
  }

  var result = hyphenateStyleName(styleName);
  styleNameCache[styleName] = result;
  return result;
};

function createMarkupForStyles(styles) {
  var serialized = '';
  var delimiter = '';

  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }

    var isCustomProperty = styleName.indexOf('--') === 0;
    var styleValue = styles[styleName];

    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styleValue);
      }
    }

    if (styleValue != null) {
      serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ':';
      serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
      delimiter = ';';
    }
  }

  return serialized || null;
}

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && getComponentName(_constructor) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;

    if (didWarnAboutNoopUpdateForComponent[warningKey]) {
      return;
    }

    error('%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);

    didWarnAboutNoopUpdateForComponent[warningKey] = true;
  }
}

function shouldConstruct$1(Component) {
  return Component.prototype && Component.prototype.isReactComponent;
}

function getNonChildrenInnerMarkup(props) {
  var innerHTML = props.dangerouslySetInnerHTML;

  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      return innerHTML.__html;
    }
  } else {
    var content = props.children;

    if (typeof content === 'string' || typeof content === 'number') {
      return escapeTextForBrowser(content);
    }
  }

  return null;
}

function flattenTopLevelChildren(children) {
  if (!React.isValidElement(children)) {
    return toArray(children);
  }

  var element = children;

  if (element.type !== REACT_FRAGMENT_TYPE) {
    return [element];
  }

  var fragmentChildren = element.props.children;

  if (!React.isValidElement(fragmentChildren)) {
    return toArray(fragmentChildren);
  }

  var fragmentChildElement = fragmentChildren;
  return [fragmentChildElement];
}

function flattenOptionChildren(children) {
  if (children === undefined || children === null) {
    return children;
  }

  var content = ''; // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.

  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }

    content += child;

    {
      if (!didWarnInvalidOptionChildren && typeof child !== 'string' && typeof child !== 'number') {
        didWarnInvalidOptionChildren = true;

        error('Only strings and numbers are supported as <option> children.');
      }
    }
  });
  return content;
}

var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var STYLE = 'style';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null,
  suppressHydrationWarning: null
};

function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
  var ret = '<' + tagVerbatim;
  var isCustomComponent$1 = isCustomComponent(tagLowercase, props);

  for (var propKey in props) {
    if (!hasOwnProperty$2.call(props, propKey)) {
      continue;
    }

    var propValue = props[propKey];

    if (propValue == null) {
      continue;
    }

    if (propKey === STYLE) {
      propValue = createMarkupForStyles(propValue);
    }

    var markup = null;

    if (isCustomComponent$1) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        markup = createMarkupForCustomAttribute(propKey, propValue);
      }
    } else {
      markup = createMarkupForProperty(propKey, propValue);
    }

    if (markup) {
      ret += ' ' + markup;
    }
  } // For static pages, no need to put React ID and checksum. Saves lots of
  // bytes.


  if (makeStaticMarkup) {
    return ret;
  }

  if (isRootElement) {
    ret += ' ' + createMarkupForRoot();
  }

  return ret;
}

function validateRenderResult(child, type) {
  if (child === undefined) {
    {
      {
        throw Error( (getComponentName(type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null." );
      }
    }
  }
}

function resolve(child, context, threadID) {
  while (React.isValidElement(child)) {
    // Safe because we just checked it's an element.
    var element = child;
    var Component = element.type;

    {
      pushElementToDebugStack(element);
    }

    if (typeof Component !== 'function') {
      break;
    }

    processChild(element, Component);
  } // Extra closure so queue and replace can be captured properly


  function processChild(element, Component) {
    var isClass = shouldConstruct$1(Component);
    var publicContext = processContext(Component, context, threadID, isClass);
    var queue = [];
    var replace = false;
    var updater = {
      isMounted: function (publicInstance) {
        return false;
      },
      enqueueForceUpdate: function (publicInstance) {
        if (queue === null) {
          warnNoop(publicInstance, 'forceUpdate');
          return null;
        }
      },
      enqueueReplaceState: function (publicInstance, completeState) {
        replace = true;
        queue = [completeState];
      },
      enqueueSetState: function (publicInstance, currentPartialState) {
        if (queue === null) {
          warnNoop(publicInstance, 'setState');
          return null;
        }

        queue.push(currentPartialState);
      }
    };
    var inst;

    if (isClass) {
      inst = new Component(element.props, publicContext, updater);

      if (typeof Component.getDerivedStateFromProps === 'function') {
        {
          if (inst.state === null || inst.state === undefined) {
            var componentName = getComponentName(Component) || 'Unknown';

            if (!didWarnAboutUninitializedState[componentName]) {
              error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, inst.state === null ? 'null' : 'undefined', componentName);

              didWarnAboutUninitializedState[componentName] = true;
            }
          }
        }

        var partialState = Component.getDerivedStateFromProps.call(null, element.props, inst.state);

        {
          if (partialState === undefined) {
            var _componentName = getComponentName(Component) || 'Unknown';

            if (!didWarnAboutUndefinedDerivedState[_componentName]) {
              error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', _componentName);

              didWarnAboutUndefinedDerivedState[_componentName] = true;
            }
          }
        }

        if (partialState != null) {
          inst.state = _assign({}, inst.state, partialState);
        }
      }
    } else {
      {
        if (Component.prototype && typeof Component.prototype.render === 'function') {
          var _componentName2 = getComponentName(Component) || 'Unknown';

          if (!didWarnAboutBadClass[_componentName2]) {
            error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', _componentName2, _componentName2);

            didWarnAboutBadClass[_componentName2] = true;
          }
        }
      }

      var componentIdentity = {};
      prepareToUseHooks(componentIdentity);
      inst = Component(element.props, publicContext, updater);
      inst = finishHooks(Component, element.props, inst, publicContext);

      {
        // Support for module components is deprecated and is removed behind a flag.
        // Whether or not it would crash later, we want to show a good message in DEV first.
        if (inst != null && inst.render != null) {
          var _componentName3 = getComponentName(Component) || 'Unknown';

          if (!didWarnAboutModulePatternComponent[_componentName3]) {
            error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName3, _componentName3, _componentName3);

            didWarnAboutModulePatternComponent[_componentName3] = true;
          }
        }
      } // If the flag is on, everything is assumed to be a function component.
      // Otherwise, we also do the unfortunate dynamic checks.


      if ( inst == null || inst.render == null) {
        child = inst;
        validateRenderResult(child, Component);
        return;
      }
    }

    inst.props = element.props;
    inst.context = publicContext;
    inst.updater = updater;
    var initialState = inst.state;

    if (initialState === undefined) {
      inst.state = initialState = null;
    }

    if (typeof inst.UNSAFE_componentWillMount === 'function' || typeof inst.componentWillMount === 'function') {
      if (typeof inst.componentWillMount === 'function') {
        {
          if ( inst.componentWillMount.__suppressDeprecationWarning !== true) {
            var _componentName4 = getComponentName(Component) || 'Unknown';

            if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
              warn( // keep this warning in sync with ReactStrictModeWarning.js
              'componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code from componentWillMount to componentDidMount (preferred in most cases) ' + 'or the constructor.\n' + '\nPlease update the following components: %s', _componentName4);

              didWarnAboutDeprecatedWillMount[_componentName4] = true;
            }
          }
        } // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for any component with the new gDSFP.


        if (typeof Component.getDerivedStateFromProps !== 'function') {
          inst.componentWillMount();
        }
      }

      if (typeof inst.UNSAFE_componentWillMount === 'function' && typeof Component.getDerivedStateFromProps !== 'function') {
        // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for any component with the new gDSFP.
        inst.UNSAFE_componentWillMount();
      }

      if (queue.length) {
        var oldQueue = queue;
        var oldReplace = replace;
        queue = null;
        replace = false;

        if (oldReplace && oldQueue.length === 1) {
          inst.state = oldQueue[0];
        } else {
          var nextState = oldReplace ? oldQueue[0] : inst.state;
          var dontMutate = true;

          for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
            var partial = oldQueue[i];

            var _partialState = typeof partial === 'function' ? partial.call(inst, nextState, element.props, publicContext) : partial;

            if (_partialState != null) {
              if (dontMutate) {
                dontMutate = false;
                nextState = _assign({}, nextState, _partialState);
              } else {
                _assign(nextState, _partialState);
              }
            }
          }

          inst.state = nextState;
        }
      } else {
        queue = null;
      }
    }

    child = inst.render();

    {
      if (child === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        child = null;
      }
    }

    validateRenderResult(child, Component);
    var childContext;

    {
      if (typeof inst.getChildContext === 'function') {
        var _childContextTypes = Component.childContextTypes;

        if (typeof _childContextTypes === 'object') {
          childContext = inst.getChildContext();

          for (var contextKey in childContext) {
            if (!(contextKey in _childContextTypes)) {
              {
                throw Error( (getComponentName(Component) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes." );
              }
            }
          }
        } else {
          {
            error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(Component) || 'Unknown');
          }
        }
      }

      if (childContext) {
        context = _assign({}, context, childContext);
      }
    }
  }

  return {
    child: child,
    context: context
  };
}

var ReactDOMServerRenderer = /*#__PURE__*/function () {
  // TODO: type this more strictly:
  // DEV-only
  function ReactDOMServerRenderer(children, makeStaticMarkup, options) {
    var flatChildren = flattenTopLevelChildren(children);
    var topFrame = {
      type: null,
      // Assume all trees start in the HTML namespace (not totally true, but
      // this is what we did historically)
      domNamespace: Namespaces.html,
      children: flatChildren,
      childIndex: 0,
      context: emptyObject,
      footer: ''
    };

    {
      topFrame.debugElementStack = [];
    }

    this.threadID = allocThreadID();
    this.stack = [topFrame];
    this.exhausted = false;
    this.currentSelectValue = null;
    this.previousWasTextNode = false;
    this.makeStaticMarkup = makeStaticMarkup;
    this.suspenseDepth = 0; // Context (new API)

    this.contextIndex = -1;
    this.contextStack = [];
    this.contextValueStack = []; // useOpaqueIdentifier ID

    this.uniqueID = 0;
    this.identifierPrefix = options && options.identifierPrefix || '';

    {
      this.contextProviderStack = [];
    }
  }

  var _proto = ReactDOMServerRenderer.prototype;

  _proto.destroy = function destroy() {
    if (!this.exhausted) {
      this.exhausted = true;
      this.clearProviders();
      freeThreadID(this.threadID);
    }
  }
  /**
   * Note: We use just two stacks regardless of how many context providers you have.
   * Providers are always popped in the reverse order to how they were pushed
   * so we always know on the way down which provider you'll encounter next on the way up.
   * On the way down, we push the current provider, and its context value *before*
   * we mutated it, onto the stacks. Therefore, on the way up, we always know which
   * provider needs to be "restored" to which value.
   * https://github.com/facebook/react/pull/12985#issuecomment-396301248
   */
  ;

  _proto.pushProvider = function pushProvider(provider) {
    var index = ++this.contextIndex;
    var context = provider.type._context;
    var threadID = this.threadID;
    validateContextBounds(context, threadID);
    var previousValue = context[threadID]; // Remember which value to restore this context to on our way up.

    this.contextStack[index] = context;
    this.contextValueStack[index] = previousValue;

    {
      // Only used for push/pop mismatch warnings.
      this.contextProviderStack[index] = provider;
    } // Mutate the current value.


    context[threadID] = provider.props.value;
  };

  _proto.popProvider = function popProvider(provider) {
    var index = this.contextIndex;

    {
      if (index < 0 || provider !== this.contextProviderStack[index]) {
        error('Unexpected pop.');
      }
    }

    var context = this.contextStack[index];
    var previousValue = this.contextValueStack[index]; // "Hide" these null assignments from Flow by using `any`
    // because conceptually they are deletions--as long as we
    // promise to never access values beyond `this.contextIndex`.

    this.contextStack[index] = null;
    this.contextValueStack[index] = null;

    {
      this.contextProviderStack[index] = null;
    }

    this.contextIndex--; // Restore to the previous value we stored as we were walking down.
    // We've already verified that this context has been expanded to accommodate
    // this thread id, so we don't need to do it again.

    context[this.threadID] = previousValue;
  };

  _proto.clearProviders = function clearProviders() {
    // Restore any remaining providers on the stack to previous values
    for (var index = this.contextIndex; index >= 0; index--) {
      var context = this.contextStack[index];
      var previousValue = this.contextValueStack[index];
      context[this.threadID] = previousValue;
    }
  };

  _proto.read = function read(bytes) {
    if (this.exhausted) {
      return null;
    }

    var prevPartialRenderer = currentPartialRenderer;
    setCurrentPartialRenderer(this);
    var prevDispatcher = ReactCurrentDispatcher$1.current;
    ReactCurrentDispatcher$1.current = Dispatcher;

    try {
      // Markup generated within <Suspense> ends up buffered until we know
      // nothing in that boundary suspended
      var out = [''];
      var suspended = false;

      while (out[0].length < bytes) {
        if (this.stack.length === 0) {
          this.exhausted = true;
          freeThreadID(this.threadID);
          break;
        }

        var frame = this.stack[this.stack.length - 1];

        if (suspended || frame.childIndex >= frame.children.length) {
          var footer = frame.footer;

          if (footer !== '') {
            this.previousWasTextNode = false;
          }

          this.stack.pop();

          if (frame.type === 'select') {
            this.currentSelectValue = null;
          } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
            var provider = frame.type;
            this.popProvider(provider);
          } else if (frame.type === REACT_SUSPENSE_TYPE) {
            this.suspenseDepth--;
            var buffered = out.pop();

            if (suspended) {
              suspended = false; // If rendering was suspended at this boundary, render the fallbackFrame

              var fallbackFrame = frame.fallbackFrame;

              if (!fallbackFrame) {
                {
                  throw Error(true ? "ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue." : undefined);
                }
              }

              this.stack.push(fallbackFrame);
              out[this.suspenseDepth] += '<!--$!-->'; // Skip flushing output since we're switching to the fallback

              continue;
            } else {
              out[this.suspenseDepth] += buffered;
            }
          } // Flush output


          out[this.suspenseDepth] += footer;
          continue;
        }

        var child = frame.children[frame.childIndex++];
        var outBuffer = '';

        if (true) {
          pushCurrentDebugStack(this.stack); // We're starting work on this frame, so reset its inner stack.

          frame.debugElementStack.length = 0;
        }

        try {
          outBuffer += this.render(child, frame.context, frame.domNamespace);
        } catch (err) {
          if (err != null && typeof err.then === 'function') {
            if (enableSuspenseServerRenderer) {
              if (!(this.suspenseDepth > 0)) {
                {
                  throw Error(true ? "A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." : undefined);
                }
              }

              suspended = true;
            } else {
              if (true) {
                {
                  throw Error(true ? "ReactDOMServer does not yet support Suspense." : undefined);
                }
              }
            }
          } else {
            throw err;
          }
        } finally {
          if (true) {
            popCurrentDebugStack();
          }
        }

        if (out.length <= this.suspenseDepth) {
          out.push('');
        }

        out[this.suspenseDepth] += outBuffer;
      }

      return out[0];
    } finally {
      ReactCurrentDispatcher$1.current = prevDispatcher;
      setCurrentPartialRenderer(prevPartialRenderer);
      resetHooksState();
    }
  };

  _proto.render = function render(child, context, parentNamespace) {
    if (typeof child === 'string' || typeof child === 'number') {
      var text = '' + child;

      if (text === '') {
        return '';
      }

      if (this.makeStaticMarkup) {
        return escapeTextForBrowser(text);
      }

      if (this.previousWasTextNode) {
        return '<!-- -->' + escapeTextForBrowser(text);
      }

      this.previousWasTextNode = true;
      return escapeTextForBrowser(text);
    } else {
      var nextChild;

      var _resolve = resolve(child, context, this.threadID);

      nextChild = _resolve.child;
      context = _resolve.context;

      if (nextChild === null || nextChild === false) {
        return '';
      } else if (!React.isValidElement(nextChild)) {
        if (nextChild != null && nextChild.$$typeof != null) {
          // Catch unexpected special types early.
          var $$typeof = nextChild.$$typeof;

          if (!($$typeof !== REACT_PORTAL_TYPE)) {
            {
              throw Error( "Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render." );
            }
          } // Catch-all to prevent an infinite loop if React.Children.toArray() supports some new type.


          {
            {
              throw Error( "Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue." );
            }
          }
        }

        var nextChildren = toArray(nextChild);
        var frame = {
          type: null,
          domNamespace: parentNamespace,
          children: nextChildren,
          childIndex: 0,
          context: context,
          footer: ''
        };

        {
          frame.debugElementStack = [];
        }

        this.stack.push(frame);
        return '';
      } // Safe because we just checked it's an element.


      var nextElement = nextChild;
      var elementType = nextElement.type;

      if (typeof elementType === 'string') {
        return this.renderDOM(nextElement, context, parentNamespace);
      }

      switch (elementType) {
        // TODO: LegacyHidden acts the same as a fragment. This only works
        // because we currently assume that every instance of LegacyHidden is
        // accompanied by a host component wrapper. In the hidden mode, the host
        // component is given a `hidden` attribute, which ensures that the
        // initial HTML is not visible. To support the use of LegacyHidden as a
        // true fragment, without an extra DOM node, we would have to hide the
        // initial HTML in some other way.
        case REACT_LEGACY_HIDDEN_TYPE:
        case REACT_DEBUG_TRACING_MODE_TYPE:
        case REACT_STRICT_MODE_TYPE:
        case REACT_PROFILER_TYPE:
        case REACT_SUSPENSE_LIST_TYPE:
        case REACT_FRAGMENT_TYPE:
          {
            var _nextChildren = toArray(nextChild.props.children);

            var _frame = {
              type: null,
              domNamespace: parentNamespace,
              children: _nextChildren,
              childIndex: 0,
              context: context,
              footer: ''
            };

            {
              _frame.debugElementStack = [];
            }

            this.stack.push(_frame);
            return '';
          }

        case REACT_SUSPENSE_TYPE:
          {
            {
              {
                {
                  throw Error( "ReactDOMServer does not yet support Suspense." );
                }
              }
            }
          }
        // eslint-disable-next-line-no-fallthrough

        case REACT_SCOPE_TYPE:
          {

            {
              {
                throw Error( "ReactDOMServer does not yet support scope components." );
              }
            }
          }
      }

      if (typeof elementType === 'object' && elementType !== null) {
        switch (elementType.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            {
              var element = nextChild;

              var _nextChildren5;

              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              _nextChildren5 = elementType.render(element.props, element.ref);
              _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref);
              _nextChildren5 = toArray(_nextChildren5);
              var _frame5 = {
                type: null,
                domNamespace: parentNamespace,
                children: _nextChildren5,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame5.debugElementStack = [];
              }

              this.stack.push(_frame5);
              return '';
            }

          case REACT_MEMO_TYPE:
            {
              var _element = nextChild;
              var _nextChildren6 = [React.createElement(elementType.type, _assign({
                ref: _element.ref
              }, _element.props))];
              var _frame6 = {
                type: null,
                domNamespace: parentNamespace,
                children: _nextChildren6,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame6.debugElementStack = [];
              }

              this.stack.push(_frame6);
              return '';
            }

          case REACT_PROVIDER_TYPE:
            {
              var provider = nextChild;
              var nextProps = provider.props;

              var _nextChildren7 = toArray(nextProps.children);

              var _frame7 = {
                type: provider,
                domNamespace: parentNamespace,
                children: _nextChildren7,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame7.debugElementStack = [];
              }

              this.pushProvider(provider);
              this.stack.push(_frame7);
              return '';
            }

          case REACT_CONTEXT_TYPE:
            {
              var reactContext = nextChild.type; // The logic below for Context differs depending on PROD or DEV mode. In
              // DEV mode, we create a separate object for Context.Consumer that acts
              // like a proxy to Context. This proxy object adds unnecessary code in PROD
              // so we use the old behaviour (Context.Consumer references Context) to
              // reduce size and overhead. The separate object references context via
              // a property called "_context", which also gives us the ability to check
              // in DEV mode if this property exists or not and warn if it does not.

              {
                if (reactContext._context === undefined) {
                  // This may be because it's a Context (rather than a Consumer).
                  // Or it may be because it's older React where they're the same thing.
                  // We only want to warn if we're sure it's a new React.
                  if (reactContext !== reactContext.Consumer) {
                    if (!hasWarnedAboutUsingContextAsConsumer) {
                      hasWarnedAboutUsingContextAsConsumer = true;

                      error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                    }
                  }
                } else {
                  reactContext = reactContext._context;
                }
              }

              var _nextProps = nextChild.props;
              var threadID = this.threadID;
              validateContextBounds(reactContext, threadID);
              var nextValue = reactContext[threadID];

              var _nextChildren8 = toArray(_nextProps.children(nextValue));

              var _frame8 = {
                type: nextChild,
                domNamespace: parentNamespace,
                children: _nextChildren8,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame8.debugElementStack = [];
              }

              this.stack.push(_frame8);
              return '';
            }
          // eslint-disable-next-line-no-fallthrough

          case REACT_FUNDAMENTAL_TYPE:
            {

              {
                {
                  throw Error( "ReactDOMServer does not yet support the fundamental API." );
                }
              }
            }
          // eslint-disable-next-line-no-fallthrough

          case REACT_LAZY_TYPE:
            {
              var _element2 = nextChild;
              var lazyComponent = nextChild.type; // Attempt to initialize lazy component regardless of whether the
              // suspense server-side renderer is enabled so synchronously
              // resolved constructors are supported.

              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              var result = init(payload);
              var _nextChildren10 = [React.createElement(result, _assign({
                ref: _element2.ref
              }, _element2.props))];
              var _frame10 = {
                type: null,
                domNamespace: parentNamespace,
                children: _nextChildren10,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame10.debugElementStack = [];
              }

              this.stack.push(_frame10);
              return '';
            }
        }
      }

      var info = '';

      {
        var owner = nextElement._owner;

        if (elementType === undefined || typeof elementType === 'object' && elementType !== null && Object.keys(elementType).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
        }

        var ownerName = owner ? getComponentName(owner) : null;

        if (ownerName) {
          info += '\n\nCheck the render method of `' + ownerName + '`.';
        }
      }

      {
        {
          throw Error( "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info );
        }
      }
    }
  };

  _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
    var tag = element.type.toLowerCase();
    var namespace = parentNamespace;

    if (parentNamespace === Namespaces.html) {
      namespace = getIntrinsicNamespace(tag);
    }

    {
      if (namespace === Namespaces.html) {
        // Should this check be gated by parent namespace? Not sure we want to
        // allow <SVG> or <mATH>.
        if (tag !== element.type) {
          error('<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', element.type);
        }
      }
    }

    validateDangerousTag(tag);
    var props = element.props;

    if (tag === 'input') {
      {
        checkControlledValueProps('input', props);

        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
          error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', 'A component', props.type);

          didWarnDefaultChecked = true;
        }

        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
          error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', 'A component', props.type);

          didWarnDefaultInputValue = true;
        }
      }

      props = _assign({
        type: undefined
      }, props, {
        defaultChecked: undefined,
        defaultValue: undefined,
        value: props.value != null ? props.value : props.defaultValue,
        checked: props.checked != null ? props.checked : props.defaultChecked
      });
    } else if (tag === 'textarea') {
      {
        checkControlledValueProps('textarea', props);

        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
          error('Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');

          didWarnDefaultTextareaValue = true;
        }
      }

      var initialValue = props.value;

      if (initialValue == null) {
        var defaultValue = props.defaultValue; // TODO (yungsters): Remove support for children content in <textarea>.

        var textareaChildren = props.children;

        if (textareaChildren != null) {
          {
            error('Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
          }

          if (!(defaultValue == null)) {
            {
              throw Error( "If you supply `defaultValue` on a <textarea>, do not pass children." );
            }
          }

          if (Array.isArray(textareaChildren)) {
            if (!(textareaChildren.length <= 1)) {
              {
                throw Error( "<textarea> can only have at most one child." );
              }
            }

            textareaChildren = textareaChildren[0];
          }

          defaultValue = '' + textareaChildren;
        }

        if (defaultValue == null) {
          defaultValue = '';
        }

        initialValue = defaultValue;
      }

      props = _assign({}, props, {
        value: undefined,
        children: '' + initialValue
      });
    } else if (tag === 'select') {
      {
        checkControlledValueProps('select', props);

        for (var i = 0; i < valuePropNames.length; i++) {
          var propName = valuePropNames[i];

          if (props[propName] == null) {
            continue;
          }

          var isArray = Array.isArray(props[propName]);

          if (props.multiple && !isArray) {
            error('The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.', propName);
          } else if (!props.multiple && isArray) {
            error('The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.', propName);
          }
        }

        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
          error('Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');

          didWarnDefaultSelectValue = true;
        }
      }

      this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
      props = _assign({}, props, {
        value: undefined
      });
    } else if (tag === 'option') {
      var selected = null;
      var selectValue = this.currentSelectValue;
      var optionChildren = flattenOptionChildren(props.children);

      if (selectValue != null) {
        var value;

        if (props.value != null) {
          value = props.value + '';
        } else {
          value = optionChildren;
        }

        selected = false;

        if (Array.isArray(selectValue)) {
          // multiple
          for (var j = 0; j < selectValue.length; j++) {
            if ('' + selectValue[j] === value) {
              selected = true;
              break;
            }
          }
        } else {
          selected = '' + selectValue === value;
        }

        props = _assign({
          selected: undefined,
          children: undefined
        }, props, {
          selected: selected,
          children: optionChildren
        });
      }
    }

    {
      validatePropertiesInDevelopment(tag, props);
    }

    assertValidProps(tag, props);
    var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
    var footer = '';

    if (omittedCloseTags.hasOwnProperty(tag)) {
      out += '/>';
    } else {
      out += '>';
      footer = '</' + element.type + '>';
    }

    var children;
    var innerMarkup = getNonChildrenInnerMarkup(props);

    if (innerMarkup != null) {
      children = [];

      if (newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === '\n') {
        // text/html ignores the first character in these tags if it's a newline
        // Prefer to break application/xml over text/html (for now) by adding
        // a newline specifically to get eaten by the parser. (Alternately for
        // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
        // \r is normalized out by HTMLTextAreaElement#value.)
        // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
        // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
        // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
        // See: Parsing of "textarea" "listing" and "pre" elements
        //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
        out += '\n';
      }

      out += innerMarkup;
    } else {
      children = toArray(props.children);
    }

    var frame = {
      domNamespace: getChildNamespace(parentNamespace, element.type),
      type: tag,
      children: children,
      childIndex: 0,
      context: context,
      footer: footer
    };

    {
      frame.debugElementStack = [];
    }

    this.stack.push(frame);
    this.previousWasTextNode = false;
    return out;
  };

  return ReactDOMServerRenderer;
}();

/**
 * Render a ReactElement to its initial HTML. This should only be used on the
 * server.
 * See https://reactjs.org/docs/react-dom-server.html#rendertostring
 */

function renderToString(element, options) {
  var renderer = new ReactDOMServerRenderer(element, false, options);

  try {
    var markup = renderer.read(Infinity);
    return markup;
  } finally {
    renderer.destroy();
  }
}
/**
 * Similar to renderToString, except this doesn't create extra DOM attributes
 * such as data-react-id that React uses internally.
 * See https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup
 */

function renderToStaticMarkup(element, options) {
  var renderer = new ReactDOMServerRenderer(element, true, options);

  try {
    var markup = renderer.read(Infinity);
    return markup;
  } finally {
    renderer.destroy();
  }
}

function renderToNodeStream() {
  {
    {
      throw Error( "ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead." );
    }
  }
}

function renderToStaticNodeStream() {
  {
    {
      throw Error( "ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead." );
    }
  }
}

exports.renderToNodeStream = renderToNodeStream;
exports.renderToStaticMarkup = renderToStaticMarkup;
exports.renderToStaticNodeStream = renderToStaticNodeStream;
exports.renderToString = renderToString;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react-dom/server.browser.js":
/*!**************************************************!*\
  !*** ./node_modules/react-dom/server.browser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom-server.browser.development.js */ "./node_modules/react-dom/cjs/react-dom-server.browser.development.js");
}


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.1
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/requires-port/index.js":
/*!*********************************************!*\
  !*** ./node_modules/requires-port/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};


/***/ }),

/***/ "./node_modules/rosetta/dist/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/rosetta/dist/index.mjs ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var dlv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dlv */ "./node_modules/dlv/dist/dlv.umd.js");
/* harmony import */ var templite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! templite */ "./node_modules/templite/dist/templite.js");



/* harmony default export */ __webpack_exports__["default"] = (function (obj) {
	var locale='', tree = obj || {};

	return {
		set(lang, table) {
			tree[lang] = Object.assign(tree[lang] || {}, table);
		},

		locale(lang) {
			return (locale = lang || locale);
		},

		table(lang) {
			return tree[lang];
		},

		t(key, params, lang) {
			var val = dlv__WEBPACK_IMPORTED_MODULE_0__(tree[lang || locale], key, '');
			if (typeof val === 'function') return val(params);
			if (typeof val === 'string') return templite__WEBPACK_IMPORTED_MODULE_1__(val, params);
			return val;
		}
	};
});


/***/ }),

/***/ "./node_modules/style-attr/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/style-attr/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/*:: type Attr = { [key: string]: string | number } */
/*:: type Opts = { preserveNumbers: ?boolean } */

/*

style-attr
====

Very simple parsing and stringifying of style attributes.

`parse`
----

Convert a style attribute string to an object.

*/

/*:: declare function parse (raw: string, opts: ?Opts): Attr */
function parse(raw, opts) {
  opts = opts || {};

  var preserveNumbers = opts.preserveNumbers;
  var trim = function (s) {
    return s.trim();
  };
  var obj = {};

  getKeyValueChunks(raw).map(trim).filter(Boolean).forEach(function (item) {
    // split with `.indexOf` rather than `.split` because the value may also contain colons.
    var pos = item.indexOf(':');
    var key = item.substr(0, pos).trim();
    var val = item.substr(pos + 1).trim();
    if (preserveNumbers && isNumeric(val)) {
      val = Number(val);
    }

    obj[key] = val;
  });

  return obj;
}

/*

`isNumeric`
----

Check if a value is numeric.
Via: https://stackoverflow.com/a/1830844/9324

*/

/*:: declare function isNumeric (n: any): boolean */

function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

/*

`getKeyValueChunks`
----

Split a string into chunks matching `<key>: <value>`

*/
/*:: declare function getKeyValueChunks (raw: string): Array<string> */
function getKeyValueChunks(raw) {
  var chunks = [];
  var offset = 0;
  var sep = ';';
  var hasUnclosedUrl = /url\([^\)]+$/;
  var chunk = '';
  var nextSplit;
  while (offset < raw.length) {
    nextSplit = raw.indexOf(sep, offset);
    if (nextSplit === -1) {
      nextSplit = raw.length;
    }

    chunk += raw.substring(offset, nextSplit);

    // data URIs can contain semicolons, so make sure we get the whole thing
    if (hasUnclosedUrl.test(chunk)) {
      chunk += ';';
      offset = nextSplit + 1;
      continue;
    }

    chunks.push(chunk);
    chunk = '';
    offset = nextSplit + 1;
  }

  return chunks;
}

/*

`stringify`
----

Convert an object into an attribute string

*/
/*:: declare function stringify (obj: Attr): string */
function stringify(obj) {
  return Object.keys(obj).map(function (key) {
    return key + ':' + obj[key];
  }).join(';');
}

/*

`normalize`
----

Normalize an attribute string (eg. collapse duplicates)

*/
/*:: declare function normalize (str: string, opts: ?Opts): string */
function normalize(str, opts) {
  return stringify(parse(str, opts));
}

module.exports.parse = parse;
module.exports.stringify = stringify;
module.exports.normalize = normalize;

/***/ }),

/***/ "./node_modules/templite/dist/templite.js":
/*!************************************************!*\
  !*** ./node_modules/templite/dist/templite.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const RGX = /{{(.*?)}}/g;

module.exports = function (str, mix) {
	return str.replace(RGX, (x, key, y) => {
		x = 0;
		y = mix;
		key = key.trim().split('.');
		while (y && x < key.length) {
			y = y[key[x++]];
		}
		return y != null ? y : '';
	});
}


/***/ }),

/***/ "./node_modules/url-parse/index.js":
/*!*****************************************!*\
  !*** ./node_modules/url-parse/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var required = __webpack_require__(/*! requires-port */ "./node_modules/requires-port/index.js")
  , qs = __webpack_require__(/*! querystringify */ "./node_modules/querystringify/index.js")
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/Layout.tsx":
/*!************************!*\
  !*** ./src/Layout.tsx ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ "./node_modules/next/dist/next-server/lib/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var next_localization__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-localization */ "./node_modules/next-localization/dist/index.modern.js");
/* harmony import */ var lib_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib/util */ "./src/lib/util.ts");
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\Layout.tsx",
    _this = undefined,
    _s = $RefreshSig$(),
    _s2 = $RefreshSig$();







// Prefix public assets with a public URL to enable compatibility with Sitecore Experience Editor.
// If you're not supporting the Experience Editor, you can remove this.
var publicUrl = Object(lib_util__WEBPACK_IMPORTED_MODULE_5__["getPublicUrl"])(); // This is boilerplate navigation for sample purposes. Most apps should throw this away and use their own navigation implementation.
// Most apps may also wish to use GraphQL for their navigation construction; this sample does not simply to support disconnected mode.

var Navigation = function Navigation() {
  _s();

  var _useI18n = Object(next_localization__WEBPACK_IMPORTED_MODULE_4__["useI18n"])(),
      t = _useI18n.t;

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    className: "d-flex flex-column flex-md-row align-items-center p-3 px-md-4 mb-3 bg-white border-bottom",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h5", {
      className: "my-0 mr-md-auto font-weight-normal",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
        href: "/",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "text-dark",
          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("img", {
            src: "".concat(publicUrl, "/sc_logo.svg"),
            alt: "Sitecore"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 27,
            columnNumber: 13
          }, _this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 26,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 25,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("nav", {
      className: "my-2 my-md-0 mr-md-3",
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
        className: "p-2 text-dark",
        href: "https://jss.sitecore.com",
        target: "_blank",
        rel: "noopener noreferrer",
        children: t('Documentation')
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
        href: "/styleguide",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "p-2 text-dark",
          children: t('Styleguide')
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 41,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 40,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
        href: "/graphql",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
          className: "p-2 text-dark",
          children: t('GraphQL')
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 44,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 43,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 23,
    columnNumber: 5
  }, _this);
};

_s(Navigation, "82N5KF9nLzZ6+2WH7KIjzIXRkLw=", false, function () {
  return [next_localization__WEBPACK_IMPORTED_MODULE_4__["useI18n"]];
});

_c = Navigation;

var Layout = function Layout(_ref) {
  _s2();

  var _route$fields, _route$fields$pageTit;

  var context = _ref.context;

  var _useSitecoreContext = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_6__["useSitecoreContext"])({
    updatable: true
  }),
      updateSitecoreContext = _useSitecoreContext.updateSitecoreContext; // Update Sitecore Context if layoutData has changed (i.e. on client-side route change).
  // Note the context object type here matches the initial value in [[...path]].tsx.


  Object(react__WEBPACK_IMPORTED_MODULE_3__["useEffect"])(function () {
    updateSitecoreContext && updateSitecoreContext(context);
  }, [context]);
  var route = context.route;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_1___default.a, {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
        children: (route === null || route === void 0 ? void 0 : (_route$fields = route.fields) === null || _route$fields === void 0 ? void 0 : (_route$fields$pageTit = _route$fields.pageTitle) === null || _route$fields$pageTit === void 0 ? void 0 : _route$fields$pageTit.value) || 'Page'
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 69,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("link", {
        rel: "icon",
        href: "".concat(publicUrl, "/favicon.ico")
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 70,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 68,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_6__["VisitorIdentification"], {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 80,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(Navigation, {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 82,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "container",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_6__["Placeholder"], {
        name: "jss-main",
        rendering: route
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 86,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 85,
      columnNumber: 7
    }, _this)]
  }, void 0, true);
};

_s2(Layout, "KI2AVWTSgRtlqeIjt6WQ0ItRwMY=", false, function () {
  return [_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_6__["useSitecoreContext"]];
});

_c2 = Layout;
/* harmony default export */ __webpack_exports__["default"] = (Layout);

var _c, _c2;

$RefreshReg$(_c, "Navigation");
$RefreshReg$(_c2, "Layout");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/NotFound.tsx":
/*!**************************!*\
  !*** ./src/NotFound.tsx ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ "./node_modules/next/dist/next-server/lib/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\NotFound.tsx",
    _this = undefined;


/**
 * Rendered in case if we have 404 error
 */

var NotFound = function NotFound() {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_head__WEBPACK_IMPORTED_MODULE_1___default.a, {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("title", {
        children: "404: NotFound"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 9,
        columnNumber: 7
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 8,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      style: {
        padding: 10
      },
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h1", {
        children: "Page not found"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 12,
        columnNumber: 7
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        children: "This page does not exist."
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 13,
        columnNumber: 7
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
        href: "/",
        children: "Go to the Home page"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 14,
        columnNumber: 7
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 5
    }, _this)]
  }, void 0, true);
};

_c = NotFound;
/* harmony default export */ __webpack_exports__["default"] = (NotFound);

var _c;

$RefreshReg$(_c, "NotFound");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/ContentBlock.tsx":
/*!*****************************************!*\
  !*** ./src/components/ContentBlock.tsx ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\ContentBlock.tsx",
    _this = undefined;



/**
 * A simple Content Block component, with a heading and rich text block.
 * This is the most basic building block of a content site, and the most basic
 * JSS component that's useful.
 */
var ContentBlock = function ContentBlock(_ref) {
  var fields = _ref.fields;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["Text"], {
      tag: "h2",
      className: "display-4",
      field: fields.heading
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["RichText"], {
      className: "contentDescription",
      field: fields.content
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 5
    }, _this)]
  }, void 0, true);
};

_c = ContentBlock;
/* harmony default export */ __webpack_exports__["default"] = (ContentBlock);

var _c;

$RefreshReg$(_c, "ContentBlock");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/Hero.tsx":
/*!*********************************!*\
  !*** ./src/components/Hero.tsx ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");


var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\Hero.tsx",
    _this = undefined;



var Hero = function Hero(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
      children: "This is our hero component hallo"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h2", {
      children: ["Heading: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["Text"], {
        field: props.fields.heading
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 18
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("h3", {
      children: ["teaser: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["Text"], {
        field: props.fields.teaser
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 21,
        columnNumber: 17
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 5
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 13,
    columnNumber: 3
  }, _this);
};

_c = Hero;
/* harmony default export */ __webpack_exports__["default"] = (Hero);

var _c;

$RefreshReg$(_c, "Hero");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-Checkbox.tsx":
/*!******************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-Checkbox.tsx ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-Checkbox.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of a Checkbox (boolean) content field within JSS.
 */
var StyleguideFieldUsageCheckbox = function StyleguideFieldUsageCheckbox(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-checkbox",
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("ul", {
      children: [props.fields && props.fields.checkbox && props.fields.checkbox.value && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("li", {
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("code", {
          children: "checkbox"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 27,
          columnNumber: 11
        }, _this), " is true"]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 26,
        columnNumber: 9
      }, _this), !props.fields || !props.fields.checkbox || !props.fields.checkbox.value && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("li", {
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("code", {
          children: "checkbox"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 34,
          columnNumber: 13
        }, _this), " is false"]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 33,
        columnNumber: 11
      }, _this), Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["getFieldValue"])(props.fields, 'checkbox2', false) && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("li", {
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("code", {
          children: "checkbox2"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 39,
          columnNumber: 11
        }, _this), " is true"]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 38,
        columnNumber: 9
      }, _this), !Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["getFieldValue"])(props.fields, 'checkbox2', false) && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("li", {
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("code", {
          children: "checkbox2"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 44,
          columnNumber: 11
        }, _this), " is false"]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 43,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 5
    }, _this)
  }), void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 17,
    columnNumber: 3
  }, _this);
};

_c = StyleguideFieldUsageCheckbox;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageCheckbox);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageCheckbox");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-ContentList.tsx":
/*!*********************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-ContentList.tsx ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-ContentList.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of a Content List field type within JSS.
 * Content Lists are references to 0..n other content items.
 * In Sitecore terms, this maps by default to a Treelist field.
 */
var StyleguideFieldUsageContentList = function StyleguideFieldUsageContentList(props) {
  var _props$fields = props.fields,
      sharedContentList = _props$fields.sharedContentList,
      localContentList = _props$fields.localContentList;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-content-list",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("h5", {
      children: "Shared Content List"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 25,
      columnNumber: 7
    }, _this), sharedContentList && sharedContentList.map(function (listItem, index) {
      return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
          children: ["Field: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
            field: listItem.fields.textField
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 36,
            columnNumber: 22
          }, _this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 35,
          columnNumber: 13
        }, _this)
      }, "sharedListItem-".concat(index), false, {
        fileName: _jsxFileName,
        lineNumber: 33,
        columnNumber: 11
      }, _this);
    }), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("h5", {
      children: "Local Content List"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 41,
      columnNumber: 7
    }, _this), localContentList && localContentList.map(function (listItem, index) {
      return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
          children: ["Field: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
            field: listItem.fields.textField
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 47,
            columnNumber: 22
          }, _this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 46,
          columnNumber: 13
        }, _this)
      }, "localListItem-".concat(index), false, {
        fileName: _jsxFileName,
        lineNumber: 44,
        columnNumber: 11
      }, _this);
    })]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 24,
    columnNumber: 5
  }, _this);
};

_c = StyleguideFieldUsageContentList;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageContentList);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageContentList");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-Custom.tsx":
/*!****************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-Custom.tsx ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-Custom.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of a custom content field type within JSS.
 * See /sitecore/definitions/components/Styleguide-FieldUsage-Custom.sitecore.js
 * for the definition of the structure of the custom field. This code is just for display.
 */
var StyleguideFieldUsageCustom = function StyleguideFieldUsageCustom(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-custom",
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
      field: props.fields.customIntField
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 5
    }, _this)
  }), void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 18,
    columnNumber: 3
  }, _this);
};

_c = StyleguideFieldUsageCustom;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageCustom);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageCustom");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-Date.tsx":
/*!**************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-Date.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-Date.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of date and time content field types within JSS.
 */
var StyleguideFieldUsageDate = function StyleguideFieldUsageDate(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-date",
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("ul", {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("li", {
        children: ["Date helper: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["DateField"], {
          field: props.fields.date
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 21,
          columnNumber: 24
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("li", {
        children: ["Date helper (datetime): ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["DateField"], {
          field: props.fields.dateTime
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 24,
          columnNumber: 35
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 23,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("li", {
        children: ["UTC Date string:\xA0", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["DateField"], {
          field: props.fields.date,
          render: function render(date) {
            return date && date.toUTCString();
          }
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 32,
          columnNumber: 11
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 26,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("li", {
        children: ["Localized Date string (local timezone):\xA0", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["DateField"], {
          field: props.fields.date,
          render: function render(date) {
            return date && date.toLocaleDateString();
          }
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 36,
          columnNumber: 11
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 34,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("li", {
        children: ["Localized DateTime string (local timezone):\xA0", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["DateField"], {
          field: props.fields.dateTime,
          render: function render(date) {
            return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("em", {
              children: date && date.toLocaleString()
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 46,
              columnNumber: 31
            }, _this);
          }
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 44,
          columnNumber: 11
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 41,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 7
    }, _this)
  }), void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 18,
    columnNumber: 5
  }, _this);
};

_c = StyleguideFieldUsageDate;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageDate);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageDate");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-File.tsx":
/*!**************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-File.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-File.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of a File content field within JSS.
 * File types are stored within Sitecore's Media Library data, and can be edited.
 */
var StyleguideFieldUsageFile = function StyleguideFieldUsageFile(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-file",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["File"], {
      field: props.fields.file
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("br", {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["File"], {
      field: props.fields.file,
      target: "_blank",
      children: "Custom link body"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 5
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 17,
    columnNumber: 3
  }, _this);
};

_c = StyleguideFieldUsageFile;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageFile);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageFile");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-Image.tsx":
/*!***************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-Image.tsx ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-Image.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of an Image content field within JSS.
 * Image field data is uploaded into the Sitecore Media Library.
 */
var StyleguideFieldUsageImage = function StyleguideFieldUsageImage(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-image",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: "Plain image"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Image"], {
      media: props.fields.sample1
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: "Advanced image (not editable)"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Image"], {
      field: props.fields.sample2,
      editable: false,
      imageParams: {
        mw: 100,
        mh: 50
      },
      height: "50",
      width: "94",
      "data-sample": "other-attributes-pass-through"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: "Srcset responsive image"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 47,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Image"], {
      field: props.fields.sample2,
      srcSet: [{
        mw: 300
      }, {
        mw: 100
      }],
      sizes: "(min-width: 960px) 300px, 100px",
      className: "img-fluid"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 48,
      columnNumber: 5
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 18,
    columnNumber: 3
  }, _this);
};

_c = StyleguideFieldUsageImage;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageImage);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageImage");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-ItemLink.tsx":
/*!******************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-ItemLink.tsx ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-ItemLink.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of a Content Link content field within JSS.
 * Content links are a reference to a single other piece of content.
 */
var StyleguideFieldUsageItemLink = function StyleguideFieldUsageItemLink(props) {
  var _props$fields = props.fields,
      sharedItemLink = _props$fields.sharedItemLink,
      localItemLink = _props$fields.localItemLink;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-itemlink",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("h5", {
      children: "Shared Item Link"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 7
    }, _this), sharedItemLink && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
        children: ["Field: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
          field: sharedItemLink.fields.textField
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 30,
          columnNumber: 20
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 29,
        columnNumber: 11
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 9
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("h5", {
      children: "Local Item Link"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 35,
      columnNumber: 7
    }, _this), localItemLink && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
        children: ["Field: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
          field: localItemLink.fields.textField
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 39,
          columnNumber: 20
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 38,
        columnNumber: 11
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 9
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 21,
    columnNumber: 5
  }, _this);
};

_c = StyleguideFieldUsageItemLink;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageItemLink);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageItemLink");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-Link.tsx":
/*!**************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-Link.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-Link.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of a General Link (hyperlink) content field within JSS.
 */
var StyleguideFieldUsageLink = function StyleguideFieldUsageLink(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-link",
    children: ["External link:\xA0", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Link"], {
      field: props.fields.externalLink
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("br", {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 5
    }, _this), "Internal link:\xA0", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Link"], {
      field: props.fields.internalLink,
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("em", {
        children: "HTML"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 25,
        columnNumber: 7
      }, _this), " or other components can be used within link renderers, for example links to images."]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("br", {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 5
    }, _this), "Email link:\xA0", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Link"], {
      field: props.fields.emailLink
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("br", {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 5
    }, _this), "All possible content params link:\xA0", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Link"], {
      field: props.fields.paramsLink
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("br", {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 5
    }, _this), "The link component accepts params of its own:\xA0", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Link"], {
      field: props.fields.externalLink,
      showLinkTextWithChildrenPresent: true,
      className: "font-weight-bold",
      "data-otherattributes": "pass-through-to-anchor-tag"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 5
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 19,
    columnNumber: 3
  }, _this);
};

_c = StyleguideFieldUsageLink;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageLink);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageLink");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-Number.tsx":
/*!****************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-Number.tsx ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-Number.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of a Number (decimal) content field within JSS.
 */
var StyleguideFieldUsageText = function StyleguideFieldUsageText(props) {
  var fieldValue = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["getFieldValue"])(props.fields, 'sample');
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-number",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
      field: props.fields.sample
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: ["JS value type: ", typeof fieldValue, /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 26,
        columnNumber: 9
      }, _this), "JS value: ", fieldValue]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 7
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 19,
    columnNumber: 5
  }, _this);
};

_c = StyleguideFieldUsageText;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageText);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageText");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-RichText.tsx":
/*!******************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-RichText.tsx ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-RichText.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of a Rich Text (HTML) content field within JSS.
 */
var StyleguideFieldUsageRichText = function StyleguideFieldUsageRichText(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-richtext",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["RichText"], {
      field: props.fields.sample
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["RichText"], {
      field: props.fields.sample2,
      tag: "section",
      editable: false,
      className: "text-center",
      "data-sample": "other-attributes-pass-through"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 5
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 17,
    columnNumber: 3
  }, _this);
};

_c = StyleguideFieldUsageRichText;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageRichText);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageRichText");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/fields/Styleguide-FieldUsage-Text.tsx":
/*!**************************************************************!*\
  !*** ./src/components/fields/Styleguide-FieldUsage-Text.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\fields\\Styleguide-FieldUsage-Text.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates usage of a Text content field within JSS.
 * Text fields are HTML encoded by default.
 */
var StyleguideFieldUsageText = function StyleguideFieldUsageText(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-fieldusage-text",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
      field: props.fields.sample
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
      field: props.fields.sample2,
      tag: "section",
      editable: false,
      encode: false,
      className: "font-weight-bold",
      "data-sample": "other-attributes-pass-through"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
      children: ["Raw value (not editable): ", Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["getFieldValue"])(props.fields, 'sample')]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 5
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 18,
    columnNumber: 3
  }, _this);
};

_c = StyleguideFieldUsageText;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideFieldUsageText);

var _c;

$RefreshReg$(_c, "StyleguideFieldUsageText");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/graphql/GraphQL-ConnectedDemo.graphql":
/*!**************************************************************!*\
  !*** ./src/components/graphql/GraphQL-ConnectedDemo.graphql ***!
  \**************************************************************/
/*! exports provided: ItemSearchOperator, Ordering, ConnectedDemoQueryDocument */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemSearchOperator", function() { return ItemSearchOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ordering", function() { return Ordering; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectedDemoQueryDocument", function() { return ConnectedDemoQueryDocument; });
/* d5ba6dc49a4a61d4f9b8f1411d303e8ef44b3652
 * This file is automatically generated by graphql-let. */

/** All built-in and custom scalars, mapped to their actual values */

/** Represents a Sitecore item whose template is not included in the schema. If you receive results of this type, consider expanding your included templates. */

/** Represents a Sitecore item whose template is not included in the schema. If you receive results of this type, consider expanding your included templates. */

/** Represents a Sitecore item whose template is not included in the schema. If you receive results of this type, consider expanding your included templates. */

/** Represents a Sitecore item whose template is not included in the schema. If you receive results of this type, consider expanding your included templates. */

/** Represents a Sitecore item whose template is not included in the schema. If you receive results of this type, consider expanding your included templates. */

/** Represents a Sitecore item whose template is not included in the schema. If you receive results of this type, consider expanding your included templates. */

/** Represents a Sitecore item whose template is not included in the schema. If you receive results of this type, consider expanding your included templates. */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Tracking template (ID: {C275104F-F117-5C93-BFB0-F62329BFDA3E}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Tracking template (ID: {C275104F-F117-5C93-BFB0-F62329BFDA3E}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Tracking template (ID: {C275104F-F117-5C93-BFB0-F62329BFDA3E}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Tracking template (ID: {C275104F-F117-5C93-BFB0-F62329BFDA3E}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Tracking template (ID: {C275104F-F117-5C93-BFB0-F62329BFDA3E}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Tracking template (ID: {C275104F-F117-5C93-BFB0-F62329BFDA3E}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Tracking template (ID: {C275104F-F117-5C93-BFB0-F62329BFDA3E}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-SitecoreContext template (ID: {0BE23A45-588E-556C-988B-66B2729220E6}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-SitecoreContext template (ID: {0BE23A45-588E-556C-988B-66B2729220E6}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-SitecoreContext template (ID: {0BE23A45-588E-556C-988B-66B2729220E6}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-SitecoreContext template (ID: {0BE23A45-588E-556C-988B-66B2729220E6}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-SitecoreContext template (ID: {0BE23A45-588E-556C-988B-66B2729220E6}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-SitecoreContext template (ID: {0BE23A45-588E-556C-988B-66B2729220E6}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-SitecoreContext template (ID: {0BE23A45-588E-556C-988B-66B2729220E6}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Section template (ID: {FCD762A0-7538-5809-AABC-0291467E570A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Section template (ID: {FCD762A0-7538-5809-AABC-0291467E570A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Section template (ID: {FCD762A0-7538-5809-AABC-0291467E570A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Section template (ID: {FCD762A0-7538-5809-AABC-0291467E570A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Section template (ID: {FCD762A0-7538-5809-AABC-0291467E570A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Section template (ID: {FCD762A0-7538-5809-AABC-0291467E570A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Section template (ID: {FCD762A0-7538-5809-AABC-0291467E570A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-RouteFields template (ID: {8841AAA8-6806-5E86-A707-81E7968221C0}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-RouteFields template (ID: {8841AAA8-6806-5E86-A707-81E7968221C0}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-RouteFields template (ID: {8841AAA8-6806-5E86-A707-81E7968221C0}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-RouteFields template (ID: {8841AAA8-6806-5E86-A707-81E7968221C0}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-RouteFields template (ID: {8841AAA8-6806-5E86-A707-81E7968221C0}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-RouteFields template (ID: {8841AAA8-6806-5E86-A707-81E7968221C0}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-RouteFields template (ID: {8841AAA8-6806-5E86-A707-81E7968221C0}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Multilingual template (ID: {419DC164-AD7F-51F3-AFA1-1E9DA4B8299D}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Multilingual template (ID: {419DC164-AD7F-51F3-AFA1-1E9DA4B8299D}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Multilingual template (ID: {419DC164-AD7F-51F3-AFA1-1E9DA4B8299D}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Multilingual template (ID: {419DC164-AD7F-51F3-AFA1-1E9DA4B8299D}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Multilingual template (ID: {419DC164-AD7F-51F3-AFA1-1E9DA4B8299D}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Multilingual template (ID: {419DC164-AD7F-51F3-AFA1-1E9DA4B8299D}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Multilingual template (ID: {419DC164-AD7F-51F3-AFA1-1E9DA4B8299D}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs-Tab template (ID: {1B1A77FA-F358-5208-935F-D70744C4DA09}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs-Tab template (ID: {1B1A77FA-F358-5208-935F-D70744C4DA09}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs-Tab template (ID: {1B1A77FA-F358-5208-935F-D70744C4DA09}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs-Tab template (ID: {1B1A77FA-F358-5208-935F-D70744C4DA09}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs-Tab template (ID: {1B1A77FA-F358-5208-935F-D70744C4DA09}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs-Tab template (ID: {1B1A77FA-F358-5208-935F-D70744C4DA09}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs-Tab template (ID: {1B1A77FA-F358-5208-935F-D70744C4DA09}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs template (ID: {A59C7DBF-C994-5219-8DF3-96ED5C63E004}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs template (ID: {A59C7DBF-C994-5219-8DF3-96ED5C63E004}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs template (ID: {A59C7DBF-C994-5219-8DF3-96ED5C63E004}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs template (ID: {A59C7DBF-C994-5219-8DF3-96ED5C63E004}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs template (ID: {A59C7DBF-C994-5219-8DF3-96ED5C63E004}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs template (ID: {A59C7DBF-C994-5219-8DF3-96ED5C63E004}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Tabs template (ID: {A59C7DBF-C994-5219-8DF3-96ED5C63E004}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Reuse template (ID: {197A1915-CBBC-5689-B5BD-A6A13467F3E7}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Reuse template (ID: {197A1915-CBBC-5689-B5BD-A6A13467F3E7}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Reuse template (ID: {197A1915-CBBC-5689-B5BD-A6A13467F3E7}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Reuse template (ID: {197A1915-CBBC-5689-B5BD-A6A13467F3E7}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Reuse template (ID: {197A1915-CBBC-5689-B5BD-A6A13467F3E7}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Reuse template (ID: {197A1915-CBBC-5689-B5BD-A6A13467F3E7}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Layout-Reuse template (ID: {197A1915-CBBC-5689-B5BD-A6A13467F3E7}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ItemLink-Item-Template template (ID: {BDC33B20-0C9C-5D9B-B52C-4762FD3B59EF}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ItemLink-Item-Template template (ID: {BDC33B20-0C9C-5D9B-B52C-4762FD3B59EF}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ItemLink-Item-Template template (ID: {BDC33B20-0C9C-5D9B-B52C-4762FD3B59EF}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ItemLink-Item-Template template (ID: {BDC33B20-0C9C-5D9B-B52C-4762FD3B59EF}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ItemLink-Item-Template template (ID: {BDC33B20-0C9C-5D9B-B52C-4762FD3B59EF}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ItemLink-Item-Template template (ID: {BDC33B20-0C9C-5D9B-B52C-4762FD3B59EF}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ItemLink-Item-Template template (ID: {BDC33B20-0C9C-5D9B-B52C-4762FD3B59EF}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Text template (ID: {374C18F3-D247-56A0-B03A-421FCC4A76A2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Text template (ID: {374C18F3-D247-56A0-B03A-421FCC4A76A2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Text template (ID: {374C18F3-D247-56A0-B03A-421FCC4A76A2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Text template (ID: {374C18F3-D247-56A0-B03A-421FCC4A76A2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Text template (ID: {374C18F3-D247-56A0-B03A-421FCC4A76A2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Text template (ID: {374C18F3-D247-56A0-B03A-421FCC4A76A2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Text template (ID: {374C18F3-D247-56A0-B03A-421FCC4A76A2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-RichText template (ID: {2DCE113F-0717-5E83-A811-C66D9E375B6A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-RichText template (ID: {2DCE113F-0717-5E83-A811-C66D9E375B6A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-RichText template (ID: {2DCE113F-0717-5E83-A811-C66D9E375B6A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-RichText template (ID: {2DCE113F-0717-5E83-A811-C66D9E375B6A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-RichText template (ID: {2DCE113F-0717-5E83-A811-C66D9E375B6A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-RichText template (ID: {2DCE113F-0717-5E83-A811-C66D9E375B6A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-RichText template (ID: {2DCE113F-0717-5E83-A811-C66D9E375B6A}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Number template (ID: {6F72FB46-D13E-5B8F-92EF-2ABD7C5CE678}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Number template (ID: {6F72FB46-D13E-5B8F-92EF-2ABD7C5CE678}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Number template (ID: {6F72FB46-D13E-5B8F-92EF-2ABD7C5CE678}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Number template (ID: {6F72FB46-D13E-5B8F-92EF-2ABD7C5CE678}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Number template (ID: {6F72FB46-D13E-5B8F-92EF-2ABD7C5CE678}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Number template (ID: {6F72FB46-D13E-5B8F-92EF-2ABD7C5CE678}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Number template (ID: {6F72FB46-D13E-5B8F-92EF-2ABD7C5CE678}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Link template (ID: {C25F15D8-3DE9-53CA-ABEC-D60A27310324}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Link template (ID: {C25F15D8-3DE9-53CA-ABEC-D60A27310324}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Link template (ID: {C25F15D8-3DE9-53CA-ABEC-D60A27310324}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Link template (ID: {C25F15D8-3DE9-53CA-ABEC-D60A27310324}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Link template (ID: {C25F15D8-3DE9-53CA-ABEC-D60A27310324}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Link template (ID: {C25F15D8-3DE9-53CA-ABEC-D60A27310324}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Link template (ID: {C25F15D8-3DE9-53CA-ABEC-D60A27310324}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ItemLink template (ID: {6607F29C-F454-51E1-AFD0-DCB416ECA18B}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ItemLink template (ID: {6607F29C-F454-51E1-AFD0-DCB416ECA18B}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ItemLink template (ID: {6607F29C-F454-51E1-AFD0-DCB416ECA18B}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ItemLink template (ID: {6607F29C-F454-51E1-AFD0-DCB416ECA18B}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ItemLink template (ID: {6607F29C-F454-51E1-AFD0-DCB416ECA18B}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ItemLink template (ID: {6607F29C-F454-51E1-AFD0-DCB416ECA18B}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ItemLink template (ID: {6607F29C-F454-51E1-AFD0-DCB416ECA18B}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Image template (ID: {2E99E84B-ED7F-51EA-A903-E1E22EF13E9F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Image template (ID: {2E99E84B-ED7F-51EA-A903-E1E22EF13E9F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Image template (ID: {2E99E84B-ED7F-51EA-A903-E1E22EF13E9F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Image template (ID: {2E99E84B-ED7F-51EA-A903-E1E22EF13E9F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Image template (ID: {2E99E84B-ED7F-51EA-A903-E1E22EF13E9F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Image template (ID: {2E99E84B-ED7F-51EA-A903-E1E22EF13E9F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Image template (ID: {2E99E84B-ED7F-51EA-A903-E1E22EF13E9F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-File template (ID: {F4FEF933-8047-51B2-8A6C-202BD6A921A1}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-File template (ID: {F4FEF933-8047-51B2-8A6C-202BD6A921A1}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-File template (ID: {F4FEF933-8047-51B2-8A6C-202BD6A921A1}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-File template (ID: {F4FEF933-8047-51B2-8A6C-202BD6A921A1}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-File template (ID: {F4FEF933-8047-51B2-8A6C-202BD6A921A1}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-File template (ID: {F4FEF933-8047-51B2-8A6C-202BD6A921A1}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-File template (ID: {F4FEF933-8047-51B2-8A6C-202BD6A921A1}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Date template (ID: {C30852C0-4E80-5BDA-A435-F7A11A5F44DE}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Date template (ID: {C30852C0-4E80-5BDA-A435-F7A11A5F44DE}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Date template (ID: {C30852C0-4E80-5BDA-A435-F7A11A5F44DE}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Date template (ID: {C30852C0-4E80-5BDA-A435-F7A11A5F44DE}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Date template (ID: {C30852C0-4E80-5BDA-A435-F7A11A5F44DE}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Date template (ID: {C30852C0-4E80-5BDA-A435-F7A11A5F44DE}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Date template (ID: {C30852C0-4E80-5BDA-A435-F7A11A5F44DE}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Custom template (ID: {6A4B3E43-1023-5AF6-89E3-99137D7DB037}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Custom template (ID: {6A4B3E43-1023-5AF6-89E3-99137D7DB037}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Custom template (ID: {6A4B3E43-1023-5AF6-89E3-99137D7DB037}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Custom template (ID: {6A4B3E43-1023-5AF6-89E3-99137D7DB037}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Custom template (ID: {6A4B3E43-1023-5AF6-89E3-99137D7DB037}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Custom template (ID: {6A4B3E43-1023-5AF6-89E3-99137D7DB037}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Custom template (ID: {6A4B3E43-1023-5AF6-89E3-99137D7DB037}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ContentList template (ID: {FCFE9F7D-7DC3-527F-B0DD-6206F20ACC88}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ContentList template (ID: {FCFE9F7D-7DC3-527F-B0DD-6206F20ACC88}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ContentList template (ID: {FCFE9F7D-7DC3-527F-B0DD-6206F20ACC88}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ContentList template (ID: {FCFE9F7D-7DC3-527F-B0DD-6206F20ACC88}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ContentList template (ID: {FCFE9F7D-7DC3-527F-B0DD-6206F20ACC88}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ContentList template (ID: {FCFE9F7D-7DC3-527F-B0DD-6206F20ACC88}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-ContentList template (ID: {FCFE9F7D-7DC3-527F-B0DD-6206F20ACC88}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Checkbox template (ID: {93D8656F-A3BD-534D-BDD6-D2C55E6A1EF2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Checkbox template (ID: {93D8656F-A3BD-534D-BDD6-D2C55E6A1EF2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Checkbox template (ID: {93D8656F-A3BD-534D-BDD6-D2C55E6A1EF2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Checkbox template (ID: {93D8656F-A3BD-534D-BDD6-D2C55E6A1EF2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Checkbox template (ID: {93D8656F-A3BD-534D-BDD6-D2C55E6A1EF2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Checkbox template (ID: {93D8656F-A3BD-534D-BDD6-D2C55E6A1EF2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-FieldUsage-Checkbox template (ID: {93D8656F-A3BD-534D-BDD6-D2C55E6A1EF2}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Explanatory-Component template (ID: {127CFAA4-4689-536B-AF98-648DB1DC0FBE}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StyleguideExplanatoryComponent) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Explanatory-Component template (ID: {127CFAA4-4689-536B-AF98-648DB1DC0FBE}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StyleguideExplanatoryComponent) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Explanatory-Component template (ID: {127CFAA4-4689-536B-AF98-648DB1DC0FBE}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StyleguideExplanatoryComponent) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Explanatory-Component template (ID: {127CFAA4-4689-536B-AF98-648DB1DC0FBE}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StyleguideExplanatoryComponent) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Explanatory-Component template (ID: {127CFAA4-4689-536B-AF98-648DB1DC0FBE}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StyleguideExplanatoryComponent) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Explanatory-Component template (ID: {127CFAA4-4689-536B-AF98-648DB1DC0FBE}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StyleguideExplanatoryComponent) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Explanatory-Component template (ID: {127CFAA4-4689-536B-AF98-648DB1DC0FBE}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StyleguideExplanatoryComponent) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ContentList-Item-Template template (ID: {CDEC86DE-6617-58C2-94BE-07E95A0FC0EB}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ContentList-Item-Template template (ID: {CDEC86DE-6617-58C2-94BE-07E95A0FC0EB}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ContentList-Item-Template template (ID: {CDEC86DE-6617-58C2-94BE-07E95A0FC0EB}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ContentList-Item-Template template (ID: {CDEC86DE-6617-58C2-94BE-07E95A0FC0EB}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ContentList-Item-Template template (ID: {CDEC86DE-6617-58C2-94BE-07E95A0FC0EB}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ContentList-Item-Template template (ID: {CDEC86DE-6617-58C2-94BE-07E95A0FC0EB}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ContentList-Item-Template template (ID: {CDEC86DE-6617-58C2-94BE-07E95A0FC0EB}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams Rendering Parameters template (ID: {57F1C4D3-6494-5339-A7DD-C67586B5CE4F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams Rendering Parameters template (ID: {57F1C4D3-6494-5339-A7DD-C67586B5CE4F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams Rendering Parameters template (ID: {57F1C4D3-6494-5339-A7DD-C67586B5CE4F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams Rendering Parameters template (ID: {57F1C4D3-6494-5339-A7DD-C67586B5CE4F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams Rendering Parameters template (ID: {57F1C4D3-6494-5339-A7DD-C67586B5CE4F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams Rendering Parameters template (ID: {57F1C4D3-6494-5339-A7DD-C67586B5CE4F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams Rendering Parameters template (ID: {57F1C4D3-6494-5339-A7DD-C67586B5CE4F}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams template (ID: {428C6724-C112-5256-9457-B2D677E2AD99}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams template (ID: {428C6724-C112-5256-9457-B2D677E2AD99}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams template (ID: {428C6724-C112-5256-9457-B2D677E2AD99}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams template (ID: {428C6724-C112-5256-9457-B2D677E2AD99}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams template (ID: {428C6724-C112-5256-9457-B2D677E2AD99}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams template (ID: {428C6724-C112-5256-9457-B2D677E2AD99}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-ComponentParams template (ID: {428C6724-C112-5256-9457-B2D677E2AD99}). */

/** /sitecore/templates/System/Templates/Standard template template (ID: {1930BBEB-7805-471A-A3BE-4858AC7CF696}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StandardTemplate) for reliable querying. */

/** /sitecore/templates/System/Templates/Standard template template (ID: {1930BBEB-7805-471A-A3BE-4858AC7CF696}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StandardTemplate) for reliable querying. */

/** /sitecore/templates/System/Templates/Standard template template (ID: {1930BBEB-7805-471A-A3BE-4858AC7CF696}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StandardTemplate) for reliable querying. */

/** /sitecore/templates/System/Templates/Standard template template (ID: {1930BBEB-7805-471A-A3BE-4858AC7CF696}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StandardTemplate) for reliable querying. */

/** /sitecore/templates/System/Templates/Standard template template (ID: {1930BBEB-7805-471A-A3BE-4858AC7CF696}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StandardTemplate) for reliable querying. */

/** /sitecore/templates/System/Templates/Standard template template (ID: {1930BBEB-7805-471A-A3BE-4858AC7CF696}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StandardTemplate) for reliable querying. */

/** /sitecore/templates/System/Templates/Standard template template (ID: {1930BBEB-7805-471A-A3BE-4858AC7CF696}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. StandardTemplate) for reliable querying. */

/** /sitecore/templates/Foundation/JavaScript Services/Route template (ID: {B36BA9FD-0DC0-49C8-BEA2-E55D70E6AF28}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. Route) for reliable querying. */

/** /sitecore/templates/Foundation/JavaScript Services/Route template (ID: {B36BA9FD-0DC0-49C8-BEA2-E55D70E6AF28}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. Route) for reliable querying. */

/** /sitecore/templates/Foundation/JavaScript Services/Route template (ID: {B36BA9FD-0DC0-49C8-BEA2-E55D70E6AF28}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. Route) for reliable querying. */

/** /sitecore/templates/Foundation/JavaScript Services/Route template (ID: {B36BA9FD-0DC0-49C8-BEA2-E55D70E6AF28}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. Route) for reliable querying. */

/** /sitecore/templates/Foundation/JavaScript Services/Route template (ID: {B36BA9FD-0DC0-49C8-BEA2-E55D70E6AF28}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. Route) for reliable querying. */

/** /sitecore/templates/Foundation/JavaScript Services/Route template (ID: {B36BA9FD-0DC0-49C8-BEA2-E55D70E6AF28}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. Route) for reliable querying. */

/** /sitecore/templates/Foundation/JavaScript Services/Route template (ID: {B36BA9FD-0DC0-49C8-BEA2-E55D70E6AF28}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. Route) for reliable querying. */

/** /sitecore/templates/Foundation/JavaScript Services/Render Engine Type template (ID: {7FEC3963-0AC6-4743-B02C-35E6971300ED}). */

/** /sitecore/templates/Foundation/JavaScript Services/Render Engine Type template (ID: {7FEC3963-0AC6-4743-B02C-35E6971300ED}). */

/** /sitecore/templates/Foundation/JavaScript Services/Render Engine Type template (ID: {7FEC3963-0AC6-4743-B02C-35E6971300ED}). */

/** /sitecore/templates/Foundation/JavaScript Services/Render Engine Type template (ID: {7FEC3963-0AC6-4743-B02C-35E6971300ED}). */

/** /sitecore/templates/Foundation/JavaScript Services/Render Engine Type template (ID: {7FEC3963-0AC6-4743-B02C-35E6971300ED}). */

/** /sitecore/templates/Foundation/JavaScript Services/Render Engine Type template (ID: {7FEC3963-0AC6-4743-B02C-35E6971300ED}). */

/** /sitecore/templates/Foundation/JavaScript Services/Render Engine Type template (ID: {7FEC3963-0AC6-4743-B02C-35E6971300ED}). */

/** /sitecore/templates/Foundation/JavaScript Services/Json Rendering template (ID: {04646A89-996F-4EE7-878A-FFDBF1F0EF0D}). */

/** /sitecore/templates/Foundation/JavaScript Services/Json Rendering template (ID: {04646A89-996F-4EE7-878A-FFDBF1F0EF0D}). */

/** /sitecore/templates/Foundation/JavaScript Services/Json Rendering template (ID: {04646A89-996F-4EE7-878A-FFDBF1F0EF0D}). */

/** /sitecore/templates/Foundation/JavaScript Services/Json Rendering template (ID: {04646A89-996F-4EE7-878A-FFDBF1F0EF0D}). */

/** /sitecore/templates/Foundation/JavaScript Services/Json Rendering template (ID: {04646A89-996F-4EE7-878A-FFDBF1F0EF0D}). */

/** /sitecore/templates/Foundation/JavaScript Services/Json Rendering template (ID: {04646A89-996F-4EE7-878A-FFDBF1F0EF0D}). */

/** /sitecore/templates/Foundation/JavaScript Services/Json Rendering template (ID: {04646A89-996F-4EE7-878A-FFDBF1F0EF0D}). */

/** /sitecore/templates/Foundation/JavaScript Services/JavaScript Rendering template (ID: {B1C80C94-792D-44DA-861E-557C6E1915F2}). */

/** /sitecore/templates/Foundation/JavaScript Services/JavaScript Rendering template (ID: {B1C80C94-792D-44DA-861E-557C6E1915F2}). */

/** /sitecore/templates/Foundation/JavaScript Services/JavaScript Rendering template (ID: {B1C80C94-792D-44DA-861E-557C6E1915F2}). */

/** /sitecore/templates/Foundation/JavaScript Services/JavaScript Rendering template (ID: {B1C80C94-792D-44DA-861E-557C6E1915F2}). */

/** /sitecore/templates/Foundation/JavaScript Services/JavaScript Rendering template (ID: {B1C80C94-792D-44DA-861E-557C6E1915F2}). */

/** /sitecore/templates/Foundation/JavaScript Services/JavaScript Rendering template (ID: {B1C80C94-792D-44DA-861E-557C6E1915F2}). */

/** /sitecore/templates/Foundation/JavaScript Services/JavaScript Rendering template (ID: {B1C80C94-792D-44DA-861E-557C6E1915F2}). */

/** /sitecore/templates/Foundation/JavaScript Services/JSS Layout template (ID: {35C61E90-47DD-43DD-83A8-D1C4D5119720}). */

/** /sitecore/templates/Foundation/JavaScript Services/JSS Layout template (ID: {35C61E90-47DD-43DD-83A8-D1C4D5119720}). */

/** /sitecore/templates/Foundation/JavaScript Services/JSS Layout template (ID: {35C61E90-47DD-43DD-83A8-D1C4D5119720}). */

/** /sitecore/templates/Foundation/JavaScript Services/JSS Layout template (ID: {35C61E90-47DD-43DD-83A8-D1C4D5119720}). */

/** /sitecore/templates/Foundation/JavaScript Services/JSS Layout template (ID: {35C61E90-47DD-43DD-83A8-D1C4D5119720}). */

/** /sitecore/templates/Foundation/JavaScript Services/JSS Layout template (ID: {35C61E90-47DD-43DD-83A8-D1C4D5119720}). */

/** /sitecore/templates/Foundation/JavaScript Services/JSS Layout template (ID: {35C61E90-47DD-43DD-83A8-D1C4D5119720}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-IntegratedDemo template (ID: {A912A721-7F5E-5E54-AA0E-BBB1964919AC}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-IntegratedDemo template (ID: {A912A721-7F5E-5E54-AA0E-BBB1964919AC}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-IntegratedDemo template (ID: {A912A721-7F5E-5E54-AA0E-BBB1964919AC}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-IntegratedDemo template (ID: {A912A721-7F5E-5E54-AA0E-BBB1964919AC}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-IntegratedDemo template (ID: {A912A721-7F5E-5E54-AA0E-BBB1964919AC}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-IntegratedDemo template (ID: {A912A721-7F5E-5E54-AA0E-BBB1964919AC}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-IntegratedDemo template (ID: {A912A721-7F5E-5E54-AA0E-BBB1964919AC}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-ConnectedDemo template (ID: {8E2A4EA1-C8F5-56E6-B097-E008C994D953}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-ConnectedDemo template (ID: {8E2A4EA1-C8F5-56E6-B097-E008C994D953}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-ConnectedDemo template (ID: {8E2A4EA1-C8F5-56E6-B097-E008C994D953}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-ConnectedDemo template (ID: {8E2A4EA1-C8F5-56E6-B097-E008C994D953}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-ConnectedDemo template (ID: {8E2A4EA1-C8F5-56E6-B097-E008C994D953}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-ConnectedDemo template (ID: {8E2A4EA1-C8F5-56E6-B097-E008C994D953}). */

/** /sitecore/templates/Project/JssNextWeb/GraphQL-ConnectedDemo template (ID: {8E2A4EA1-C8F5-56E6-B097-E008C994D953}). */

/** /sitecore/templates/Project/JssNextWeb/ExampleCustomRouteType template (ID: {0747C353-0A7D-5CAA-961E-431AB3579863}). */

/** /sitecore/templates/Project/JssNextWeb/ExampleCustomRouteType template (ID: {0747C353-0A7D-5CAA-961E-431AB3579863}). */

/** /sitecore/templates/Project/JssNextWeb/ExampleCustomRouteType template (ID: {0747C353-0A7D-5CAA-961E-431AB3579863}). */

/** /sitecore/templates/Project/JssNextWeb/ExampleCustomRouteType template (ID: {0747C353-0A7D-5CAA-961E-431AB3579863}). */

/** /sitecore/templates/Project/JssNextWeb/ExampleCustomRouteType template (ID: {0747C353-0A7D-5CAA-961E-431AB3579863}). */

/** /sitecore/templates/Project/JssNextWeb/ExampleCustomRouteType template (ID: {0747C353-0A7D-5CAA-961E-431AB3579863}). */

/** /sitecore/templates/Project/JssNextWeb/ExampleCustomRouteType template (ID: {0747C353-0A7D-5CAA-961E-431AB3579863}). */

/** /sitecore/templates/Project/JssNextWeb/ContentBlock template (ID: {FF17DDD8-7D5E-5062-A608-B34AA34432EA}). */

/** /sitecore/templates/Project/JssNextWeb/ContentBlock template (ID: {FF17DDD8-7D5E-5062-A608-B34AA34432EA}). */

/** /sitecore/templates/Project/JssNextWeb/ContentBlock template (ID: {FF17DDD8-7D5E-5062-A608-B34AA34432EA}). */

/** /sitecore/templates/Project/JssNextWeb/ContentBlock template (ID: {FF17DDD8-7D5E-5062-A608-B34AA34432EA}). */

/** /sitecore/templates/Project/JssNextWeb/ContentBlock template (ID: {FF17DDD8-7D5E-5062-A608-B34AA34432EA}). */

/** /sitecore/templates/Project/JssNextWeb/ContentBlock template (ID: {FF17DDD8-7D5E-5062-A608-B34AA34432EA}). */

/** /sitecore/templates/Project/JssNextWeb/ContentBlock template (ID: {FF17DDD8-7D5E-5062-A608-B34AA34432EA}). */

/** /sitecore/templates/Project/JssNextWeb/App Route template (ID: {787584C0-A057-5876-9836-F8B3708F0CAF}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. AppRoute) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/App Route template (ID: {787584C0-A057-5876-9836-F8B3708F0CAF}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. AppRoute) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/App Route template (ID: {787584C0-A057-5876-9836-F8B3708F0CAF}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. AppRoute) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/App Route template (ID: {787584C0-A057-5876-9836-F8B3708F0CAF}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. AppRoute) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/App Route template (ID: {787584C0-A057-5876-9836-F8B3708F0CAF}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. AppRoute) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/App Route template (ID: {787584C0-A057-5876-9836-F8B3708F0CAF}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. AppRoute) for reliable querying. */

/** /sitecore/templates/Project/JssNextWeb/App Route template (ID: {787584C0-A057-5876-9836-F8B3708F0CAF}). NOTE: This is a concrete type. Favor using interfaces instead of this type (e.g. AppRoute) for reliable querying. */

/** /sitecore/templates/Foundation/JavaScript Services/App template (ID: {061CBA15-5474-4B91-8A06-17903B102B82}). */

/** /sitecore/templates/Foundation/JavaScript Services/App template (ID: {061CBA15-5474-4B91-8A06-17903B102B82}). */

/** /sitecore/templates/Foundation/JavaScript Services/App template (ID: {061CBA15-5474-4B91-8A06-17903B102B82}). */

/** /sitecore/templates/Foundation/JavaScript Services/App template (ID: {061CBA15-5474-4B91-8A06-17903B102B82}). */

/** /sitecore/templates/Foundation/JavaScript Services/App template (ID: {061CBA15-5474-4B91-8A06-17903B102B82}). */

/** /sitecore/templates/Foundation/JavaScript Services/App template (ID: {061CBA15-5474-4B91-8A06-17903B102B82}). */

/** /sitecore/templates/Foundation/JavaScript Services/App template (ID: {061CBA15-5474-4B91-8A06-17903B102B82}). */

/** /sitecore/templates/Project/JssNextWeb/Styleguide-Explanatory-Component template (ID: {127CFAA4-4689-536B-AF98-648DB1DC0FBE}). */

/** /sitecore/templates/System/Layout/Sections/Rendering Options template (ID: {D1592226-3898-4CE2-B190-090FD5F84A4C}). */

/** /sitecore/templates/System/Layout/Layout template (ID: {3A45A723-64EE-4919-9D41-02FD40FD1466}). */

/** /sitecore/templates/System/Layout/Sections/Caching template (ID: {E8D2DD19-1347-4562-AE3F-310DC0B21A6C}). */

/** /sitecore/templates/Project/JssNextWeb/App Route template (ID: {787584C0-A057-5876-9836-F8B3708F0CAF}). Also implements Route. */
var ItemSearchOperator;

(function (ItemSearchOperator) {
  ItemSearchOperator["Eq"] = "EQ";
  ItemSearchOperator["Contains"] = "CONTAINS";
  ItemSearchOperator["Neq"] = "NEQ";
  ItemSearchOperator["Ncontains"] = "NCONTAINS";
})(ItemSearchOperator || (ItemSearchOperator = {}));

var Ordering;

(function (Ordering) {
  Ordering["Asc"] = "ASC";
  Ordering["Desc"] = "DESC";
})(Ordering || (Ordering = {}));

var ConnectedDemoQueryDocument = {
  "kind": "Document",
  "definitions": [{
    "kind": "OperationDefinition",
    "operation": "query",
    "name": {
      "kind": "Name",
      "value": "ConnectedDemoQuery"
    },
    "variableDefinitions": [{
      "kind": "VariableDefinition",
      "variable": {
        "kind": "Variable",
        "name": {
          "kind": "Name",
          "value": "datasource"
        }
      },
      "type": {
        "kind": "NonNullType",
        "type": {
          "kind": "NamedType",
          "name": {
            "kind": "Name",
            "value": "String"
          }
        }
      }
    }, {
      "kind": "VariableDefinition",
      "variable": {
        "kind": "Variable",
        "name": {
          "kind": "Name",
          "value": "contextItem"
        }
      },
      "type": {
        "kind": "NonNullType",
        "type": {
          "kind": "NamedType",
          "name": {
            "kind": "Name",
            "value": "String"
          }
        }
      }
    }, {
      "kind": "VariableDefinition",
      "variable": {
        "kind": "Variable",
        "name": {
          "kind": "Name",
          "value": "language"
        }
      },
      "type": {
        "kind": "NonNullType",
        "type": {
          "kind": "NamedType",
          "name": {
            "kind": "Name",
            "value": "String"
          }
        }
      }
    }],
    "selectionSet": {
      "kind": "SelectionSet",
      "selections": [{
        "kind": "Field",
        "alias": {
          "kind": "Name",
          "value": "datasource"
        },
        "name": {
          "kind": "Name",
          "value": "item"
        },
        "arguments": [{
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "path"
          },
          "value": {
            "kind": "Variable",
            "name": {
              "kind": "Name",
              "value": "datasource"
            }
          }
        }, {
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "language"
          },
          "value": {
            "kind": "Variable",
            "name": {
              "kind": "Name",
              "value": "language"
            }
          }
        }],
        "selectionSet": {
          "kind": "SelectionSet",
          "selections": [{
            "kind": "Field",
            "name": {
              "kind": "Name",
              "value": "id"
            }
          }, {
            "kind": "Field",
            "name": {
              "kind": "Name",
              "value": "name"
            }
          }, {
            "kind": "InlineFragment",
            "typeCondition": {
              "kind": "NamedType",
              "name": {
                "kind": "Name",
                "value": "GraphQLConnectedDemo"
              }
            },
            "selectionSet": {
              "kind": "SelectionSet",
              "selections": [{
                "kind": "Field",
                "name": {
                  "kind": "Name",
                  "value": "sample1"
                },
                "selectionSet": {
                  "kind": "SelectionSet",
                  "selections": [{
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "jsonValue"
                    }
                  }, {
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "value"
                    }
                  }]
                }
              }, {
                "kind": "Field",
                "name": {
                  "kind": "Name",
                  "value": "sample2"
                },
                "selectionSet": {
                  "kind": "SelectionSet",
                  "selections": [{
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "jsonValue"
                    }
                  }, {
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "text"
                    }
                  }, {
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "target"
                    }
                  }, {
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "url"
                    }
                  }, {
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "definition"
                    },
                    "selectionSet": {
                      "kind": "SelectionSet",
                      "selections": [{
                        "kind": "Field",
                        "name": {
                          "kind": "Name",
                          "value": "type"
                        }
                      }, {
                        "kind": "Field",
                        "name": {
                          "kind": "Name",
                          "value": "shared"
                        }
                      }]
                    }
                  }]
                }
              }]
            }
          }]
        }
      }, {
        "kind": "Field",
        "alias": {
          "kind": "Name",
          "value": "contextItem"
        },
        "name": {
          "kind": "Name",
          "value": "item"
        },
        "arguments": [{
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "path"
          },
          "value": {
            "kind": "Variable",
            "name": {
              "kind": "Name",
              "value": "contextItem"
            }
          }
        }, {
          "kind": "Argument",
          "name": {
            "kind": "Name",
            "value": "language"
          },
          "value": {
            "kind": "Variable",
            "name": {
              "kind": "Name",
              "value": "language"
            }
          }
        }],
        "selectionSet": {
          "kind": "SelectionSet",
          "selections": [{
            "kind": "Field",
            "name": {
              "kind": "Name",
              "value": "id"
            }
          }, {
            "kind": "InlineFragment",
            "typeCondition": {
              "kind": "NamedType",
              "name": {
                "kind": "Name",
                "value": "AppRoute"
              }
            },
            "selectionSet": {
              "kind": "SelectionSet",
              "selections": [{
                "kind": "Field",
                "name": {
                  "kind": "Name",
                  "value": "pageTitle"
                },
                "selectionSet": {
                  "kind": "SelectionSet",
                  "selections": [{
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "value"
                    }
                  }]
                }
              }]
            }
          }, {
            "kind": "Field",
            "name": {
              "kind": "Name",
              "value": "children"
            },
            "arguments": [{
              "kind": "Argument",
              "name": {
                "kind": "Name",
                "value": "hasLayout"
              },
              "value": {
                "kind": "BooleanValue",
                "value": true
              }
            }],
            "selectionSet": {
              "kind": "SelectionSet",
              "selections": [{
                "kind": "Field",
                "name": {
                  "kind": "Name",
                  "value": "results"
                },
                "selectionSet": {
                  "kind": "SelectionSet",
                  "selections": [{
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "id"
                    }
                  }, {
                    "kind": "InlineFragment",
                    "typeCondition": {
                      "kind": "NamedType",
                      "name": {
                        "kind": "Name",
                        "value": "AppRoute"
                      }
                    },
                    "selectionSet": {
                      "kind": "SelectionSet",
                      "selections": [{
                        "kind": "Field",
                        "name": {
                          "kind": "Name",
                          "value": "pageTitle"
                        },
                        "selectionSet": {
                          "kind": "SelectionSet",
                          "selections": [{
                            "kind": "Field",
                            "name": {
                              "kind": "Name",
                              "value": "jsonValue"
                            }
                          }, {
                            "kind": "Field",
                            "name": {
                              "kind": "Name",
                              "value": "value"
                            }
                          }]
                        }
                      }]
                    }
                  }, {
                    "kind": "Field",
                    "name": {
                      "kind": "Name",
                      "value": "url"
                    },
                    "selectionSet": {
                      "kind": "SelectionSet",
                      "selections": [{
                        "kind": "Field",
                        "name": {
                          "kind": "Name",
                          "value": "path"
                        }
                      }]
                    }
                  }]
                }
              }]
            }
          }]
        }
      }]
    }
  }]
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/graphql/GraphQL-ConnectedDemo.tsx":
/*!**********************************************************!*\
  !*** ./src/components/graphql/GraphQL-ConnectedDemo.tsx ***!
  \**********************************************************/
/*! exports provided: getStaticProps, getServerSideProps, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStaticProps", function() { return getStaticProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getServerSideProps", function() { return getServerSideProps; });
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/regenerator */ "./node_modules/next/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _GraphQL_ConnectedDemo_graphql__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GraphQL-ConnectedDemo.graphql */ "./src/components/graphql/GraphQL-ConnectedDemo.graphql");
/* harmony import */ var temp_config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! temp/config */ "./src/temp/config.js");
/* harmony import */ var temp_config__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(temp_config__WEBPACK_IMPORTED_MODULE_7__);




var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\graphql\\GraphQL-ConnectedDemo.tsx",
    _this = undefined,
    _s = $RefreshSig$();







var GraphQLConnectedDemo = function GraphQLConnectedDemo(props) {
  _s();

  var _data$datasource$samp, _data$datasource$samp2, _data$datasource$samp3, _data$datasource$samp4, _data$datasource$samp5, _data$datasource$samp6, _data$datasource$samp7, _data$datasource$samp8, _data$datasource$samp9, _data$datasource$samp10, _data$contextItem$pag;

  var data = props.rendering.uid ? Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__["useComponentProps"])(props.rendering.uid) : undefined;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("div", {
    "data-e2e-id": "graphql-connected",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("h2", {
      children: "GraphQL Connected Demo"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 35,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("p", {
      children: ["Connected GraphQL executes GraphQL queries directly against the Sitecore GraphQL endpoint. This example runs the query server-side using component-level ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("code", {
        children: "getStaticProps"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 71
      }, _this), "/", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("code", {
        children: "getServerSideProps"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 40,
        columnNumber: 9
      }, _this), ", a feature of the Sitecore JSS Next.js SDK. These are aggregated during the the Next.js page-level ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("code", {
        children: "getStaticProps"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 41,
        columnNumber: 54
      }, _this), "/", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("code", {
        children: "getServerSideProps"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 42,
        columnNumber: 9
      }, _this), " execution."]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 7
    }, _this), data && data.datasource && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("div", {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("h4", {
        children: "Datasource Item (via Connected GraphQL)"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 47,
        columnNumber: 11
      }, _this), "id: ", data.datasource.id, /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 49,
        columnNumber: 11
      }, _this), "name: ", data.datasource.name, /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 51,
        columnNumber: 11
      }, _this), "sample1: ", (_data$datasource$samp = data.datasource.sample1) === null || _data$datasource$samp === void 0 ? void 0 : _data$datasource$samp.value, /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 53,
        columnNumber: 11
      }, _this), "sample1 (editable): ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__["Text"], {
        field: (_data$datasource$samp2 = data.datasource.sample1) === null || _data$datasource$samp2 === void 0 ? void 0 : _data$datasource$samp2.jsonValue
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 54,
        columnNumber: 31
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 55,
        columnNumber: 11
      }, _this), "sample2:", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 57,
        columnNumber: 11
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("ul", {
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("li", {
          children: ["text: ", (_data$datasource$samp3 = data.datasource.sample2) === null || _data$datasource$samp3 === void 0 ? void 0 : _data$datasource$samp3.text]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 59,
          columnNumber: 13
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("li", {
          children: ["url: ", (_data$datasource$samp4 = data.datasource.sample2) === null || _data$datasource$samp4 === void 0 ? void 0 : _data$datasource$samp4.url]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 60,
          columnNumber: 13
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("li", {
          children: ["target: ", (_data$datasource$samp5 = data.datasource.sample2) === null || _data$datasource$samp5 === void 0 ? void 0 : _data$datasource$samp5.target]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 61,
          columnNumber: 13
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("li", {
          children: ["editable: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__["Link"], {
            field: (_data$datasource$samp6 = data.datasource.sample2) === null || _data$datasource$samp6 === void 0 ? void 0 : _data$datasource$samp6.jsonValue
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 63,
            columnNumber: 25
          }, _this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 62,
          columnNumber: 13
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("li", {
          children: ["field type: ", (_data$datasource$samp7 = data.datasource.sample2) === null || _data$datasource$samp7 === void 0 ? void 0 : (_data$datasource$samp8 = _data$datasource$samp7.definition) === null || _data$datasource$samp8 === void 0 ? void 0 : _data$datasource$samp8.type]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 65,
          columnNumber: 13
        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("li", {
          children: ["field is shared?: ", (_data$datasource$samp9 = data.datasource.sample2) === null || _data$datasource$samp9 === void 0 ? void 0 : (_data$datasource$samp10 = _data$datasource$samp9.definition) === null || _data$datasource$samp10 === void 0 ? void 0 : _data$datasource$samp10.shared.toString()]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 66,
          columnNumber: 13
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 58,
        columnNumber: 11
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 46,
      columnNumber: 9
    }, _this), data && data.contextItem && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("div", {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("h4", {
        children: "Route Item (via Connected GraphQL)"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 72,
        columnNumber: 11
      }, _this), "id: ", data.contextItem.id, /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 74,
        columnNumber: 11
      }, _this), "page title: ", (_data$contextItem$pag = data.contextItem.pageTitle) === null || _data$contextItem$pag === void 0 ? void 0 : _data$contextItem$pag.value, /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 76,
        columnNumber: 11
      }, _this), "children:", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("ul", {
        children: data.contextItem.children.results.map(function (child) {
          var _routeItem$pageTitle, _routeItem$pageTitle2;

          var routeItem = child;
          return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("li", {
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_5___default.a, {
              href: routeItem.url.path,
              children: (_routeItem$pageTitle = routeItem.pageTitle) === null || _routeItem$pageTitle === void 0 ? void 0 : _routeItem$pageTitle.value
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 84,
              columnNumber: 19
            }, _this), "(editable title too! ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__["Text"], {
              field: (_routeItem$pageTitle2 = routeItem.pageTitle) === null || _routeItem$pageTitle2 === void 0 ? void 0 : _routeItem$pageTitle2.jsonValue
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 85,
              columnNumber: 40
            }, _this), ")"]
          }, routeItem.id, true, {
            fileName: _jsxFileName,
            lineNumber: 83,
            columnNumber: 17
          }, _this);
        })
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 78,
        columnNumber: 11
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 71,
      columnNumber: 9
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 34,
    columnNumber: 5
  }, _this);
};
/**
 * Will be called during SSG
 * @param {ComponentRendering} rendering
 * @param {LayoutServiceData} layoutData
 * @param {GetStaticPropsContext} context
 */


_s(GraphQLConnectedDemo, "icmJAJgAp7KSXDh7fLKIGn2P8I8=", false, function () {
  return [_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__["useComponentProps"]];
});

_c = GraphQLConnectedDemo;
var getStaticProps = /*#__PURE__*/function () {
  var _ref = Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(rendering, layoutData) {
    var _layoutData$sitecore, _layoutData$sitecore$, _layoutData$sitecore2, _layoutData$sitecore3;

    var graphQLClient, result;
    return D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(process.env.JSS_MODE === _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__["JSS_MODE_DISCONNECTED"])) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", null);

          case 2:
            graphQLClient = new _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__["GraphQLRequestClient"](temp_config__WEBPACK_IMPORTED_MODULE_7___default.a.graphQLEndpoint, {
              apiKey: temp_config__WEBPACK_IMPORTED_MODULE_7___default.a.sitecoreApiKey
            });
            _context.next = 5;
            return graphQLClient.request(_GraphQL_ConnectedDemo_graphql__WEBPACK_IMPORTED_MODULE_6__["ConnectedDemoQueryDocument"], {
              datasource: rendering.dataSource,
              contextItem: layoutData === null || layoutData === void 0 ? void 0 : (_layoutData$sitecore = layoutData.sitecore) === null || _layoutData$sitecore === void 0 ? void 0 : (_layoutData$sitecore$ = _layoutData$sitecore.route) === null || _layoutData$sitecore$ === void 0 ? void 0 : _layoutData$sitecore$.itemId,
              language: layoutData === null || layoutData === void 0 ? void 0 : (_layoutData$sitecore2 = layoutData.sitecore) === null || _layoutData$sitecore2 === void 0 ? void 0 : (_layoutData$sitecore3 = _layoutData$sitecore2.context) === null || _layoutData$sitecore3 === void 0 ? void 0 : _layoutData$sitecore3.language
            });

          case 5:
            result = _context.sent;
            return _context.abrupt("return", result);

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getStaticProps(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Will be called during SSR
 * @param {ComponentRendering} rendering
 * @param {LayoutServiceData} layoutData
 * @param {GetServerSidePropsContext} context
 */

var getServerSideProps = /*#__PURE__*/function () {
  var _ref2 = Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(rendering, layoutData) {
    var _layoutData$sitecore4, _layoutData$sitecore5, _layoutData$sitecore6, _layoutData$sitecore7;

    var graphQLClient, result;
    return D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(process.env.JSS_MODE === _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__["JSS_MODE_DISCONNECTED"])) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt("return", null);

          case 2:
            graphQLClient = new _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_4__["GraphQLRequestClient"](temp_config__WEBPACK_IMPORTED_MODULE_7___default.a.graphQLEndpoint, {
              apiKey: temp_config__WEBPACK_IMPORTED_MODULE_7___default.a.sitecoreApiKey
            });
            _context2.next = 5;
            return graphQLClient.request(_GraphQL_ConnectedDemo_graphql__WEBPACK_IMPORTED_MODULE_6__["ConnectedDemoQueryDocument"], {
              datasource: rendering.dataSource,
              contextItem: layoutData === null || layoutData === void 0 ? void 0 : (_layoutData$sitecore4 = layoutData.sitecore) === null || _layoutData$sitecore4 === void 0 ? void 0 : (_layoutData$sitecore5 = _layoutData$sitecore4.route) === null || _layoutData$sitecore5 === void 0 ? void 0 : _layoutData$sitecore5.itemId,
              language: layoutData === null || layoutData === void 0 ? void 0 : (_layoutData$sitecore6 = layoutData.sitecore) === null || _layoutData$sitecore6 === void 0 ? void 0 : (_layoutData$sitecore7 = _layoutData$sitecore6.context) === null || _layoutData$sitecore7 === void 0 ? void 0 : _layoutData$sitecore7.language
            });

          case 5:
            result = _context2.sent;
            return _context2.abrupt("return", result);

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function getServerSideProps(_x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();
/* harmony default export */ __webpack_exports__["default"] = (GraphQLConnectedDemo);

var _c;

$RefreshReg$(_c, "GraphQLConnectedDemo");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/graphql/GraphQL-IntegratedDemo.tsx":
/*!***********************************************************!*\
  !*** ./src/components/graphql/GraphQL-IntegratedDemo.tsx ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);


var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\graphql\\GraphQL-IntegratedDemo.tsx",
    _this = undefined;

var GraphQLIntegratedDemo = function GraphQLIntegratedDemo(props) {
  // Query results in integrated GraphQL replace the normal `fields` data
  // i.e. with { data, }
  console.error(JSON.stringify(props));
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    "data-e2e-id": "graphql-integrated"
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 72,
    columnNumber: 5
  }, _this);
};

_c = GraphQLIntegratedDemo;
/* harmony default export */ __webpack_exports__["default"] = (GraphQLIntegratedDemo);

var _c;

$RefreshReg$(_c, "GraphQLIntegratedDemo");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/graphql/GraphQL-Layout.tsx":
/*!***************************************************!*\
  !*** ./src/components/graphql/GraphQL-Layout.tsx ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\graphql\\GraphQL-Layout.tsx",
    _this = undefined,
    _s = $RefreshSig$();



var GraphQLLayout = function GraphQLLayout(_ref) {
  _s();

  var rendering = _ref.rendering;

  var _useSitecoreContext = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["useSitecoreContext"])(),
      sitecoreContext = _useSitecoreContext.sitecoreContext;

  var disconnectedMode = sitecoreContext.route && sitecoreContext.route.layoutId === 'available-in-connected-mode';
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    "data-e2e-id": "graphql-layout",
    children: [disconnectedMode && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["Fragment"], {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        children: "This app is running in disconnected mode. GraphQL requires connected mode, headless connected mode, or integrated mode to work."
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 14,
        columnNumber: 11
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        children: ["Libraries such as ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("code", {
          children: "graphql-tools"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 19,
          columnNumber: 31
        }, _this), " can provide GraphQL API mocking capabilities, which could enable disconnected GraphQL. This is not supported out of the box, however."]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 18,
        columnNumber: 11
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
        children: ["To view the GraphQL samples, restart the app using ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("code", {
          children: "jss start:connected"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 24,
          columnNumber: 64
        }, _this), "\xA0 or deploy the app to Sitecore to run in integrated mode per the JSS documentation."]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 23,
        columnNumber: 11
      }, _this)]
    }, void 0, true), !disconnectedMode && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["Placeholder"], {
      name: "jss-graphql-layout",
      rendering: rendering
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 29
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 11,
    columnNumber: 5
  }, _this);
};

_s(GraphQLLayout, "i83+ib4PqgplvyTVx+W5yVffvmI=", false, function () {
  return [_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["useSitecoreContext"]];
});

_c = GraphQLLayout;
/* harmony default export */ __webpack_exports__["default"] = (GraphQLLayout);

var _c;

$RefreshReg$(_c, "GraphQLLayout");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-ComponentParams.tsx":
/*!******************************************************************!*\
  !*** ./src/components/styleguide/Styleguide-ComponentParams.tsx ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");




var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-ComponentParams.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



var StyleguideComponentParams = function StyleguideComponentParams(props) {
  // props.params (i.e. props.params.cssClass without destructuring) contains the component's params
  var _props$params = props.params,
      cssClass = _props$params.cssClass,
      columns = _props$params.columns,
      useCallToAction = _props$params.useCallToAction;

  var columnsArray = columns && Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(Array(parseInt(columns)));

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])(_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-componentparams",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("p", {
      className: cssClass,
      children: ["The CSS class of this paragraph (", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("code", {
        children: cssClass
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 22,
        columnNumber: 42
      }, _this), ") is set using a param"]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("div", {
      children: ["useCallToAction param: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("code", {
        children: useCallToAction
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 26,
        columnNumber: 32
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 27,
        columnNumber: 9
      }, _this), "param type: ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("code", {
        children: typeof useCallToAction
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 28,
        columnNumber: 21
      }, _this), useCallToAction === 'true' && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("div", {
        className: "alert alert-info",
        children: "the call to action is shown"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 11
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("p", {
      children: ["columns param: ", columns]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("div", {
      className: "row",
      children: columnsArray && columnsArray.map(function (_, index) {
        return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__["jsxDEV"])("div", {
          className: "col-sm",
          children: ["Column ", index]
        }, "col-".concat(index), true, {
          fileName: _jsxFileName,
          lineNumber: 37,
          columnNumber: 13
        }, _this);
      })
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 7
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 20,
    columnNumber: 5
  }, _this);
};

_c = StyleguideComponentParams;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideComponentParams);

var _c;

$RefreshReg$(_c, "StyleguideComponentParams");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-CustomRouteType.tsx":
/*!******************************************************************!*\
  !*** ./src/components/styleguide/Styleguide-CustomRouteType.tsx ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");


var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-CustomRouteType.tsx",
    _this = undefined,
    _s = $RefreshSig$();




var StyleguideCustomRouteType = function StyleguideCustomRouteType() {
  _s();

  // useSitecoreContext() is the magical glue that gives you route-level context access
  // see the context examples in the styleguide for more details.
  // this fancy destructure syntax is essentially equivalent to
  // const fields = props.sitecoreContext.route.fields
  var _useSitecoreContext = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["useSitecoreContext"])(),
      fields = _useSitecoreContext.sitecoreContext.route.fields;

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    "data-e2e-id": "styleguide-customroutetype",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
      tag: "h3",
      field: fields.headline
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("em", {
        children: ["By ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
          field: fields.author
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 32,
          columnNumber: 14
        }, _this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 31,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["RichText"], {
      field: fields.content
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
      href: "/styleguide",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
        children: "Return to the Styleguide"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 27,
    columnNumber: 5
  }, _this);
};

_s(StyleguideCustomRouteType, "eRhlBsgg6zR5AxvmDe8Xjjh4xCQ=", false, function () {
  return [_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["useSitecoreContext"]];
});

_c = StyleguideCustomRouteType;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideCustomRouteType);

var _c;

$RefreshReg$(_c, "StyleguideCustomRouteType");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-Layout-Reuse.tsx":
/*!***************************************************************!*\
  !*** ./src/components/styleguide/Styleguide-Layout-Reuse.tsx ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var _Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-Layout-Reuse.tsx",
    _this = undefined;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates how to reuse content within JSS. See /data/routes/styleguide/en.yml
 * for the reused content definition sample. This component also demonstrates how to use
 * the Placeholder component's render props API to wrap all components in the placeholder
 * in a column tag (thus creating a horizontally laid out placeholder)
 */
var StyleguideLayoutReuse = function StyleguideLayoutReuse(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-layout-reuse",
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
      className: "row",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Placeholder"], {
        rendering: props.rendering,
        name: "jss-reuse-example",
        renderEach: function renderEach(component, index) {
          return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
            className: "col-sm",
            children: component
          }, index, false, {
            fileName: _jsxFileName,
            lineNumber: 34,
            columnNumber: 11
          }, _this);
        },
        renderEmpty: function renderEmpty(components) {
          return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("div", {
            className: "col-sm",
            children: components
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 38,
            columnNumber: 38
          }, _this);
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 7
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 5
    }, _this)
  }), void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 14,
    columnNumber: 3
  }, _this);
};

_c = StyleguideLayoutReuse;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideLayoutReuse);

var _c;

$RefreshReg$(_c, "StyleguideLayoutReuse");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-Layout-Tabs-Tab.tsx":
/*!******************************************************************!*\
  !*** ./src/components/styleguide/Styleguide-Layout-Tabs-Tab.tsx ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");


var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-Layout-Tabs-Tab.tsx",
    _this = undefined,
    _s = $RefreshSig$();



/**
 * This is a single tab within the tabs sample component. These are added to the tabs placeholder.
 * This component demonstrates conditionally altering rendering when in the Sitecore Experience Editor to improve
 * author experience.
 */
var StyleguideLayoutTabsTab = function StyleguideLayoutTabsTab(props) {
  _s();

  var _useSitecoreContext = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["useSitecoreContext"])(),
      sitecoreContext = _useSitecoreContext.sitecoreContext;

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    "data-e2e-class": "styleguide-layout-tabs-tab",
    children: [sitecoreContext && sitecoreContext.pageEditing && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["Text"], {
      tag: "h5",
      field: props.fields.title
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 26,
      columnNumber: 9
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["RichText"], {
      field: props.fields.content
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 20,
    columnNumber: 5
  }, _this);
};

_s(StyleguideLayoutTabsTab, "i83+ib4PqgplvyTVx+W5yVffvmI=", false, function () {
  return [_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["useSitecoreContext"]];
});

_c = StyleguideLayoutTabsTab;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideLayoutTabsTab);

var _c;

$RefreshReg$(_c, "StyleguideLayoutTabsTab");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-Layout-Tabs.tsx":
/*!**************************************************************!*\
  !*** ./src/components/styleguide/Styleguide-Layout-Tabs.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var _Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");








var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-Layout-Tabs.tsx";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_6__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_5__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





/**
 * Demonstrates advanced component techniques in JSS.
 * This example implements a simple-looking tabs component.
 * Each tab is itself a child component added to a placeholder defined on the tabs component.
 * The tab component introspects its child components to render the tab headings (i.e. the tab children render partial content in two places).
 * When this component is edited in Sitecore Experience Editor, the tabbing behavior is turned off and each tab stacks on top of each other
 * for easy inline editing.
 */
var StyleguideLayoutTabs = /*#__PURE__*/function (_React$Component) {
  Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(StyleguideLayoutTabs, _React$Component);

  var _super = _createSuper(StyleguideLayoutTabs);

  function StyleguideLayoutTabs(props) {
    var _this;

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, StyleguideLayoutTabs);

    _this = _super.call(this, props);
    _this.state = {
      activeTabIndex: 0
    };
    _this.setActiveTab = _this.setActiveTab.bind(Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__["default"])(_this));
    return _this;
  }

  Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(StyleguideLayoutTabs, [{
    key: "setActiveTab",
    value: function setActiveTab(index) {
      this.setState({
        activeTabIndex: index
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          tabsPlaceholder = _this$props.tabsPlaceholder,
          sitecoreContext = _this$props.sitecoreContext;
      var validTabIndex = 0;
      var isEditing = sitecoreContext && sitecoreContext.pageEditing;
      return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])(_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_10__["default"], _objectSpread(_objectSpread({}, this.props), {}, {
        e2eId: "styleguide-layout-tabs",
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("ul", {
          className: "nav nav-tabs",
          children: !isEditing && (tabsPlaceholder || []).filter(function (tab) {
            return tab.props && tab.props.fields;
          }).map(function (tab, index) {
            return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("li", {
              className: "nav-item",
              children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("a", {
                className: "nav-link ".concat(index === _this2.state.activeTabIndex ? 'active' : null),
                onClick: function onClick() {
                  return _this2.setActiveTab(index);
                },
                href: "#t",
                children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_9__["Text"], {
                  field: tab.props.fields.title
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 65,
                  columnNumber: 21
                }, _this2)
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 60,
                columnNumber: 19
              }, _this2)
            }, "tab".concat(index), false, {
              fileName: _jsxFileName,
              lineNumber: 59,
              columnNumber: 17
            }, _this2);
          })
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 50,
          columnNumber: 9
        }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("div", {
          className: "p-3 border-left border-right border-bottom",
          children: (tabsPlaceholder || []).map(function (tab) {
            var isValid = tab.props && tab.props.fields; // allow experience editor markup components to render

            if (!isValid && isEditing) return tab;
            validTabIndex += 1; // we render the tab either if it's active - or we're editing,
            // in which case we stack all tabs for visual editing

            if (_this2.state.activeTabIndex === validTabIndex - 1 || isEditing) {
              return tab;
            }

            return null;
          })
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 70,
          columnNumber: 9
        }, this)]
      }), void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 49,
        columnNumber: 7
      }, this);
    }
  }]);

  return StyleguideLayoutTabs;
}(react__WEBPACK_IMPORTED_MODULE_8___default.a.Component); // This is a _higher order component_ that will wrap our component and inject placeholder
// data into it as a prop (in this case, props.tabsPlaceholder).
// this another option compared to using the <Placeholder> component;
// in this case, chosen because we primarily need access to the _data_
// of the placeholder.


var tabsComponentWithPlaceholderInjected = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_9__["withPlaceholder"])({
  placeholder: 'jss-tabs',
  prop: 'tabsPlaceholder'
})(StyleguideLayoutTabs); // We need to know if experience editor is active, to disable the dynamic tab behavior for editing.
// Using the same technique as injecting the placeholder, we wrap the component again to inject the
// `sitecoreContext` prop.

var tabsWithPlaceholderAndSitecoreContext = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_9__["withSitecoreContext"])()(tabsComponentWithPlaceholderInjected);
/* harmony default export */ __webpack_exports__["default"] = (tabsWithPlaceholderAndSitecoreContext);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-Layout.tsx":
/*!*********************************************************!*\
  !*** ./src/components/styleguide/Styleguide-Layout.tsx ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");


var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-Layout.tsx",
    _this = undefined;



/**
 * The main layout (columns) of the styleguide.
 * Navigation is automatically generated based on the components added to the layout,
 * and does not need to be manually maintained.
 */
var StyleguideLayout = function StyleguideLayout(props) {
  var getRendering = function getRendering(section) {
    return section;
  };

  var convertUID = function convertUID(uid) {
    if (!uid) return '';
    return uid.replace(/[{}]/g, '');
  }; // this code reads the components in the child placeholders of this component,
  // and projects them into the left navigation column for the styleguide


  var sections = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["getChildPlaceholder"])(props.rendering, 'jss-styleguide-layout').filter(function (section) {
    return Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["getFieldValue"])(getRendering(section), 'heading');
  }).map(function (section) {
    return {
      heading: Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["getFieldValue"])(getRendering(section), 'heading'),
      id: "i".concat(convertUID(getRendering(section).uid)),
      children: Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["getChildPlaceholder"])(getRendering(section), 'jss-styleguide-section').filter(function (component) {
        return Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["getFieldValue"])(getRendering(component), 'heading');
      }).map(function (component) {
        return {
          heading: Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["getFieldValue"])(getRendering(component), 'heading'),
          id: "i".concat(convertUID(getRendering(component).uid))
        };
      })
    };
  }).map(function (section) {
    return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("nav", {
      className: "nav flex-column pt-2",
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
        href: "#".concat(section.id),
        className: "nav-item font-weight-bold",
        children: section.heading
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 40,
        columnNumber: 9
      }, _this), section.children && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("nav", {
        className: "nav flex-column",
        children: section.children.map(function (child) {
          return child.heading && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("a", {
            href: "#".concat(child.id),
            children: child.heading
          }, child.id, false, {
            fileName: _jsxFileName,
            lineNumber: 48,
            columnNumber: 19
          }, _this);
        })
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 44,
        columnNumber: 11
      }, _this)]
    }, section.heading, true, {
      fileName: _jsxFileName,
      lineNumber: 39,
      columnNumber: 7
    }, _this);
  });
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    className: "row",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "col-sm-8 col-lg-10",
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["Placeholder"], {
        name: "jss-styleguide-layout",
        rendering: props.rendering
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 61,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 60,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "col-sm-4 col-lg-2 order-sm-first pt-2",
      children: sections
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 63,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 59,
    columnNumber: 5
  }, _this);
};

_c = StyleguideLayout;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideLayout);

var _c;

$RefreshReg$(_c, "StyleguideLayout");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-Multilingual.tsx":
/*!***************************************************************!*\
  !*** ./src/components/styleguide/Styleguide-Multilingual.tsx ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var next_localization__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-localization */ "./node_modules/next-localization/dist/index.modern.js");
/* harmony import */ var _Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-Multilingual.tsx",
    _this = undefined,
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






/**
 * Demonstrates using the dictionary functionality and defining route data in
 * multiple languages.
 */
var StyleguideMultilingual = function StyleguideMultilingual(props) {
  _s();

  var _useI18n = Object(next_localization__WEBPACK_IMPORTED_MODULE_4__["useI18n"])(),
      t = _useI18n.t,
      locale = _useI18n.locale;

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_5__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-multilingual",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["Text"], {
      field: props.fields.sample,
      encode: false,
      tag: "p"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: ["This is a static dictionary entry from ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("code", {
        children: "/data/dictionary"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 26,
        columnNumber: 48
      }, _this), ":\xA0", t('styleguide-sample')]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 25,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
        href: "/en/styleguide",
        locale: false,
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("a", {
          children: "Show in English"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 34,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 33,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("br", {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 36,
        columnNumber: 9
      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
        href: "/styleguide",
        locale: "da-DK",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("a", {
          children: "Show in Danish"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 38,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 37,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: ["The current language is: ", locale()]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 7
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 22,
    columnNumber: 5
  }, _this);
};

_s(StyleguideMultilingual, "/rZNKWoyX/4aa4Kt0/pMTsnDzeE=", false, function () {
  return [next_localization__WEBPACK_IMPORTED_MODULE_4__["useI18n"]];
});

_c = StyleguideMultilingual;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideMultilingual);

var _c;

$RefreshReg$(_c, "StyleguideMultilingual");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-RouteFields.tsx":
/*!**************************************************************!*\
  !*** ./src/components/styleguide/Styleguide-RouteFields.tsx ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var _Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-RouteFields.tsx",
    _this = undefined,
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





/**
 * Demonstrates gaining access to route-level fields.
 * This technique builds on the Styleguide-SitecoreContext technique,
 * to also get the route level field data and make it editable.
 */
var StyleguideRouteFields = function StyleguideRouteFields(props) {
  _s();

  var _useSitecoreContext = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_3__["useSitecoreContext"])(),
      sitecoreContext = _useSitecoreContext.sitecoreContext;

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_4__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-route-fields",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: ["Route level ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("code", {
        children: "pageTitle"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 31,
        columnNumber: 21
      }, _this), " field:", ' ', sitecoreContext.route && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_3__["Text"], {
        field: sitecoreContext.route.fields.pageTitle
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 32,
        columnNumber: 35
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {
        href: "/styleguide/custom-route-type",
        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("a", {
          children: "Sample of using a custom route type"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 36,
          columnNumber: 11
        }, _this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 35,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 7
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 29,
    columnNumber: 5
  }, _this);
};

_s(StyleguideRouteFields, "i83+ib4PqgplvyTVx+W5yVffvmI=", false, function () {
  return [_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_3__["useSitecoreContext"]];
});

_c = StyleguideRouteFields;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideRouteFields);

var _c;

$RefreshReg$(_c, "StyleguideRouteFields");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-Section.tsx":
/*!**********************************************************!*\
  !*** ./src/components/styleguide/Styleguide-Section.tsx ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");


var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-Section.tsx",
    _this = undefined;



/**
 * Represents a category of styleguide specimens within the Styleguide-Layout.
 * Usage examples are added to the `styleguide-section` placeholder that this
 * exposes.
 */
var StyleguideSection = function StyleguideSection(props) {
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    className: "pt-3",
    id: "i".concat(props.rendering.uid && props.rendering.uid.replace(/[{}]/g, '')),
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["Text"], {
      className: "border-bottom",
      field: props.fields.heading,
      tag: "h3"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_1__["Placeholder"], {
      name: "jss-styleguide-section",
      rendering: props.rendering
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 5
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 16,
    columnNumber: 3
  }, _this);
};

_c = StyleguideSection;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideSection);

var _c;

$RefreshReg$(_c, "StyleguideSection");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-SitecoreContext.tsx":
/*!******************************************************************!*\
  !*** ./src/components/styleguide/Styleguide-SitecoreContext.tsx ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var _Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-SitecoreContext.tsx",
    _this = undefined,
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




/**
 * Demonstrates gaining access to the route-level Sitecore Context from
 * within other components.
 */
var StyleguideSitecoreContext = function StyleguideSitecoreContext(props) {
  _s();

  var _useSitecoreContext = Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["useSitecoreContext"])(),
      sitecoreContext = _useSitecoreContext.sitecoreContext;

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_3__["default"], _objectSpread(_objectSpread({}, props), {}, {
    e2eId: "styleguide-sitecore-context",
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("p", {
      children: "The current Sitecore Context is..."
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 7
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])("pre", {
      style: {
        maxHeight: '400px',
        overflow: 'scroll'
      },
      children: JSON.stringify(sitecoreContext, null, 2)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 7
    }, _this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 19,
    columnNumber: 5
  }, _this);
};

_s(StyleguideSitecoreContext, "i83+ib4PqgplvyTVx+W5yVffvmI=", false, function () {
  return [_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_2__["useSitecoreContext"]];
});

_c = StyleguideSitecoreContext;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideSitecoreContext);

var _c;

$RefreshReg$(_c, "StyleguideSitecoreContext");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-Specimen.tsx":
/*!***********************************************************!*\
  !*** ./src/components/styleguide/Styleguide-Specimen.tsx ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);


var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-Specimen.tsx",
    _this = undefined;

/**
 * Helper component that displays explanatory information and where to find the definitions
 * of styleguide specimens.
 */
var StyleguideSpecimen = function StyleguideSpecimen(_ref) {
  var children = _ref.children,
      e2eId = _ref.e2eId;
  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
    className: "pt-3" // id={`i${rendering.uid && rendering.uid.replace(/[{}]/g, '')}`}
    ,
    "data-e2e-id": e2eId,
    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("p", {
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("small", {
        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("br", {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 30,
          columnNumber: 9
        }, _this), "Definition:", ' ']
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 29,
        columnNumber: 7
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 5
    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__["jsxDEV"])("div", {
      className: "border p-2",
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 5
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 20,
    columnNumber: 3
  }, _this);
};

_c = StyleguideSpecimen;
/* harmony default export */ __webpack_exports__["default"] = (StyleguideSpecimen);

var _c;

$RefreshReg$(_c, "StyleguideSpecimen");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/components/styleguide/Styleguide-Tracking.tsx":
/*!***********************************************************!*\
  !*** ./src/components/styleguide/Styleguide-Tracking.tsx ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var _sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-tracking */ "./node_modules/@sitecore-jss/sitecore-jss-tracking/dist/index.js");
/* harmony import */ var _sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var lib_data_fetcher__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib/data-fetcher */ "./src/lib/data-fetcher.ts");
/* harmony import */ var temp_config__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! temp/config */ "./src/temp/config.js");
/* harmony import */ var temp_config__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(temp_config__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");








var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\components\\styleguide\\Styleguide-Tracking.tsx";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }








/**
 * Demonstrates analytics tracking patterns (xDB)
 */
var StyleguideTracking = /*#__PURE__*/function (_React$Component) {
  Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_3__["default"])(StyleguideTracking, _React$Component);

  var _super = _createSuper(StyleguideTracking);

  function StyleguideTracking(props) {
    var _this;

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, StyleguideTracking);

    _this = _super.call(this, props);

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "event", void 0);

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "goal", void 0);

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "outcomeName", void 0);

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "outcomeValue", void 0);

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "campaign", void 0);

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "pageId", void 0);

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "pageUrl", void 0);

    Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this), "trackingApiOptions", void 0);

    _this.event = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8___default.a.createRef();
    _this.goal = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8___default.a.createRef();
    _this.outcomeName = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8___default.a.createRef();
    _this.outcomeValue = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8___default.a.createRef();
    _this.campaign = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8___default.a.createRef();
    _this.pageId = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8___default.a.createRef();
    _this.pageUrl = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_8___default.a.createRef();
    _this.trackingApiOptions = {
      host: temp_config__WEBPACK_IMPORTED_MODULE_12___default.a.sitecoreApiHost,
      querystringParams: {
        sc_apikey: temp_config__WEBPACK_IMPORTED_MODULE_12___default.a.sitecoreApiKey
      },
      fetcher: lib_data_fetcher__WEBPACK_IMPORTED_MODULE_11__["dataFetcher"]
    };
    return _this;
  }

  Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(StyleguideTracking, [{
    key: "submitEvent",
    value: function submitEvent() {
      if (!this.event.current) return;
      _sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10__["trackingApi"].trackEvent([{
        eventId: this.event.current.value
      }], this.trackingApiOptions).then(function () {
        return alert('Page event pushed');
      })["catch"](function (error) {
        return alert(error);
      });
    }
  }, {
    key: "submitGoal",
    value: function submitGoal() {
      if (!this.goal.current) return;
      _sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10__["trackingApi"].trackEvent([{
        goalId: this.goal.current.value
      }], this.trackingApiOptions).then(function () {
        return alert('Goal pushed');
      })["catch"](function (error) {
        return alert(error);
      });
    }
  }, {
    key: "submitOutcome",
    value: function submitOutcome() {
      if (!this.pageUrl.current || !this.pageId.current || !this.outcomeName.current || !this.outcomeValue.current) {
        return;
      }

      _sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10__["trackingApi"].trackEvent([{
        url: this.pageUrl.current.value,
        pageId: this.pageId.current.value,
        outcomeId: this.outcomeName.current.value,
        currencyCode: 'USD',
        monetaryValue: this.outcomeValue.current.value
      }], this.trackingApiOptions).then(function () {
        return alert('Outcome pushed');
      })["catch"](function (error) {
        return alert(error);
      });
    }
  }, {
    key: "triggerCampaign",
    value: function triggerCampaign() {
      if (!this.campaign.current) return;
      _sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10__["trackingApi"].trackEvent([{
        campaignId: this.campaign.current.value
      }], this.trackingApiOptions).then(function () {
        return alert('Campaign set');
      })["catch"](function (error) {
        return alert(error);
      });
    }
  }, {
    key: "submitPageView",
    value: function submitPageView() {
      if (!this.pageId.current || !this.pageUrl.current) return;
      _sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10__["trackingApi"].trackEvent([{
        pageId: this.pageId.current.value,
        url: this.pageUrl.current.value
      }], this.trackingApiOptions).then(function () {
        return alert('Page view pushed');
      })["catch"](function (error) {
        return alert(error);
      });
    }
  }, {
    key: "abandonSession",
    value: function abandonSession() {
      var abandonOptions = _objectSpread({
        action: 'flush'
      }, this.trackingApiOptions);

      _sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10__["trackingApi"].trackEvent([], abandonOptions).then(function () {
        return alert('Interaction has been terminated and its data pushed to xConnect.');
      })["catch"](function (error) {
        return alert(error);
      });
    }
  }, {
    key: "submitBatching",
    value: function submitBatching() {
      _sitecore_jss_sitecore_jss_tracking__WEBPACK_IMPORTED_MODULE_10__["trackingApi"].trackEvent([{
        eventId: 'Download'
      }, {
        goalId: 'Instant Demo'
      }, {
        outcomeId: 'Opportunity'
      }, {
        pageId: '{110D559F-DEA5-42EA-9C1C-8A5DF7E70EF9}',
        url: '/arbitrary/url/you/own'
      }, // this goal will be added to the new page/route ID set above, not the current route
      {
        goalId: 'Register'
      }], this.trackingApiOptions).then(function () {
        return alert('Batch of events pushed');
      })["catch"](function (error) {
        return alert(error);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var disconnectedMode = this.props.sitecoreContext.itemId === 'available-in-connected-mode';
      return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])(_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_13__["default"], _objectSpread(_objectSpread({}, this.props), {}, {
        e2eId: "styleguide-tracking",
        children: [disconnectedMode && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
          children: "The tracking API is only available in connected, integrated, or headless modes."
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 157,
          columnNumber: 11
        }, this), !disconnectedMode && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("div", {
          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
            className: "alert alert-warning",
            children: ["Note: The JSS tracker API is disabled by default. Consult the", ' ', /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("a", {
              href: "https://jss.sitecore.com/docs/fundamentals/services/tracking",
              children: "tracking documentation"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 163,
              columnNumber: 15
            }, this), ' ', "to enable it."]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 161,
            columnNumber: 13
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("div", {
            className: "row",
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("fieldset", {
              className: "form-group col-sm",
              children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("legend", {
                children: "Event"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 170,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
                children: ["Events are defined in ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("code", {
                  children: "/sitecore/system/Settings/Analytics/Page Events"
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 172,
                  columnNumber: 41
                }, this)]
              }, void 0, true, {
                fileName: _jsxFileName,
                lineNumber: 171,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("label", {
                htmlFor: "event",
                children: "Event GUID or Name"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 174,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("input", {
                type: "text",
                id: "event",
                className: "form-control",
                ref: this.event
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 175,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("button", {
                type: "button",
                className: "btn btn-primary mt-3",
                onClick: this.submitEvent.bind(this),
                children: "Submit"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 176,
                columnNumber: 17
              }, this)]
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 169,
              columnNumber: 15
            }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("fieldset", {
              className: "form-group col-sm",
              children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("legend", {
                children: "Goal"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 186,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
                children: ["Goals are defined in ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("code", {
                  children: "/sitecore/system/Marketing Control Panel/Goals"
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 188,
                  columnNumber: 40
                }, this)]
              }, void 0, true, {
                fileName: _jsxFileName,
                lineNumber: 187,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("label", {
                htmlFor: "goal",
                children: "Goal GUID or Name"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 190,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("input", {
                type: "text",
                className: "form-control",
                id: "goal",
                ref: this.goal,
                placeholder: "i.e. Register"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 191,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("button", {
                type: "button",
                className: "btn btn-primary mt-3",
                onClick: this.submitGoal.bind(this),
                children: "Submit"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 198,
                columnNumber: 17
              }, this)]
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 185,
              columnNumber: 15
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 168,
            columnNumber: 13
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("div", {
            className: "row",
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("fieldset", {
              className: "form-group col-sm",
              children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("legend", {
                children: "Outcome"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 209,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
                children: ["Outcomes are defined in", ' ', /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("code", {
                  children: "/sitecore/system/Marketing Control Panel/Outcomes"
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 212,
                  columnNumber: 19
                }, this)]
              }, void 0, true, {
                fileName: _jsxFileName,
                lineNumber: 210,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("label", {
                htmlFor: "outcomeName",
                children: "Outcome GUID or Name"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 214,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("input", {
                type: "text",
                className: "form-control",
                id: "outcomeName",
                ref: this.outcomeName,
                placeholder: "i.e. Marketing Lead"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 215,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("br", {}, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 222,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("label", {
                htmlFor: "outcomeValue",
                children: "Monetary Value (optional)"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 223,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("input", {
                type: "number",
                className: "form-control",
                id: "outcomeValue",
                ref: this.outcomeValue,
                placeholder: "i.e. 1337.00"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 224,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("button", {
                type: "button",
                className: "btn btn-primary mt-3",
                onClick: this.submitOutcome.bind(this),
                children: "Submit"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 231,
                columnNumber: 17
              }, this)]
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 208,
              columnNumber: 15
            }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("fieldset", {
              className: "form-group col-sm",
              children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("legend", {
                children: "Campaign"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 241,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
                children: ["Campaigns are defined in", ' ', /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("code", {
                  children: "/sitecore/system/Marketing Control Panel/Campaigns"
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 244,
                  columnNumber: 19
                }, this)]
              }, void 0, true, {
                fileName: _jsxFileName,
                lineNumber: 242,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("label", {
                htmlFor: "campaign",
                children: "Campaign GUID or Name"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 246,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("input", {
                type: "text",
                className: "form-control",
                id: "campaign",
                ref: this.campaign
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 247,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("button", {
                type: "button",
                className: "btn btn-primary mt-3",
                onClick: this.triggerCampaign.bind(this),
                children: "Submit"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 248,
                columnNumber: 17
              }, this)]
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 240,
              columnNumber: 15
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 207,
            columnNumber: 13
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("div", {
            className: "row",
            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("fieldset", {
              className: "form-group col-sm",
              children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("legend", {
                children: "Page View"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 259,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
                children: ["Track arbitrary page views for custom routing or offline use. Note that Layout Service tracks page views by default unless ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("code", {
                  children: "tracking=false"
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 262,
                  columnNumber: 63
                }, this), " is passed in its query string."]
              }, void 0, true, {
                fileName: _jsxFileName,
                lineNumber: 260,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("label", {
                htmlFor: "pageId",
                children: "Page Item GUID"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 265,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("input", {
                type: "text",
                className: "form-control",
                id: "pageId",
                ref: this.pageId,
                placeholder: "i.e. {11111111-1111-1111-1111-111111111111}"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 266,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("br", {}, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 273,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("label", {
                htmlFor: "pageUrl",
                children: "Page URL"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 274,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("input", {
                type: "text",
                className: "form-control",
                id: "pageUrl",
                ref: this.pageUrl,
                placeholder: "i.e. /foo/bar"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 275,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("button", {
                type: "button",
                className: "btn btn-primary mt-3",
                onClick: this.submitPageView.bind(this),
                children: "Submit"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 282,
                columnNumber: 17
              }, this)]
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 258,
              columnNumber: 15
            }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("fieldset", {
              className: "form-group col-sm",
              children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("legend", {
                children: "Batching"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 292,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
                children: "The tracking API supports pushing a whole batch of events in a single request. This can be useful for queuing strategies or offline PWA usage."
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 293,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("button", {
                type: "button",
                className: "btn btn-primary",
                onClick: this.submitBatching.bind(this),
                children: "Submit Batch of Events"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 297,
                columnNumber: 17
              }, this)]
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 291,
              columnNumber: 15
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 257,
            columnNumber: 13
          }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("div", {
            className: "row",
            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("fieldset", {
              className: "form-group col-sm",
              children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("legend", {
                children: "Interaction Control"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 308,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
                children: "Tracking data is not pushed into the xConnect service until your session ends on the Sitecore server. Click this button to instantly end your session and flush the data - great for debugging and testing."
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 309,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("p", {
                className: "alert alert-warning",
                children: ["Note: By default ", /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("em", {
                  children: "anonymous"
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 315,
                  columnNumber: 36
                }, this), " contacts will not be shown in Experience Profile. If your interactions are not showing up in Experience Profile, you may need to", ' ', /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("a", {
                  href: "https://doc.sitecore.net/developers/xp/xconnect/xconnect-search-indexer/enable-anonymous-contact-indexing.html",
                  children: "enable anonymous contact indexing."
                }, void 0, false, {
                  fileName: _jsxFileName,
                  lineNumber: 318,
                  columnNumber: 19
                }, this)]
              }, void 0, true, {
                fileName: _jsxFileName,
                lineNumber: 314,
                columnNumber: 17
              }, this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_7__["jsxDEV"])("button", {
                type: "button",
                className: "btn btn-primary",
                onClick: this.abandonSession.bind(this),
                children: "End Interaction"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 322,
                columnNumber: 17
              }, this)]
            }, void 0, true, {
              fileName: _jsxFileName,
              lineNumber: 307,
              columnNumber: 15
            }, this)
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 306,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 160,
          columnNumber: 11
        }, this)]
      }), void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 155,
        columnNumber: 7
      }, this);
    }
  }]);

  return StyleguideTracking;
}(react__WEBPACK_IMPORTED_MODULE_8___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_9__["withSitecoreContext"])()(StyleguideTracking));

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/lib/data-fetcher.ts":
/*!*********************************!*\
  !*** ./src/lib/data-fetcher.ts ***!
  \*********************************/
/*! exports provided: dataFetcher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataFetcher", function() { return dataFetcher; });
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");

/**
 * Implements a data fetcher using Axios - replace with your favorite
 * SSR-capable HTTP or fetch library if you like. See HttpDataFetcher<T> type
 * in sitecore-jss library for implementation details/notes.
 * @param {string} url The URL to request; may include query string
 * @param {any} data Optional data to POST with the request.
 */

function dataFetcher(url, data) {
  return new _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_0__["AxiosDataFetcher"]().fetch(url, data);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/lib/util.ts":
/*!*************************!*\
  !*** ./src/lib/util.ts ***!
  \*************************/
/*! exports provided: getPublicUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPublicUrl", function() { return getPublicUrl; });
/**
 * Get the publicUrl.
 * This is used primarily to enable compatibility with the Sitecore Experience Editor.
 */
var getPublicUrl = function getPublicUrl() {
  return "http://localhost:3000" || false;
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/pages/[[...path]].tsx":
/*!***********************************!*\
  !*** ./src/pages/[[...path]].tsx ***!
  \***********************************/
/*! exports provided: __N_SSG, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__N_SSG", function() { return __N_SSG; });
/* harmony import */ var D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var src_NotFound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! src/NotFound */ "./src/NotFound.tsx");
/* harmony import */ var src_Layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/Layout */ "./src/Layout.tsx");
/* harmony import */ var _sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sitecore-jss/sitecore-jss-nextjs */ "./node_modules/@sitecore-jss/sitecore-jss-nextjs/dist/esm/index.js");
/* harmony import */ var temp_componentFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! temp/componentFactory */ "./src/temp/componentFactory.ts");



var _jsxFileName = "D:\\projects\\jss\\nextjsonazure\\packages\\jss-nextjs-app\\src\\pages\\[[...path]].tsx",
    _this = undefined,
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(D_projects_jss_nextjsonazure_packages_jss_nextjs_app_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







var SitecorePage = function SitecorePage(_ref) {
  _s();

  var _layoutData$sitecore, _layoutData$sitecore$;

  var notFound = _ref.notFound,
      layoutData = _ref.layoutData,
      componentProps = _ref.componentProps;
  Object(react__WEBPACK_IMPORTED_MODULE_2__["useEffect"])(function () {
    // Since Experience Editor does not support Fast Refresh need to refresh EE chromes after Fast Refresh finished
    Object(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_5__["handleExperienceEditorFastRefresh"])();
  }, []);

  if (notFound || !(layoutData === null || layoutData === void 0 ? void 0 : (_layoutData$sitecore = layoutData.sitecore) === null || _layoutData$sitecore === void 0 ? void 0 : _layoutData$sitecore.route)) {
    // Shouldn't hit this (as long as 'notFound' is being returned below), but just to be safe
    return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(src_NotFound__WEBPACK_IMPORTED_MODULE_3__["default"], {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 12
    }, _this);
  }

  var context = _objectSpread({
    route: layoutData.sitecore.route,
    itemId: (_layoutData$sitecore$ = layoutData.sitecore.route) === null || _layoutData$sitecore$ === void 0 ? void 0 : _layoutData$sitecore$.itemId
  }, layoutData.sitecore.context);

  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_5__["ComponentPropsContext"], {
    value: componentProps,
    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(_sitecore_jss_sitecore_jss_nextjs__WEBPACK_IMPORTED_MODULE_5__["SitecoreContext"], {
      componentFactory: temp_componentFactory__WEBPACK_IMPORTED_MODULE_6__["componentFactory"],
      context: context,
      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__["jsxDEV"])(src_Layout__WEBPACK_IMPORTED_MODULE_4__["default"], {
        context: context
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 9
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 35,
      columnNumber: 7
    }, _this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 34,
    columnNumber: 5
  }, _this);
}; // This function gets called at build and export time to determine
// pages for SSG ("paths", as tokenized array).


_s(SitecorePage, "OD7bBpZva5O2jO+Puf00hKivP7c=");

_c = SitecorePage;
var __N_SSG = true;
/* harmony default export */ __webpack_exports__["default"] = (SitecorePage);

var _c;

$RefreshReg$(_c, "SitecorePage");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/temp/componentFactory.ts":
/*!**************************************!*\
  !*** ./src/temp/componentFactory.ts ***!
  \**************************************/
/*! exports provided: componentModule, componentFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "componentModule", function() { return componentModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "componentFactory", function() { return componentFactory; });
/* harmony import */ var src_components_ContentBlock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/components/ContentBlock */ "./src/components/ContentBlock.tsx");
/* harmony import */ var src_components_Hero__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/components/Hero */ "./src/components/Hero.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_Checkbox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-Checkbox */ "./src/components/fields/Styleguide-FieldUsage-Checkbox.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_ContentList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-ContentList */ "./src/components/fields/Styleguide-FieldUsage-ContentList.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_Custom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-Custom */ "./src/components/fields/Styleguide-FieldUsage-Custom.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_Date__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-Date */ "./src/components/fields/Styleguide-FieldUsage-Date.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_File__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-File */ "./src/components/fields/Styleguide-FieldUsage-File.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_Image__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-Image */ "./src/components/fields/Styleguide-FieldUsage-Image.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_ItemLink__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-ItemLink */ "./src/components/fields/Styleguide-FieldUsage-ItemLink.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_Link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-Link */ "./src/components/fields/Styleguide-FieldUsage-Link.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_Number__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-Number */ "./src/components/fields/Styleguide-FieldUsage-Number.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_RichText__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-RichText */ "./src/components/fields/Styleguide-FieldUsage-RichText.tsx");
/* harmony import */ var src_components_fields_Styleguide_FieldUsage_Text__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! src/components/fields/Styleguide-FieldUsage-Text */ "./src/components/fields/Styleguide-FieldUsage-Text.tsx");
/* harmony import */ var src_components_graphql_GraphQL_ConnectedDemo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! src/components/graphql/GraphQL-ConnectedDemo */ "./src/components/graphql/GraphQL-ConnectedDemo.tsx");
/* harmony import */ var src_components_graphql_GraphQL_IntegratedDemo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! src/components/graphql/GraphQL-IntegratedDemo */ "./src/components/graphql/GraphQL-IntegratedDemo.tsx");
/* harmony import */ var src_components_graphql_GraphQL_Layout__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! src/components/graphql/GraphQL-Layout */ "./src/components/graphql/GraphQL-Layout.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_ComponentParams__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! src/components/styleguide/Styleguide-ComponentParams */ "./src/components/styleguide/Styleguide-ComponentParams.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_CustomRouteType__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! src/components/styleguide/Styleguide-CustomRouteType */ "./src/components/styleguide/Styleguide-CustomRouteType.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_Layout_Reuse__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! src/components/styleguide/Styleguide-Layout-Reuse */ "./src/components/styleguide/Styleguide-Layout-Reuse.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_Layout_Tabs_Tab__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! src/components/styleguide/Styleguide-Layout-Tabs-Tab */ "./src/components/styleguide/Styleguide-Layout-Tabs-Tab.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_Layout_Tabs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! src/components/styleguide/Styleguide-Layout-Tabs */ "./src/components/styleguide/Styleguide-Layout-Tabs.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_Layout__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! src/components/styleguide/Styleguide-Layout */ "./src/components/styleguide/Styleguide-Layout.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_Multilingual__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! src/components/styleguide/Styleguide-Multilingual */ "./src/components/styleguide/Styleguide-Multilingual.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_RouteFields__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! src/components/styleguide/Styleguide-RouteFields */ "./src/components/styleguide/Styleguide-RouteFields.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_Section__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! src/components/styleguide/Styleguide-Section */ "./src/components/styleguide/Styleguide-Section.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_SitecoreContext__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! src/components/styleguide/Styleguide-SitecoreContext */ "./src/components/styleguide/Styleguide-SitecoreContext.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! src/components/styleguide/Styleguide-Specimen */ "./src/components/styleguide/Styleguide-Specimen.tsx");
/* harmony import */ var src_components_styleguide_Styleguide_Tracking__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! src/components/styleguide/Styleguide-Tracking */ "./src/components/styleguide/Styleguide-Tracking.tsx");
/* eslint-disable */
// Do not edit this file, it is auto-generated at build time!
// See scripts/generate-component-factory.ts to modify the generation of this file.




























var components = new Map();
components.set('ContentBlock', src_components_ContentBlock__WEBPACK_IMPORTED_MODULE_0__);
components.set('Hero', src_components_Hero__WEBPACK_IMPORTED_MODULE_1__);
components.set('Styleguide-FieldUsage-Checkbox', src_components_fields_Styleguide_FieldUsage_Checkbox__WEBPACK_IMPORTED_MODULE_2__);
components.set('Styleguide-FieldUsage-ContentList', src_components_fields_Styleguide_FieldUsage_ContentList__WEBPACK_IMPORTED_MODULE_3__);
components.set('Styleguide-FieldUsage-Custom', src_components_fields_Styleguide_FieldUsage_Custom__WEBPACK_IMPORTED_MODULE_4__);
components.set('Styleguide-FieldUsage-Date', src_components_fields_Styleguide_FieldUsage_Date__WEBPACK_IMPORTED_MODULE_5__);
components.set('Styleguide-FieldUsage-File', src_components_fields_Styleguide_FieldUsage_File__WEBPACK_IMPORTED_MODULE_6__);
components.set('Styleguide-FieldUsage-Image', src_components_fields_Styleguide_FieldUsage_Image__WEBPACK_IMPORTED_MODULE_7__);
components.set('Styleguide-FieldUsage-ItemLink', src_components_fields_Styleguide_FieldUsage_ItemLink__WEBPACK_IMPORTED_MODULE_8__);
components.set('Styleguide-FieldUsage-Link', src_components_fields_Styleguide_FieldUsage_Link__WEBPACK_IMPORTED_MODULE_9__);
components.set('Styleguide-FieldUsage-Number', src_components_fields_Styleguide_FieldUsage_Number__WEBPACK_IMPORTED_MODULE_10__);
components.set('Styleguide-FieldUsage-RichText', src_components_fields_Styleguide_FieldUsage_RichText__WEBPACK_IMPORTED_MODULE_11__);
components.set('Styleguide-FieldUsage-Text', src_components_fields_Styleguide_FieldUsage_Text__WEBPACK_IMPORTED_MODULE_12__);
components.set('GraphQL-ConnectedDemo', src_components_graphql_GraphQL_ConnectedDemo__WEBPACK_IMPORTED_MODULE_13__);
components.set('GraphQL-IntegratedDemo', src_components_graphql_GraphQL_IntegratedDemo__WEBPACK_IMPORTED_MODULE_14__);
components.set('GraphQL-Layout', src_components_graphql_GraphQL_Layout__WEBPACK_IMPORTED_MODULE_15__);
components.set('Styleguide-ComponentParams', src_components_styleguide_Styleguide_ComponentParams__WEBPACK_IMPORTED_MODULE_16__);
components.set('Styleguide-CustomRouteType', src_components_styleguide_Styleguide_CustomRouteType__WEBPACK_IMPORTED_MODULE_17__);
components.set('Styleguide-Layout-Reuse', src_components_styleguide_Styleguide_Layout_Reuse__WEBPACK_IMPORTED_MODULE_18__);
components.set('Styleguide-Layout-Tabs-Tab', src_components_styleguide_Styleguide_Layout_Tabs_Tab__WEBPACK_IMPORTED_MODULE_19__);
components.set('Styleguide-Layout-Tabs', src_components_styleguide_Styleguide_Layout_Tabs__WEBPACK_IMPORTED_MODULE_20__);
components.set('Styleguide-Layout', src_components_styleguide_Styleguide_Layout__WEBPACK_IMPORTED_MODULE_21__);
components.set('Styleguide-Multilingual', src_components_styleguide_Styleguide_Multilingual__WEBPACK_IMPORTED_MODULE_22__);
components.set('Styleguide-RouteFields', src_components_styleguide_Styleguide_RouteFields__WEBPACK_IMPORTED_MODULE_23__);
components.set('Styleguide-Section', src_components_styleguide_Styleguide_Section__WEBPACK_IMPORTED_MODULE_24__);
components.set('Styleguide-SitecoreContext', src_components_styleguide_Styleguide_SitecoreContext__WEBPACK_IMPORTED_MODULE_25__);
components.set('Styleguide-Specimen', src_components_styleguide_Styleguide_Specimen__WEBPACK_IMPORTED_MODULE_26__);
components.set('Styleguide-Tracking', src_components_styleguide_Styleguide_Tracking__WEBPACK_IMPORTED_MODULE_27__);
function componentModule(componentName) {
  return components.get(componentName);
}
;
function componentFactory(componentName) {
  var _components$get;

  return (_components$get = components.get(componentName)) === null || _components$get === void 0 ? void 0 : _components$get["default"];
}
;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/temp/config.js":
/*!****************************!*\
  !*** ./src/temp/config.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, module) {/* eslint-disable */
// Do not edit this file, it is auto-generated at build time!
// See scripts/bootstrap.ts to modify the generation of this file.
var config = {};
config.sitecoreApiKey = process.env.SITECORE_API_KEY || "614017FB-9733-462E-BF1D-4FDED698EB0D", config.sitecoreApiHost = process.env.SITECORE_API_HOST || "https://dev-mi-paas-xm110-rg-118130-single.azurewebsites.net/", config.jssAppName = process.env.JSS_APP_NAME || "jss-nextjs-app", config.graphQLEndpointPath = process.env.GRAPH_QL_ENDPOINT_PATH || "/sitecore/api/graph/edge", config.graphQLEndpoint = process.env.GRAPH_QL_ENDPOINT || "".concat(config.sitecoreApiHost).concat(config.graphQLEndpointPath);
module.exports = config;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ })

},[["./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F%5B%5B...path%5D%5D&absolutePagePath=D%3A%5Cprojects%5Cjss%5Cnextjsonazure%5Cpackages%5Cjss-nextjs-app%5Csrc%5Cpages%5C%5B%5B...path%5D%5D.tsx!./","webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcy9kaXN0L2VzbS9jb21wb25lbnRzL0NvbXBvbmVudFByb3BzQ29udGV4dC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcy9kaXN0L2VzbS9jb21wb25lbnRzL0xpbmsuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMvZGlzdC9lc20vY29tcG9uZW50cy9SaWNoVGV4dC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcy9kaXN0L2VzbS9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMvZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMvZGlzdC9lc20vc2VydmljZXMvY29tcG9uZW50LXByb3BzLXNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMvZGlzdC9lc20vc2VydmljZXMvZGlzY29ubmVjdGVkLXNpdGVtYXAtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcy9kaXN0L2VzbS9zZXJ2aWNlcy9lZGl0aW5nLWRhdGEtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcy9kaXN0L2VzbS9zZXJ2aWNlcy9ncmFwaHFsLXNpdGVtYXAtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcy9kaXN0L2VzbS9zaGFyZWRUeXBlcy9lZGl0aW5nLWRhdGEuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMvZGlzdC9lc20vdXRpbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1yZWFjdC9kaXN0L2NvbXBvbmVudHMvRGF0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0L2Rpc3QvY29tcG9uZW50cy9GaWxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtcmVhY3QvZGlzdC9jb21wb25lbnRzL0ltYWdlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtcmVhY3QvZGlzdC9jb21wb25lbnRzL0xpbmsuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1yZWFjdC9kaXN0L2NvbXBvbmVudHMvTWlzc2luZ0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0L2Rpc3QvY29tcG9uZW50cy9QbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0L2Rpc3QvY29tcG9uZW50cy9QbGFjZWhvbGRlckNvbW1vbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0L2Rpc3QvY29tcG9uZW50cy9SaWNoVGV4dC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0L2Rpc3QvY29tcG9uZW50cy9TaXRlY29yZUNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1yZWFjdC9kaXN0L2NvbXBvbmVudHMvVGV4dC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0L2Rpc3QvY29tcG9uZW50cy9WaXNpdG9ySWRlbnRpZmljYXRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1yZWFjdC9kaXN0L2VuaGFuY2Vycy93aXRoQ29tcG9uZW50RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0L2Rpc3QvZW5oYW5jZXJzL3dpdGhFeHBlcmllbmNlRWRpdG9yQ2hyb21lcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0L2Rpc3QvZW5oYW5jZXJzL3dpdGhQbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0L2Rpc3QvZW5oYW5jZXJzL3dpdGhTaXRlY29yZUNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1yZWFjdC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtcmVhY3QvZGlzdC91dGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXRyYWNraW5nL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy10cmFja2luZy9kaXN0L3RyYWNraW5nQXBpLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MvZGlzdC9heGlvcy1mZXRjaGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MvZGlzdC9jYWNoZS1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy9kaXN0L2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL2Rpc3QvZGF0YS1mZXRjaGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MvZGlzdC9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL2Rpc3QvZ3JhcGhxbC1yZXF1ZXN0LWNsaWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL2Rpc3QvZ3JhcGhxbC9hcHAtcm9vdC1xdWVyeS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL2Rpc3QvZ3JhcGhxbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL2Rpc3QvZ3JhcGhxbC9zZWFyY2gtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL2Rpc3QvaTE4bi9kaWN0aW9uYXJ5LXNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy9kaXN0L2kxOG4vZ3JhcGhxbC1kaWN0aW9uYXJ5LXNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy9kaXN0L2kxOG4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy9kaXN0L2kxOG4vcmVzdC1kaWN0aW9uYXJ5LXNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MvZGlzdC9sYXlvdXQvZ3JhcGhxbC1sYXlvdXQtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL2Rpc3QvbGF5b3V0L2xheW91dC1zZXJ2aWNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MvZGlzdC9sYXlvdXQvbW9kZWxzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MvZGlzdC9sYXlvdXQvcmVzdC1sYXlvdXQtc2VydmljZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL2Rpc3QvbGF5b3V0L3V0aWxzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MvZGlzdC9tZWRpYS1hcGkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy9kaXN0L3V0aWxzL2V4cGVyaWVuY2UtZWRpdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MvZGlzdC91dGlscy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL2Rpc3QvdXRpbHMvaXMtc2VydmVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MvZGlzdC91dGlscy9yZXNvbHZlLXVybC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL25vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3QvZGlzdC9jcmVhdGVSZXF1ZXN0Qm9keS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL25vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3QvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzL25vZGVfbW9kdWxlcy9ncmFwaHFsLXJlcXVlc3QvZGlzdC90eXBlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Fuc2ktc3R5bGVzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jaGFsay9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NoYWxrL25vZGVfbW9kdWxlcy9zdXBwb3J0cy1jb2xvci9icm93c2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY2hhbGsvdGVtcGxhdGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L3JvdXRlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Nyb3NzLWZldGNoL2Rpc3QvYnJvd3Nlci1wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RlYnVnL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Rsdi9kaXN0L2Rsdi51bWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtZmlsZXMvcHVibGljL1JlYWN0TmF0aXZlRmlsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtZmlsZXMvcHVibGljL2V4dHJhY3RGaWxlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtZmlsZXMvcHVibGljL2luZGV4Lm1qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V4dHJhY3QtZmlsZXMvcHVibGljL2lzRXh0cmFjdGFibGVGaWxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2RlZmluZUluc3BlY3QubWpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2luc3BlY3QubWpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC9qc3V0aWxzL2ludmFyaWFudC5tanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2pzdXRpbHMvbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbC5tanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2FzdC5tanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL2Jsb2NrU3RyaW5nLm1qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyYXBocWwvbGFuZ3VhZ2UvcHJpbnRlci5tanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncmFwaHFsL2xhbmd1YWdlL3Zpc2l0b3IubWpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbG9kYXNoLnVuZXNjYXBlL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVtb3J5LWNhY2hlL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1sb2NhbGl6YXRpb24vZGlzdC9pbmRleC5tb2Rlcm4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9saW5rLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvdXNlLWludGVyc2VjdGlvbi50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2FtcC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9taXR0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2VzY2FwZS1wYXRoLWRlbGltaXRlcnMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGF0aC1tYXRjaC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcHJlcGFyZS1kZXN0aW5hdGlvbi50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3NpZGUtZWZmZWN0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9zZXJ2ZXIvZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRob3V0SG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlUmVzdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLXNlcnZlci5icm93c2VyLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5icm93c2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZXF1aXJlcy1wb3J0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcm9zZXR0YS9kaXN0L2luZGV4Lm1qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWF0dHIvbGliL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGVtcGxpdGUvZGlzdC90ZW1wbGl0ZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VybC1wYXJzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvLi9zcmMvTGF5b3V0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL05vdEZvdW5kLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvQ29udGVudEJsb2NrLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvSGVyby50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2ZpZWxkcy9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ2hlY2tib3gudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUNvbnRlbnRMaXN0LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvZmllbGRzL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1DdXN0b20udHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLURhdGUudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUZpbGUudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUltYWdlLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvZmllbGRzL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1JdGVtTGluay50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2ZpZWxkcy9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtTGluay50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2ZpZWxkcy9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtTnVtYmVyLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvZmllbGRzL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1SaWNoVGV4dC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2ZpZWxkcy9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtVGV4dC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2dyYXBocWwvR3JhcGhRTC1Db25uZWN0ZWREZW1vLmdyYXBocWwudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9ncmFwaHFsL0dyYXBoUUwtQ29ubmVjdGVkRGVtby50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2dyYXBocWwvR3JhcGhRTC1JbnRlZ3JhdGVkRGVtby50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2dyYXBocWwvR3JhcGhRTC1MYXlvdXQudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtQ29tcG9uZW50UGFyYW1zLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLUN1c3RvbVJvdXRlVHlwZS50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3N0eWxlZ3VpZGUvU3R5bGVndWlkZS1MYXlvdXQtUmV1c2UudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtTGF5b3V0LVRhYnMtVGFiLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLUxheW91dC1UYWJzLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLUxheW91dC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3N0eWxlZ3VpZGUvU3R5bGVndWlkZS1NdWx0aWxpbmd1YWwudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtUm91dGVGaWVsZHMudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtU2VjdGlvbi50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3N0eWxlZ3VpZGUvU3R5bGVndWlkZS1TaXRlY29yZUNvbnRleHQudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtU3BlY2ltZW4udHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtVHJhY2tpbmcudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvbGliL2RhdGEtZmV0Y2hlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi91dGlsLnRzIiwid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvW1suLi5wYXRoXV0udHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvdGVtcC9jb21wb25lbnRGYWN0b3J5LnRzIiwid2VicGFjazovL19OX0UvLi9zcmMvdGVtcC9jb25maWcuanMiXSwibmFtZXMiOlsicHJlZmV0Y2hlZCIsInJvdXRlciIsImVyciIsImN1ckxvY2FsZSIsIm9wdGlvbnMiLCJocmVmIiwiZXZlbnQiLCJ0YXJnZXQiLCJlIiwibm9kZU5hbWUiLCJpc01vZGlmaWVkRXZlbnQiLCJzY3JvbGwiLCJhcyIsInJlcGxhY2UiLCJzaGFsbG93IiwibG9jYWxlIiwic3VjY2VzcyIsIndpbmRvdyIsImRvY3VtZW50IiwiYXJncyIsImtleSIsImV4cGVjdGVkIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsInByb3BzIiwiY3JlYXRlUHJvcEVycm9yIiwiYWN0dWFsIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsInBhc3NIcmVmIiwicHJlZmV0Y2giLCJvcHRpb25hbFByb3BzIiwidmFsVHlwZSIsImhhc1dhcm5lZCIsIlJlYWN0IiwiY29uc29sZSIsInAiLCJwYXRobmFtZSIsInJlc29sdmVkQXMiLCJjaGlsZHJlbiIsImNoaWxkIiwiQ2hpbGRyZW4iLCJjaGlsZFJlZiIsInJvb3RNYXJnaW4iLCJzZXRSZWYiLCJlbCIsInNldEludGVyc2VjdGlvblJlZiIsInNob3VsZFByZWZldGNoIiwiaXNWaXNpYmxlIiwiaXNQcmVmZXRjaGVkIiwiY2hpbGRQcm9wcyIsInJlZiIsIm9uQ2xpY2siLCJsaW5rQ2xpY2tlZCIsInByaW9yaXR5IiwiTGluayIsInBhdGgiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInByb2Nlc3MiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsInN0YXJ0IiwiRGF0ZSIsInNldFRpbWVvdXQiLCJjYiIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIk1TX01BWF9JRExFX0RFTEFZIiwiZW50cnkiLCJtYXAiLCJQcm9taXNlIiwicHJvbSIsInJlc29sdmUiLCJyZXNvbHZlciIsImZ1dHVyZSIsImdlbmVyYXRvciIsInZhbHVlIiwibGluayIsImNhblByZWZldGNoIiwiaGFzUHJlZmV0Y2giLCJyZXMiLCJBU1NFVF9MT0FEX0VSUk9SIiwiU3ltYm9sIiwic2NyaXB0IiwicmVqZWN0IiwibWFya0Fzc2V0RXJyb3IiLCJvbkJ1aWxkTWFuaWZlc3QiLCJpZGxlVGltZW91dCIsInNjcmlwdHMiLCJhc3NldFByZWZpeCIsImVuY29kZVVSSSIsImNzcyIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJtYW5pZmVzdCIsInJvdXRlIiwiYWxsRmlsZXMiLCJ2IiwiZW50cnlwb2ludHMiLCJsb2FkZWRTY3JpcHRzIiwic3R5bGVTaGVldHMiLCJyb3V0ZXMiLCJhcHBlbmRTY3JpcHQiLCJmZXRjaCIsInRleHQiLCJjb250ZW50Iiwid2hlbkVudHJ5cG9pbnQiLCJ3aXRoRnV0dXJlIiwib25FbnRyeXBvaW50IiwiZm4iLCJleHBvcnRzIiwiY29tcG9uZW50IiwiZXJyb3IiLCJpbnB1dCIsIm9sZCIsImxvYWRSb3V0ZSIsImdldEZpbGVzRm9yUm91dGUiLCJlbnRyeXBvaW50Iiwic3R5bGVzIiwiY24iLCJuYXZpZ2F0b3IiLCJvdXRwdXQiLCJwcmVmZXRjaFZpYURvbSIsImNyZWF0ZVJvdXRlTG9hZGVyIiwic2luZ2xldG9uUm91dGVyIiwicmVhZHlDYWxsYmFja3MiLCJyZWFkeSIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsImdldCIsIlJvdXRlciIsImZpZWxkIiwiZ2V0Um91dGVyIiwiZXZlbnRGaWVsZCIsIl9zaW5nbGV0b25Sb3V0ZXIiLCJtZXNzYWdlIiwiUm91dGVyQ29udGV4dCIsImNyZWF0ZVJvdXRlciIsIl9yb3V0ZXIiLCJpbnN0YW5jZSIsIkFycmF5IiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJpc0Rpc2FibGVkIiwiZGlzYWJsZWQiLCJ1bm9ic2VydmUiLCJvYnNlcnZlIiwic2V0VmlzaWJsZSIsImNyZWF0ZU9ic2VydmVyIiwiZWxlbWVudHMiLCJvYnNlcnZlciIsIm9ic2VydmVycyIsImlkIiwiZW50cmllcyIsImNhbGxiYWNrIiwiQ29tcG9zZWRDb21wb25lbnQiLCJnZXRJbml0aWFsUHJvcHMiLCJXaXRoUm91dGVyV3JhcHBlciIsIm5hbWUiLCJBbXBTdGF0ZUNvbnRleHQiLCJhbXBGaXJzdCIsImh5YnJpZCIsImhhc1F1ZXJ5IiwiaXNJbkFtcE1vZGUiLCJIZWFkTWFuYWdlckNvbnRleHQiLCJpbkFtcE1vZGUiLCJoZWFkIiwibGlzdCIsImZyYWdtZW50TGlzdCIsIk1FVEFUWVBFUyIsImtleXMiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJpIiwibGVuIiwibWV0YXR5cGUiLCJjYXRlZ29yeSIsImNhdGVnb3JpZXMiLCJoZWFkRWxlbWVudHMiLCJoZWFkRWxlbWVudENoaWxkcmVuIiwiaGVhZEVsZW1lbnQiLCJkZWZhdWx0SGVhZCIsInVuaXF1ZSIsImMiLCJhbXBTdGF0ZSIsImhlYWRNYW5hZ2VyIiwiSGVhZCIsInBhdGhuYW1lUGFydHMiLCJsb2NhbGVzIiwiZGV0ZWN0ZWRMb2NhbGUiLCJhbGwiLCJvbiIsIm9mZiIsImVtaXQiLCJoYW5kbGVyIiwiYmFzZVBhdGgiLCJjYW5jZWxsZWQiLCJwcmVmaXgiLCJhZGRQYXRoUHJlZml4IiwidXJsIiwibG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsImhhc0Jhc2VQYXRoIiwiaW50ZXJwb2xhdGVkUm91dGUiLCJkeW5hbWljUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJhc1BhdGhuYW1lIiwicGFyYW1zIiwicGFyYW0iLCJyZXBsYWNlZCIsInJlcGVhdCIsIm9wdGlvbmFsIiwiZXNjYXBlUGF0aERlbGltaXRlcnMiLCJyZXN1bHQiLCJmaWx0ZXJlZFF1ZXJ5IiwicXVlcnkiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJpc0xvY2FsVVJMIiwicmVzb2x2ZUFzIiwiZmluYWxVcmwiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJoYXNoIiwib21pdFBhcm1zRnJvbVF1ZXJ5IiwicmVzb2x2ZWRIcmVmIiwiYWRkQmFzZVBhdGgiLCJyZXNvbHZlSHJlZiIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiU1NHX0RBVEFfTk9UX0ZPVU5EX0VSUk9SIiwiY3JlZGVudGlhbHMiLCJhdHRlbXB0cyIsImZldGNoUmV0cnkiLCJpc1NlcnZlclJlbmRlciIsImNvbnN0cnVjdG9yIiwiYXNQYXRoIiwiY29tcG9uZW50cyIsInNkYyIsInN1YiIsImNsYyIsInBhZ2VMb2FkZXIiLCJfYnBzIiwiZXZlbnRzIiwiX3dyYXBBcHAiLCJpc1NzciIsImlzRmFsbGJhY2siLCJfaW5GbGlnaHRSb3V0ZSIsIl9zaGFsbG93IiwiZGVmYXVsdExvY2FsZSIsInN0YXRlIiwiQ29tcG9uZW50IiwiaW5pdGlhbCIsIl9fTl9TU0ciLCJpbml0aWFsUHJvcHMiLCJfX05fU1NQIiwiX19ORVhUX0RBVEFfXyIsInJlbG9hZCIsInByZXBhcmVVcmxBcyIsImxvY2FsZUNoYW5nZSIsInJlcXVpcmUiLCJwYXJzZWRBcyIsImRlbEJhc2VQYXRoIiwibG9jYWxlUGF0aFJlc3VsdCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJhZGRMb2NhbGUiLCJTVCIsInBlcmZvcm1hbmNlIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwicGFyc2VkIiwicGFnZXMiLCJfX3Jld3JpdGVzIiwibWV0aG9kIiwicG90ZW50aWFsSHJlZiIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwic2hvdWxkSW50ZXJwb2xhdGUiLCJtaXNzaW5nUGFyYW1zIiwicm91dGVJbmZvIiwiZGVzdGluYXRpb24iLCJwYXJzZWRIcmVmIiwiYXBwQ29tcCIsIl9fTiIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJzc2c0MDQiLCJwYWdlIiwibW9kIiwiZXhpc3RpbmdSb3V0ZUluZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJkYXRhSHJlZiIsIm9ubHlBSGFzaENoYW5nZSIsIm5ld0hhc2giLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwic2Nyb2xsVG9IYXNoIiwiaWRFbCIsIm5hbWVFbCIsInVybElzTmV3IiwiX3Jlc29sdmVIcmVmIiwiYXBwbHlCYXNlUGF0aCIsImNsZWFuUGF0aG5hbWUiLCJpc1NzZyIsImNhbmNlbCIsImNvbXBvbmVudFJlc3VsdCIsImRhdGEiLCJfZ2V0U3RhdGljRGF0YSIsImZldGNoTmV4dERhdGEiLCJfZ2V0U2VydmVyRGF0YSIsIkFwcFRyZWUiLCJjdHgiLCJhYm9ydENvbXBvbmVudExvYWQiLCJub3RpZnkiLCJzZWdtZW50IiwiY2hhciIsImVuY29kZVVSSUNvbXBvbmVudCIsInNsYXNoZWRQcm90b2NvbHMiLCJwcm90b2NvbCIsInVybE9iaiIsImhvc3QiLCJhdXRoIiwiaG9zdG5hbWUiLCJTdHJpbmciLCJxdWVyeXN0cmluZyIsInNlYXJjaCIsImV4dCIsIlRFU1RfUk9VVEUiLCJnbG9iYWxCYXNlIiwicmVzb2x2ZWRCYXNlIiwib3JpZ2luIiwibWF0Y2hlck9wdGlvbnMiLCJzZW5zaXRpdmUiLCJkZWxpbWl0ZXIiLCJjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zIiwic3RyaWN0IiwiY3VzdG9tUm91dGUiLCJtYXRjaGVyUmVnZXgiLCJwYXRoVG9SZWdleHAiLCJtYXRjaGVyIiwidmFsaWRhdGUiLCJwYXJzZWREZXN0aW5hdGlvbiIsImhhZExvY2FsZSIsInBvcnQiLCJkZXN0UXVlcnkiLCJkZXN0UGF0aCIsImRlc3RQYXRoUGFyYW1LZXlzIiwiZGVzdFBhdGhQYXJhbXMiLCJkZXN0aW5hdGlvbkNvbXBpbGVyIiwic3RyT3JBcnJheSIsImNvbXBpbGVOb25QYXRoIiwicGFyYW1LZXlzIiwiYXBwZW5kUGFyYW1zVG9RdWVyeSIsInNob3VsZEFkZEJhc2VQYXRoIiwibmV3VXJsIiwic2VhcmNoUGFyYW1zIiwiaXNOYU4iLCJpdGVtIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInNlYXJjaFBhcmFtc0xpc3QiLCJjdXN0b21Sb3V0ZU1hdGNoZXIiLCJyZXdyaXRlIiwiZGVzdFJlcyIsInJlIiwiZGVjb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2x1Z05hbWUiLCJnIiwiZ3JvdXBzIiwibSIsInN0ciIsInNlZ21lbnRzIiwibm9ybWFsaXplZFJvdXRlIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsInBhcnNlUGFyYW1ldGVyIiwicG9zIiwiZXNjYXBlUmVnZXgiLCJpc1NlcnZlciIsIl9oYXNIZWFkTWFuYWdlciIsImVtaXRDaGFuZ2UiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVuZGVyIiwidXNlZCIsImdldExvY2F0aW9uT3JpZ2luIiwiQXBwIiwiZ2V0RGlzcGxheU5hbWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwicGFnZVByb3BzIiwiaXNSZXNTZW50IiwidXJsT2JqZWN0S2V5cyIsIlNQIiwicHVibGljVXJsIiwiZ2V0UHVibGljVXJsIiwiTmF2aWdhdGlvbiIsInVzZUkxOG4iLCJ0IiwiTGF5b3V0IiwiY29udGV4dCIsInVzZVNpdGVjb3JlQ29udGV4dCIsInVwZGF0YWJsZSIsInVwZGF0ZVNpdGVjb3JlQ29udGV4dCIsInVzZUVmZmVjdCIsImZpZWxkcyIsInBhZ2VUaXRsZSIsIk5vdEZvdW5kIiwicGFkZGluZyIsIkNvbnRlbnRCbG9jayIsImhlYWRpbmciLCJIZXJvIiwidGVhc2VyIiwiU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCIsImNoZWNrYm94IiwiZ2V0RmllbGRWYWx1ZSIsIlN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QiLCJzaGFyZWRDb250ZW50TGlzdCIsImxvY2FsQ29udGVudExpc3QiLCJsaXN0SXRlbSIsImluZGV4IiwidGV4dEZpZWxkIiwiU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20iLCJjdXN0b21JbnRGaWVsZCIsIlN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSIsImRhdGUiLCJkYXRlVGltZSIsInRvVVRDU3RyaW5nIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwidG9Mb2NhbGVTdHJpbmciLCJTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUiLCJmaWxlIiwiU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSIsInNhbXBsZTEiLCJzYW1wbGUyIiwibXciLCJtaCIsIlN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsiLCJzaGFyZWRJdGVtTGluayIsImxvY2FsSXRlbUxpbmsiLCJTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsiLCJleHRlcm5hbExpbmsiLCJpbnRlcm5hbExpbmsiLCJlbWFpbExpbmsiLCJwYXJhbXNMaW5rIiwiU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0IiwiZmllbGRWYWx1ZSIsInNhbXBsZSIsIlN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQiLCJJdGVtU2VhcmNoT3BlcmF0b3IiLCJPcmRlcmluZyIsIkNvbm5lY3RlZERlbW9RdWVyeURvY3VtZW50IiwiR3JhcGhRTENvbm5lY3RlZERlbW8iLCJyZW5kZXJpbmciLCJ1aWQiLCJ1c2VDb21wb25lbnRQcm9wcyIsInVuZGVmaW5lZCIsImRhdGFzb3VyY2UiLCJqc29uVmFsdWUiLCJkZWZpbml0aW9uIiwidHlwZSIsInNoYXJlZCIsInRvU3RyaW5nIiwiY29udGV4dEl0ZW0iLCJyZXN1bHRzIiwicm91dGVJdGVtIiwiZ2V0U3RhdGljUHJvcHMiLCJsYXlvdXREYXRhIiwiZW52IiwiSlNTX01PREUiLCJKU1NfTU9ERV9ESVNDT05ORUNURUQiLCJncmFwaFFMQ2xpZW50IiwiR3JhcGhRTFJlcXVlc3RDbGllbnQiLCJjb25maWciLCJncmFwaFFMRW5kcG9pbnQiLCJhcGlLZXkiLCJzaXRlY29yZUFwaUtleSIsInJlcXVlc3QiLCJkYXRhU291cmNlIiwic2l0ZWNvcmUiLCJpdGVtSWQiLCJsYW5ndWFnZSIsImdldFNlcnZlclNpZGVQcm9wcyIsIkdyYXBoUUxJbnRlZ3JhdGVkRGVtbyIsIkpTT04iLCJzdHJpbmdpZnkiLCJHcmFwaFFMTGF5b3V0Iiwic2l0ZWNvcmVDb250ZXh0IiwiZGlzY29ubmVjdGVkTW9kZSIsImxheW91dElkIiwiU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcyIsImNzc0NsYXNzIiwiY29sdW1ucyIsInVzZUNhbGxUb0FjdGlvbiIsImNvbHVtbnNBcnJheSIsInBhcnNlSW50IiwiU3R5bGVndWlkZUN1c3RvbVJvdXRlVHlwZSIsImhlYWRsaW5lIiwiYXV0aG9yIiwiU3R5bGVndWlkZUxheW91dFJldXNlIiwiU3R5bGVndWlkZUxheW91dFRhYnNUYWIiLCJwYWdlRWRpdGluZyIsInRpdGxlIiwiU3R5bGVndWlkZUxheW91dFRhYnMiLCJhY3RpdmVUYWJJbmRleCIsInNldEFjdGl2ZVRhYiIsImJpbmQiLCJzZXRTdGF0ZSIsInRhYnNQbGFjZWhvbGRlciIsInZhbGlkVGFiSW5kZXgiLCJpc0VkaXRpbmciLCJmaWx0ZXIiLCJ0YWIiLCJpc1ZhbGlkIiwidGFic0NvbXBvbmVudFdpdGhQbGFjZWhvbGRlckluamVjdGVkIiwid2l0aFBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXIiLCJwcm9wIiwidGFic1dpdGhQbGFjZWhvbGRlckFuZFNpdGVjb3JlQ29udGV4dCIsIndpdGhTaXRlY29yZUNvbnRleHQiLCJTdHlsZWd1aWRlTGF5b3V0IiwiZ2V0UmVuZGVyaW5nIiwic2VjdGlvbiIsImNvbnZlcnRVSUQiLCJzZWN0aW9ucyIsImdldENoaWxkUGxhY2Vob2xkZXIiLCJTdHlsZWd1aWRlTXVsdGlsaW5ndWFsIiwiU3R5bGVndWlkZVJvdXRlRmllbGRzIiwiU3R5bGVndWlkZVNlY3Rpb24iLCJTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0IiwibWF4SGVpZ2h0Iiwib3ZlcmZsb3ciLCJTdHlsZWd1aWRlU3BlY2ltZW4iLCJlMmVJZCIsIlN0eWxlZ3VpZGVUcmFja2luZyIsImNyZWF0ZVJlZiIsImdvYWwiLCJvdXRjb21lTmFtZSIsIm91dGNvbWVWYWx1ZSIsImNhbXBhaWduIiwicGFnZUlkIiwicGFnZVVybCIsInRyYWNraW5nQXBpT3B0aW9ucyIsInNpdGVjb3JlQXBpSG9zdCIsInF1ZXJ5c3RyaW5nUGFyYW1zIiwic2NfYXBpa2V5IiwiZmV0Y2hlciIsImRhdGFGZXRjaGVyIiwiY3VycmVudCIsInRyYWNraW5nQXBpIiwidHJhY2tFdmVudCIsImV2ZW50SWQiLCJ0aGVuIiwiYWxlcnQiLCJnb2FsSWQiLCJvdXRjb21lSWQiLCJjdXJyZW5jeUNvZGUiLCJtb25ldGFyeVZhbHVlIiwiY2FtcGFpZ25JZCIsImFiYW5kb25PcHRpb25zIiwiYWN0aW9uIiwic3VibWl0RXZlbnQiLCJzdWJtaXRHb2FsIiwic3VibWl0T3V0Y29tZSIsInRyaWdnZXJDYW1wYWlnbiIsInN1Ym1pdFBhZ2VWaWV3Iiwic3VibWl0QmF0Y2hpbmciLCJhYmFuZG9uU2Vzc2lvbiIsIkF4aW9zRGF0YUZldGNoZXIiLCJTaXRlY29yZVBhZ2UiLCJub3RGb3VuZCIsImNvbXBvbmVudFByb3BzIiwiaGFuZGxlRXhwZXJpZW5jZUVkaXRvckZhc3RSZWZyZXNoIiwiY29tcG9uZW50RmFjdG9yeSIsIk1hcCIsInNldCIsIlN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyIiwiY29tcG9uZW50TW9kdWxlIiwiY29tcG9uZW50TmFtZSIsIlNJVEVDT1JFX0FQSV9LRVkiLCJTSVRFQ09SRV9BUElfSE9TVCIsImpzc0FwcE5hbWUiLCJKU1NfQVBQX05BTUUiLCJncmFwaFFMRW5kcG9pbnRQYXRoIiwiR1JBUEhfUUxfRU5EUE9JTlRfUEFUSCIsIkdSQVBIX1FMX0VORFBPSU5UIiwibW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsMkRBQWEsR0FBRztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxjQUFjO0FBQzNCO0FBQ087QUFDUCxpQkFBaUIsd0RBQVU7QUFDM0I7QUFDQTtBQUNPLGdDQUFnQyxtQkFBbUIsTUFBTSw0Q0FBSyxxREFBcUQsZUFBZTs7Ozs7Ozs7Ozs7OztBQ2Z6STtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQWMsU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBCO0FBQ1M7QUFDRjtBQUNvRDtBQUM5RTtBQUNQLFdBQVcsMEVBQTBFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFLLGVBQWUsZ0RBQVEsR0FBRyx5Q0FBeUM7QUFDNUYsZ0JBQWdCLDRDQUFLLG1DQUFtQyxtRUFBbUU7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUFLLGVBQWUscUVBQVMsa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCLGlEQUFTLHFCQUFxQixFQUFFLDhFQUFh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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU8sUUFBUTtBQUMvQixnQkFBZ0IsT0FBTyxRQUFRO0FBQy9CLGlCQUFpQixPQUFPLE9BQU87QUFDL0IsaUJBQWlCLE9BQU8sT0FBTztBQUMvQixnQkFBZ0IsUUFBUSxPQUFPO0FBQy9CLGdCQUFnQixRQUFRLE9BQU87QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLEVBQUUsVUFBVSxFQUFFO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWEsYUFBYTtBQUN6QztBQUNBLGVBQWUsYUFBYSxhQUFhO0FBQ3pDO0FBQ0EsZUFBZSxhQUFhLGFBQWE7QUFDekM7QUFDQSxlQUFlLGFBQWEsYUFBYTtBQUN6QztBQUNBLGVBQWUsYUFBYSxhQUFhO0FBQ3pDO0FBQ0EsZUFBZSxhQUFhO0FBQzVCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ24yQkEsa0JBQWtCLG1CQUFPLENBQUMsa0VBQWU7QUFDekMsWUFBWSxtQkFBTyxDQUFDLHNEQUFTOztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3REFBd0QsdUNBQXVDO0FBQy9GLHNEQUFzRCxxQ0FBcUM7O0FBRTNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7Ozs7Ozs7Ozs7OztBQzdFQSxrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBZTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDL0ZZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFP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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pLQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUVBQWdCO0FBQzNDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QVEsUUFBUSxVQUFVLFNBQVMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUN0TWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVUsS0FBcUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNB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QUFFQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGVBQWU7QUFDN0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVAsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQztBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUI7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7QUFHakI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrSUFBK0k7O0FBRS9JO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsb0VBQW9FLDRDQUE0QztBQUNoSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZ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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFLFlBQVk7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJIQUEySCw2QkFBNkI7QUFDeEo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5Qiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7OztBQUdqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7OztBQUdqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkU7O0FBRTdFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0pBQXNKLGlCQUFpQjtBQUN2SyxPQUFPO0FBQ1Asc0pBQXNKLGlCQUFpQix3REFBd0QsbUJBQW1CLGdCQUFnQiw4QkFBOEI7QUFDaFM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0Esb0dBQW9HLEdBQUc7O0FBRXZHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFrRTs7QUFFbEUsd0NBQXdDOztBQUV4QywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsbUJBQW1COztBQUVuQixtQ0FBbUMsUUFBUTtBQUMzQyw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsb0RBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsMENBQTBDLHFCQUFxQjtBQUMvRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0EsNEpBQTRKLFNBQTJCO0FBQ3ZMO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ1BBQWdQLFNBQTJCO0FBQzNRO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2Isa0JBQWtCLElBQU07QUFDeEI7QUFDQSx1RkFBdUYsU0FBMkI7QUFDbEg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QU8sQ0FBQywySEFBK0M7QUFDMUU7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7O0FBSWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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LFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFNQTs7QUFNQTs7QUFPQTs7QUFLQTs7QUF5QkE7O0FBT0E7O0FBU0E7O0FBTUE7O0FBTUE7O0FBT0E7O0FBS0E7O0FBK0JBOztBQU9BOztBQVNBOztBQU1BOztBQU1BOztBQU9BOztBQUtBOztBQStCQTs7QUFPQTs7QUFTQTs7QUFNQTs7QUFNQTs7QUFPQTs7QUFLQTs7QUE2QkE7O0FBT0E7O0FBU0E7O0FBTUE7O0FBTUE7O0FBT0E7O0FBS0E7O0FBbUNBOztBQU9BOztBQVNBOztBQU1BOztBQU1BOztBQU9BOztBQUtBOztBQStCQTs7QUFPQTs7QUFTQTs7QUFNQTs7QUFNQTs7QUFPQTs7QUFLQTs7QUErQkE7O0FBT0E7O0FBU0E7O0FBTUE7O0FBTUE7O0FBT0E7O0FBS0E7O0FBNkJBOztBQU9BOztBQVNBOztBQU1BOztBQU1BOztBQU9BOztBQUtBOztBQStCQTs7QUFPQTs7QUFTQTs7QUFNQTs7QUFNQTs7QUFPQTs7QUFLQTs7QUE2QkE7O0FBT0E7O0FBU0E7O0FBTUE7O0FBTUE7O0FBT0E7O0FBS0E7O0FBK0JBOztBQU9BOztBQVNBOztBQU1BOztBQU1BOztBQU9BOztBQUtBOztBQStCQTs7QUFPQTs7QUFTQTs7QUFNQTs7QUFNQTs7QUFPQTs7QUFLQTs7QUEyQkE7O0FBT0E7O0FBU0E7O0FBTUE7O0FBTUE7O0FBT0E7O0FBS0E7O0FBeUJBOztBQU9BOztBQVNBOztBQU1BOztBQU1BOztBQU9BOztBQUtBOztBQTZCQTs7QUFPQTs7QUFTQTs7QUFNQTs7QUFNQTs7QUFPQTs7QUFLQTs7QUEyQkE7O0FBT0E7O0FBU0E7O0FBTUE7O0FBTUE7O0FBT0E7O0FBS0E7O0FBdUJBOztBQU9BOztBQVNBOztBQU1BOztBQU1BOztBQU9BOztBQUtBOztBQXVCQTs7QUFPQTs7QUFTQTs7QUFNQTs7QUFNQTs7QUFPQTs7QUFLQTs7QUF5QkE7O0FBT0E7O0FBU0E7O0FBTUE7O0FBTUE7O0FBT0E7O0FBS0E7O0FBK0VBOztBQU9BOztBQVNBOztBQU1BOztBQU1BOztBQU9BOztBQUtBOztBQXlGQTs7QUFPQTs7QUFT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Q0EsSUFBTXpHLE1BQU0sR0FBRyxFQUFmO0FBQ0FBLE1BQU0sQ0FBQ0csY0FBUCxHQUF3QnJhLE9BQU8sQ0FBQzZaLEdBQVIsQ0FBWStHLGdCQUFaLElBQWdDLHNDQUF4RCxFQUNBMUcsTUFBTSxDQUFDc0UsZUFBUCxHQUF5QnhlLE9BQU8sQ0FBQzZaLEdBQVIsQ0FBWWdILGlCQUFaLElBQWlDLHdCQUQxRCxFQUVBM0csTUFBTSxDQUFDNEcsVUFBUCxHQUFvQjlnQixPQUFPLENBQUM2WixHQUFSLENBQVlrSCxZQUFaLElBQTRCLGdCQUZoRCxFQUdBN0csTUFBTSxDQUFDOEcsbUJBQVAsR0FBNkJoaEIsT0FBTyxDQUFDNlosR0FBUixDQUFZb0gsc0JBQVosSUFBc0MsMEJBSG5FLEVBSUEvRyxNQUFNLENBQUNDLGVBQVAsR0FBeUJuYSxPQUFPLENBQUM2WixHQUFSLENBQVlxSCxpQkFBWixjQUFvQ2hILE1BQU0sQ0FBQ3NFLGVBQTNDLFNBQTZEdEUsTUFBTSxDQUFDOEcsbUJBQXBFLENBSnpCO0FBS0FHLE1BQU0sQ0FBQy9kLE9BQVAsR0FBaUI4VyxNQUFqQiIsImZpbGUiOiJzdGF0aWMvY2h1bmtzL3BhZ2VzL1tbLi4ucGF0aF1dLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG4vKipcbiAqIENvbXBvbmVudCBwcm9wcyBjb250ZXh0IHdoaWNoIHdlIGFyZSB1c2luZyBpbiBvcmRlciB0byBzdG9yZSBkYXRhIGZldGNoZWQgb24gY29tcG9uZW50cyBsZXZlbCAoZ2V0U3RhdGljUHJvcHMvZ2V0U2VydmVyU2lkZVByb3BzKVxuICovXG5leHBvcnQgY29uc3QgQ29tcG9uZW50UHJvcHNSZWFjdENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbi8qKlxuICogSG9vayBpbiBvcmRlciB0byBnZXQgYWNjZXNzIHRvIHByb3BzIHJlbGF0ZWQgdG8gc3BlY2lmaWMgY29tcG9uZW50LiBEYXRhIGNvbWVzIGZyb20gQ29tcG9uZW50UHJvcHNDb250ZXh0LlxuICogQHNlZSBDb21wb25lbnRQcm9wc0NvbnRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRVaWQgY29tcG9uZW50IHVJZFxuICogQHJldHVybnMge0NvbXBvbmVudERhdGF9IGNvbXBvbmVudCBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29tcG9uZW50UHJvcHMoY29tcG9uZW50VWlkKSB7XG4gICAgY29uc3QgZGF0YSA9IHVzZUNvbnRleHQoQ29tcG9uZW50UHJvcHNSZWFjdENvbnRleHQpO1xuICAgIHJldHVybiBkYXRhW2NvbXBvbmVudFVpZF07XG59XG5leHBvcnQgY29uc3QgQ29tcG9uZW50UHJvcHNDb250ZXh0ID0gKHsgY2hpbGRyZW4sIHZhbHVlLCB9KSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnRQcm9wc1JlYWN0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUgfSwgY2hpbGRyZW4pKTtcbiIsInZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IE5leHRMaW5rIGZyb20gJ25leHQvbGluayc7XG5pbXBvcnQgeyBMaW5rIGFzIFJlYWN0TGluaywgTGlua1Byb3BUeXBlcywgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1yZWFjdCc7XG5leHBvcnQgY29uc3QgTGluayA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgZWRpdGFibGUsIGludGVybmFsTGlua01hdGNoZXIgPSAvXlxcLy9nLCBzaG93TGlua1RleHRXaXRoQ2hpbGRyZW5QcmVzZW50IH0gPSBwcm9wcywgaHRtbExpbmtQcm9wcyA9IF9fcmVzdChwcm9wcywgW1wiZWRpdGFibGVcIiwgXCJpbnRlcm5hbExpbmtNYXRjaGVyXCIsIFwic2hvd0xpbmtUZXh0V2l0aENoaWxkcmVuUHJlc2VudFwiXSk7XG4gICAgY29uc3QgdmFsdWUgPSAocHJvcHMuZmllbGQuaHJlZlxuICAgICAgICA/IHByb3BzLmZpZWxkXG4gICAgICAgIDogcHJvcHMuZmllbGQudmFsdWUpO1xuICAgIGNvbnN0IHsgaHJlZiB9ID0gdmFsdWU7XG4gICAgY29uc3QgaXNFZGl0aW5nID0gZWRpdGFibGUgJiYgcHJvcHMuZmllbGQuZWRpdGFibGU7XG4gICAgaWYgKGhyZWYgJiYgIWlzRWRpdGluZykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gc2hvd0xpbmtUZXh0V2l0aENoaWxkcmVuUHJlc2VudCB8fCAhcHJvcHMuY2hpbGRyZW4gPyB2YWx1ZS50ZXh0IHx8IHZhbHVlLmhyZWYgOiBudWxsO1xuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgYSBsaW5rIGlzIGEgcm91dGUgb3Igbm90LlxuICAgICAgICBpZiAoaW50ZXJuYWxMaW5rTWF0Y2hlci50ZXN0KGhyZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTmV4dExpbmssIHsgaHJlZjogaHJlZiwga2V5OiBcImxpbmtcIiwgbG9jYWxlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIE9iamVjdC5hc3NpZ24oeyB0aXRsZTogdmFsdWUudGl0bGUsIHRhcmdldDogdmFsdWUudGFyZ2V0LCBjbGFzc05hbWU6IHZhbHVlLmNsYXNzIH0sIGh0bWxMaW5rUHJvcHMpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGlsZHJlbikpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdExpbmssIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSk7XG59O1xuTGluay5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZWRpdGFibGU6IHRydWUsXG59O1xuTGluay5kaXNwbGF5TmFtZSA9ICdOZXh0TGluayc7XG5MaW5rLnByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oeyBpbnRlcm5hbExpbmtNYXRjaGVyOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihSZWdFeHApIH0sIExpbmtQcm9wVHlwZXMpO1xuIiwidmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJztcbmltcG9ydCB7IFJpY2hUZXh0IGFzIFJlYWN0UmljaFRleHQsIFJpY2hUZXh0UHJvcFR5cGVzLCB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLXJlYWN0JztcbmNvbnN0IHByZWZldGNoZWQgPSB7fTtcbmV4cG9ydCBjb25zdCBSaWNoVGV4dCA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgaW50ZXJuYWxMaW5rc1NlbGVjdG9yID0gJ2FbaHJlZl49XCIvXCJdJyB9ID0gcHJvcHMsIHJlc3QgPSBfX3Jlc3QocHJvcHMsIFtcImludGVybmFsTGlua3NTZWxlY3RvclwiXSk7XG4gICAgY29uc3QgaGFzVGV4dCA9IHByb3BzLmZpZWxkICYmIHByb3BzLmZpZWxkLnZhbHVlO1xuICAgIGNvbnN0IGlzRWRpdGluZyA9IHByb3BzLmVkaXRhYmxlICYmIHByb3BzLmZpZWxkICYmIHByb3BzLmZpZWxkLmVkaXRhYmxlO1xuICAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICAgIGNvbnN0IHJpY2hUZXh0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIE5PVCBJTiBFWFBFUklFTkNFIEVESVRPUlxuICAgICAgICBpZiAoaGFzVGV4dCAmJiAhaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplTGlua3MoKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBjb25zdCByb3V0ZUhhbmRsZXIgPSAoZXYpID0+IHtcbiAgICAgICAgaWYgKCFldi50YXJnZXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gZXYudGFyZ2V0LnBhdGhuYW1lO1xuICAgICAgICByb3V0ZXIucHVzaChwYXRobmFtZSwgcGF0aG5hbWUsIHsgbG9jYWxlOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGluaXRpYWxpemVMaW5rcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHJpY2hUZXh0UmVmLmN1cnJlbnQ7XG4gICAgICAgIC8vIHNlbGVjdHMgYWxsIGxpbmtzIHRoYXQgc3RhcnQgd2l0aCAnLydcbiAgICAgICAgY29uc3QgaW50ZXJuYWxMaW5rcyA9IG5vZGUgJiYgbm9kZS5xdWVyeVNlbGVjdG9yQWxsKGludGVybmFsTGlua3NTZWxlY3Rvcik7XG4gICAgICAgIGlmICghaW50ZXJuYWxMaW5rcyB8fCAhaW50ZXJuYWxMaW5rcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGludGVybmFsTGlua3MuZm9yRWFjaCgobGluaykgPT4ge1xuICAgICAgICAgICAgaWYgKCFwcmVmZXRjaGVkW2xpbmsucGF0aG5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcm91dGVyLnByZWZldGNoKGxpbmsucGF0aG5hbWUsIHVuZGVmaW5lZCwgeyBsb2NhbGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHByZWZldGNoZWRbbGluay5wYXRobmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvdXRlSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0UmljaFRleHQsIE9iamVjdC5hc3NpZ24oeyByZWY6IHJpY2hUZXh0UmVmIH0sIHJlc3QpKTtcbn07XG5SaWNoVGV4dC5wcm9wVHlwZXMgPSBPYmplY3QuYXNzaWduKHsgaW50ZXJuYWxMaW5rc1NlbGVjdG9yOiBQcm9wVHlwZXMuc3RyaW5nIH0sIFJpY2hUZXh0UHJvcFR5cGVzKTtcblJpY2hUZXh0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICB0YWc6ICdkaXYnLFxuICAgIGVkaXRhYmxlOiB0cnVlLFxufTtcblJpY2hUZXh0LmRpc3BsYXlOYW1lID0gJ05leHRSaWNoVGV4dCc7XG4iLCJleHBvcnQgY29uc3QgSlNTX01PREVfQ09OTkVDVEVEID0gJ2Nvbm5lY3RlZCc7XG5leHBvcnQgY29uc3QgSlNTX01PREVfRElTQ09OTkVDVEVEID0gJ2Rpc2Nvbm5lY3RlZCc7XG4iLCJleHBvcnQgeyBkYXRhQXBpLCBtZWRpYUFwaSwgQXhpb3NEYXRhRmV0Y2hlciwgR3JhcGhRTFJlcXVlc3RDbGllbnQsIEdyYXBoUUxEaWN0aW9uYXJ5U2VydmljZSwgUmVzdERpY3Rpb25hcnlTZXJ2aWNlLCBMYXlvdXRTZXJ2aWNlUGFnZVN0YXRlLCBHcmFwaFFMTGF5b3V0U2VydmljZSwgUmVzdExheW91dFNlcnZpY2UsIGlzRXhwZXJpZW5jZUVkaXRvckFjdGl2ZSwgcmVzZXRFeHBlcmllbmNlRWRpdG9yQ2hyb21lcywgZ2V0Q2hpbGRQbGFjZWhvbGRlciwgZ2V0RmllbGRWYWx1ZSwgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQgeyBDb21wb25lbnRQcm9wc1NlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL2NvbXBvbmVudC1wcm9wcy1zZXJ2aWNlJztcbmV4cG9ydCB7IERpc2Nvbm5lY3RlZFNpdGVtYXBTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9kaXNjb25uZWN0ZWQtc2l0ZW1hcC1zZXJ2aWNlJztcbmV4cG9ydCB7IEdyYXBoUUxTaXRlbWFwU2VydmljZSwgfSBmcm9tICcuL3NlcnZpY2VzL2dyYXBocWwtc2l0ZW1hcC1zZXJ2aWNlJztcbmV4cG9ydCB7IENvbXBvbmVudFByb3BzUmVhY3RDb250ZXh0LCBDb21wb25lbnRQcm9wc0NvbnRleHQsIHVzZUNvbXBvbmVudFByb3BzLCB9IGZyb20gJy4vY29tcG9uZW50cy9Db21wb25lbnRQcm9wc0NvbnRleHQnO1xuZXhwb3J0IHsgaGFuZGxlRXhwZXJpZW5jZUVkaXRvckZhc3RSZWZyZXNoIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgeyBpc0VkaXRpbmdEYXRhIH0gZnJvbSAnLi9zaGFyZWRUeXBlcy9lZGl0aW5nLWRhdGEnO1xuZXhwb3J0IHsgRWRpdGluZ0RhdGFTZXJ2aWNlLCBlZGl0aW5nRGF0YVNlcnZpY2UsIH0gZnJvbSAnLi9zZXJ2aWNlcy9lZGl0aW5nLWRhdGEtc2VydmljZSc7XG5leHBvcnQgeyBMaW5rIH0gZnJvbSAnLi9jb21wb25lbnRzL0xpbmsnO1xuZXhwb3J0IHsgUmljaFRleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvUmljaFRleHQnO1xuZXhwb3J0IHsgUGxhY2Vob2xkZXIsIEltYWdlLCBUZXh0LCBEYXRlRmllbGQsIEZpbGUsIFZpc2l0b3JJZGVudGlmaWNhdGlvbiwgU2l0ZWNvcmVDb250ZXh0LCBTaXRlY29yZUNvbnRleHRSZWFjdENvbnRleHQsIHdpdGhTaXRlY29yZUNvbnRleHQsIHVzZVNpdGVjb3JlQ29udGV4dCwgd2l0aEV4cGVyaWVuY2VFZGl0b3JDaHJvbWVzLCB3aXRoUGxhY2Vob2xkZXIsIH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtcmVhY3QnO1xuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xuZXhwb3J0IGNsYXNzIENvbXBvbmVudFByb3BzU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogU1NSIG1vZGVcbiAgICAgKiBGZXRjaCBjb21wb25lbnQgcHJvcHMgdXNpbmcgZ2V0U2VydmVyU2lkZVByb3BzIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGZXRjaENvbXBvbmVudFByb3BzQXJndW1lbnRzPEdldFNlcnZlclNpZGVQcm9wc0NvbnRleHQ+fSBwYXJhbXMgZmV0Y2ggcGFyYW1zXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29tcG9uZW50UHJvcHNDb2xsZWN0aW9uPn0gcHJvcHNcbiAgICAgKi9cbiAgICBmZXRjaFNlcnZlclNpZGVDb21wb25lbnRQcm9wcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29tcG9uZW50TW9kdWxlLCBsYXlvdXREYXRhLCBjb250ZXh0IH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBmZXRjaEZ1bmN0aW9uRmFjdG9yeSA9IChjb21wb25lbnROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gY29tcG9uZW50TW9kdWxlKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUuZ2V0U2VydmVyU2lkZVByb3BzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoQ29tcG9uZW50UHJvcHMoZmV0Y2hGdW5jdGlvbkZhY3RvcnksIGxheW91dERhdGEsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU1NHIG1vZGVcbiAgICAgKiBGZXRjaCBjb21wb25lbnQgcHJvcHMgdXNpbmcgZ2V0U3RhdGljUHJvcHMgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ZldGNoQ29tcG9uZW50UHJvcHNBcmd1bWVudHM8R2V0U3RhdGljUHJvcHNDb250ZXh0Pn0gcGFyYW1zIGZldGNoIGFyZ3VtZW50c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbXBvbmVudFByb3BzQ29sbGVjdGlvbj59IHByb3BzXG4gICAgICovXG4gICAgZmV0Y2hTdGF0aWNDb21wb25lbnRQcm9wcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29tcG9uZW50TW9kdWxlLCBsYXlvdXREYXRhLCBjb250ZXh0IH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBmZXRjaEZ1bmN0aW9uRmFjdG9yeSA9IChjb21wb25lbnROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gY29tcG9uZW50TW9kdWxlKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUgPT09IG51bGwgfHwgbW9kdWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb2R1bGUuZ2V0U3RhdGljUHJvcHM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hDb21wb25lbnRQcm9wcyhmZXRjaEZ1bmN0aW9uRmFjdG9yeSwgbGF5b3V0RGF0YSwgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSBMYXlvdXQgU2VydmljZSBkYXRhIHRyZWUgYW5kIGNhbGwgc2lkZSBlZmZlY3RzIG9uIGNvbXBvbmVudCBsZXZlbC5cbiAgICAgKiBTaWRlIGVmZmVjdCBmdW5jdGlvbiBjYW4gYmU6IGdldFN0YXRpY1Byb3BzIChTU0cpIG9yIGdldFNlcnZlclNpZGVQcm9wcyAoU1NSKVxuICAgICAqIEBwYXJhbSB7RmV0Y2hGdW5jdGlvbkZhY3Rvcnk8TmV4dENvbnRleHQ+fSBmZXRjaEZ1bmN0aW9uRmFjdG9yeSBmZXRjaCBmdW5jdGlvbiBmYWN0b3J5XG4gICAgICogQHBhcmFtIHtMYXlvdXRTZXJ2aWNlRGF0YX0gbGF5b3V0RGF0YSBsYXlvdXQgZGF0YVxuICAgICAqIEBwYXJhbSB7TmV4dENvbnRleHR9IGNvbnRleHQgbmV4dCBjb250ZXh0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29tcG9uZW50UHJvcHNDb2xsZWN0aW9uPn0gY29tcG9uZW50IHByb3BzXG4gICAgICovXG4gICAgZmV0Y2hDb21wb25lbnRQcm9wcyhmZXRjaEZ1bmN0aW9uRmFjdG9yeSwgbGF5b3V0RGF0YSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBBcnJheSBvZiBzaWRlIGVmZmVjdCBmdW5jdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RzID0gdGhpcy5jb2xsZWN0UmVxdWVzdHMoe1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyczogKF9hID0gbGF5b3V0RGF0YS5zaXRlY29yZS5yb3V0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBsYWNlaG9sZGVycyxcbiAgICAgICAgICAgICAgICBmZXRjaEZ1bmN0aW9uRmFjdG9yeSxcbiAgICAgICAgICAgICAgICBsYXlvdXREYXRhLFxuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmV4ZWNSZXF1ZXN0cyhyZXF1ZXN0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHbyB0aHJvdWdoIGxheW91dCBzZXJ2aWNlIGRhdGEsIGNoZWNrIGFsbCByZW5kZXJpbmdzIHVzaW5nIGRpc3BsYXlOYW1lLCB3aGljaCBzaG91bGQgbWFrZSBzb21lIHNpZGUgZWZmZWN0cy5cbiAgICAgKiBXcml0ZSByZXN1bHQgaW4gcmVxdWVzdHMgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7UGxhY2Vob2xkZXJzRGF0YX0gW3BhcmFtcy5wbGFjZWhvbGRlcnNdXG4gICAgICogQHBhcmFtIHtGZXRjaEZ1bmN0aW9uRmFjdG9yeTxOZXh0Q29udGV4dD59IHBhcmFtcy5mZXRjaEZ1bmN0aW9uRmFjdG9yeVxuICAgICAqIEBwYXJhbSB7TGF5b3V0U2VydmljZURhdGF9IHBhcmFtcy5sYXlvdXREYXRhXG4gICAgICogQHBhcmFtIHtOZXh0Q29udGV4dH0gcGFyYW1zLmNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudFByb3BzUmVxdWVzdDxOZXh0Q29udGV4dD5bXX0gcGFyYW1zLnJlcXVlc3RzXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFByb3BzUmVxdWVzdDxOZXh0Q29udGV4dD5bXX0gYXJyYXkgb2YgcmVxdWVzdHNcbiAgICAgKi9cbiAgICBjb2xsZWN0UmVxdWVzdHMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgcGxhY2Vob2xkZXJzID0ge30sIGZldGNoRnVuY3Rpb25GYWN0b3J5LCBsYXlvdXREYXRhLCBjb250ZXh0IH0gPSBwYXJhbXM7XG4gICAgICAgIC8vIFdpbGwgYmUgY2FsbGVkIG9uIGZpcnN0IHJvdW5kXG4gICAgICAgIGlmICghcGFyYW1zLnJlcXVlc3RzKSB7XG4gICAgICAgICAgICBwYXJhbXMucmVxdWVzdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJpbmdzID0gdGhpcy5mbGF0UmVuZGVyaW5ncyhwbGFjZWhvbGRlcnMpO1xuICAgICAgICByZW5kZXJpbmdzLm1hcCgocikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hGdW5jID0gZmV0Y2hGdW5jdGlvbkZhY3Rvcnkoci5jb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgIGlmIChmZXRjaEZ1bmMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucmVxdWVzdHMgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnJlcXVlc3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2g6IGZldGNoRnVuYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmluZzogcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dERhdGE6IGxheW91dERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHBsYWNlaG9sZGVycyBleGlzdCBpbiBjdXJyZW50IHJlbmRlcmluZ1xuICAgICAgICAgICAgaWYgKHIucGxhY2Vob2xkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0UmVxdWVzdHMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHBsYWNlaG9sZGVyczogci5wbGFjZWhvbGRlcnMgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5yZXF1ZXN0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSByZXF1ZXN0IGZvciBjb21wb25lbnQgcHJvcHNcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudFByb3BzUmVxdWVzdDxOZXh0Q29udGV4dD5bXX0gcmVxdWVzdHMgcmVxdWVzdHNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb21wb25lbnRQcm9wc0NvbGxlY3Rpb24+fSByZXF1ZXN0cyByZXN1bHRcbiAgICAgKi9cbiAgICBleGVjUmVxdWVzdHMocmVxdWVzdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFByb3BzID0ge307XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHJlcXVlc3RzLm1hcCgocmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1aWQgfSA9IHJlcS5yZW5kZXJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKCF1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENvbXBvbmVudCAke3JlcS5yZW5kZXJpbmcuY29tcG9uZW50TmFtZX0gZG9lc24ndCBoYXZlIHVpZCwgY2FuJ3Qgc3RvcmUgZGF0YSBmb3IgdGhpcyBjb21wb25lbnRgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJyZXFcIiwgSlNPTi5zdHJpbmdpZnkocmVxLCBudWxsLCAyKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxXG4gICAgICAgICAgICAgICAgICAgIC5mZXRjaChyZXEucmVuZGVyaW5nLCByZXEubGF5b3V0RGF0YSwgcmVxLmNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGNvbXBvbmVudCBzcGVjaWZpYyBkYXRhIGluIGNvbXBvbmVudFByb3BzIHN0b3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3BzW3VpZF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJMb2cgPSBgRXJyb3IgZHVyaW5nIHByZWxvYWQgZGF0YSBmb3IgY29tcG9uZW50ICR7dWlkfTogJHtlcnJvci5tZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcn1gO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGNoYWxrLnJlZChlcnJMb2cpKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50UHJvcHNbdWlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8IGVyckxvZyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFByb3BzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZSByZW5kZXJpbmdzIGZyb20gYWxsIHBsYWNlaG9sZGVycyBhbmQgcmV0dXJucyBhIGZsYXQgYXJyYXkgb2YgcmVuZGVyaW5ncy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHBsYWNlaG9sZGVycyA9IHtcbiAgICAgKiAgICB4MTogW3sgdWlkOiAxIH0sIHsgdWlkOiAyIH1dLFxuICAgICAqICAgIHgyOiBbeyB1aWQ6IDExIH0sIHsgdWlkOiAyMiB9XVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZsYXRSZW5kZXJpbmdzKHBsYWNlaG9sZGVycyk7XG4gICAgICpcbiAgICAgKiBSRVNVTFQ6IFt7IHVpZDogMSB9LCB7IHVpZDogMiB9LCB7IHVpZDogMTEgfSwgeyB1aWQ6IDIyIH1dXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BsYWNlaG9sZGVyc0RhdGF9IHBsYWNlaG9sZGVycyBwbGFjZWhvbGRlcnNcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVuZGVyaW5nW119IHJlbmRlcmluZ3NcbiAgICAgKi9cbiAgICBmbGF0UmVuZGVyaW5ncyhwbGFjZWhvbGRlcnMpIHtcbiAgICAgICAgY29uc3QgYWxsQ29tcG9uZW50UmVuZGVyaW5ncyA9IFtdO1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlcnNBcnIgPSBPYmplY3QudmFsdWVzKHBsYWNlaG9sZGVycyk7XG4gICAgICAgIHBsYWNlaG9sZGVyc0Fyci5mb3JFYWNoKChwbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyaW5ncyA9IHBsO1xuICAgICAgICAgICAgYWxsQ29tcG9uZW50UmVuZGVyaW5ncy5wdXNoKC4uLnJlbmRlcmluZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFsbENvbXBvbmVudFJlbmRlcmluZ3M7XG4gICAgfVxufVxuIiwiZXhwb3J0IGNsYXNzIERpc2Nvbm5lY3RlZFNpdGVtYXBTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhYmlsaXR5IHRvIGdlbmVyYXRlIHNpdGVtYXAgdXNpbmcgbWFuaWZlc3QuXG4gICAgICogU2l0ZW1hcCBjYW4gYmUgdXNlZCBmb3IgYG5leHQgZXhwb3J0YFxuICAgICAqIFlvdSBjYW4gdXNlIGBzaXRlY29yZS9tYW5pZmVzdC9zaXRlY29yZS1pbXBvcnQuanNvbmAgYXMgbWFuaWZlc3RcbiAgICAgKiBAcGFyYW0ge01hbmlmZXN0SW5zdGFuY2V9IG1hbmlmZXN0IG1hbmlmZXN0IGluc3RhbmNlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWFuaWZlc3QpIHtcbiAgICAgICAgdGhpcy5tYW5pZmVzdCA9IG1hbmlmZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgc2l0ZW1hcCB3aGljaCBjb3VsZCBiZSB1c2VkIGZvciBnZW5lcmF0aW9uIG9mIHN0YXRpYyBwYWdlcyBkdXJpbmcgYG5leHQgZXhwb3J0YCBpbiBkaXNjb25uZWN0ZWQgbW9kZS5cbiAgICAgKiBTaW5jZSBpMThuIGlzIG5vdCBzdXBwb3J0ZWQsIHRoZSBvdXRwdXQgcGF0aHMgd2lsbCBub3QgaW5jbHVkZSBhIGBsb2NhbGVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZldGNoRXhwb3J0U2l0ZW1hcCgpIHtcbiAgICAgICAgY29uc3Qgc2l0ZW1hcCA9IFtdO1xuICAgICAgICAvLyBQYXRoIGlzIGVtcHR5IHdoZW4gd2Ugc3RhcnQgZnJvbSB0aGUgcm9vdCByb3V0ZVxuICAgICAgICBjb25zdCBwcm9jZXNzUm91dGVzID0gKHJvdXRlcywgcGF0aCkgPT4ge1xuICAgICAgICAgICAgcm91dGVzLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmluZ3MgPSAoX2EgPSByb3V0ZS5sYXlvdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW5kZXJpbmdzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUGF0aCA9IHBhdGggPyBwYXRoLmNvbmNhdChyb3V0ZS5uYW1lKSA6IFsnJ107XG4gICAgICAgICAgICAgICAgaWYgKHJlbmRlcmluZ3MgJiYgcmVuZGVyaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2l0ZW1hcC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHJvdXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGluIHRoZSByb290IHJvdXRlLCBzbyBuZXh0IGNoaWxkIHNob3VsZCBub3QgY29udGFpbiBwYXRocyBpbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzUm91dGVzKHJvdXRlLmNoaWxkcmVuLCBwYXRoID8gcm91dGVQYXRoIDogW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzUm91dGVzKHRoaXMubWFuaWZlc3QuaXRlbXMucm91dGVzKTtcbiAgICAgICAgcmV0dXJuIHNpdGVtYXA7XG4gICAgfVxufVxuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBBeGlvc0RhdGFGZXRjaGVyLCBkZWJ1ZyB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzJztcbmltcG9ydCB7IGdldEpzc0VkaXRpbmdTZWNyZXQgfSBmcm9tICcuLi91dGlscyc7XG5leHBvcnQgY29uc3QgUVVFUllfUEFSQU1fRURJVElOR19TRUNSRVQgPSAnc2VjcmV0Jztcbi8qKlxuICogU2VydmljZSByZXNwb25zaWJsZSBmb3IgbWFpbnRhaW5pbmcgU2l0ZWNvcmUgRXhwZXJpZW5jZSBFZGl0b3IgZGF0YSBiZXR3ZWVuIHJlcXVlc3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBFZGl0aW5nRGF0YVNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWRpdGluZ0RhdGFTZXJ2aWNlQ29uZmlnfSBbY29uZmlnXSBFZGl0aW5nIGRhdGEgc2VydmljZSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5hcGlSb3V0ZSA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hcGlSb3V0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJy9hcGkvZWRpdGluZy9kYXRhL1trZXldJztcbiAgICAgICAgaWYgKCF0aGlzLmFwaVJvdXRlLmluY2x1ZGVzKCdba2V5XScpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzcGVjaWZpZWQgYXBpUm91dGUgJyR7dGhpcy5hcGlSb3V0ZX0nIGlzIG1pc3NpbmcgJ1trZXldJy5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFGZXRjaGVyID0gKF9iID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmRhdGFGZXRjaGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgQXhpb3NEYXRhRmV0Y2hlcih7IGRlYnVnZ2VyOiBkZWJ1Zy5leHBlcmllbmNlRWRpdG9yIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgRXhwZXJpZW5jZSBFZGl0b3IgcGF5bG9hZCBkYXRhIGZvciBsYXRlciByZXRyaWV2YWwgYnkga2V5XG4gICAgICogQHBhcmFtIHtFZGl0aW5nRGF0YX0gZGF0YSBFZGl0aW5nIGRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyVXJsIFRoZSBzZXJ2ZXIgdXJsIHRvIHVzZSBmb3Igc3Vic2VxdWVudCBkYXRhIEFQSSByZXF1ZXN0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUge0BsaW5rIEVkaXRpbmdQcmV2aWV3RGF0YX0gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIGtleSBhbmQgc2VydmVyVXJsIHRvIHVzZSBmb3IgcmV0cmlldmFsXG4gICAgICovXG4gICAgc2V0RWRpdGluZ0RhdGEoZGF0YSwgc2VydmVyVXJsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdlbmVyYXRlS2V5KGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5nZXRVcmwoc2VydmVyVXJsLCBrZXkpO1xuICAgICAgICAgICAgY29uc3QgcHJldmlld0RhdGEgPSB7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHNlcnZlclVybCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJ1Zy5leHBlcmllbmNlRWRpdG9yKCdzdG9yaW5nIGVkaXRpbmcgZGF0YSBmb3IgJW86ICVvJywgcHJldmlld0RhdGEsIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZldGNoZXIucHV0KHVybCwgZGF0YSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpZXdEYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgRXhwZXJpZW5jZSBFZGl0b3IgcGF5bG9hZCBkYXRhIGJ5IGtleVxuICAgICAqIEBwYXJhbSB7RWRpdGluZ1ByZXZpZXdEYXRhfSBwcmV2aWV3RGF0YSBFZGl0aW5nIHByZXZpZXcgZGF0YSBjb250YWluaW5nIHRoZSBrZXkgYW5kIHNlcnZlclVybCB0byB1c2UgZm9yIHJldHJpZXZhbFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUge0BsaW5rIEVkaXRpbmdEYXRhfVxuICAgICAqL1xuICAgIGdldEVkaXRpbmdEYXRhKHByZXZpZXdEYXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmdldFVybChwcmV2aWV3RGF0YS5zZXJ2ZXJVcmwsIHByZXZpZXdEYXRhLmtleSk7XG4gICAgICAgICAgICBkZWJ1Zy5leHBlcmllbmNlRWRpdG9yKCdmZXRjaGluZyBlZGl0aW5nIGRhdGEgZm9yICVvJywgcHJldmlld0RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZldGNoZXIuZ2V0KHVybCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJhdGVLZXkoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIE5lZWQgbW9yZSB0aGFuIGp1c3QgdGhlIGl0ZW0gR1VJRCBzaW5jZSByZXF1ZXN0cyBhcmUgbWFkZSBcImxpdmVcIiBkdXJpbmcgZWRpdGluZyBpbiBFRS5cbiAgICAgICAgLy8gVGhlIHN1ZmZpeCBjb2RlIHdpbGwgcHJvZHVjZSBhIHJhbmRvbSAxMCBjaGFyYWN0ZXIgYWxwaGEtbnVtZXJpYyAoYS16IDAtOSkgc2VxdWVuY2UsIHdoaWNoIGlzIFVSSS1zYWZlLlxuICAgICAgICAvLyBFeGFtcGxlIGdlbmVyYXRlZCBrZXk6IDUyOTYxZWVhLWJhZmQtNTI4Ny1hNTMyLWE3MmUzNmJkOGEzNi1xa2I0ZTNmdjV4XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IE1hdGgucmFuZG9tKClcbiAgICAgICAgICAgIC50b1N0cmluZygzNilcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMiwgMTIpO1xuICAgICAgICByZXR1cm4gYCR7KF9hID0gZGF0YS5sYXlvdXREYXRhLnNpdGVjb3JlLnJvdXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXRlbUlkfS0ke3N1ZmZpeH1gO1xuICAgIH1cbiAgICBnZXRVcmwoc2VydmVyVXJsLCBrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBFeGFtcGxlIFVSTCBmb3JtYXQ6XG4gICAgICAgIC8vICBodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2VkaXRpbmcvZGF0YS81Mjk2MWVlYS1iYWZkLTUyODctYTUzMi1hNzJlMzZiZDhhMzYtcWtiNGUzZnY1eD9zZWNyZXQ9MTIzNHNlY3JldFxuICAgICAgICBjb25zdCBhcGlSb3V0ZSA9IChfYSA9IHRoaXMuYXBpUm91dGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKCdba2V5XScsIGtleSk7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYXBpUm91dGUsIHNlcnZlclVybCk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFFVRVJZX1BBUkFNX0VESVRJTkdfU0VDUkVULCBnZXRKc3NFZGl0aW5nU2VjcmV0KCkpO1xuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqIEVkaXRpbmdEYXRhU2VydmljZSBzaW5nbGV0b24gKHdpdGggZGVmYXVsdCB2YWx1ZXMpICovXG5leHBvcnQgY29uc3QgZWRpdGluZ0RhdGFTZXJ2aWNlID0gbmV3IEVkaXRpbmdEYXRhU2VydmljZSgpO1xuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBHcmFwaFFMUmVxdWVzdENsaWVudCwgZGVidWcsIGdldEFwcFJvb3RJZCwgU2VhcmNoUXVlcnlTZXJ2aWNlLCB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzJztcbi8qKiBAcHJpdmF0ZSAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5RXJyb3IgPSAnVmFsaWQgdmFsdWUgZm9yIHJvb3RJdGVtSWQgbm90IHByb3ZpZGVkIGFuZCBmYWlsZWQgdG8gYXV0by1yZXNvbHZlIGFwcCByb290IGl0ZW0uJztcbi8qKiBAcHJpdmF0ZSAqL1xuZXhwb3J0IGNvbnN0IGxhbmd1YWdlRXJyb3IgPSAnVGhlIGxpc3Qgb2YgbGFuZ3VhZ2VzIGNhbm5vdCBiZSBlbXB0eSc7XG4vLyBFdmVuIHRob3VnaCBfaGFzTGF5b3V0IHNob3VsZCBhbHdheXMgYmUgXCJ0cnVlXCIgaW4gdGhpcyBxdWVyeSwgdXNpbmcgYSB2YXJpYWJsZSBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBFZGdlXG5jb25zdCBkZWZhdWx0UXVlcnkgPSAvKiBHcmFwaFFMICovIGBcclxuICBxdWVyeSBTaXRlbWFwUXVlcnkoXHJcbiAgICAkcm9vdEl0ZW1JZDogU3RyaW5nIVxyXG4gICAgJGxhbmd1YWdlOiBTdHJpbmchXHJcbiAgICAkcGFnZVNpemU6IEludCA9IDEwXHJcbiAgICAkaGFzTGF5b3V0OiBTdHJpbmcgPSBcInRydWVcIlxyXG4gICAgJGFmdGVyOiBTdHJpbmdcclxuICApIHtcclxuICAgIHNlYXJjaChcclxuICAgICAgd2hlcmU6IHtcclxuICAgICAgICBBTkQ6IFtcclxuICAgICAgICAgIHsgbmFtZTogXCJfcGF0aFwiLCB2YWx1ZTogJHJvb3RJdGVtSWQsIG9wZXJhdG9yOiBDT05UQUlOUyB9XHJcbiAgICAgICAgICB7IG5hbWU6IFwiX2xhbmd1YWdlXCIsIHZhbHVlOiAkbGFuZ3VhZ2UgfVxyXG4gICAgICAgICAgeyBuYW1lOiBcIl9oYXNMYXlvdXRcIiwgdmFsdWU6ICRoYXNMYXlvdXQgfVxyXG4gICAgICAgIF1cclxuICAgICAgfVxyXG4gICAgICBmaXJzdDogJHBhZ2VTaXplXHJcbiAgICAgIGFmdGVyOiAkYWZ0ZXJcclxuICAgICkge1xyXG4gICAgICB0b3RhbFxyXG4gICAgICBwYWdlSW5mbyB7XHJcbiAgICAgICAgZW5kQ3Vyc29yXHJcbiAgICAgICAgaGFzTmV4dFxyXG4gICAgICB9XHJcbiAgICAgIHJlc3VsdHMge1xyXG4gICAgICAgIHVybCB7XHJcbiAgICAgICAgICBwYXRoXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5gO1xuLyoqXG4gKiBTZXJ2aWNlIHRoYXQgZmV0Y2hlcyB0aGUgbGlzdCBvZiBzaXRlIHBhZ2VzIHVzaW5nIFNpdGVjb3JlJ3MgR3JhcGhRTCBBUEkuXG4gKiBUaGlzIGxpc3QgaXMgdXNlZCBmb3IgU1NHIGFuZCBFeHBvcnQgZnVuY3Rpb25hbGl0eS5cbiAqIEBtaXhlcyBTZWFyY2hRdWVyeVNlcnZpY2U8UGFnZUxpc3RRdWVyeVJlc3VsdD5cbiAqL1xuZXhwb3J0IGNsYXNzIEdyYXBoUUxTaXRlbWFwU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBncmFwaFFMIHNpdGVtYXAgc2VydmljZSB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtHcmFwaFFMU2l0ZW1hcFNlcnZpY2VDb25maWd9IG9wdGlvbnMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JhcGhRTENsaWVudCA9IHRoaXMuZ2V0R3JhcGhRTENsaWVudCgpO1xuICAgICAgICB0aGlzLnNlYXJjaFNlcnZpY2UgPSBuZXcgU2VhcmNoUXVlcnlTZXJ2aWNlKHRoaXMuZ3JhcGhRTENsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlZmF1bHQgcXVlcnkgdXNlZCBmb3IgZmV0Y2hpbmcgdGhlIGxpc3Qgb2Ygc2l0ZSBwYWdlc1xuICAgICAqL1xuICAgIGdldCBxdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRRdWVyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggc2l0ZW1hcCB3aGljaCBjb3VsZCBiZSB1c2VkIGZvciBnZW5lcmF0aW9uIG9mIHN0YXRpYyBwYWdlcyBkdXJpbmcgYG5leHQgZXhwb3J0YC5cbiAgICAgKiBUaGUgYGxvY2FsZWAgcGFyYW1ldGVyIHdpbGwgYmUgdXNlZCBpbiB0aGUgaXRlbSBxdWVyeSwgYnV0IHNpbmNlIGkxOG4gaXMgbm90IHN1cHBvcnRlZCxcbiAgICAgKiB0aGUgb3V0cHV0IHBhdGhzIHdpbGwgbm90IGluY2x1ZGUgYSBgbGFuZ3VhZ2VgIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGUgd2hpY2ggYXBwbGljYXRpb24gc3VwcG9ydHNcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBAc2VlIFN0YXRpY1BhdGggb2JqZWN0c1xuICAgICAqL1xuICAgIGZldGNoRXhwb3J0U2l0ZW1hcChsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdFBhdGggPSAocGF0aCkgPT4gKHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFNpdGVtYXAoW2xvY2FsZV0sIGZvcm1hdFBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggc2l0ZW1hcCB3aGljaCBjb3VsZCBiZSB1c2VkIGZvciBnZW5lcmF0aW9uIG9mIHN0YXRpYyBwYWdlcyB1c2luZyBTU0cgbW9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxvY2FsZXMgbG9jYWxlcyB3aGljaCBhcHBsaWNhdGlvbiBzdXBwb3J0c1xuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIEBzZWUgU3RhdGljUGF0aCBvYmplY3RzXG4gICAgICovXG4gICAgZmV0Y2hTU0dTaXRlbWFwKGxvY2FsZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdFBhdGggPSAocGF0aCwgbG9jYWxlKSA9PiAoe1xuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFNpdGVtYXAobG9jYWxlcywgZm9ybWF0UGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGZsYXQgbGlzdCBvZiBhbGwgcGFnZXMgdGhhdCBhcmUgZGVzY2VuZGFudHMgb2YgdGhlIHNwZWNpZmllZCByb290IGl0ZW0gYW5kIGhhdmUgYVxuICAgICAqIHZlcnNpb24gaW4gdGhlIHNwZWNpZmllZCBsYW5ndWFnZShzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsYW5ndWFnZXMgRmV0Y2ggcGFnZXMgdGhhdCBoYXZlIHZlcnNpb25zIGluIHRoaXMgbGFuZ3VhZ2UocykuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm9ybWF0U3RhdGljUGF0aCBGdW5jdGlvbiBmb3IgdHJhbnNmb3JtaW5nIHRoZSByYXcgc2VhcmNoIHJlc3VsdHMgaW50byAoQHNlZSBTdGF0aWNQYXRoKSB0eXBlcy5cbiAgICAgKiBAcmV0dXJucyBsaXN0IG9mIHBhZ2VzXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gaWYgdGhlIGxpc3Qgb2YgbGFuZ3VhZ2VzIGlzIGVtcHR5LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgYXBwIHJvb3Qgd2FzIG5vdCBmb3VuZCBmb3IgdGhlIHNwZWNpZmllZCBzaXRlIGFuZCBsYW5ndWFnZS5cbiAgICAgKi9cbiAgICBmZXRjaFNpdGVtYXAobGFuZ3VhZ2VzLCBmb3JtYXRTdGF0aWNQYXRoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIWxhbmd1YWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihsYW5ndWFnZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjYWxsZXIgZG9lcyBub3Qgc3BlY2lmeSBhIHJvb3QgaXRlbSBJRCwgdGhlbiB3ZSB0cnkgdG8gZmlndXJlIGl0IG91dFxuICAgICAgICAgICAgY29uc3Qgcm9vdEl0ZW1JZCA9IHRoaXMub3B0aW9ucy5yb290SXRlbUlkIHx8XG4gICAgICAgICAgICAgICAgKHlpZWxkIGdldEFwcFJvb3RJZCh0aGlzLmdyYXBoUUxDbGllbnQsIHRoaXMub3B0aW9ucy5zaXRlTmFtZSwgbGFuZ3VhZ2VzWzBdKSk7XG4gICAgICAgICAgICBpZiAoIXJvb3RJdGVtSWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocXVlcnlFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGZXRjaCBwYXRocyB1c2luZyBhbGwgbG9jYWxlc1xuICAgICAgICAgICAgY29uc3QgcGF0aHMgPSB5aWVsZCBQcm9taXNlLmFsbChsYW5ndWFnZXMubWFwKChsYW5ndWFnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnLnNpdGVtYXAoJ2ZldGNoaW5nIHNpdGVtYXAgZGF0YSBmb3IgJXMnLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoU2VydmljZVxuICAgICAgICAgICAgICAgICAgICAuZmV0Y2godGhpcy5xdWVyeSwge1xuICAgICAgICAgICAgICAgICAgICByb290SXRlbUlkLFxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMub3B0aW9ucy5wYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cy5tYXAoKGl0ZW0pID0+IGZvcm1hdFN0YXRpY1BhdGgoaXRlbS51cmwucGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgJycpLnNwbGl0KCcvJyksIGxhbmd1YWdlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBtZXJnZSBwcm9taXNlcyByZXN1bHRzIGludG8gc2luZ2xlIHJlc3VsdFxuICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi5wYXRocyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgR3JhcGhRTCBjbGllbnQgdGhhdCBjYW4gbWFrZSByZXF1ZXN0cyB0byB0aGUgQVBJLiBVc2VzIGdyYXBocWwtcmVxdWVzdCBhcyB0aGUgZGVmYXVsdFxuICAgICAqIGxpYnJhcnkgZm9yIGZldGNoaW5nIGdyYXBocWwgZGF0YSAoQHNlZSBHcmFwaFFMUmVxdWVzdENsaWVudCkuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdVxuICAgICAqIHdhbnQgdG8gdXNlIHNvbWV0aGluZyBlbHNlLlxuICAgICAqIEByZXR1cm5zIHtHcmFwaFFMQ2xpZW50fSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGdldEdyYXBoUUxDbGllbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhRTFJlcXVlc3RDbGllbnQodGhpcy5vcHRpb25zLmVuZHBvaW50LCB7XG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgICAgICBkZWJ1Z2dlcjogZGVidWcuc2l0ZW1hcCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzZXJ2aWNlIHRoYXQgY2FuIHBlcmZvcm0gR3JhcGhRTCBcInNlYXJjaFwiIHF1ZXJpZXMgdG8gZmV0Y2ggQHNlZSBQYWdlTGlzdFF1ZXJ5UmVzdWx0XG4gICAgICogQHJldHVybnMge1NlYXJjaFF1ZXJ5U2VydmljZTxQYWdlTGlzdFF1ZXJ5UmVzdWx0Pn0gdGhlIHNlYXJjaCBxdWVyeSBzZXJ2aWNlXG4gICAgICovXG4gICAgZ2V0U2VhcmNoU2VydmljZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWFyY2hRdWVyeVNlcnZpY2UodGhpcy5ncmFwaFFMQ2xpZW50KTtcbiAgICB9XG59XG4iLCIvKipcbiAqIEBwYXJhbSB7RWRpdGluZ0RhdGF9IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWRpdGluZ0RhdGEoZGF0YSkge1xuICAgIHJldHVybiAoZGF0YS5wYXRoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZGF0YS5sYW5ndWFnZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGRhdGEubGF5b3V0RGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGRhdGEuZGljdGlvbmFyeSAhPT0gdW5kZWZpbmVkKTtcbn1cbiIsImltcG9ydCBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBpc0V4cGVyaWVuY2VFZGl0b3JBY3RpdmUsIHJlc2V0RXhwZXJpZW5jZUVkaXRvckNocm9tZXMgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcyc7XG5leHBvcnQgY29uc3QgZ2V0UHVibGljVXJsID0gKCkgPT4ge1xuICAgIGxldCB1cmwgPSBwcm9jZXNzLmVudi5QVUJMSUNfVVJMO1xuICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7Y2hhbGsueWVsbG93LmJvbGQoJ1dhcm5pbmc6Jyl9IEFuIFBVQkxJQ19VUkwgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGRlZmluZWQuIEZhbGxpbmcgYmFjayB0byBodHRwOi8vbG9jYWxob3N0OjMwMDAuYCk7XG4gICAgICAgIHVybCA9ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBVUkwodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFBVQkxJQ19VUkwgZW52aXJvbm1lbnQgdmFyaWFibGUgJyR7dXJsfScgaXMgbm90IGEgdmFsaWQgVVJMLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEVuc3VyZSBubyB0cmFpbGluZyBzbGFzaFxuICAgIHJldHVybiB1cmwudG9TdHJpbmcoKS5yZXBsYWNlKC9cXC8kLywgJycpO1xufTtcbi8qKlxuICogU2luY2UgRXhwZXJpZW5jZSBFZGl0b3IgZG9lcyBub3Qgc3VwcG9ydCBGYXN0IFJlZnJlc2g6XG4gKiAxLiBTdWJzY3JpYmUgb24gZXZlbnRzIHByb3ZpZGVkIGJ5IHdlYnBhY2suXG4gKiAyLiBSZXNldCBleHBlcmllbmNlIGVkaXRvciBjaHJvbWVzIHdoZW4gYnVpbGQgaXMgZmluaXNoZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlUmVsb2FkXSBmb3JjZSBwYWdlIHJlbG9hZCBpbnN0ZWFkIG9mIHJlc2V0IGNocm9tZXNcbiAqIEBkZWZhdWx0IGZvcmNlUmVsb2FkIGZhbHNlXG4gKi9cbmV4cG9ydCBjb25zdCBoYW5kbGVFeHBlcmllbmNlRWRpdG9yRmFzdFJlZnJlc2ggPSAoZm9yY2VSZWxvYWQgPSBmYWxzZSkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyB8fCAhaXNFeHBlcmllbmNlRWRpdG9yQWN0aXZlKCkpIHtcbiAgICAgICAgLy8gT25seSBydW4gaWYgZGV2ZWxvcG1lbnQgbW9kZSBhbmQgRXhwZXJpZW5jZSBFZGl0b3IgaXMgYWN0aXZlXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRTb3VyY2UgPSBuZXcgd2luZG93LkV2ZW50U291cmNlKGAke2dldFB1YmxpY1VybCgpfS9fbmV4dC93ZWJwYWNrLWhtcmApO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiBldmVudFNvdXJjZS5jbG9zZSgpKTtcbiAgICBldmVudFNvdXJjZS5vbm9wZW4gPSAoKSA9PiBjb25zb2xlLmxvZygnW0V4cGVyaWVuY2UgRWRpdG9yIEZhc3QgUmVmcmVzaCBMaXN0ZW5lcl0gT25saW5lJyk7XG4gICAgZXZlbnRTb3VyY2Uub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ3snKSA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm47IC8vIGhlYXJ0YmVhdFxuICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhgW0V4cGVyaWVuY2UgRWRpdG9yIEZhc3QgUmVmcmVzaCBMaXN0ZW5lcl0gU2F3IGV2ZW50OiAke0pTT04uc3RyaW5naWZ5KHBheWxvYWQpfWApO1xuICAgICAgICBpZiAocGF5bG9hZC5hY3Rpb24gIT09ICdidWlsdCcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChmb3JjZVJlbG9hZClcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tFeHBlcmllbmNlIEVkaXRvciBITVIgTGlzdGVuZXJdIEV4cGVyaWVuY2UgRWRpdG9yIGRvZXMgbm90IHN1cHBvcnQgRmFzdCBSZWZyZXNoLCByZWxvYWRpbmcgY2hyb21lcy4uLicpO1xuICAgICAgICAgICAgcmVzZXRFeHBlcmllbmNlRWRpdG9yQ2hyb21lcygpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IGdldEpzc0VkaXRpbmdTZWNyZXQgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2VjcmV0ID0gcHJvY2Vzcy5lbnYuSlNTX0VESVRJTkdfU0VDUkVUO1xuICAgIGlmICghc2VjcmV0IHx8IHNlY3JldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgSlNTX0VESVRJTkdfU0VDUkVUIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlY3JldDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHByb3BfdHlwZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5leHBvcnRzLkRhdGVGaWVsZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCB0YWcgPSBfYS50YWcsIGVkaXRhYmxlID0gX2EuZWRpdGFibGUsIHJlbmRlciA9IF9hLnJlbmRlciwgb3RoZXJQcm9wcyA9IF9fcmVzdChfYSwgW1wiZmllbGRcIiwgXCJ0YWdcIiwgXCJlZGl0YWJsZVwiLCBcInJlbmRlclwiXSk7XG4gICAgaWYgKCFmaWVsZCB8fCAoIWZpZWxkLmVkaXRhYmxlICYmICFmaWVsZC52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZHJlbjtcbiAgICB2YXIgaHRtbFByb3BzID0gX19hc3NpZ24oe30sIG90aGVyUHJvcHMpO1xuICAgIGlmIChmaWVsZC5lZGl0YWJsZSAmJiBlZGl0YWJsZSkge1xuICAgICAgICBodG1sUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7XG4gICAgICAgICAgICBfX2h0bWw6IGZpZWxkLmVkaXRhYmxlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChyZW5kZXIpIHtcbiAgICAgICAgY2hpbGRyZW4gPSByZW5kZXIoZmllbGQudmFsdWUgPyBuZXcgRGF0ZShmaWVsZC52YWx1ZSkgOiBudWxsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gZmllbGQudmFsdWU7XG4gICAgfVxuICAgIGlmICh0YWcgfHwgKGZpZWxkLmVkaXRhYmxlICYmIGVkaXRhYmxlKSkge1xuICAgICAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodGFnIHx8ICdzcGFuJywgaHRtbFByb3BzLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxufTtcbmV4cG9ydHMuRGF0ZUZpZWxkLnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZDogcHJvcF90eXBlc18xLmRlZmF1bHQuc2hhcGUoe1xuICAgICAgICB2YWx1ZTogcHJvcF90eXBlc18xLmRlZmF1bHQuYW55LFxuICAgICAgICBlZGl0YWJsZTogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgIH0pLmlzUmVxdWlyZWQsXG4gICAgdGFnOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsXG4gICAgZWRpdGFibGU6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgcmVuZGVyOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLFxufTtcbmV4cG9ydHMuRGF0ZUZpZWxkLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBlZGl0YWJsZTogdHJ1ZSxcbn07XG5leHBvcnRzLkRhdGVGaWVsZC5kaXNwbGF5TmFtZSA9ICdEYXRlJztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9wX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmV4cG9ydHMuRmlsZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIC8qXG4gICAgICBGaWxlIGZpZWxkcyBjYW5ub3QgYmUgbWFuYWdlZCB2aWEgdGhlIEVFLiBXZSBuZXZlciBvdXRwdXQgXCJlZGl0YWJsZS5cIlxuICAgICovXG4gICAgdmFyIGZpZWxkID0gX2EuZmllbGQsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIG90aGVyUHJvcHMgPSBfX3Jlc3QoX2EsIFtcImZpZWxkXCIsIFwiY2hpbGRyZW5cIl0pO1xuICAgIHZhciBkeW5hbWljRmllbGQgPSBmaWVsZDtcbiAgICBpZiAoIWZpZWxkIHx8ICghZHluYW1pY0ZpZWxkLnZhbHVlICYmICFkeW5hbWljRmllbGQuc3JjKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGxpbmsgZGlyZWN0bHkgb24gZmllbGQgZm9yIGZvcmdldGZ1bCBkZXZzXG4gICAgdmFyIGZpbGUgPSAoZHluYW1pY0ZpZWxkLnNyY1xuICAgICAgICA/IGZpZWxkXG4gICAgICAgIDogZHluYW1pY0ZpZWxkLnZhbHVlKTtcbiAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBsaW5rVGV4dCA9ICFjaGlsZHJlbiA/IGZpbGUudGl0bGUgfHwgZmlsZS5kaXNwbGF5TmFtZSA6IG51bGw7XG4gICAgdmFyIGFuY2hvckF0dHJzID0ge1xuICAgICAgICBocmVmOiBmaWxlLnNyYyxcbiAgICB9O1xuICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYScsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhbmNob3JBdHRycyksIG90aGVyUHJvcHMpLCBsaW5rVGV4dCwgY2hpbGRyZW4pO1xufTtcbmV4cG9ydHMuRmlsZS5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbXG4gICAgICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0LnNoYXBlKHtcbiAgICAgICAgICAgIHNyYzogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgICAgICB9KSxcbiAgICAgICAgcHJvcF90eXBlc18xLmRlZmF1bHQuc2hhcGUoe1xuICAgICAgICAgICAgdmFsdWU6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9iamVjdCxcbiAgICAgICAgfSksXG4gICAgXSkuaXNSZXF1aXJlZCxcbiAgICBjaGlsZHJlbjogcHJvcF90eXBlc18xLmRlZmF1bHQubm9kZSxcbn07XG5leHBvcnRzLkZpbGUuZGlzcGxheU5hbWUgPSAnRmlsZSc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2l0ZWNvcmVfanNzXzEgPSByZXF1aXJlKFwiQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3NcIik7XG52YXIgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgc2VydmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbS9zZXJ2ZXJcIikpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgZ2V0RWRpdGFibGVXcmFwcGVyID0gZnVuY3Rpb24gKGVkaXRhYmxlTWFya3VwKSB7XG4gICAgdmFyIG90aGVyUHJvcHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvdGhlclByb3BzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgIC8vIGNyZWF0ZSBhbiBpbmxpbmUgd3JhcHBlciBhbmQgdXNlIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLlxuICAgIC8vIGlmIHdlIHRyeSB0byBwYXJzZSB0aGUgRUUgdmFsdWUsIHRoZSBwYXJzZXIgd2lsbCBzdHJpcCBpbnZhbGlkIG9yIGRpc2FsbG93ZWQgYXR0cmlidXRlcyBmcm9tIGh0bWwgZWxlbWVudHMgLSBhbmQgRUUgdXNlcyBzZXZlcmFsXG4gICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBcInNjLWltYWdlLXdyYXBwZXJcIiB9LCBvdGhlclByb3BzLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogZWRpdGFibGVNYXJrdXAgfSB9KSkpO1xufTtcbnZhciBnZXRJbWFnZUF0dHJzID0gZnVuY3Rpb24gKF9hLCBpbWFnZVBhcmFtcywgbWVkaWFVcmxQcmVmaXgpIHtcbiAgICB2YXIgc3JjID0gX2Euc3JjLCBzcmNTZXQgPSBfYS5zcmNTZXQsIG90aGVyQXR0cnMgPSBfX3Jlc3QoX2EsIFtcInNyY1wiLCBcInNyY1NldFwiXSk7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBuZXdBdHRycyA9IF9fYXNzaWduKHt9LCBvdGhlckF0dHJzKTtcbiAgICAvLyB1cGRhdGUgaW1hZ2UgVVJMIGZvciBqc3MgaGFuZGxlciBhbmQgaW1hZ2UgcmVuZGVyaW5nIHBhcmFtc1xuICAgIHZhciByZXNvbHZlZFNyYyA9IHNpdGVjb3JlX2pzc18xLm1lZGlhQXBpLnVwZGF0ZUltYWdlVXJsKHNyYywgaW1hZ2VQYXJhbXMsIG1lZGlhVXJsUHJlZml4KTtcbiAgICBpZiAoc3JjU2V0KSB7XG4gICAgICAgIC8vIHJlcGxhY2Ugd2l0aCBIVE1MLWZvcm1hdHRlZCBzcmNzZXQsIGluY2x1ZGluZyB1cGRhdGVkIGltYWdlIFVSTHNcbiAgICAgICAgbmV3QXR0cnMuc3JjU2V0ID0gc2l0ZWNvcmVfanNzXzEubWVkaWFBcGkuZ2V0U3JjU2V0KHJlc29sdmVkU3JjLCBzcmNTZXQsIGltYWdlUGFyYW1zLCBtZWRpYVVybFByZWZpeCk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBvdXRwdXQgb3JpZ2luYWwgc3JjIGFzIGZhbGxiYWNrIGZvciBvbGRlciBicm93c2Vyc1xuICAgIG5ld0F0dHJzLnNyYyA9IHJlc29sdmVkU3JjO1xuICAgIHJldHVybiBuZXdBdHRycztcbn07XG5leHBvcnRzLkltYWdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIG1lZGlhID0gX2EubWVkaWEsIGVkaXRhYmxlID0gX2EuZWRpdGFibGUsIGltYWdlUGFyYW1zID0gX2EuaW1hZ2VQYXJhbXMsIGZpZWxkID0gX2EuZmllbGQsIG1lZGlhVXJsUHJlZml4ID0gX2EubWVkaWFVcmxQcmVmaXgsIG90aGVyUHJvcHMgPSBfX3Jlc3QoX2EsIFtcIm1lZGlhXCIsIFwiZWRpdGFibGVcIiwgXCJpbWFnZVBhcmFtc1wiLCBcImZpZWxkXCIsIFwibWVkaWFVcmxQcmVmaXhcIl0pO1xuICAgIC8vIGFsbG93cyB0aGUgbWlzdGFrZSBvZiB1c2luZyAnZmllbGQnIHByb3AgaW5zdGVhZCBvZiAnbWVkaWEnIChjb25zaXN0ZW50IHdpdGggb3RoZXIgaGVscGVycylcbiAgICBpZiAoZmllbGQgJiYgIW1lZGlhKSB7XG4gICAgICAgIG1lZGlhID0gZmllbGQ7XG4gICAgfVxuICAgIHZhciBkeW5hbWljTWVkaWEgPSBtZWRpYTtcbiAgICBpZiAoIW1lZGlhIHx8XG4gICAgICAgICghZHluYW1pY01lZGlhLmVkaXRhYmxlICYmICFkeW5hbWljTWVkaWEudmFsdWUgJiYgIWR5bmFtaWNNZWRpYS5zcmMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgaW1hZ2VGaWVsZCA9IGR5bmFtaWNNZWRpYTtcbiAgICAvLyB3ZSBsaWtlbHkgaGF2ZSBhbiBleHBlcmllbmNlIGVkaXRvciB2YWx1ZSwgc2hvdWxkIGJlIGEgc3RyaW5nXG4gICAgaWYgKGVkaXRhYmxlICYmIGltYWdlRmllbGQuZWRpdGFibGUpIHtcbiAgICAgICAgdmFyIGZvdW5kSW1nID0gc2l0ZWNvcmVfanNzXzEubWVkaWFBcGkuZmluZEVkaXRvckltYWdlVGFnKGltYWdlRmllbGQuZWRpdGFibGUpO1xuICAgICAgICBpZiAoIWZvdW5kSW1nKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RWRpdGFibGVXcmFwcGVyKGltYWdlRmllbGQuZWRpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3VuZEltZ1Byb3BzID0gdXRpbHNfMS5jb252ZXJ0QXR0cmlidXRlc1RvUmVhY3RQcm9wcyhmb3VuZEltZy5hdHRycyk7XG4gICAgICAgIC8vIE5vdGU6IG90aGVyUHJvcHMgbWF5IG92ZXJyaWRlIHZhbHVlcyBmcm9tIGZvdW5kSW1nUHJvcHMsIGUuZy4gYHN0eWxlYCwgYGNsYXNzTmFtZWAgcHJvcFxuICAgICAgICAvLyBXZSBkbyBub3QgYXR0ZW1wdCB0byBtZXJnZS5cbiAgICAgICAgdmFyIGltZ0F0dHJzID0gZ2V0SW1hZ2VBdHRycyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm91bmRJbWdQcm9wcyksIG90aGVyUHJvcHMpLCBpbWFnZVBhcmFtcywgbWVkaWFVcmxQcmVmaXgpO1xuICAgICAgICBpZiAoIWltZ0F0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RWRpdGFibGVXcmFwcGVyKGltYWdlRmllbGQuZWRpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbWdIdG1sID0gc2VydmVyXzEuZGVmYXVsdC5yZW5kZXJUb1N0YXRpY01hcmt1cChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCBfX2Fzc2lnbih7fSwgaW1nQXR0cnMpKSk7XG4gICAgICAgIHZhciBlZGl0YWJsZU1hcmt1cCA9IGltYWdlRmllbGQuZWRpdGFibGUucmVwbGFjZShmb3VuZEltZy5pbWdUYWcsIGltZ0h0bWwpO1xuICAgICAgICByZXR1cm4gZ2V0RWRpdGFibGVXcmFwcGVyKGVkaXRhYmxlTWFya3VwKTtcbiAgICB9XG4gICAgLy8gc29tZSB3aXNlLWd1eS9nYWwgaXMgcGFzc2luZyBpbiBhICdyYXcnIGltYWdlIG9iamVjdCB2YWx1ZVxuICAgIHZhciBpbWcgPSBkeW5hbWljTWVkaWEuc3JjXG4gICAgICAgID8gbWVkaWFcbiAgICAgICAgOiBkeW5hbWljTWVkaWEudmFsdWU7XG4gICAgaWYgKCFpbWcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhdHRycyA9IGdldEltYWdlQXR0cnMoX19hc3NpZ24oX19hc3NpZ24oe30sIGltZyksIG90aGVyUHJvcHMpLCBpbWFnZVBhcmFtcywgbWVkaWFVcmxQcmVmaXgpO1xuICAgIGlmIChhdHRycykge1xuICAgICAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgX19hc3NpZ24oe30sIGF0dHJzKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsOyAvLyB3ZSBjYW4ndCBoYW5kbGUgdGhlIHRydXRoXG59O1xuZXhwb3J0cy5JbWFnZS5wcm9wVHlwZXMgPSB7XG4gICAgbWVkaWE6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbXG4gICAgICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0LnNoYXBlKHtcbiAgICAgICAgICAgIHNyYzogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgICAgICB9KSxcbiAgICAgICAgcHJvcF90eXBlc18xLmRlZmF1bHQuc2hhcGUoe1xuICAgICAgICAgICAgdmFsdWU6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9iamVjdCxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsXG4gICAgICAgIH0pLFxuICAgIF0pLFxuICAgIGZpZWxkOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW1xuICAgICAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zaGFwZSh7XG4gICAgICAgICAgICBzcmM6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICAgICAgfSksXG4gICAgICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0LnNoYXBlKHtcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3QsXG4gICAgICAgICAgICBlZGl0YWJsZTogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgICAgICB9KSxcbiAgICBdKSxcbiAgICBlZGl0YWJsZTogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICBtZWRpYVVybFByZWZpeDogcHJvcF90eXBlc18xLmRlZmF1bHQuaW5zdGFuY2VPZihSZWdFeHApLFxuICAgIGltYWdlUGFyYW1zOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3RPZihwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW3Byb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLCBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcuaXNSZXF1aXJlZF0pLmlzUmVxdWlyZWQpLFxufTtcbmV4cG9ydHMuSW1hZ2UuZGVmYXVsdFByb3BzID0ge1xuICAgIGVkaXRhYmxlOiB0cnVlLFxufTtcbmV4cG9ydHMuSW1hZ2UuZGlzcGxheU5hbWUgPSAnSW1hZ2UnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBwcm9wX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuZXhwb3J0cy5MaW5rID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZpZWxkID0gX2EuZmllbGQsIGVkaXRhYmxlID0gX2EuZWRpdGFibGUsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIHNob3dMaW5rVGV4dFdpdGhDaGlsZHJlblByZXNlbnQgPSBfYS5zaG93TGlua1RleHRXaXRoQ2hpbGRyZW5QcmVzZW50LCBvdGhlclByb3BzID0gX19yZXN0KF9hLCBbXCJmaWVsZFwiLCBcImVkaXRhYmxlXCIsIFwiY2hpbGRyZW5cIiwgXCJzaG93TGlua1RleHRXaXRoQ2hpbGRyZW5QcmVzZW50XCJdKTtcbiAgICB2YXIgZHluYW1pY0ZpZWxkID0gZmllbGQ7XG4gICAgaWYgKCFmaWVsZCB8fFxuICAgICAgICAoIWR5bmFtaWNGaWVsZC5lZGl0YWJsZUZpcnN0UGFydCAmJlxuICAgICAgICAgICAgIWR5bmFtaWNGaWVsZC52YWx1ZSAmJlxuICAgICAgICAgICAgIWR5bmFtaWNGaWVsZC5ocmVmKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdFRhZ3MgPSBbXTtcbiAgICAvLyBFWFBFUklFTkNFIEVESVRPUiBSRU5ERVJJTkdcbiAgICBpZiAoZWRpdGFibGUgJiYgZHluYW1pY0ZpZWxkLmVkaXRhYmxlRmlyc3RQYXJ0KSB7XG4gICAgICAgIHZhciBtYXJrdXAgPSBkeW5hbWljRmllbGQuZWRpdGFibGVGaXJzdFBhcnQgKyBkeW5hbWljRmllbGQuZWRpdGFibGVMYXN0UGFydDtcbiAgICAgICAgLy8gaW4gYW4gaWRlYWwgd29ybGQsIHdlJ2QgcHJlLXJlbmRlciBSZWFjdCBjaGlsZHJlbiBoZXJlIGFuZCBpbmplY3QgdGhlbSBiZXR3ZWVuIGVkaXRhYmxlRmlyc3RQYXJ0IGFuZCBlZGl0YWJsZUxhc3RQYXJ0LlxuICAgICAgICAvLyBIb3dldmVyLCB3ZSBjYW5ub3QgY29tYmluZSBhcmJpdHJhcnkgdW5wYXJzZWQgSFRNTCAoaW5uZXJIVE1MKSBiYXNlZCBjb21wb25lbnRzIHdpdGggYWN0dWFsIHZET00gY29tcG9uZW50cyAodGhlIGNoaWxkcmVuKVxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBpbm5lckhUTUwgaXMgbm90IHBhcnNlZCAtIGl0J2QgbWFrZSBhIGRpc2NvbnRpbnVvdXMgdkRPTS4gU28sIHdlJ2xsIGdvIGZvciB0aGUgbmV4dCBiZXN0IGNvbXByb21pc2Ugb2YgcmVuZGVyaW5nIHRoZSBsaW5rIGZpZWxkIGFuZCBjaGlsZHJlbiBzZXBhcmF0ZWx5XG4gICAgICAgIC8vIGFzIHNpYmxpbmdzLiBTaG91bGQgYmUgXCJnb29kIGVub3VnaFwiIGZvciBtb3N0IGNhc2VzIC0gYW5kIHdyaXRlIHlvdXIgb3duIGhlbHBlciBpZiBpdCBpc24ndC4gT3IgYnJpbmcgeEVkaXRvciBvdXQgb2YgMjAwNi5cbiAgICAgICAgdmFyIGh0bWxQcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKHsgY2xhc3NOYW1lOiAnc2MtbGluay13cmFwcGVyJywgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgICAgICBfX2h0bWw6IG1hcmt1cCxcbiAgICAgICAgICAgIH0gfSwgb3RoZXJQcm9wcyksIHsga2V5OiAnZWRpdGFibGUnIH0pO1xuICAgICAgICByZXN1bHRUYWdzLnB1c2gocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9fYXNzaWduKHt9LCBodG1sUHJvcHMpKSk7XG4gICAgICAgIC8vIGRvbid0IHJlbmRlciBub3JtYWwgbGluayB0YWcgd2hlbiBlZGl0aW5nLCBpZiBubyBjaGlsZHJlbiBleGlzdFxuICAgICAgICAvLyB0aGlzIHByZXNlcnZlcyBub3JtYWwtaXNoIGJlaGF2aW9yIGlmIG5vdCB1c2luZyBhIGxpbmsgYm9keSAobm8gaGFja3MgcmVxdWlyZWQpXG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRUYWdzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGhhbmRsZSBsaW5rIGRpcmVjdGx5IG9uIGZpZWxkIGZvciBmb3JnZXRmdWwgZGV2c1xuICAgIHZhciBsaW5rID0gZHluYW1pY0ZpZWxkLmhyZWZcbiAgICAgICAgPyBmaWVsZFxuICAgICAgICA6IGR5bmFtaWNGaWVsZC52YWx1ZTtcbiAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBhbmNob3JBdHRycyA9IHtcbiAgICAgICAgaHJlZjogbGluay5ocmVmLFxuICAgICAgICBjbGFzc05hbWU6IGxpbmsuY2xhc3MsXG4gICAgICAgIHRpdGxlOiBsaW5rLnRpdGxlLFxuICAgICAgICB0YXJnZXQ6IGxpbmsudGFyZ2V0LFxuICAgIH07XG4gICAgaWYgKGFuY2hvckF0dHJzLnRhcmdldCA9PT0gJ19ibGFuaycgJiYgIWFuY2hvckF0dHJzLnJlbCkge1xuICAgICAgICAvLyBpbmZvcm1hdGlvbiBkaXNjbG9zdXJlIGF0dGFjayBwcmV2ZW50aW9uIGtlZXBzIHRhcmdldCBibGFuayBzaXRlIGZyb20gZ2V0dGluZyByZWYgdG8gd2luZG93Lm9wZW5lclxuICAgICAgICBhbmNob3JBdHRycy5yZWwgPSAnbm9vcGVuZXIgbm9yZWZlcnJlcic7XG4gICAgfVxuICAgIHZhciBsaW5rVGV4dCA9IHNob3dMaW5rVGV4dFdpdGhDaGlsZHJlblByZXNlbnQgfHwgIWNoaWxkcmVuID8gbGluay50ZXh0IHx8IGxpbmsuaHJlZiA6IG51bGw7XG4gICAgcmVzdWx0VGFncy5wdXNoKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdhJywgX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGFuY2hvckF0dHJzKSwgb3RoZXJQcm9wcyksIHsga2V5OiAnbGluaycgfSksIGxpbmtUZXh0LCBjaGlsZHJlbikpO1xuICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChyZWFjdF8xLmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHJlc3VsdFRhZ3MpO1xufTtcbmV4cG9ydHMuTGlua1Byb3BUeXBlcyA9IHtcbiAgICBmaWVsZDogcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKFtcbiAgICAgICAgcHJvcF90eXBlc18xLmRlZmF1bHQuc2hhcGUoe1xuICAgICAgICAgICAgaHJlZjogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgICAgICB9KSxcbiAgICAgICAgcHJvcF90eXBlc18xLmRlZmF1bHQuc2hhcGUoe1xuICAgICAgICAgICAgdmFsdWU6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9iamVjdCxcbiAgICAgICAgICAgIGVkaXRhYmxlRmlyc3RQYXJ0OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsXG4gICAgICAgICAgICBlZGl0YWJsZUxhc3RQYXJ0OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsXG4gICAgICAgIH0pLFxuICAgIF0pLmlzUmVxdWlyZWQsXG4gICAgZWRpdGFibGU6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgY2hpbGRyZW46IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm5vZGUsXG4gICAgc2hvd0xpbmtUZXh0V2l0aENoaWxkcmVuUHJlc2VudDogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbn07XG5leHBvcnRzLkxpbmsucHJvcFR5cGVzID0gZXhwb3J0cy5MaW5rUHJvcFR5cGVzO1xuZXhwb3J0cy5MaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBlZGl0YWJsZTogdHJ1ZSxcbn07XG5leHBvcnRzLkxpbmsuZGlzcGxheU5hbWUgPSAnTGluayc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9wX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmV4cG9ydHMuTWlzc2luZ0NvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gcHJvcHMucmVuZGVyaW5nICYmIHByb3BzLnJlbmRlcmluZy5jb21wb25lbnROYW1lXG4gICAgICAgID8gcHJvcHMucmVuZGVyaW5nLmNvbXBvbmVudE5hbWVcbiAgICAgICAgOiAnVW5uYW1lZCBDb21wb25lbnQnO1xuICAgIGNvbnNvbGUubG9nKFwiQ29tcG9uZW50IHByb3BzIGZvciB1bmltcGxlbWVudGVkICdcIiArIGNvbXBvbmVudE5hbWUgKyBcIicgY29tcG9uZW50XCIsIHByb3BzKTtcbiAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICdkYXJrb3JhbmdlJyxcbiAgICAgICAgICAgIG91dGxpbmU6ICc1cHggc29saWQgb3JhbmdlJyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICcxMHB4JyxcbiAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgbWF4V2lkdGg6ICc1MDBweCcsXG4gICAgICAgIH0gfSxcbiAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBjb21wb25lbnROYW1lKSxcbiAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiSlNTIGNvbXBvbmVudCBpcyBtaXNzaW5nIFJlYWN0IGltcGxlbWVudGF0aW9uLiBTZWUgdGhlIGRldmVsb3BlciBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKSkpO1xufTtcbmV4cG9ydHMuTWlzc2luZ0NvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gICAgcmVuZGVyaW5nOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zaGFwZSh7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICB9KSxcbn07XG5leHBvcnRzLk1pc3NpbmdDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnTWlzc2luZ0NvbXBvbmVudCc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgUGxhY2Vob2xkZXJDb21tb25fMSA9IHJlcXVpcmUoXCIuL1BsYWNlaG9sZGVyQ29tbW9uXCIpO1xudmFyIHdpdGhDb21wb25lbnRGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vZW5oYW5jZXJzL3dpdGhDb21wb25lbnRGYWN0b3J5XCIpO1xuLyoqXG4gKiBAcGFyYW0ge0h0bWxFbGVtZW50UmVuZGVyaW5nIHwgQ29tcG9uZW50UmVuZGVyaW5nfSByZW5kZXJpbmdcbiAqL1xuZnVuY3Rpb24gaXNSYXdSZW5kZXJpbmcocmVuZGVyaW5nKSB7XG4gICAgcmV0dXJuICghcmVuZGVyaW5nLmNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgcmVuZGVyaW5nLm5hbWUgIT09IHVuZGVmaW5lZCk7XG59XG52YXIgUGxhY2Vob2xkZXJDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBsYWNlaG9sZGVyQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyQ29tcG9uZW50KHByb3BzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICB9XG4gICAgUGxhY2Vob2xkZXJDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoaWxkUHJvcHMgPSBfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcyk7XG4gICAgICAgIGRlbGV0ZSBjaGlsZFByb3BzLmNvbXBvbmVudEZhY3Rvcnk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRQcm9wcy5lcnJvckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChjaGlsZFByb3BzLmVycm9yQ29tcG9uZW50LCB7IGVycm9yOiB0aGlzLnN0YXRlLmVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzYy1qc3MtcGxhY2Vob2xkZXItZXJyb3JcIiB9LFxuICAgICAgICAgICAgICAgIFwiQSByZW5kZXJpbmcgZXJyb3Igb2NjdXJyZWQ6IFwiLFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW5kZXJpbmdEYXRhID0gY2hpbGRQcm9wcy5yZW5kZXJpbmc7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlckRhdGEgPSBQbGFjZWhvbGRlckNvbW1vbl8xLlBsYWNlaG9sZGVyQ29tbW9uLmdldFBsYWNlaG9sZGVyRGF0YUZyb21SZW5kZXJpbmdEYXRhKHJlbmRlcmluZ0RhdGEsIHRoaXMucHJvcHMubmFtZSk7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzRm9yUmVuZGVyaW5nRGF0YShwbGFjZWhvbGRlckRhdGEpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZW5kZXJFbXB0eSAmJlxuICAgICAgICAgICAgcGxhY2Vob2xkZXJEYXRhLmV2ZXJ5KGZ1bmN0aW9uIChyZW5kZXJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNSYXdSZW5kZXJpbmcocmVuZGVyaW5nKTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5yZW5kZXJFbXB0eShjb21wb25lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLnJlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMucmVuZGVyKGNvbXBvbmVudHMsIHBsYWNlaG9sZGVyRGF0YSwgY2hpbGRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wcy5yZW5kZXJFYWNoKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyRWFjaF8xID0gdGhpcy5wcm9wcy5yZW5kZXJFYWNoO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQucHJvcHMgJiYgY29tcG9uZW50LnByb3BzLnR5cGUgPT09ICd0ZXh0L3NpdGVjb3JlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyRWFjaF8xKGNvbXBvbmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGxhY2Vob2xkZXJDb21wb25lbnQucHJvcFR5cGVzID0gUGxhY2Vob2xkZXJDb21tb25fMS5QbGFjZWhvbGRlckNvbW1vbi5wcm9wVHlwZXM7XG4gICAgcmV0dXJuIFBsYWNlaG9sZGVyQ29tcG9uZW50O1xufShQbGFjZWhvbGRlckNvbW1vbl8xLlBsYWNlaG9sZGVyQ29tbW9uKSk7XG5leHBvcnRzLlBsYWNlaG9sZGVyID0gd2l0aENvbXBvbmVudEZhY3RvcnlfMS53aXRoQ29tcG9uZW50RmFjdG9yeShQbGFjZWhvbGRlckNvbXBvbmVudCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBNaXNzaW5nQ29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9NaXNzaW5nQ29tcG9uZW50XCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgUGxhY2Vob2xkZXJDb21tb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBsYWNlaG9sZGVyQ29tbW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyQ29tbW9uKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ub2RlUmVmcyA9IFtdO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICBfdGhpcy5hZGRSZWYgPSBfdGhpcy5hZGRSZWYuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLnVwZGF0ZUtleUF0dHJpYnV0ZXMgPSBfdGhpcy51cGRhdGVLZXlBdHRyaWJ1dGVzLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5jcmVhdGVSYXdFbGVtZW50ID0gX3RoaXMuY3JlYXRlUmF3RWxlbWVudC5iaW5kKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQbGFjZWhvbGRlckNvbW1vbi5nZXRQbGFjZWhvbGRlckRhdGFGcm9tUmVuZGVyaW5nRGF0YSA9IGZ1bmN0aW9uIChyZW5kZXJpbmcsIG5hbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHJlbmRlcmluZyAmJiByZW5kZXJpbmcucGxhY2Vob2xkZXJzICYmIE9iamVjdC5rZXlzKHJlbmRlcmluZy5wbGFjZWhvbGRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlbmRlcmluZy5wbGFjZWhvbGRlcnNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQbGFjZWhvbGRlciAnXCIgKyBuYW1lICsgXCInIHdhcyBub3QgZm91bmQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyaW5nIGRhdGFcIiwgSlNPTi5zdHJpbmdpZnkocmVuZGVyaW5nLCBudWxsLCAyKSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFBsYWNlaG9sZGVyQ29tbW9uLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVLZXlBdHRyaWJ1dGVzKCk7XG4gICAgfTtcbiAgICBQbGFjZWhvbGRlckNvbW1vbi5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUtleUF0dHJpYnV0ZXMoKTtcbiAgICB9O1xuICAgIFBsYWNlaG9sZGVyQ29tbW9uLnByb3RvdHlwZS5jb21wb25lbnREaWRDYXRjaCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IGVycm9yIH0pO1xuICAgIH07XG4gICAgUGxhY2Vob2xkZXJDb21tb24ucHJvdG90eXBlLmdldENvbXBvbmVudHNGb3JSZW5kZXJpbmdEYXRhID0gZnVuY3Rpb24gKHBsYWNlaG9sZGVyRGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBuYW1lID0gX2EubmFtZSwgcGxhY2Vob2xkZXJGaWVsZHMgPSBfYS5maWVsZHMsIHBsYWNlaG9sZGVyUGFyYW1zID0gX2EucGFyYW1zLCBtaXNzaW5nQ29tcG9uZW50Q29tcG9uZW50ID0gX2EubWlzc2luZ0NvbXBvbmVudENvbXBvbmVudCwgcGxhY2Vob2xkZXJQcm9wcyA9IF9fcmVzdChfYSwgW1wibmFtZVwiLCBcImZpZWxkc1wiLCBcInBhcmFtc1wiLCBcIm1pc3NpbmdDb21wb25lbnRDb21wb25lbnRcIl0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXJEYXRhXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyZW5kZXJpbmcsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcmVuZGVyaW5nLnVpZFxuICAgICAgICAgICAgICAgID8gcmVuZGVyaW5nLnVpZFxuICAgICAgICAgICAgICAgIDogXCJjb21wb25lbnQtXCIgKyBpbmRleDtcbiAgICAgICAgICAgIHZhciBjb21tb25Qcm9wcyA9IHsga2V5OiBrZXkgfTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBhICdjb21wb25lbnQgcmVuZGVyaW5nJywgcmVuZGVyIGl0ICdyYXcnXG4gICAgICAgICAgICBpZiAoIXJlbmRlcmluZy5jb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgICAgcmVuZGVyaW5nLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlUmF3RWxlbWVudChyZW5kZXJpbmcsIGNvbW1vblByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wb25lbnRSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gX3RoaXMuZ2V0Q29tcG9uZW50Rm9yUmVuZGVyaW5nKGNvbXBvbmVudFJlbmRlcmluZyk7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQbGFjZWhvbGRlciBcIiArIG5hbWUgKyBcIiBjb250YWlucyB1bmtub3duIGNvbXBvbmVudCBcIiArIGNvbXBvbmVudFJlbmRlcmluZy5jb21wb25lbnROYW1lICsgXCIuIEVuc3VyZSB0aGF0IGEgUmVhY3QgY29tcG9uZW50IGV4aXN0cyBmb3IgaXQsIGFuZCB0aGF0IGl0IGlzIHJlZ2lzdGVyZWQgaW4geW91ciBjb21wb25lbnRGYWN0b3J5LmpzLlwiKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSAobWlzc2luZ0NvbXBvbmVudENvbXBvbmVudCAhPT0gbnVsbCAmJiBtaXNzaW5nQ29tcG9uZW50Q29tcG9uZW50ICE9PSB2b2lkIDAgPyBtaXNzaW5nQ29tcG9uZW50Q29tcG9uZW50IDogTWlzc2luZ0NvbXBvbmVudF8xLk1pc3NpbmdDb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpbmFsUHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29tbW9uUHJvcHMpLCBwbGFjZWhvbGRlclByb3BzKSwgKChwbGFjZWhvbGRlckZpZWxkcyB8fCBjb21wb25lbnRSZW5kZXJpbmcuZmllbGRzKSAmJiB7XG4gICAgICAgICAgICAgICAgZmllbGRzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGxhY2Vob2xkZXJGaWVsZHMpLCBjb21wb25lbnRSZW5kZXJpbmcuZmllbGRzKSxcbiAgICAgICAgICAgIH0pKSwgKChwbGFjZWhvbGRlclBhcmFtcyB8fCBjb21wb25lbnRSZW5kZXJpbmcucGFyYW1zKSAmJiB7XG4gICAgICAgICAgICAgICAgcGFyYW1zOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGxhY2Vob2xkZXJQYXJhbXMpLCBjb21wb25lbnRSZW5kZXJpbmcucGFyYW1zKSxcbiAgICAgICAgICAgIH0pKSwgeyByZW5kZXJpbmc6IGNvbXBvbmVudFJlbmRlcmluZyB9KTtcbiAgICAgICAgICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIGZpbmFsUHJvcHMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudDsgfSk7IC8vIHJlbW92ZSBudWxsc1xuICAgIH07XG4gICAgUGxhY2Vob2xkZXJDb21tb24ucHJvdG90eXBlLmdldENvbXBvbmVudEZvclJlbmRlcmluZyA9IGZ1bmN0aW9uIChyZW5kZXJpbmdEZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5wcm9wcy5jb21wb25lbnRGYWN0b3J5O1xuICAgICAgICBpZiAoIWNvbXBvbmVudEZhY3RvcnkgfHwgdHlwZW9mIGNvbXBvbmVudEZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIGNvbXBvbmVudEZhY3Rvcnkgd2FzIGF2YWlsYWJsZSB0byBzZXJ2aWNlIHJlcXVlc3QgZm9yIGNvbXBvbmVudCBcIiArIHJlbmRlcmluZ0RlZmluaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudEZhY3RvcnkocmVuZGVyaW5nRGVmaW5pdGlvbi5jb21wb25lbnROYW1lKTtcbiAgICB9O1xuICAgIFBsYWNlaG9sZGVyQ29tbW9uLnByb3RvdHlwZS5hZGRSZWYgPSBmdW5jdGlvbiAobm9kZVJlZikge1xuICAgICAgICB0aGlzLm5vZGVSZWZzLnB1c2gobm9kZVJlZik7XG4gICAgfTtcbiAgICBQbGFjZWhvbGRlckNvbW1vbi5wcm90b3R5cGUuY3JlYXRlUmF3RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtLCBiYXNlUHJvcHMpIHtcbiAgICAgICAgaWYgKCFlbGVtLm5hbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiZWxlbS5uYW1lXCIgaXMgdW5kZWZpbmVkIGluIFwiY3JlYXRlUmF3RWxlbWVudFwiLiBTb21ldGhpbmcgaXMgbGlrZWx5IHdyb25nIHdpdGggeW91ciBjb21wb25lbnQgZGF0YS4gRW5zdXJlIHRoYXQgeW91ciBjb21wb25lbnRzIGhhdmUgYSBuYW1lLicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB1dGlsc18xLmNvbnZlcnRBdHRyaWJ1dGVzVG9SZWFjdFByb3BzKGVsZW0uYXR0cmlidXRlcyk7XG4gICAgICAgIHZhciBwcm9wcyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBiYXNlUHJvcHMpLCBhdHRyaWJ1dGVzKSwgeyBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGVsZW0uY29udGVudHMgfSB9KTtcbiAgICAgICAgLyogU2luY2Ugd2UgY2FuJ3Qgc2V0IHRoZSBcImtleVwiIGF0dHJpYnV0ZSB2aWEgUmVhY3QsIHN0YXNoIGl0XG4gICAgICAgICAqIHNvIHdlIGNhbiBzZXQgaW4gdGhlIERPTSBhZnRlciByZW5kZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykgJiYgYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmNocm9tZXR5cGUgPT09ICdwbGFjZWhvbGRlcicpIHtcbiAgICAgICAgICAgIHByb3BzLnBoa2V5ID0gZWxlbS5hdHRyaWJ1dGVzLmtleTsgLy8gcHJvcHMgdGhhdCBnZXQgcmVuZGVyZWQgYXMgZG9tIGF0dHJpYnV0ZSBuYW1lcyBuZWVkIHRvIGJlIGxvd2VyY2FzZSwgb3RoZXJ3aXNlIFJlYWN0IGNvbXBsYWlucy5cbiAgICAgICAgICAgIHByb3BzLnJlZiA9IHRoaXMuYWRkUmVmOyAvLyBvbmx5IG5lZWQgcmVmIGZvciBwbGFjZWhvbGRlciBjb250YWluZXJzLCB0cnlpbmcgdG8gYWRkIGl0IHRvIG90aGVyIGNvbXBvbmVudHMgKGUuZy4gc3RhdGVsZXNzIGNvbXBvbmVudHMpIG1heSByZXN1bHQgaW4gYSB3YXJuaW5nLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChlbGVtLm5hbWUsIHByb3BzKTtcbiAgICB9O1xuICAgIFBsYWNlaG9sZGVyQ29tbW9uLnByb3RvdHlwZS51cGRhdGVLZXlBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZVJlZnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVSZWZzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgaWYgKHJlZiAmJiByZWYuZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVmIG1pZ2h0IGJlIGEgd3JhcHBlZCBjb21wb25lbnQsIHNvIGNoZWNrIGZvciBleGlzdGVuY2Ugb2YgZ2V0QXR0cmlidXRlIG1ldGhvZFxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSByZWYuZ2V0QXR0cmlidXRlKCdwaGtleScpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBtYW51YWxseSBzZXQgdGhlICdrZXknIGF0dHJpYnV0ZSBhZnRlciBjb21wb25lbnQgbW91bnQgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyAna2V5JyBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS9wcm9wIGluIFJlYWN0LiBzbyBpdCB3aWxsIG5ldmVyIGJlIHJlbmRlcmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGFuIGh0bWwgYXR0cmlidXRlLlxuICAgICAgICAgICAgICAgICAgICByZWYuc2V0QXR0cmlidXRlKCdrZXknLCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQbGFjZWhvbGRlckNvbW1vbi5wcm9wVHlwZXMgPSB7XG4gICAgICAgIHJlbmRlcmluZzogcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKFtcbiAgICAgICAgICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9iamVjdCxcbiAgICAgICAgICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9iamVjdCxcbiAgICAgICAgXSkuaXNSZXF1aXJlZCxcbiAgICAgICAgZmllbGRzOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3RPZihwcm9wX3R5cGVzXzEuZGVmYXVsdC5vbmVPZlR5cGUoW1xuICAgICAgICAgICAgcHJvcF90eXBlc18xLmRlZmF1bHQub2JqZWN0LFxuICAgICAgICAgICAgcHJvcF90eXBlc18xLmRlZmF1bHQub2JqZWN0LFxuICAgICAgICBdKS5pc1JlcXVpcmVkKSxcbiAgICAgICAgcGFyYW1zOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3RPZihwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcuaXNSZXF1aXJlZCksXG4gICAgICAgIG1pc3NpbmdDb21wb25lbnRDb21wb25lbnQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbXG4gICAgICAgICAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3QsXG4gICAgICAgICAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLFxuICAgICAgICBdKSxcbiAgICAgICAgZXJyb3JDb21wb25lbnQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbXG4gICAgICAgICAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3QsXG4gICAgICAgICAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLFxuICAgICAgICBdKSxcbiAgICB9O1xuICAgIHJldHVybiBQbGFjZWhvbGRlckNvbW1vbjtcbn0ocmVhY3RfMS5kZWZhdWx0LkNvbXBvbmVudCkpO1xuZXhwb3J0cy5QbGFjZWhvbGRlckNvbW1vbiA9IFBsYWNlaG9sZGVyQ29tbW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBwcm9wX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuZXhwb3J0cy5SaWNoVGV4dCA9IHJlYWN0XzEuZm9yd2FyZFJlZihmdW5jdGlvbiAoX2EsIHJlZikge1xuICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCB0YWcgPSBfYS50YWcsIGVkaXRhYmxlID0gX2EuZWRpdGFibGUsIG90aGVyUHJvcHMgPSBfX3Jlc3QoX2EsIFtcImZpZWxkXCIsIFwidGFnXCIsIFwiZWRpdGFibGVcIl0pO1xuICAgIGlmICghZmllbGQgfHwgKCFmaWVsZC5lZGl0YWJsZSAmJiAhZmllbGQudmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgaHRtbFByb3BzID0gX19hc3NpZ24oeyBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgICAgX19odG1sOiBmaWVsZC5lZGl0YWJsZSAmJiBlZGl0YWJsZSA/IGZpZWxkLmVkaXRhYmxlIDogZmllbGQudmFsdWUsXG4gICAgICAgIH0sIHJlZjogcmVmIH0sIG90aGVyUHJvcHMpO1xuICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudCh0YWcgfHwgJ2RpdicsIGh0bWxQcm9wcyk7XG59KTtcbmV4cG9ydHMuUmljaFRleHRQcm9wVHlwZXMgPSB7XG4gICAgZmllbGQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnNoYXBlKHtcbiAgICAgICAgdmFsdWU6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICAgICAgZWRpdGFibGU6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICB9KSxcbiAgICB0YWc6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICBlZGl0YWJsZTogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbn07XG5leHBvcnRzLlJpY2hUZXh0LnByb3BUeXBlcyA9IGV4cG9ydHMuUmljaFRleHRQcm9wVHlwZXM7XG5leHBvcnRzLlJpY2hUZXh0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICB0YWc6ICdkaXYnLFxuICAgIGVkaXRhYmxlOiB0cnVlLFxufTtcbmV4cG9ydHMuUmljaFRleHQuZGlzcGxheU5hbWUgPSAnUmljaFRleHQnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbmV4cG9ydHMuU2l0ZWNvcmVDb250ZXh0UmVhY3RDb250ZXh0ID0gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUNvbnRleHQoe30pO1xuZXhwb3J0cy5Db21wb25lbnRGYWN0b3J5UmVhY3RDb250ZXh0ID0gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUNvbnRleHQoe30pO1xudmFyIFNpdGVjb3JlQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2l0ZWNvcmVDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpdGVjb3JlQ29udGV4dChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgcGFnZUVkaXRpbmc6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvcHMuY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IHByb3BzLmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIHNldENvbnRleHQ6IF90aGlzLnNldENvbnRleHQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2l0ZWNvcmVDb250ZXh0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoZXhwb3J0cy5Db21wb25lbnRGYWN0b3J5UmVhY3RDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLnByb3BzLmNvbXBvbmVudEZhY3RvcnkgfSxcbiAgICAgICAgICAgIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGV4cG9ydHMuU2l0ZWNvcmVDb250ZXh0UmVhY3RDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0aGlzLnN0YXRlIH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pKSk7XG4gICAgfTtcbiAgICBTaXRlY29yZUNvbnRleHQucHJvcFR5cGVzID0ge1xuICAgICAgICBjaGlsZHJlbjogcHJvcF90eXBlc18xLmRlZmF1bHQuYW55LmlzUmVxdWlyZWQsXG4gICAgICAgIGNvbXBvbmVudEZhY3Rvcnk6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmZ1bmMsXG4gICAgICAgIGNvbnRleHQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmFueSxcbiAgICB9O1xuICAgIFNpdGVjb3JlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdTaXRlY29yZUNvbnRleHQnO1xuICAgIHJldHVybiBTaXRlY29yZUNvbnRleHQ7XG59KHJlYWN0XzEuZGVmYXVsdC5Db21wb25lbnQpKTtcbmV4cG9ydHMuU2l0ZWNvcmVDb250ZXh0ID0gU2l0ZWNvcmVDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBwcm9wX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuZXhwb3J0cy5UZXh0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZpZWxkID0gX2EuZmllbGQsIHRhZyA9IF9hLnRhZywgZWRpdGFibGUgPSBfYS5lZGl0YWJsZSwgZW5jb2RlID0gX2EuZW5jb2RlLCBvdGhlclByb3BzID0gX19yZXN0KF9hLCBbXCJmaWVsZFwiLCBcInRhZ1wiLCBcImVkaXRhYmxlXCIsIFwiZW5jb2RlXCJdKTtcbiAgICBpZiAoIWZpZWxkIHx8ICghZmllbGQuZWRpdGFibGUgJiYgKGZpZWxkLnZhbHVlID09PSB1bmRlZmluZWQgfHwgZmllbGQudmFsdWUgPT09ICcnKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGNhbid0IHVzZSBlZGl0YWJsZSB2YWx1ZSBpZiB3ZSB3YW50IHRvIG91dHB1dCB1bmVuY29kZWRcbiAgICBpZiAoIWVuY29kZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgZWRpdGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlzRWRpdGFibGUgPSBmaWVsZC5lZGl0YWJsZSAmJiBlZGl0YWJsZTtcbiAgICB2YXIgb3V0cHV0ID0gaXNFZGl0YWJsZVxuICAgICAgICA/IGZpZWxkLmVkaXRhYmxlIHx8ICcnXG4gICAgICAgIDogZmllbGQudmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgOiBmaWVsZC52YWx1ZTtcbiAgICAvLyB3aGVuIHN0cmluZyB2YWx1ZSBpc24ndCBmb3JtYXR0ZWQsIHdlIHNob3VsZCBmb3JtYXQgbGluZSBicmVha3NcbiAgICBpZiAoIWZpZWxkLmVkaXRhYmxlICYmIHR5cGVvZiBvdXRwdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBzcGxpdHRlZF8xID0gU3RyaW5nKG91dHB1dCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICBpZiAoc3BsaXR0ZWRfMS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRfMSA9IFtdO1xuICAgICAgICAgICAgc3BsaXR0ZWRfMS5mb3JFYWNoKGZ1bmN0aW9uIChzdHIsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNMYXN0ID0gaSA9PT0gc3BsaXR0ZWRfMS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZF8xLnB1c2goc3RyKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRfMS5wdXNoKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYnJcIiwgeyBrZXk6IGkgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0dGVkXzE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNldERhbmdlcm91c2x5ID0gaXNFZGl0YWJsZSB8fCAhZW5jb2RlO1xuICAgIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gICAgdmFyIGh0bWxQcm9wcyA9IF9fYXNzaWduKHt9LCBvdGhlclByb3BzKTtcbiAgICBpZiAoc2V0RGFuZ2Vyb3VzbHkpIHtcbiAgICAgICAgaHRtbFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID0ge1xuICAgICAgICAgICAgX19odG1sOiBvdXRwdXQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IG91dHB1dDtcbiAgICB9XG4gICAgaWYgKHRhZyB8fCBzZXREYW5nZXJvdXNseSkge1xuICAgICAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQodGFnIHx8ICdzcGFuJywgaHRtbFByb3BzLCBjaGlsZHJlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQocmVhY3RfMS5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG4gICAgfVxufTtcbmV4cG9ydHMuVGV4dC5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnNoYXBlKHtcbiAgICAgICAgdmFsdWU6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLCBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXJdKSxcbiAgICAgICAgZWRpdGFibGU6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICB9KSxcbiAgICB0YWc6IHByb3BfdHlwZXNfMS5kZWZhdWx0LnN0cmluZyxcbiAgICBlZGl0YWJsZTogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICBlbmNvZGU6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG59O1xuZXhwb3J0cy5UZXh0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBlZGl0YWJsZTogdHJ1ZSxcbiAgICBlbmNvZGU6IHRydWUsXG59O1xuZXhwb3J0cy5UZXh0LmRpc3BsYXlOYW1lID0gJ1RleHQnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd2l0aFNpdGVjb3JlQ29udGV4dF8xID0gcmVxdWlyZShcIi4uL2VuaGFuY2Vycy93aXRoU2l0ZWNvcmVDb250ZXh0XCIpO1xudmFyIGVtaXR0ZWRWSSA9IGZhbHNlO1xudmFyIFZJQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNpdGVjb3JlQ29udGV4dCA9IF9hLnNpdGVjb3JlQ29udGV4dDtcbiAgICBpZiAoZW1pdHRlZFZJIHx8XG4gICAgICAgIHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgIXNpdGVjb3JlQ29udGV4dC52aXNpdG9ySWRlbnRpZmljYXRpb25UaW1lc3RhbXApIHtcbiAgICAgICAgLy8gRG9uJ3QgZW1pdCBWSSBzY3JpcHQgYW5kIG1ldGEgdGFnIGlmIHdlJ3ZlIGFscmVhZHkgZG9uZSBzbyxcbiAgICAgICAgLy8gYXJlbid0IHJlbmRlcmluZyBjbGllbnQtc2lkZSwgb3IgZG9uJ3QgaGF2ZSBhIFZJIHRpbWVzdGFtcC5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVtaXR0ZWRWSSA9IHRydWU7XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zcmMgPSAnL2xheW91dHMvc3lzdGVtL1Zpc2l0b3JJZGVudGlmaWNhdGlvbi5qcyc7XG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICB2YXIgbWV0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICBtZXRhLm5hbWUgPSAnVkljdXJyZW50RGF0ZVRpbWUnO1xuICAgIG1ldGEuY29udGVudCA9IHNpdGVjb3JlQ29udGV4dC52aXNpdG9ySWRlbnRpZmljYXRpb25UaW1lc3RhbXA7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG4gICAgaGVhZCAmJiBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgaGVhZCAmJiBoZWFkLmFwcGVuZENoaWxkKG1ldGEpO1xuICAgIHJldHVybiBudWxsO1xufTtcblZJQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ1Zpc2l0b3JJZGVudGlmaWNhdGlvbic7XG5leHBvcnRzLlZpc2l0b3JJZGVudGlmaWNhdGlvbiA9IHdpdGhTaXRlY29yZUNvbnRleHRfMS53aXRoU2l0ZWNvcmVDb250ZXh0KCkoVklDb21wb25lbnQpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBTaXRlY29yZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL1NpdGVjb3JlQ29udGV4dFwiKTtcbi8qKlxuICogQHBhcmFtIHtSZWFjdC5Db21wb25lbnRDbGFzczxUPiB8IFJlYWN0LlNGQzxUPn0gQ29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIHdpdGhDb21wb25lbnRGYWN0b3J5KENvbXBvbmVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBXaXRoQ29tcG9uZW50RmFjdG9yeShwcm9wcykge1xuICAgICAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNpdGVjb3JlQ29udGV4dF8xLkNvbXBvbmVudEZhY3RvcnlSZWFjdENvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9fYXNzaWduKHt9LCBwcm9wcywgeyBjb21wb25lbnRGYWN0b3J5OiBwcm9wcy5jb21wb25lbnRGYWN0b3J5IHx8IGNvbnRleHQgfSkpOyB9KSk7XG4gICAgfTtcbn1cbmV4cG9ydHMud2l0aENvbXBvbmVudEZhY3RvcnkgPSB3aXRoQ29tcG9uZW50RmFjdG9yeTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfXzEgPSByZXF1aXJlKFwiLi4vXCIpO1xuZXhwb3J0cy53aXRoRXhwZXJpZW5jZUVkaXRvckNocm9tZXMgPSBmdW5jdGlvbiAoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIHZhciBFbmhhbmNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEVuaGFuY2VyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFbmhhbmNlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuZGlzcGxheU5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBFbmhhbmNlci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX18xLnJlc2V0RXhwZXJpZW5jZUVkaXRvckNocm9tZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgRW5oYW5jZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcykpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRW5oYW5jZXI7XG4gICAgfShyZWFjdF8xLmRlZmF1bHQuQ29tcG9uZW50KSk7XG4gICAgcmV0dXJuIEVuaGFuY2VyO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBQbGFjZWhvbGRlckNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvUGxhY2Vob2xkZXJDb21tb25cIik7XG52YXIgd2l0aENvbXBvbmVudEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3dpdGhDb21wb25lbnRGYWN0b3J5XCIpO1xuLyoqXG4gKiBAcGFyYW0ge1dpdGhQbGFjZWhvbGRlclNwZWN9IHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtXaXRoUGxhY2Vob2xkZXJPcHRpb25zfSBbb3B0aW9uc11cbiAqL1xuZnVuY3Rpb24gd2l0aFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVycywgb3B0aW9ucykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChXcmFwcGVkQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBXaXRoUGxhY2Vob2xkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoV2l0aFBsYWNlaG9sZGVyLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gV2l0aFBsYWNlaG9sZGVyKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV2l0aFBsYWNlaG9sZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRQcm9wcyA9IF9fYXNzaWduKHt9LCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGRQcm9wcy5jb21wb25lbnRGYWN0b3J5O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvcHNUcmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzID0gb3B0aW9ucy5wcm9wc1RyYW5zZm9ybWVyKGNoaWxkUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRQcm9wcy5lcnJvckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGNoaWxkUHJvcHMuZXJyb3JDb21wb25lbnQsIHsgZXJyb3I6IHRoaXMuc3RhdGUuZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzYy1qc3MtcGxhY2Vob2xkZXItZXJyb3JcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJBIHJlbmRlcmluZyBlcnJvciBvY2N1cnJlZDogXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVuZGVyaW5nRGF0YSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yZXNvbHZlUGxhY2Vob2xkZXJEYXRhRnJvbVByb3BzXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5yZXNvbHZlUGxhY2Vob2xkZXJEYXRhRnJvbVByb3BzKGNoaWxkUHJvcHMpXG4gICAgICAgICAgICAgICAgICAgIDogY2hpbGRQcm9wcy5yZW5kZXJpbmc7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmluaXRlbHlBcnJheVBsYWNob2xkZXJzID0gIUFycmF5LmlzQXJyYXkocGxhY2Vob2xkZXJzKVxuICAgICAgICAgICAgICAgICAgICA/IFtwbGFjZWhvbGRlcnNdXG4gICAgICAgICAgICAgICAgICAgIDogcGxhY2Vob2xkZXJzO1xuICAgICAgICAgICAgICAgIGRlZmluaXRlbHlBcnJheVBsYWNob2xkZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlckRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGxhY2Vob2xkZXIgIT09ICdzdHJpbmcnICYmIHBsYWNlaG9sZGVyLnBsYWNlaG9sZGVyICYmIHBsYWNlaG9sZGVyLnByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyRGF0YSA9IFBsYWNlaG9sZGVyQ29tbW9uXzEuUGxhY2Vob2xkZXJDb21tb24uZ2V0UGxhY2Vob2xkZXJEYXRhRnJvbVJlbmRlcmluZ0RhdGEocmVuZGVyaW5nRGF0YSwgcGxhY2Vob2xkZXIucGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcHNbcGxhY2Vob2xkZXIucHJvcF0gPSBfdGhpcy5nZXRDb21wb25lbnRzRm9yUmVuZGVyaW5nRGF0YShwbGFjZWhvbGRlckRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJEYXRhID0gUGxhY2Vob2xkZXJDb21tb25fMS5QbGFjZWhvbGRlckNvbW1vbi5nZXRQbGFjZWhvbGRlckRhdGFGcm9tUmVuZGVyaW5nRGF0YShyZW5kZXJpbmdEYXRhLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wc1twbGFjZWhvbGRlcl0gPSBfdGhpcy5nZXRDb21wb25lbnRzRm9yUmVuZGVyaW5nRGF0YShwbGFjZWhvbGRlckRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIF9fYXNzaWduKHt9LCBjaGlsZFByb3BzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgV2l0aFBsYWNlaG9sZGVyLnByb3BUeXBlcyA9IFBsYWNlaG9sZGVyQ29tbW9uXzEuUGxhY2Vob2xkZXJDb21tb24ucHJvcFR5cGVzO1xuICAgICAgICAgICAgcmV0dXJuIFdpdGhQbGFjZWhvbGRlcjtcbiAgICAgICAgfShQbGFjZWhvbGRlckNvbW1vbl8xLlBsYWNlaG9sZGVyQ29tbW9uKSk7XG4gICAgICAgIHJldHVybiB3aXRoQ29tcG9uZW50RmFjdG9yeV8xLndpdGhDb21wb25lbnRGYWN0b3J5KFdpdGhQbGFjZWhvbGRlcik7XG4gICAgfTtcbn1cbmV4cG9ydHMud2l0aFBsYWNlaG9sZGVyID0gd2l0aFBsYWNlaG9sZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBTaXRlY29yZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL1NpdGVjb3JlQ29udGV4dFwiKTtcbi8qKlxuICogQHBhcmFtIHtXaXRoU2l0ZWNvcmVDb250ZXh0T3B0aW9uc30gW29wdGlvbnNdXG4gKi9cbmZ1bmN0aW9uIHdpdGhTaXRlY29yZUNvbnRleHQob3B0aW9ucykge1xuICAgIHJldHVybiBmdW5jdGlvbiB3aXRoU2l0ZWNvcmVDb250ZXh0SG9jKENvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gV2l0aFNpdGVjb3JlQ29udGV4dChwcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIChyZWFjdF8xLmRlZmF1bHQuY3JlYXRlRWxlbWVudChTaXRlY29yZUNvbnRleHRfMS5TaXRlY29yZUNvbnRleHRSZWFjdENvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7IHJldHVybiAocmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgc2l0ZWNvcmVDb250ZXh0OiBjb250ZXh0LmNvbnRleHQsIHVwZGF0ZVNpdGVjb3JlQ29udGV4dDogb3B0aW9ucyAmJiBvcHRpb25zLnVwZGF0YWJsZSAmJiBjb250ZXh0LnNldENvbnRleHQgfSkpKTsgfSkpO1xuICAgICAgICB9O1xuICAgIH07XG59XG5leHBvcnRzLndpdGhTaXRlY29yZUNvbnRleHQgPSB3aXRoU2l0ZWNvcmVDb250ZXh0O1xuLyoqXG4gKiBUaGlzIGhvb2sgZ3JhbnRzIGFj0YFlc3MgdG8gdGhlIGN1cnJlbnQgU2l0ZUNvcmUgcGFnZSBjb250ZXh0XG4gKiBieSBkZWZhdWx0IEpTUyBpbmNsdWRlcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW4gdGhpcyBjb250ZXh0OlxuICogLSBwYWdlRWRpdGluZyAtIFByb3ZpZGVkIGJ5IExheW91dCBTZXJ2aWNlLCBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByb3V0ZSBpcyBiZWluZyBhY2Nlc3NlZCB2aWEgdGhlIEV4cGVyaWVuY2UgRWRpdG9yLlxuICogLSBwYWdlU3RhdGUgLSBMaWtlIHBhZ2VFZGl0aW5nLCBidXQgYSBzdHJpbmc6IG5vcm1hbCwgcHJldmlldyBvciBlZGl0LlxuICogLSBzaXRlIC0gUHJvdmlkZWQgYnkgTGF5b3V0IFNlcnZpY2UsIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IFNpdGVjb3JlIHNpdGUgY29udGV4dC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vanNzLnNpdGVjb3JlLmNvbS9kb2NzL3RlY2huaXF1ZXMvZXh0ZW5kaW5nLWxheW91dC1zZXJ2aWNlL2xheW91dHNlcnZpY2UtZXh0ZW5kaW5nLWNvbnRleHRcbiAqXG4gKiBAcGFyYW0ge1dpdGhTaXRlY29yZUNvbnRleHRPcHRpb25zfSBbb3B0aW9uc10gaG9vayBvcHRpb25zXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IEVkaXRNb2RlID0gKCkgPT4ge1xuICogICAgY29uc3QgeyBzaXRlY29yZUNvbnRleHQgfSA9IHVzZVNpdGVjb3JlQ29udGV4dCgpO1xuICogICAgcmV0dXJuIDxzcGFuPkVkaXQgTW9kZSBpcyB7c2l0ZWNvcmVDb250ZXh0LnBhZ2VFZGl0aW5nID8gJ2FjdGl2ZScgOiAnaW5hY3RpdmUnfTwvc3Bhbj5cbiAqIH1cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgRWRpdE1vZGUgPSAoKSA9PiB7XG4gKiAgICBjb25zdCB7IHNpdGVjb3JlQ29udGV4dCwgdXBkYXRlU2l0ZWNvcmVDb250ZXh0IH0gPSB1c2VTaXRlY29yZUNvbnRleHQoeyB1cGRhdGFibGU6IHRydWUgfSk7XG4gKiAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4gdXBkYXRlU2l0ZWNvcmVDb250ZXh0KHsgcGFnZUVkaXRpbmc6IHRydWUgfSk7XG4gKiAgICByZXR1cm4gPHNwYW4gb25DbGljaz17b25DbGlja30+RWRpdCBNb2RlIGlzIHtzaXRlY29yZUNvbnRleHQucGFnZUVkaXRpbmcgPyAnYWN0aXZlJyA6ICdpbmFjdGl2ZSd9PC9zcGFuPlxuICogfVxuICogQHJldHVybnMge09iamVjdH0geyBzaXRlY29yZUNvbnRleHQsIHVwZGF0ZVNpdGVjb3JlQ29udGV4dCB9XG4gKi9cbmZ1bmN0aW9uIHVzZVNpdGVjb3JlQ29udGV4dChvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciByZWFjdENvbnRleHQgPSByZWFjdF8xLmRlZmF1bHQudXNlQ29udGV4dChTaXRlY29yZUNvbnRleHRfMS5TaXRlY29yZUNvbnRleHRSZWFjdENvbnRleHQpO1xuICAgIHZhciB1cGRhdGFibGUgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRhYmxlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpdGVjb3JlQ29udGV4dDogcmVhY3RDb250ZXh0LmNvbnRleHQsXG4gICAgICAgIHVwZGF0ZVNpdGVjb3JlQ29udGV4dDogdXBkYXRhYmxlID8gcmVhY3RDb250ZXh0LnNldENvbnRleHQgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMudXNlU2l0ZWNvcmVDb250ZXh0ID0gdXNlU2l0ZWNvcmVDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2l0ZWNvcmVfanNzXzEgPSByZXF1aXJlKFwiQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3NcIik7XG5leHBvcnRzLmRhdGFBcGkgPSBzaXRlY29yZV9qc3NfMS5kYXRhQXBpO1xuZXhwb3J0cy5tZWRpYUFwaSA9IHNpdGVjb3JlX2pzc18xLm1lZGlhQXBpO1xuZXhwb3J0cy5pc0V4cGVyaWVuY2VFZGl0b3JBY3RpdmUgPSBzaXRlY29yZV9qc3NfMS5pc0V4cGVyaWVuY2VFZGl0b3JBY3RpdmU7XG5leHBvcnRzLnJlc2V0RXhwZXJpZW5jZUVkaXRvckNocm9tZXMgPSBzaXRlY29yZV9qc3NfMS5yZXNldEV4cGVyaWVuY2VFZGl0b3JDaHJvbWVzO1xuZXhwb3J0cy5MYXlvdXRTZXJ2aWNlUGFnZVN0YXRlID0gc2l0ZWNvcmVfanNzXzEuTGF5b3V0U2VydmljZVBhZ2VTdGF0ZTtcbmV4cG9ydHMuZ2V0Q2hpbGRQbGFjZWhvbGRlciA9IHNpdGVjb3JlX2pzc18xLmdldENoaWxkUGxhY2Vob2xkZXI7XG5leHBvcnRzLmdldEZpZWxkVmFsdWUgPSBzaXRlY29yZV9qc3NfMS5nZXRGaWVsZFZhbHVlO1xudmFyIFBsYWNlaG9sZGVyXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL1BsYWNlaG9sZGVyXCIpO1xuZXhwb3J0cy5QbGFjZWhvbGRlciA9IFBsYWNlaG9sZGVyXzEuUGxhY2Vob2xkZXI7XG52YXIgSW1hZ2VfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvSW1hZ2VcIik7XG5leHBvcnRzLkltYWdlID0gSW1hZ2VfMS5JbWFnZTtcbnZhciBSaWNoVGV4dF8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9SaWNoVGV4dFwiKTtcbmV4cG9ydHMuUmljaFRleHQgPSBSaWNoVGV4dF8xLlJpY2hUZXh0O1xuZXhwb3J0cy5SaWNoVGV4dFByb3BUeXBlcyA9IFJpY2hUZXh0XzEuUmljaFRleHRQcm9wVHlwZXM7XG52YXIgVGV4dF8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9UZXh0XCIpO1xuZXhwb3J0cy5UZXh0ID0gVGV4dF8xLlRleHQ7XG52YXIgRGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9EYXRlXCIpO1xuZXhwb3J0cy5EYXRlRmllbGQgPSBEYXRlXzEuRGF0ZUZpZWxkO1xudmFyIExpbmtfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvTGlua1wiKTtcbmV4cG9ydHMuTGluayA9IExpbmtfMS5MaW5rO1xuZXhwb3J0cy5MaW5rUHJvcFR5cGVzID0gTGlua18xLkxpbmtQcm9wVHlwZXM7XG52YXIgRmlsZV8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9GaWxlXCIpO1xuZXhwb3J0cy5GaWxlID0gRmlsZV8xLkZpbGU7XG52YXIgVmlzaXRvcklkZW50aWZpY2F0aW9uXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL1Zpc2l0b3JJZGVudGlmaWNhdGlvblwiKTtcbmV4cG9ydHMuVmlzaXRvcklkZW50aWZpY2F0aW9uID0gVmlzaXRvcklkZW50aWZpY2F0aW9uXzEuVmlzaXRvcklkZW50aWZpY2F0aW9uO1xudmFyIFNpdGVjb3JlQ29udGV4dF8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9TaXRlY29yZUNvbnRleHRcIik7XG5leHBvcnRzLlNpdGVjb3JlQ29udGV4dCA9IFNpdGVjb3JlQ29udGV4dF8xLlNpdGVjb3JlQ29udGV4dDtcbmV4cG9ydHMuU2l0ZWNvcmVDb250ZXh0UmVhY3RDb250ZXh0ID0gU2l0ZWNvcmVDb250ZXh0XzEuU2l0ZWNvcmVDb250ZXh0UmVhY3RDb250ZXh0O1xudmFyIHdpdGhTaXRlY29yZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2VuaGFuY2Vycy93aXRoU2l0ZWNvcmVDb250ZXh0XCIpO1xuZXhwb3J0cy53aXRoU2l0ZWNvcmVDb250ZXh0ID0gd2l0aFNpdGVjb3JlQ29udGV4dF8xLndpdGhTaXRlY29yZUNvbnRleHQ7XG5leHBvcnRzLnVzZVNpdGVjb3JlQ29udGV4dCA9IHdpdGhTaXRlY29yZUNvbnRleHRfMS51c2VTaXRlY29yZUNvbnRleHQ7XG52YXIgd2l0aEV4cGVyaWVuY2VFZGl0b3JDaHJvbWVzXzEgPSByZXF1aXJlKFwiLi9lbmhhbmNlcnMvd2l0aEV4cGVyaWVuY2VFZGl0b3JDaHJvbWVzXCIpO1xuZXhwb3J0cy53aXRoRXhwZXJpZW5jZUVkaXRvckNocm9tZXMgPSB3aXRoRXhwZXJpZW5jZUVkaXRvckNocm9tZXNfMS53aXRoRXhwZXJpZW5jZUVkaXRvckNocm9tZXM7XG52YXIgd2l0aFBsYWNlaG9sZGVyXzEgPSByZXF1aXJlKFwiLi9lbmhhbmNlcnMvd2l0aFBsYWNlaG9sZGVyXCIpO1xuZXhwb3J0cy53aXRoUGxhY2Vob2xkZXIgPSB3aXRoUGxhY2Vob2xkZXJfMS53aXRoUGxhY2Vob2xkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdHlsZV9hdHRyXzEgPSByZXF1aXJlKFwic3R5bGUtYXR0clwiKTtcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDQyNjY3NC85MzI0XG5leHBvcnRzLmNvbnZlcnRLZWJhYkNhc2V0b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14ufC0uL2csIGZ1bmN0aW9uIChsZXR0ZXIsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gMCA/IGxldHRlci50b0xvd2VyQ2FzZSgpIDogbGV0dGVyLnN1YnN0cigxKS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xufTtcbi8qKlxuICogaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9kb20tZWxlbWVudHMuaHRtbFxuICogV2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggc3R5bGUgYXQgdGhlIG1vbWVudCwgd2hpY2ggbmVlZHMgdG8gYmUgY29udmVydGVkIGZyb20gc3RyaW5nIHRvIG9iamVjdCB0byBzYXRpc2Z5IFJlYWN0LlxuICogV2UgZG9uJ3QgbmVlZCB0byBjb252ZXJ0IGFueSBvdGhlciBhdHRyaWJ1dGVzICh0aGF0IHdlIGtub3cgb2YpLCBiZWNhdXNlIHRoZSBwbGFjZWhvbGRlciByZW5kZXJzIHRoZW0gXCJhcy1pc1wiIGJ5IHVzaW5nIHRoZSBzcGVjaWFsIFwiaXNcIiBSZWFjdCBwcm9wLlxuICogRm9yIHdoYXRldmVyIHJlYXNvbiB0aG91Z2gsIHRoZSBcInN0eWxlXCIgcHJvcCBpcyBzdGlsbCB2YWxpZGF0ZWQgYXMgbmVlZGluZyB0byBiZSBhbiBvYmplY3Qgd2hlbiB1c2luZyB0aGUgXCJpc1wiIHByb3AsIHdoaWNoIGlzIHdoeSB3ZSBuZWVkIHRvIGNvbnZlcnQgZnJvbSBzdHJpbmcgdG8gb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtzdHlsZV0gc3R5bGVcbiAqIEByZXR1cm5zIHtBcnJheX0gY29udmVydGVkIGF0dHJpYnV0ZXNcbiAqL1xuZXhwb3J0cy5jb252ZXJ0U3R5bGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUgPT09IHZvaWQgMCkgeyBzdHlsZSA9ICcnOyB9XG4gICAgLy8gc3R5bGVQYXJzZSBjb252ZXJ0cyBhIHN0eWxlIGF0dHJpYnV0ZSBzdHJpbmcgaW50byBhbiBvYmplY3QgZm9ybWF0XG4gICAgdmFyIHBhcnNlZFN0eWxlID0gc3R5bGVfYXR0cl8xLnBhcnNlKHN0eWxlLCB7IHByZXNlcnZlTnVtYmVyczogdHJ1ZSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGFyc2VkU3R5bGUpLnJlZHVjZShmdW5jdGlvbiAoaW5pdGlhbFJlc3VsdCwgc3R5bGVLZXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGluaXRpYWxSZXN1bHQ7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRLZXkgPSBleHBvcnRzLmNvbnZlcnRLZWJhYkNhc2V0b0NhbWVsQ2FzZShzdHlsZUtleSk7XG4gICAgICAgIHJlc3VsdFtjb252ZXJ0ZWRLZXldID0gcGFyc2VkU3R5bGVbc3R5bGVLZXldO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbn07XG5leHBvcnRzLmNvbnZlcnRBdHRyaWJ1dGVzVG9SZWFjdFByb3BzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChpbml0aWFsUmVzdWx0LCBhdHRyTmFtZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaW5pdGlhbFJlc3VsdDtcbiAgICAgICAgc3dpdGNoIChhdHRyTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnY2xhc3MnOiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNsYXNzTmFtZSA9IGF0dHJpYnV0ZXMuY2xhc3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzdHlsZSc6IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3R5bGUgPSBleHBvcnRzLmNvbnZlcnRTdHlsZUF0dHJpYnV0ZShhdHRyaWJ1dGVzLnN0eWxlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYXR0ck5hbWVdID0gYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHJhY2tpbmdBcGkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHJhY2tpbmdBcGlcIikpO1xuZXhwb3J0cy50cmFja2luZ0FwaSA9IHRyYWNraW5nQXBpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaXRlY29yZV9qc3NfMSA9IHJlcXVpcmUoXCJAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzc1wiKTtcbnZhciBSZXNwb25zZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNwb25zZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc3BvbnNlRXJyb3IobWVzc2FnZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSZXNwb25zZUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlRXJyb3I7XG59KEVycm9yKSk7XG4vKipcbiAqIEBwYXJhbSB7SHR0cFJlc3BvbnNlPHVua25vd24+fSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBjaGVja1N0YXR1cyhyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIHZhciBlcnJvciA9IG5ldyBSZXNwb25zZUVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlKTtcbiAgICB0aHJvdyBlcnJvcjtcbn1cbi8qKlxuICogTm90ZTogYXhpb3MgbmVlZHMgdG8gdXNlIGB3aXRoQ3JlZGVudGlhbHM6IHRydWVgIGluIG9yZGVyIGZvciBTaXRlY29yZSBjb29raWVzIHRvIGJlIGluY2x1ZGVkIGluIENPUlMgcmVxdWVzdHNcbiAqIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgYW5hbHl0aWNzIGFuZCBzdWNoXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge2FueX0gZGF0YVxuICogQHBhcmFtIHtIdHRwRGF0YUZldGNoZXI8VD59IGZldGNoZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZGF0YSwgZmV0Y2hlciwgcGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgcmV0dXJuIGZldGNoZXIoc2l0ZWNvcmVfanNzXzEucmVzb2x2ZVVybCh1cmwsIHBhcmFtcyksIGRhdGEpXG4gICAgICAgIC50aGVuKGNoZWNrU3RhdHVzKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gYXhpb3MgYXV0by1wYXJzZXMgSlNPTiByZXNwb25zZXMsIGRvbid0IG5lZWQgdG8gSlNPTi5wYXJzZVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHtUcmFja2luZ1JlcXVlc3RPcHRpb25zfSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUcmFja2luZ1VybChvcHRpb25zKSB7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5ob3N0LCBob3N0ID0gX2EgPT09IHZvaWQgMCA/ICcnIDogX2EsIF9iID0gb3B0aW9ucy5zZXJ2aWNlVXJsLCBzZXJ2aWNlVXJsID0gX2IgPT09IHZvaWQgMCA/ICcvc2l0ZWNvcmUvYXBpL2pzcy90cmFjaycgOiBfYiwgX2MgPSBvcHRpb25zLmFjdGlvbiwgYWN0aW9uID0gX2MgPT09IHZvaWQgMCA/ICdldmVudCcgOiBfYztcbiAgICByZXR1cm4gXCJcIiArIGhvc3QgKyBzZXJ2aWNlVXJsICsgXCIvXCIgKyBhY3Rpb247XG59XG4vKipcbiAqIE1ha2VzIGEgcmVxdWVzdCB0byBTaXRlY29yZSBMYXlvdXQgU2VydmljZSBmb3IgdGhlIHNwZWNpZmllZCByb3V0ZSBpdGVtIHBhdGguXG4gKiBAcGFyYW0ge0FycmF5PEV2ZW50SW5zdGFuY2UgfCBHb2FsSW5zdGFuY2UgfCBPdXRjb21lSW5zdGFuY2UgfCBDYW1wYWlnbkluc3RhbmNlIHwgUGFnZVZpZXdJbnN0YW5jZT59IGV2ZW50c1xuICogQHBhcmFtIHtUcmFja2luZ1JlcXVlc3RPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gdm9pZFxuICovXG5mdW5jdGlvbiB0cmFja0V2ZW50KGV2ZW50cywgb3B0aW9ucykge1xuICAgIHZhciBxdWVyeXN0cmluZ1BhcmFtcyA9IG9wdGlvbnMucXVlcnlzdHJpbmdQYXJhbXM7XG4gICAgaWYgKCFvcHRpb25zLnRlc3QgJiYgc2l0ZWNvcmVfanNzXzEuaXNTZXJ2ZXIoKSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nIGZvciBTU1IsIG9ubHkgdHJhY2sgZXZlbnRzIHdoZW4gYSBicm93c2VyIHJlcXVlc3RzIGl0XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICAgICAgZXZlbnRzID0gW2V2ZW50c107XG4gICAgfVxuICAgIHZhciBmZXRjaFVybCA9IHJlc29sdmVUcmFja2luZ1VybChvcHRpb25zKTtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKGZldGNoVXJsLCBldmVudHMsIG9wdGlvbnMuZmV0Y2hlciwgcXVlcnlzdHJpbmdQYXJhbXMpO1xufVxuZXhwb3J0cy50cmFja0V2ZW50ID0gdHJhY2tFdmVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbnZhciBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2RlYnVnXCIpKTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGVycm9yIGlzIEF4aW9zRXJyb3JcbiAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3JcbiAqL1xudmFyIGlzQXhpb3NFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5pc0F4aW9zRXJyb3IgIT09IHVuZGVmaW5lZDtcbn07XG52YXIgQXhpb3NEYXRhRmV0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0F4aW9zRGF0YUZldGNoZXJDb25maWd9IGRhdGFGZXRjaGVyQ29uZmlnIEF4aW9zIGRhdGEgZmV0Y2hlciBjb25maWd1cmF0aW9uLlxuICAgICAqIE5vdGUgYHdpdGhDcmVkZW50aWFsc2AgaXMgc2V0IHRvIGB0cnVlYCBieSBkZWZhdWx0IGluIG9yZGVyIGZvciBTaXRlY29yZSBjb29raWVzIHRvXG4gICAgICogYmUgaW5jbHVkZWQgaW4gQ09SUyByZXF1ZXN0cyAod2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBhbmFseXRpY3MgYW5kIHN1Y2gpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF4aW9zRGF0YUZldGNoZXIoZGF0YUZldGNoZXJDb25maWcpIHtcbiAgICAgICAgaWYgKGRhdGFGZXRjaGVyQ29uZmlnID09PSB2b2lkIDApIHsgZGF0YUZldGNoZXJDb25maWcgPSB7fTsgfVxuICAgICAgICB2YXIgb25SZXEgPSBkYXRhRmV0Y2hlckNvbmZpZy5vblJlcSwgb25SZXMgPSBkYXRhRmV0Y2hlckNvbmZpZy5vblJlcywgb25SZXFFcnJvciA9IGRhdGFGZXRjaGVyQ29uZmlnLm9uUmVxRXJyb3IsIG9uUmVzRXJyb3IgPSBkYXRhRmV0Y2hlckNvbmZpZy5vblJlc0Vycm9yLCBheGlvc0NvbmZpZyA9IF9fcmVzdChkYXRhRmV0Y2hlckNvbmZpZywgW1wib25SZXFcIiwgXCJvblJlc1wiLCBcIm9uUmVxRXJyb3JcIiwgXCJvblJlc0Vycm9yXCJdKTtcbiAgICAgICAgaWYgKGF4aW9zQ29uZmlnLndpdGhDcmVkZW50aWFscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBheGlvc0NvbmZpZy53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBheGlvc18xLmRlZmF1bHQuY3JlYXRlKGF4aW9zQ29uZmlnKTtcbiAgICAgICAgdmFyIGRlYnVnID0gZGF0YUZldGNoZXJDb25maWcuZGVidWdnZXIgfHwgZGVidWdfMS5kZWZhdWx0Lmh0dHA7XG4gICAgICAgIC8vIE5vdGUgQXhpb3MgcmVzcG9uc2UgaW50ZXJjZXB0b3JzIGFyZSBhcHBsaWVkIGluIHJlZ2lzdGVyZWQgb3JkZXI7XG4gICAgICAgIC8vIGhvd2V2ZXIsIHJlcXVlc3QgaW50ZXJjZXB0b3JzIGFyZSBSRVZFUlNFRCAoaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zL2lzc3Vlcy8xNjYzKS5cbiAgICAgICAgLy8gSGVuY2UsIHdlJ3JlIGFkZGluZyBvdXIgcmVxdWVzdCBkZWJ1ZyBsb2dnaW5nIGZpcnN0IChzaW5jZSB3ZSB3YW50IHRoYXQgcGVyZm9ybWVkIGFmdGVyIGFueSBvblJlcSlcbiAgICAgICAgLy8gYW5kIG91ciByZXNwb25zZSBkZWJ1ZyBsb2dnaW5nIHNlY29uZCAoc2luY2Ugd2Ugd2FudCB0aGF0IHBlcmZvcm1lZCBhZnRlciBhbnkgb25SZXMpLlxuICAgICAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdyZXF1ZXN0OiAlbycsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdyZXF1ZXN0IGVycm9yOiAlbycsIGlzQXhpb3NFcnJvcihlcnJvcikgPyBlcnJvci50b0pTT04oKSA6IGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUmVxKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShvblJlcSwgb25SZXFFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUmVzKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2Uob25SZXMsIG9uUmVzRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB3ZSdyZSByZW1vdmluZyByZWR1bmRhbnQgcHJvcGVydGllcyAoYWxyZWFkeSBwYXJ0IG9mIHJlcXVlc3QgbG9nIGFib3ZlKSB0byB0cmltIGRvd24gbG9nIGVudHJ5XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVzcG9uc2UucmVxdWVzdCwgY29uZmlnID0gcmVzcG9uc2UuY29uZmlnLCByZXN0ID0gX19yZXN0KHJlc3BvbnNlLCBbXCJyZXF1ZXN0XCIsIFwiY29uZmlnXCJdKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZygncmVzcG9uc2U6ICVvJywgcmVzdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3Jlc3BvbnNlIGVycm9yOiAlbycsIGlzQXhpb3NFcnJvcihlcnJvcikgPyBlcnJvci50b0pTT04oKSA6IGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBhIGRhdGEgZmV0Y2hlci4gQHNlZSBIdHRwRGF0YUZldGNoZXI8VD4gdHlwZSBmb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscy9ub3Rlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gcmVxdWVzdDsgbWF5IGluY2x1ZGUgcXVlcnkgc3RyaW5nXG4gICAgICogQHBhcmFtIHthbnl9IFtkYXRhXSBPcHRpb25hbCBkYXRhIHRvIFBPU1Qgd2l0aCB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBeGlvc1Jlc3BvbnNlPFQ+Pn0gcmVzcG9uc2VcbiAgICAgKi9cbiAgICBBeGlvc0RhdGFGZXRjaGVyLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UucmVxdWVzdCh7XG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIG1ldGhvZDogZGF0YSA/ICdQT1NUJyA6ICdHRVQnLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgR0VUIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gcmVxdWVzdDsgbWF5IGluY2x1ZGUgcXVlcnkgc3RyaW5nXG4gICAgICogQHBhcmFtIHtBeGlvc1JlcXVlc3RDb25maWd9IFtjb25maWddIEF4aW9zIGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEF4aW9zUmVzcG9uc2U8VD4+fSByZXNwb25zZVxuICAgICAqL1xuICAgIEF4aW9zRGF0YUZldGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5nZXQodXJsLCBjb25maWcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIEhFQUQgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byByZXF1ZXN0OyBtYXkgaW5jbHVkZSBxdWVyeSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0F4aW9zUmVxdWVzdENvbmZpZ30gW2NvbmZpZ10gQXhpb3MgY29uZmlnXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXhpb3NSZXNwb25zZT59IHJlc3BvbnNlXG4gICAgICovXG4gICAgQXhpb3NEYXRhRmV0Y2hlci5wcm90b3R5cGUuaGVhZCA9IGZ1bmN0aW9uICh1cmwsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5oZWFkKHVybCwgY29uZmlnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBQT1NUIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gcmVxdWVzdDsgbWF5IGluY2x1ZGUgcXVlcnkgc3RyaW5nXG4gICAgICogQHBhcmFtIHthbnl9IFtkYXRhXSBEYXRhIHRvIFBPU1Qgd2l0aCB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0ge0F4aW9zUmVxdWVzdENvbmZpZ30gW2NvbmZpZ10gQXhpb3MgY29uZmlnXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXhpb3NSZXNwb25zZT59IHJlc3BvbnNlXG4gICAgICovXG4gICAgQXhpb3NEYXRhRmV0Y2hlci5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5wb3N0KHVybCwgZGF0YSwgY29uZmlnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBQVVQgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byByZXF1ZXN0OyBtYXkgaW5jbHVkZSBxdWVyeSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge2FueX0gW2RhdGFdIERhdGEgdG8gUFVUIHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtBeGlvc1JlcXVlc3RDb25maWd9IFtjb25maWddIEF4aW9zIGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEF4aW9zUmVzcG9uc2U+fSByZXNwb25zZVxuICAgICAqL1xuICAgIEF4aW9zRGF0YUZldGNoZXIucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5wdXQodXJsLCBkYXRhLCBjb25maWcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIERFTEVURSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHJlcXVlc3Q7IG1heSBpbmNsdWRlIHF1ZXJ5IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7QXhpb3NSZXF1ZXN0Q29uZmlnfSBbY29uZmlnXSBBeGlvcyBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBeGlvc1Jlc3BvbnNlPn0gcmVzcG9uc2VcbiAgICAgKi9cbiAgICBBeGlvc0RhdGFGZXRjaGVyLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuZGVsZXRlKHVybCwgY29uZmlnKTtcbiAgICB9O1xuICAgIHJldHVybiBBeGlvc0RhdGFGZXRjaGVyO1xufSgpKTtcbmV4cG9ydHMuQXhpb3NEYXRhRmV0Y2hlciA9IEF4aW9zRGF0YUZldGNoZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtZW1vcnlfY2FjaGVfMSA9IHJlcXVpcmUoXCJtZW1vcnktY2FjaGVcIik7XG4vKipcbiAqIERlZmF1bHQgY2FjaGUgY29uZmlndXJhdGlvblxuICovXG52YXIgREVGQVVMVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBjYWNoZVRpbWVvdXQ6IDYwLFxuICAgIGNhY2hlRW5hYmxlZDogdHJ1ZSxcbn0pO1xuLyoqXG4gKiBBIGNhY2hlIGNsaWVudCB0aGF0IHVzZXMgdGhlICdtZW1vcnktY2FjaGUnIGxpYnJhcnkgKGh0dHBzOi8vZ2l0aHViLmNvbS9wdGFyamFuL25vZGUtY2FjaGUpLlxuICogVGhpcyBjbGFzcyBpcyBtZWFudCB0byBiZSBleHRlbmRlZCBvciB1c2VkIGFzIGEgbWl4aW47IGl0J3Mgbm90IG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBkYXRhIGJlaW5nIGNhY2hlZC5cbiAqIEBtaXhpblxuICovXG52YXIgTWVtb3J5Q2FjaGVDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQHNlZSBNZW1vcnlDYWNoZUNsaWVudCB1c2luZyB0aGUgcHJvdmlkZWQgQHNlZSBDYWNoZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0NhY2hlT3B0aW9uc30gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZW1vcnlDYWNoZUNsaWVudChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBtZW1vcnlfY2FjaGVfMS5DYWNoZSgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuY2FjaGVUaW1lb3V0ID0gKF9hID0gdGhpcy5vcHRpb25zLmNhY2hlVGltZW91dCwgKF9hICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRTLmNhY2hlVGltZW91dCkpICogMTAwMDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jYWNoZUVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNhY2hlRW5hYmxlZCA9IERFRkFVTFRTLmNhY2hlRW5hYmxlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBkYXRhIGJlaW5nIGNhY2hlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlIHZhbHVlIGFzIHtUfSwgb3IgbnVsbCBpZiB0aGUgc3BlY2lmaWVkIGtleSBpcyBub3QgZm91bmQgaW4gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIE1lbW9yeUNhY2hlQ2xpZW50LnByb3RvdHlwZS5nZXRDYWNoZVZhbHVlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNhY2hlRW5hYmxlZCA/IHRoaXMuY2FjaGUuZ2V0KGtleSkgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBjYWNoZSBmb3IgdGhlIHNwZWNpZmllZCBjYWNoZSBrZXkuXG4gICAgICogQHRlbXBsYXRlIFQgVGhlIHR5cGUgb2YgZGF0YSBiZWluZyBjYWNoZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgY2FjaGUga2V5LlxuICAgICAqIEBwYXJhbSB7VH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhZGRlZCB0byB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgTWVtb3J5Q2FjaGVDbGllbnQucHJvdG90eXBlLnNldENhY2hlVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNhY2hlRW5hYmxlZFxuICAgICAgICAgICAgPyB0aGlzLmNhY2hlLnB1dChrZXksIHZhbHVlLCB0aGlzLm9wdGlvbnMuY2FjaGVUaW1lb3V0KVxuICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBNZW1vcnlDYWNoZUNsaWVudDtcbn0oKSk7XG5leHBvcnRzLk1lbW9yeUNhY2hlQ2xpZW50ID0gTWVtb3J5Q2FjaGVDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTaXRlY29yZVRlbXBsYXRlSWQ7XG4oZnVuY3Rpb24gKFNpdGVjb3JlVGVtcGxhdGVJZCkge1xuICAgIC8vIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL0FwcFxuICAgIFNpdGVjb3JlVGVtcGxhdGVJZFtcIkpzc0FwcFwiXSA9IFwiMDYxY2JhMTU1NDc0NGI5MThhMDYxNzkwM2IxMDJiODJcIjtcbiAgICAvLyAvc2l0ZWNvcmUvdGVtcGxhdGVzL1N5c3RlbS9EaWN0aW9uYXJ5L0RpY3Rpb25hcnkgZW50cnlcbiAgICBTaXRlY29yZVRlbXBsYXRlSWRbXCJEaWN0aW9uYXJ5RW50cnlcIl0gPSBcIjZkMWNkODk3MTkzNjRhM2FhNTExMjg5YTk0YzJhN2IxXCI7XG59KShTaXRlY29yZVRlbXBsYXRlSWQgPSBleHBvcnRzLlNpdGVjb3JlVGVtcGxhdGVJZCB8fCAoZXhwb3J0cy5TaXRlY29yZVRlbXBsYXRlSWQgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByZXNvbHZlX3VybF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtdXJsXCIpKTtcbnZhciBSZXNwb25zZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNwb25zZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc3BvbnNlRXJyb3IobWVzc2FnZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBSZXNwb25zZUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlRXJyb3I7XG59KEVycm9yKSk7XG4vKipcbiAqIEBwYXJhbSB7SHR0cFJlc3BvbnNlPFQ+fSByZXNwb25zZVxuICogQHRocm93cyB7UmVzcG9uc2VFcnJvcn0gaWYgcmVzcG9uc2UgY29kZSBpcyBub3Qgb2tcbiAqL1xuZnVuY3Rpb24gY2hlY2tTdGF0dXMocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICB2YXIgZXJyb3IgPSBuZXcgUmVzcG9uc2VFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0LCByZXNwb25zZSk7XG4gICAgdGhyb3cgZXJyb3I7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7SHR0cERhdGFGZXRjaGVyfSBmZXRjaGVyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIGZldGNoZXIsIHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMgPT09IHZvaWQgMCkgeyBwYXJhbXMgPSB7fTsgfVxuICAgIHJldHVybiBmZXRjaGVyKHJlc29sdmVfdXJsXzEuZGVmYXVsdCh1cmwsIHBhcmFtcykpXG4gICAgICAgIC50aGVuKGNoZWNrU3RhdHVzKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gYXhpb3MgYXV0by1wYXJzZXMgSlNPTiByZXNwb25zZXMsIGRvbid0IG5lZWQgdG8gSlNPTi5wYXJzZVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hEYXRhID0gZmV0Y2hEYXRhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX2EsIF9iO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbnZhciBpc19zZXJ2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9pcy1zZXJ2ZXJcIikpO1xudmFyIHJvb3ROYW1lc3BhY2UgPSAnc2l0ZWNvcmUtanNzJztcbi8vIE9uIHNlcnZlci9ub2RlIHNpZGUsIGFsbG93IHN3aXRjaGluZyBmcm9tIHRoZSBidWlsdC1pblxuLy8gYCVvYCAocHJldHR5LXByaW50IHNpbmdsZSBsaW5lKSBhbmQgYCVPYCAocHJldHR5LXByaW50IG11bHRpcGxlIGxpbmUpXG4vLyB3aXRoIGEgYERFQlVHX01VTFRJTElORWAgZW52aXJvbm1lbnQgdmFyaWFibGUuXG5pZiAoaXNfc2VydmVyXzEuZGVmYXVsdCgpICYmXG4gICAgKChfYiA9IChfYSA9IHByb2Nlc3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbnYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ERUJVR19NVUxUSUxJTkUpID09PSAndHJ1ZScgJiZcbiAgICBkZWJ1Z18xLmRlZmF1bHQuZm9ybWF0dGVycy5vICYmXG4gICAgZGVidWdfMS5kZWZhdWx0LmZvcm1hdHRlcnMuTykge1xuICAgIGRlYnVnXzEuZGVmYXVsdC5mb3JtYXR0ZXJzLm8gPSBkZWJ1Z18xLmRlZmF1bHQuZm9ybWF0dGVycy5PO1xufVxuLyoqXG4gKiBEZWZhdWx0IFNpdGVjb3JlIEpTUyAnZGVidWcnIG1vZHVsZSBkZWJ1Z2dlcnMuIFVzZXMgbmFtZXNwYWNlIHByZWZpeCAnc2l0ZWNvcmUtanNzOicuXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2RlYnVnfSBmb3IgZGV0YWlscy5cbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgaHR0cDogZGVidWdfMS5kZWZhdWx0KHJvb3ROYW1lc3BhY2UgKyBcIjpodHRwXCIpLFxuICAgIGxheW91dDogZGVidWdfMS5kZWZhdWx0KHJvb3ROYW1lc3BhY2UgKyBcIjpsYXlvdXRcIiksXG4gICAgZGljdGlvbmFyeTogZGVidWdfMS5kZWZhdWx0KHJvb3ROYW1lc3BhY2UgKyBcIjpkaWN0aW9uYXJ5XCIpLFxuICAgIGV4cGVyaWVuY2VFZGl0b3I6IGRlYnVnXzEuZGVmYXVsdChyb290TmFtZXNwYWNlICsgXCI6ZWRpdGluZ1wiKSxcbiAgICBzaXRlbWFwOiBkZWJ1Z18xLmRlZmF1bHQocm9vdE5hbWVzcGFjZSArIFwiOnNpdGVtYXBcIiksXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFwaHFsX3JlcXVlc3RfMSA9IHJlcXVpcmUoXCJncmFwaHFsLXJlcXVlc3RcIik7XG52YXIgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9kZWJ1Z1wiKSk7XG4vKipcbiAqIEEgR3JhcGhRTCBjbGllbnQgZm9yIFNpdGVjb3JlIEFQSXMgdGhhdCB1c2VzIHRoZSAnZ3JhcGhxbC1yZXF1ZXN0JyBsaWJyYXJ5LlxuICogaHR0cHM6Ly9naXRodWIuY29tL3ByaXNtYS1sYWJzL2dyYXBocWwtcmVxdWVzdFxuICovXG52YXIgR3JhcGhRTFJlcXVlc3RDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYWJpbGl0eSB0byBleGVjdXRlIGdyYXBocWwgcXVlcnkgdXNpbmcgZ2l2ZW4gYGVuZHBvaW50YFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCBUaGUgR3JhcGhxbCBlbmRwb2ludFxuICAgICAqIEBwYXJhbSB7R3JhcGhRTFJlcXVlc3RDbGllbnRDb25maWd9IFtjbGllbnRDb25maWddIEdyYXBoUUwgcmVxdWVzdCBjbGllbnQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHcmFwaFFMUmVxdWVzdENsaWVudChlbmRwb2ludCwgY2xpZW50Q29uZmlnKSB7XG4gICAgICAgIGlmIChjbGllbnRDb25maWcgPT09IHZvaWQgMCkgeyBjbGllbnRDb25maWcgPSB7fTsgfVxuICAgICAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgICAgICBpZiAoY2xpZW50Q29uZmlnLmFwaUtleSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNjX2FwaWtleSA9IGNsaWVudENvbmZpZy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgZ3JhcGhxbF9yZXF1ZXN0XzEuR3JhcGhRTENsaWVudChlbmRwb2ludCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgIHRoaXMuZGVidWcgPSBjbGllbnRDb25maWcuZGVidWdnZXIgfHwgZGVidWdfMS5kZWZhdWx0Lmh0dHA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgZ3JhcGhxbCByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBEb2N1bWVudE5vZGV9IHF1ZXJ5IGdyYXBocWwgcXVlcnlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFyaWFibGVzIGdyYXBocWwgdmFyaWFibGVzXG4gICAgICovXG4gICAgR3JhcGhRTFJlcXVlc3RDbGllbnQucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAocXVlcnksIHZhcmlhYmxlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHJhdyByZXF1ZXN0L3Jlc3BvbnNlIHdpdGggZ3JhcGhxbC1yZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAob3IgbmljZSBob29rcyBsaWtlIHdlIGhhdmUgd2l0aCBBeGlvcyksIGJ1dCB3ZSBzaG91bGQgbG9nIHdoYXRldmVyIHdlIGhhdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWJ1ZygncmVxdWVzdDogJW8nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBfdGhpcy5lbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBfdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xpZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcXVlc3QocXVlcnksIHZhcmlhYmxlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRlYnVnKCdyZXNwb25zZTogJW8nLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVidWcoJ3Jlc3BvbnNlIGVycm9yOiAlbycsIGVycm9yLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGhRTFJlcXVlc3RDbGllbnQ7XG59KCkpO1xuZXhwb3J0cy5HcmFwaFFMUmVxdWVzdENsaWVudCA9IEdyYXBoUUxSZXF1ZXN0Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWJ1Z1wiKSk7XG4vKiogQHByaXZhdGUgKi9cbmV4cG9ydHMuc2l0ZU5hbWVFcnJvciA9ICdUaGUgc2l0ZSBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJztcbi8qKiBAcHJpdmF0ZSAqL1xuZXhwb3J0cy5sYW5ndWFnZUVycm9yID0gJ1RoZSBsYW5ndWFnZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyc7XG4vKlxuICogR3JhcGhRTCBxdWVyeSB0aGF0IHJldHVybnMgdGhlIElEIG9mIHRoZSByb290IGl0ZW0gb2YgdGhlIHNwZWNpZmllZCBzaXRlIGFuZCBsYW5ndWFnZVxuICovXG52YXIgYXBwUm9vdFF1ZXJ5ID0gLyogR3JhcGhRTCAqLyBcIlxcbiAgcXVlcnkgQXBwUm9vdFF1ZXJ5KCRqc3NBcHBUZW1wbGF0ZUlkOiBTdHJpbmchLCAkc2l0ZU5hbWU6IFN0cmluZyEsICRsYW5ndWFnZTogU3RyaW5nISkge1xcbiAgICBsYXlvdXQoc2l0ZTogJHNpdGVOYW1lLCByb3V0ZVBhdGg6IFxcXCIvXFxcIiwgbGFuZ3VhZ2U6ICRsYW5ndWFnZSkge1xcbiAgICAgIGhvbWVQYWdlOiBpdGVtIHtcXG4gICAgICAgIHJvb3RJdGVtOiBhbmNlc3RvcnMoaW5jbHVkZVRlbXBsYXRlSURzOiBbJGpzc0FwcFRlbXBsYXRlSWRdKSB7XFxuICAgICAgICAgIGlkXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXCI7XG4vKipcbiAqIEdldHMgdGhlIElEIG9mIHRoZSBKU1MgQXBwIHJvb3QgaXRlbSBmb3IgdGhlIHNwZWNpZmllZCBzaXRlIGFuZCBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7R3JhcGhRTENsaWVudH0gY2xpZW50IHRoYXQgZmV0Y2hlcyBkYXRhIGZyb20gYSBHcmFwaFFMIGVuZHBvaW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHNpdGVOYW1lIHRoZSBuYW1lIG9mIHRoZSBTaXRlY29yZSBzaXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIHRoZSBpdGVtIGxhbmd1YWdlIHZlcnNpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30ganNzQXBwVGVtcGxhdGVJZCBvcHRpb25hbCB0ZW1wbGF0ZSBJRCBvZiB0aGUgYXBwIHJvb3QgaXRlbS4gSWYgbm90XG4gKiBzcGVjaWZpZWQsIHRoZSBJRCBvZiB0aGUgXCIvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9BcHBcIlxuICogaXRlbSBpcyB1c2VkLlxuICogQHJldHVybnMgdGhlIHJvb3QgaXRlbSBJRCBvZiB0aGUgSlNTIEFwcCBpbiBTaXRlY29yZS4gUmV0dXJucyBudWxsIGlmIHRoZSBhcHAgcm9vdCBpdGVtIGlzIG5vdCBmb3VuZC5cbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGlmIGEgdmFsaWQgc2l0ZSBuYW1lIHZhbHVlIGlzIG5vdCBwcm92aWRlZC5cbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGlmIGEgdmFsaWQgbGFuZ3VhZ2UgdmFsdWUgaXMgbm90IHByb3ZpZGVkLlxuICogVGhpcyBmdW5jdGlvbiBpbnRlbnRpb25hbGx5IGF2b2lkcyB0aHJvd2luZyBhbiBlcnJvciBpZiBhIHJvb3QgaXRlbSBpcyBub3QgZm91bmQsXG4gKiBsZWF2aW5nIHRoYXQgZGVjaXNpb24gdXAgdG8gaW1wbGVtZW50YXRpb25zLlxuICovXG5mdW5jdGlvbiBnZXRBcHBSb290SWQoY2xpZW50LCBzaXRlTmFtZSwgbGFuZ3VhZ2UsIGpzc0FwcFRlbXBsYXRlSWQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmV0Y2hSZXNwb25zZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaXRlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZXhwb3J0cy5zaXRlTmFtZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihleHBvcnRzLmxhbmd1YWdlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnXzEuZGVmYXVsdC5kaWN0aW9uYXJ5KCdmZXRjaGluZyBzaXRlIHJvb3QgZm9yICVzICVzJywgbGFuZ3VhZ2UsIHNpdGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY2xpZW50LnJlcXVlc3QoYXBwUm9vdFF1ZXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNzQXBwVGVtcGxhdGVJZDoganNzQXBwVGVtcGxhdGVJZCB8fCBjb25zdGFudHNfMS5TaXRlY29yZVRlbXBsYXRlSWQuSnNzQXBwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpdGVOYW1lOiBzaXRlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBmZXRjaFJlc3BvbnNlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSBmZXRjaFJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGF5b3V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaG9tZVBhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yb290SXRlbSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmV0Y2hSZXNwb25zZS5sYXlvdXQuaG9tZVBhZ2Uucm9vdEl0ZW1bMF0uaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0QXBwUm9vdElkID0gZ2V0QXBwUm9vdElkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXBwX3Jvb3RfcXVlcnlfMSA9IHJlcXVpcmUoXCIuL2FwcC1yb290LXF1ZXJ5XCIpO1xuZXhwb3J0cy5nZXRBcHBSb290SWQgPSBhcHBfcm9vdF9xdWVyeV8xLmdldEFwcFJvb3RJZDtcbnZhciBzZWFyY2hfc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VhcmNoLXNlcnZpY2VcIik7XG5leHBvcnRzLlNlYXJjaFF1ZXJ5U2VydmljZSA9IHNlYXJjaF9zZXJ2aWNlXzEuU2VhcmNoUXVlcnlTZXJ2aWNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgcGVyZm9ybWluZyBHcmFwaFFMICdzZWFyY2gnIG9wZXJhdGlvbnMsIGluY2x1ZGluZyBoYW5kbGluZyBwYWdpbmF0aW9uLlxuICogVGhpcyBjbGFzcyBpcyBtZWFudCB0byBiZSBleHRlbmRlZCBvciB1c2VkIGFzIGEgbWl4aW47IGl0J3Mgbm90IG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBvYmplY3RzIGJlaW5nIHJlcXVlc3RlZC5cbiAqIEBtaXhpblxuICovXG52YXIgU2VhcmNoUXVlcnlTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2Ygc2VhcmNoIHF1ZXJ5IHNlcnZpY2UuXG4gICAgICogQHBhcmFtIHtHcmFwaFFMQ2xpZW50fSBjbGllbnQgdGhhdCBmZXRjaGVzIGRhdGEgZnJvbSBhIEdyYXBoUUwgZW5kcG9pbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2VhcmNoUXVlcnlTZXJ2aWNlKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogMS4gVmFsaWRhdGVzIG1hbmRhdG9yeSBzZWFyY2ggcXVlcnkgYXJndW1lbnRzXG4gICAgICogMi4gRXhlY3V0ZXMgc2VhcmNoIHF1ZXJ5IHdpdGggcGFnaW5hdGlvblxuICAgICAqIDMuIEFnZ3JlZ2F0ZXMgcGFnaW5hdGlvbiByZXN1bHRzIGludG8gYSBzaW5nbGUgcmVzdWx0LXNldC5cbiAgICAgKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBvYmplY3RzIGJlaW5nIHJlcXVlc3RlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IERvY3VtZW50Tm9kZX0gcXVlcnkgdGhlIHNlYXJjaCBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge1NlYXJjaFF1ZXJ5VmFyaWFibGVzfSBhcmdzIHNlYXJjaCBxdWVyeSBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge1RbXX0gYXJyYXkgb2YgcmVzdWx0IG9iamVjdHMuXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gaWYgYSB2YWxpZCByb290IGl0ZW0gSUQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGlmIHRoZSBwcm92aWRlZCBsYW5ndWFnZShzKSBpcyhhcmUpIG5vdCB2YWxpZC5cbiAgICAgKi9cbiAgICBTZWFyY2hRdWVyeVNlcnZpY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHF1ZXJ5LCBhcmdzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNOZXh0LCBhZnRlciwgZmV0Y2hSZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXJncy5yb290SXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wicm9vdEl0ZW1JZFwiIGFuZCBcImxhbmd1YWdlXCIgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzLmxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wicm9vdEl0ZW1JZFwiIGFuZCBcImxhbmd1YWdlXCIgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc05leHQpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jbGllbnQucmVxdWVzdChxdWVyeSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGFyZ3MpLCB7IGFmdGVyOiBhZnRlciB9KSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFJlc3BvbnNlID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KChfYiA9IChfYSA9IGZldGNoUmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZWFyY2gpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc05leHQgPSBmZXRjaFJlc3BvbnNlLnNlYXJjaC5wYWdlSW5mby5oYXNOZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBmZXRjaFJlc3BvbnNlLnNlYXJjaC5wYWdlSW5mby5lbmRDdXJzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0c107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNlYXJjaFF1ZXJ5U2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlNlYXJjaFF1ZXJ5U2VydmljZSA9IFNlYXJjaFF1ZXJ5U2VydmljZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNhY2hlX2NsaWVudF8xID0gcmVxdWlyZShcIi4uL2NhY2hlLWNsaWVudFwiKTtcbi8qKlxuICogQmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBAc2VlIERpY3Rpb25hcnlTZXJ2aWNlIHRoYXQgaGFuZGxlcyBjYWNoaW5nIGRpY3Rpb25hcnkgdmFsdWVzXG4gKi9cbnZhciBEaWN0aW9uYXJ5U2VydmljZUJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQHNlZSBEaWN0aW9uYXJ5U2VydmljZSB1c2luZyB0aGUgcHJvdmlkZWQgQHNlZSBDYWNoZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0NhY2hlT3B0aW9uc30gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5U2VydmljZUJhc2Uob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNhY2hlID0gdGhpcy5nZXRDYWNoZUNsaWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWNoZXMgYSBAc2VlIERpY3Rpb25hcnlQaHJhc2VzIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIGNhY2hlIGtleS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBjYWNoZSBrZXkuXG4gICAgICogQHBhcmFtIHtEaWN0aW9uYXJ5UGhyYXNlc30gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhZGRlZCB0byB0aGUgY2FjaGUuXG4gICAgICogQG1peGVzIENhY2hlQ2xpZW50PERpY3Rpb25hcnlQaHJhc2VzPlxuICAgICAqL1xuICAgIERpY3Rpb25hcnlTZXJ2aWNlQmFzZS5wcm90b3R5cGUuc2V0Q2FjaGVWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLnNldENhY2hlVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBAc2VlIERpY3Rpb25hcnlQaHJhc2VzIHZhbHVlIGZyb20gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyBUaGUgQHNlZSBEaWN0aW9uYXJ5UGhyYXNlcyB2YWx1ZSwgb3IgbnVsbCBpZiB0aGUgc3BlY2lmaWVkIGtleSBpcyBub3QgZm91bmQgaW4gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIERpY3Rpb25hcnlTZXJ2aWNlQmFzZS5wcm90b3R5cGUuZ2V0Q2FjaGVWYWx1ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0Q2FjaGVWYWx1ZShrZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGNhY2hlIGNsaWVudCB0aGF0IGNhbiBjYWNoZSBkYXRhLiBVc2VzIG1lbW9yeS1jYWNoZSBhcyB0aGUgZGVmYXVsdFxuICAgICAqIGxpYnJhcnkgZm9yIGNhY2hpbmcgKEBzZWUgTWVtb3J5Q2FjaGVDbGllbnQpLiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VcbiAgICAgKiB3YW50IHRvIHVzZSBzb21ldGhpbmcgZWxzZS5cbiAgICAgKiBAcmV0dXJucyB7Q2FjaGVDbGllbnR9IGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgRGljdGlvbmFyeVNlcnZpY2VCYXNlLnByb3RvdHlwZS5nZXRDYWNoZUNsaWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjYWNoZV9jbGllbnRfMS5NZW1vcnlDYWNoZUNsaWVudCh0aGlzLm9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIERpY3Rpb25hcnlTZXJ2aWNlQmFzZTtcbn0oKSk7XG5leHBvcnRzLkRpY3Rpb25hcnlTZXJ2aWNlQmFzZSA9IERpY3Rpb25hcnlTZXJ2aWNlQmFzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBocWxfcmVxdWVzdF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaHFsLXJlcXVlc3QtY2xpZW50XCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBkaWN0aW9uYXJ5X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2RpY3Rpb25hcnktc2VydmljZVwiKTtcbnZhciBncmFwaHFsXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGhxbFwiKTtcbnZhciBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWJ1Z1wiKSk7XG4vKiogQHByaXZhdGUgKi9cbmV4cG9ydHMucXVlcnlFcnJvciA9ICdWYWxpZCB2YWx1ZSBmb3Igcm9vdEl0ZW1JZCBub3QgcHJvdmlkZWQgYW5kIGZhaWxlZCB0byBhdXRvLXJlc29sdmUgYXBwIHJvb3QgaXRlbS4nO1xudmFyIHF1ZXJ5ID0gLyogR3JhcGhRTCAqLyBcIlxcbiAgcXVlcnkgRGljdGlvbmFyeVNlYXJjaChcXG4gICAgJHJvb3RJdGVtSWQ6IFN0cmluZyFcXG4gICAgJGxhbmd1YWdlOiBTdHJpbmchXFxuICAgICR0ZW1wbGF0ZXM6IFN0cmluZyFcXG4gICAgJHBhZ2VTaXplOiBJbnQgPSAxMFxcbiAgICAkYWZ0ZXI6IFN0cmluZ1xcbiAgKSB7XFxuICAgIHNlYXJjaChcXG4gICAgICB3aGVyZToge1xcbiAgICAgICAgQU5EOiBbXFxuICAgICAgICAgIHsgbmFtZTogXFxcIl9wYXRoXFxcIiwgdmFsdWU6ICRyb290SXRlbUlkLCBvcGVyYXRvcjogQ09OVEFJTlMgfVxcbiAgICAgICAgICB7IG5hbWU6IFxcXCJfbGFuZ3VhZ2VcXFwiLCB2YWx1ZTogJGxhbmd1YWdlIH1cXG4gICAgICAgICAgeyBuYW1lOiBcXFwiX3RlbXBsYXRlc1xcXCIsIHZhbHVlOiAkdGVtcGxhdGVzLCBvcGVyYXRvcjogQ09OVEFJTlMgfVxcbiAgICAgICAgXVxcbiAgICAgIH1cXG4gICAgICBmaXJzdDogJHBhZ2VTaXplXFxuICAgICAgYWZ0ZXI6ICRhZnRlclxcbiAgICApIHtcXG4gICAgICB0b3RhbFxcbiAgICAgIHBhZ2VJbmZvIHtcXG4gICAgICAgIGVuZEN1cnNvclxcbiAgICAgICAgaGFzTmV4dFxcbiAgICAgIH1cXG4gICAgICByZXN1bHRzIHtcXG4gICAgICAgIGtleTogZmllbGQobmFtZTogXFxcIktleVxcXCIpIHtcXG4gICAgICAgICAgdmFsdWVcXG4gICAgICAgIH1cXG4gICAgICAgIHBocmFzZTogZmllbGQobmFtZTogXFxcIlBocmFzZVxcXCIpIHtcXG4gICAgICAgICAgdmFsdWVcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cIjtcbi8qKlxuICogU2VydmljZSB0aGF0IGZldGNoIGRpY3Rpb25hcnkgZGF0YSB1c2luZyBTaXRlY29yZSdzIEdyYXBoUUwgQVBJLlxuICogQGF1Z21lbnRzIERpY3Rpb25hcnlTZXJ2aWNlQmFzZVxuICogQG1peGVzIFNlYXJjaFF1ZXJ5U2VydmljZTxEaWN0aW9uYXJ5UXVlcnlSZXN1bHQ+XG4gKi9cbnZhciBHcmFwaFFMRGljdGlvbmFyeVNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyYXBoUUxEaWN0aW9uYXJ5U2VydmljZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGdyYXBoUUwgZGljdGlvbmFyeSBzZXJ2aWNlIHdpdGggdGhlIHByb3ZpZGVkIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0dyYXBoUUxEaWN0aW9uYXJ5U2VydmljZX0gb3B0aW9ucyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdyYXBoUUxEaWN0aW9uYXJ5U2VydmljZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBfdGhpcy5ncmFwaFFMQ2xpZW50ID0gX3RoaXMuZ2V0R3JhcGhRTENsaWVudCgpO1xuICAgICAgICBfdGhpcy5zZWFyY2hTZXJ2aWNlID0gbmV3IGdyYXBocWxfMS5TZWFyY2hRdWVyeVNlcnZpY2UoX3RoaXMuZ3JhcGhRTENsaWVudCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBkaWN0aW9uYXJ5IGRhdGEgZm9yIGludGVybmFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgdGhlIGxhbmd1YWdlIHRvIGZldGNoXG4gICAgICogQGRlZmF1bHQgcXVlcnkgKEBzZWUgcXVlcnkpXG4gICAgICogQHJldHVybnMgZGljdGlvbmFyeSBwaHJhc2VzXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBhcHAgcm9vdCB3YXMgbm90IGZvdW5kIGZvciB0aGUgc3BlY2lmaWVkIHNpdGUgYW5kIGxhbmd1YWdlLlxuICAgICAqL1xuICAgIEdyYXBoUUxEaWN0aW9uYXJ5U2VydmljZS5wcm90b3R5cGUuZmV0Y2hEaWN0aW9uYXJ5RGF0YSA9IGZ1bmN0aW9uIChsYW5ndWFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVLZXksIGNhY2hlZFZhbHVlLCByb290SXRlbUlkLCBfYSwgcGhyYXNlcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5ID0gdGhpcy5vcHRpb25zLnNpdGVOYW1lICsgbGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRWYWx1ZSA9IHRoaXMuZ2V0Q2FjaGVWYWx1ZShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z18xLmRlZmF1bHQuZGljdGlvbmFyeSgndXNpbmcgY2FjaGVkIGRpY3Rpb25hcnkgZGF0YSBmb3IgJXMgJXMnLCBsYW5ndWFnZSwgdGhpcy5vcHRpb25zLnNpdGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2FjaGVkVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzLm9wdGlvbnMucm9vdEl0ZW1JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBncmFwaHFsXzEuZ2V0QXBwUm9vdElkKHRoaXMuZ3JhcGhRTENsaWVudCwgdGhpcy5vcHRpb25zLnNpdGVOYW1lLCBsYW5ndWFnZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IChfYi5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByb290SXRlbUlkID0gX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvb3RJdGVtSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5xdWVyeUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnXzEuZGVmYXVsdC5kaWN0aW9uYXJ5KCdmZXRjaGluZyBkaWN0aW9uYXJ5IGRhdGEgZm9yICVzICVzJywgbGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5zaXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaHJhc2VzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlYXJjaFNlcnZpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZldGNoKHF1ZXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RJdGVtSWQ6IHJvb3RJdGVtSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzOiB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeUVudHJ5VGVtcGxhdGVJZCB8fCBjb25zdGFudHNfMS5TaXRlY29yZVRlbXBsYXRlSWQuRGljdGlvbmFyeUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5vcHRpb25zLnBhZ2VTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gKHBocmFzZXNbaXRlbS5rZXkudmFsdWVdID0gaXRlbS5waHJhc2UudmFsdWUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2FjaGVWYWx1ZShjYWNoZUtleSwgcGhyYXNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGhyYXNlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhIEdyYXBoUUwgY2xpZW50IHRoYXQgY2FuIG1ha2UgcmVxdWVzdHMgdG8gdGhlIEFQSS4gVXNlcyBncmFwaHFsLXJlcXVlc3QgYXMgdGhlIGRlZmF1bHRcbiAgICAgKiBsaWJyYXJ5IGZvciBmZXRjaGluZyBncmFwaHFsIGRhdGEgKEBzZWUgR3JhcGhRTFJlcXVlc3RDbGllbnQpLiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VcbiAgICAgKiB3YW50IHRvIHVzZSBzb21ldGhpbmcgZWxzZS5cbiAgICAgKiBAcmV0dXJucyB7R3JhcGhRTENsaWVudH0gaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBHcmFwaFFMRGljdGlvbmFyeVNlcnZpY2UucHJvdG90eXBlLmdldEdyYXBoUUxDbGllbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgZ3JhcGhxbF9yZXF1ZXN0X2NsaWVudF8xLkdyYXBoUUxSZXF1ZXN0Q2xpZW50KHRoaXMub3B0aW9ucy5lbmRwb2ludCwge1xuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICAgICAgZGVidWdnZXI6IGRlYnVnXzEuZGVmYXVsdC5kaWN0aW9uYXJ5LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBHcmFwaFFMRGljdGlvbmFyeVNlcnZpY2U7XG59KGRpY3Rpb25hcnlfc2VydmljZV8xLkRpY3Rpb25hcnlTZXJ2aWNlQmFzZSkpO1xuZXhwb3J0cy5HcmFwaFFMRGljdGlvbmFyeVNlcnZpY2UgPSBHcmFwaFFMRGljdGlvbmFyeVNlcnZpY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkaWN0aW9uYXJ5X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2RpY3Rpb25hcnktc2VydmljZVwiKTtcbmV4cG9ydHMuRGljdGlvbmFyeVNlcnZpY2VCYXNlID0gZGljdGlvbmFyeV9zZXJ2aWNlXzEuRGljdGlvbmFyeVNlcnZpY2VCYXNlO1xudmFyIGdyYXBocWxfZGljdGlvbmFyeV9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9ncmFwaHFsLWRpY3Rpb25hcnktc2VydmljZVwiKTtcbmV4cG9ydHMuR3JhcGhRTERpY3Rpb25hcnlTZXJ2aWNlID0gZ3JhcGhxbF9kaWN0aW9uYXJ5X3NlcnZpY2VfMS5HcmFwaFFMRGljdGlvbmFyeVNlcnZpY2U7XG52YXIgcmVzdF9kaWN0aW9uYXJ5X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3Jlc3QtZGljdGlvbmFyeS1zZXJ2aWNlXCIpO1xuZXhwb3J0cy5SZXN0RGljdGlvbmFyeVNlcnZpY2UgPSByZXN0X2RpY3Rpb25hcnlfc2VydmljZV8xLlJlc3REaWN0aW9uYXJ5U2VydmljZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGF4aW9zX2ZldGNoZXJfMSA9IHJlcXVpcmUoXCIuLi9heGlvcy1mZXRjaGVyXCIpO1xudmFyIGRhdGFfZmV0Y2hlcl8xID0gcmVxdWlyZShcIi4uL2RhdGEtZmV0Y2hlclwiKTtcbnZhciBkaWN0aW9uYXJ5X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2RpY3Rpb25hcnktc2VydmljZVwiKTtcbnZhciBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9kZWJ1Z1wiKSk7XG4vKipcbiAqIEZldGNoIGRpY3Rpb25hcnkgZGF0YSB1c2luZyB0aGUgU2l0ZWNvcmUgRGljdGlvbmFyeSBTZXJ2aWNlIFJFU1QgQVBJLlxuICogVXNlcyBBeGlvcyBhcyB0aGUgZGVmYXVsdCBkYXRhIGZldGNoZXIgKEBzZWUgQXhpb3NEYXRhRmV0Y2hlcikuXG4gKi9cbnZhciBSZXN0RGljdGlvbmFyeVNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc3REaWN0aW9uYXJ5U2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXN0RGljdGlvbmFyeVNlcnZpY2Uob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzdERpY3Rpb25hcnlTZXJ2aWNlLnByb3RvdHlwZSwgXCJkZWZhdWx0RmV0Y2hlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm92aWRlcyBkZWZhdWx0IEBzZWUgQXhpb3NEYXRhRmV0Y2hlciBkYXRhIGZldGNoZXJcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRhdGFGZXRjaGVyID0gbmV3IGF4aW9zX2ZldGNoZXJfMS5BeGlvc0RhdGFGZXRjaGVyKHsgZGVidWdnZXI6IGRlYnVnXzEuZGVmYXVsdC5kaWN0aW9uYXJ5IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIGRhdGFGZXRjaGVyLmZldGNoKHVybCk7IH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEZldGNoIGRpY3Rpb25hcnkgZGF0YSBmb3IgYSBsYW5ndWFnZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICAgKi9cbiAgICBSZXN0RGljdGlvbmFyeVNlcnZpY2UucHJvdG90eXBlLmZldGNoRGljdGlvbmFyeURhdGEgPSBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVuZHBvaW50LCBjYWNoZWRWYWx1ZSwgZmV0Y2hlciwgcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludCA9IHRoaXMuZ2V0VXJsKGxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFZhbHVlID0gdGhpcy5nZXRDYWNoZVZhbHVlKGVuZHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnXzEuZGVmYXVsdC5kaWN0aW9uYXJ5KCd1c2luZyBjYWNoZWQgZGljdGlvbmFyeSBkYXRhIGZvciAlcyAlcycsIGxhbmd1YWdlLCB0aGlzLm9wdGlvbnMuc2l0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjYWNoZWRWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Z18xLmRlZmF1bHQuZGljdGlvbmFyeSgnZmV0Y2hpbmcgZGljdGlvbmFyeSBkYXRhIGZvciAlcyAlcycsIGxhbmd1YWdlLCB0aGlzLm9wdGlvbnMuc2l0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hlciA9IHRoaXMub3B0aW9ucy5kYXRhRmV0Y2hlciB8fCB0aGlzLmRlZmF1bHRGZXRjaGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZGF0YV9mZXRjaGVyXzEuZmV0Y2hEYXRhKGVuZHBvaW50LCBmZXRjaGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjX2FwaWtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc2V0Q2FjaGVWYWx1ZShlbmRwb2ludCwgcmVzcG9uc2UucGhyYXNlcyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGRpY3Rpb25hcnkgc2VydmljZSB1cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICAgKi9cbiAgICBSZXN0RGljdGlvbmFyeVNlcnZpY2UucHJvdG90eXBlLmdldFVybCA9IGZ1bmN0aW9uIChsYW5ndWFnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmFwaUhvc3QgKyBcIi9zaXRlY29yZS9hcGkvanNzL2RpY3Rpb25hcnkvXCIgKyB0aGlzLm9wdGlvbnMuc2l0ZU5hbWUgKyBcIi9cIiArIGxhbmd1YWdlO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc3REaWN0aW9uYXJ5U2VydmljZTtcbn0oZGljdGlvbmFyeV9zZXJ2aWNlXzEuRGljdGlvbmFyeVNlcnZpY2VCYXNlKSk7XG5leHBvcnRzLlJlc3REaWN0aW9uYXJ5U2VydmljZSA9IFJlc3REaWN0aW9uYXJ5U2VydmljZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtZWRpYUFwaSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9tZWRpYS1hcGlcIikpO1xuZXhwb3J0cy5tZWRpYUFwaSA9IG1lZGlhQXBpO1xudmFyIGNvbnN0YW50cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9jb25zdGFudHNcIikpO1xuZXhwb3J0cy5jb25zdGFudHMgPSBjb25zdGFudHM7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ncmFwaHFsXCIpKTtcbnZhciBkZWJ1Z18xID0gcmVxdWlyZShcIi4vZGVidWdcIik7XG5leHBvcnRzLmRlYnVnID0gZGVidWdfMS5kZWZhdWx0O1xudmFyIGRhdGFfZmV0Y2hlcl8xID0gcmVxdWlyZShcIi4vZGF0YS1mZXRjaGVyXCIpO1xuZXhwb3J0cy5mZXRjaERhdGEgPSBkYXRhX2ZldGNoZXJfMS5mZXRjaERhdGE7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ncmFwaHFsLXJlcXVlc3QtY2xpZW50XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2F4aW9zLWZldGNoZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vY2FjaGUtY2xpZW50XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2kxOG5cIikpO1xuLy8gbGF5b3V0XG52YXIgbW9kZWxzXzEgPSByZXF1aXJlKFwiLi9sYXlvdXQvbW9kZWxzXCIpO1xuZXhwb3J0cy5MYXlvdXRTZXJ2aWNlUGFnZVN0YXRlID0gbW9kZWxzXzEuTGF5b3V0U2VydmljZVBhZ2VTdGF0ZTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vbGF5b3V0L3V0aWxzXCIpO1xuZXhwb3J0cy5nZXRGaWVsZFZhbHVlID0gdXRpbHNfMS5nZXRGaWVsZFZhbHVlO1xuZXhwb3J0cy5nZXRDaGlsZFBsYWNlaG9sZGVyID0gdXRpbHNfMS5nZXRDaGlsZFBsYWNlaG9sZGVyO1xudmFyIHJlc3RfbGF5b3V0X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2xheW91dC9yZXN0LWxheW91dC1zZXJ2aWNlXCIpO1xuZXhwb3J0cy5SZXN0TGF5b3V0U2VydmljZSA9IHJlc3RfbGF5b3V0X3NlcnZpY2VfMS5SZXN0TGF5b3V0U2VydmljZTtcbnZhciBncmFwaHFsX2xheW91dF9zZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9sYXlvdXQvZ3JhcGhxbC1sYXlvdXQtc2VydmljZVwiKTtcbmV4cG9ydHMuR3JhcGhRTExheW91dFNlcnZpY2UgPSBncmFwaHFsX2xheW91dF9zZXJ2aWNlXzEuR3JhcGhRTExheW91dFNlcnZpY2U7XG4vLyBUT0RPOiB0aGVzZSBhcmUgZGVwcmVjYXRlZCBhbmQgd2Ugc2hvdWxkIHN0b3AgZXhwb3J0aW5nIHRoZW1cbnZhciByZXN0X2xheW91dF9zZXJ2aWNlXzIgPSByZXF1aXJlKFwiLi9sYXlvdXQvcmVzdC1sYXlvdXQtc2VydmljZVwiKTtcbnZhciBkYXRhQXBpID0geyBmZXRjaFJvdXRlRGF0YTogcmVzdF9sYXlvdXRfc2VydmljZV8yLmZldGNoUm91dGVEYXRhLCBmZXRjaFBsYWNlaG9sZGVyRGF0YTogcmVzdF9sYXlvdXRfc2VydmljZV8yLmZldGNoUGxhY2Vob2xkZXJEYXRhIH07XG5leHBvcnRzLmRhdGFBcGkgPSBkYXRhQXBpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGF5b3V0X3NlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2xheW91dC1zZXJ2aWNlXCIpO1xudmFyIGdyYXBocWxfcmVxdWVzdF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaHFsLXJlcXVlc3QtY2xpZW50XCIpO1xudmFyIGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2RlYnVnXCIpKTtcbnZhciBHcmFwaFFMTGF5b3V0U2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JhcGhRTExheW91dFNlcnZpY2UsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogRmV0Y2ggbGF5b3V0IGRhdGEgdXNpbmcgdGhlIFNpdGVjb3JlIEdyYXBoUUwgZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHtHcmFwaFFMTGF5b3V0U2VydmljZUNvbmZpZ30gc2VydmljZUNvbmZpZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEdyYXBoUUxMYXlvdXRTZXJ2aWNlKHNlcnZpY2VDb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgICAgIF90aGlzLmdyYXBoUUxDbGllbnQgPSBfdGhpcy5nZXRHcmFwaFFMQ2xpZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggbGF5b3V0IGRhdGEgZm9yIGFuIGl0ZW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMYXlvdXRTZXJ2aWNlRGF0YT59IGxheW91dCBzZXJ2aWNlIGRhdGFcbiAgICAgKi9cbiAgICBHcmFwaFFMTGF5b3V0U2VydmljZS5wcm90b3R5cGUuZmV0Y2hMYXlvdXREYXRhID0gZnVuY3Rpb24gKGl0ZW1QYXRoLCBsYW5ndWFnZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVlcnksIGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHRoaXMuZ2V0TGF5b3V0UXVlcnkoaXRlbVBhdGgsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnXzEuZGVmYXVsdC5sYXlvdXQoJ2ZldGNoaW5nIGxheW91dCBkYXRhIGZvciAlcyAlcyAlcycsIGl0ZW1QYXRoLCBsYW5ndWFnZSwgdGhpcy5zZXJ2aWNlQ29uZmlnLnNpdGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ3JhcGhRTENsaWVudC5yZXF1ZXN0KHF1ZXJ5KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBgcmVuZGVyZWRgIGlzIGVtcHR5IC0+IG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sICgoKF9iID0gKF9hID0gZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxheW91dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLml0ZW0ucmVuZGVyZWQpIHx8IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l0ZWNvcmU6IHsgY29udGV4dDogeyBwYWdlRWRpdGluZzogZmFsc2UsIGxhbmd1YWdlOiBsYW5ndWFnZSB9LCByb3V0ZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgR3JhcGhRTCBjbGllbnQgdGhhdCBjYW4gbWFrZSByZXF1ZXN0cyB0byB0aGUgQVBJLiBVc2VzIGdyYXBocWwtcmVxdWVzdCBhcyB0aGUgZGVmYXVsdFxuICAgICAqIGxpYnJhcnkgZm9yIGZldGNoaW5nIGdyYXBocWwgZGF0YSAoQHNlZSBHcmFwaFFMUmVxdWVzdENsaWVudCkuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdVxuICAgICAqIHdhbnQgdG8gdXNlIHNvbWV0aGluZyBlbHNlLlxuICAgICAqIEByZXR1cm5zIHtHcmFwaFFMQ2xpZW50fSBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIEdyYXBoUUxMYXlvdXRTZXJ2aWNlLnByb3RvdHlwZS5nZXRHcmFwaFFMQ2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGdyYXBocWxfcmVxdWVzdF9jbGllbnRfMS5HcmFwaFFMUmVxdWVzdENsaWVudCh0aGlzLnNlcnZpY2VDb25maWcuZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5zZXJ2aWNlQ29uZmlnLmFwaUtleSxcbiAgICAgICAgICAgIGRlYnVnZ2VyOiBkZWJ1Z18xLmRlZmF1bHQubGF5b3V0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgR3JhcGhRTCBMYXlvdXQgcXVlcnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXRlbVBhdGggcGFnZSByb3V0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2VdIGxhbmd1YWdlXG4gICAgICovXG4gICAgR3JhcGhRTExheW91dFNlcnZpY2UucHJvdG90eXBlLmdldExheW91dFF1ZXJ5ID0gZnVuY3Rpb24gKGl0ZW1QYXRoLCBsYW5ndWFnZSkge1xuICAgICAgICB2YXIgbGFuZ3VhZ2VWYXJpYWJsZSA9IGxhbmd1YWdlID8gXCIsIGxhbmd1YWdlOlxcXCJcIiArIGxhbmd1YWdlICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgdmFyIGxheW91dFF1ZXJ5ID0gdGhpcy5zZXJ2aWNlQ29uZmlnLmZvcm1hdExheW91dFF1ZXJ5XG4gICAgICAgICAgICA/IHRoaXMuc2VydmljZUNvbmZpZy5mb3JtYXRMYXlvdXRRdWVyeSh0aGlzLnNlcnZpY2VDb25maWcuc2l0ZU5hbWUsIGl0ZW1QYXRoLCBsYW5ndWFnZSlcbiAgICAgICAgICAgIDogXCJsYXlvdXQoc2l0ZTpcXFwiXCIgKyB0aGlzLnNlcnZpY2VDb25maWcuc2l0ZU5hbWUgKyBcIlxcXCIsIHJvdXRlUGF0aDpcXFwiXCIgKyBpdGVtUGF0aCArIFwiXFxcIlwiICsgbGFuZ3VhZ2VWYXJpYWJsZSArIFwiKVwiO1xuICAgICAgICByZXR1cm4gXCJxdWVyeSB7XFxuICAgICAgXCIgKyBsYXlvdXRRdWVyeSArIFwie1xcbiAgICAgICAgaXRlbSB7XFxuICAgICAgICAgIHJlbmRlcmVkXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XCI7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGhRTExheW91dFNlcnZpY2U7XG59KGxheW91dF9zZXJ2aWNlXzEuTGF5b3V0U2VydmljZUJhc2UpKTtcbmV4cG9ydHMuR3JhcGhRTExheW91dFNlcnZpY2UgPSBHcmFwaFFMTGF5b3V0U2VydmljZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExheW91dFNlcnZpY2VCYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExheW91dFNlcnZpY2VCYXNlKCkge1xuICAgIH1cbiAgICByZXR1cm4gTGF5b3V0U2VydmljZUJhc2U7XG59KCkpO1xuZXhwb3J0cy5MYXlvdXRTZXJ2aWNlQmFzZSA9IExheW91dFNlcnZpY2VCYXNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIExheW91dCBTZXJ2aWNlIHBhZ2Ugc3RhdGUgZW51bVxuICovXG52YXIgTGF5b3V0U2VydmljZVBhZ2VTdGF0ZTtcbihmdW5jdGlvbiAoTGF5b3V0U2VydmljZVBhZ2VTdGF0ZSkge1xuICAgIExheW91dFNlcnZpY2VQYWdlU3RhdGVbXCJQcmV2aWV3XCJdID0gXCJwcmV2aWV3XCI7XG4gICAgTGF5b3V0U2VydmljZVBhZ2VTdGF0ZVtcIkVkaXRcIl0gPSBcImVkaXRcIjtcbiAgICBMYXlvdXRTZXJ2aWNlUGFnZVN0YXRlW1wiTm9ybWFsXCJdID0gXCJub3JtYWxcIjtcbn0pKExheW91dFNlcnZpY2VQYWdlU3RhdGUgPSBleHBvcnRzLkxheW91dFNlcnZpY2VQYWdlU3RhdGUgfHwgKGV4cG9ydHMuTGF5b3V0U2VydmljZVBhZ2VTdGF0ZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsYXlvdXRfc2VydmljZV8xID0gcmVxdWlyZShcIi4vbGF5b3V0LXNlcnZpY2VcIik7XG52YXIgYXhpb3NfZmV0Y2hlcl8xID0gcmVxdWlyZShcIi4uL2F4aW9zLWZldGNoZXJcIik7XG52YXIgZGF0YV9mZXRjaGVyXzEgPSByZXF1aXJlKFwiLi4vZGF0YS1mZXRjaGVyXCIpO1xudmFyIGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2RlYnVnXCIpKTtcbi8qKlxuICogUmVzb2x2ZXMgbGF5b3V0IHNlcnZpY2UgdXJsXG4gKiBAcGFyYW0ge0xheW91dFNlcnZpY2VDb25maWd9IFtvcHRpb25zXSBsYXlvdXQgc2VydmljZSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBpVHlwZSB3aGljaCBsYXlvdXQgc2VydmljZSBBUEkgdG8gY2FsbCAoJ3JlbmRlcicgb3IgJ3BsYWNlaG9sZGVyJylcbiAqIEByZXR1cm5zIHRoZSBsYXlvdXQgc2VydmljZSB1cmxcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUxheW91dFNlcnZpY2VVcmwob3B0aW9ucywgYXBpVHlwZSkge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5ob3N0LCBob3N0ID0gX2EgPT09IHZvaWQgMCA/ICcnIDogX2EsIF9iID0gb3B0aW9ucy5jb25maWd1cmF0aW9uTmFtZSwgY29uZmlndXJhdGlvbk5hbWUgPSBfYiA9PT0gdm9pZCAwID8gJ2pzcycgOiBfYiwgc2VydmljZVVybCA9IG9wdGlvbnMuc2VydmljZVVybDtcbiAgICBpZiAoc2VydmljZVVybCkge1xuICAgICAgICByZXR1cm4gc2VydmljZVVybDtcbiAgICB9XG4gICAgcmV0dXJuIGhvc3QgKyBcIi9zaXRlY29yZS9hcGkvbGF5b3V0L1wiICsgYXBpVHlwZSArIFwiL1wiICsgY29uZmlndXJhdGlvbk5hbWU7XG59XG5leHBvcnRzLnJlc29sdmVMYXlvdXRTZXJ2aWNlVXJsID0gcmVzb2x2ZUxheW91dFNlcnZpY2VVcmw7XG4vKipcbiAqIE1ha2VzIGEgcmVxdWVzdCB0byBTaXRlY29yZSBMYXlvdXQgU2VydmljZSBmb3IgdGhlIHNwZWNpZmllZCByb3V0ZSBpdGVtIHBhdGguXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gUGxlYXNlIHVzZSBMYXlvdXRTZXJ2aWNlLmZldGNoTGF5b3V0RGF0YSBpbnN0ZWFkLFxuICogQHNlZSB7TGF5b3V0U2VydmljZX0gLSBmZXRjaExheW91dERhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtUGF0aFxuICogQHBhcmFtIHtMYXlvdXRTZXJ2aWNlUmVxdWVzdE9wdGlvbnM8TGF5b3V0U2VydmljZURhdGE+fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxMYXlvdXRTZXJ2aWNlRGF0YT59IGxheW91dCBkYXRhXG4gKi9cbmZ1bmN0aW9uIGZldGNoUm91dGVEYXRhKGl0ZW1QYXRoLCBvcHRpb25zKSB7XG4gICAgdmFyIHF1ZXJ5c3RyaW5nUGFyYW1zID0gb3B0aW9ucy5xdWVyeXN0cmluZ1BhcmFtcywgbGF5b3V0U2VydmljZUNvbmZpZyA9IG9wdGlvbnMubGF5b3V0U2VydmljZUNvbmZpZztcbiAgICB2YXIgZmV0Y2hVcmwgPSByZXNvbHZlTGF5b3V0U2VydmljZVVybChsYXlvdXRTZXJ2aWNlQ29uZmlnLCAncmVuZGVyJyk7XG4gICAgcmV0dXJuIGRhdGFfZmV0Y2hlcl8xLmZldGNoRGF0YShmZXRjaFVybCwgb3B0aW9ucy5mZXRjaGVyLCBfX2Fzc2lnbih7IGl0ZW06IGl0ZW1QYXRoIH0sIHF1ZXJ5c3RyaW5nUGFyYW1zKSk7XG59XG5leHBvcnRzLmZldGNoUm91dGVEYXRhID0gZmV0Y2hSb3V0ZURhdGE7XG4vKipcbiAqIE1ha2VzIGEgcmVxdWVzdCB0byBTaXRlY29yZSBMYXlvdXQgU2VydmljZSBmb3IgdGhlIHNwZWNpZmllZCBwbGFjZWhvbGRlciBpblxuICogYSBzcGVjaWZpYyByb3V0ZSBpdGVtLiBBbGxvd3MgeW91IHRvIHJldHJpZXZlIHJlbmRlcmVkIGRhdGEgZm9yIGluZGl2aWR1YWwgcGxhY2Vob2xkZXJzIGluc3RlYWQgb2YgZW50aXJlIHJvdXRlcy5cbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBQbGVhc2UgdXNlIExheW91dFNlcnZpY2UuZmV0Y2hQbGFjZWhvbGRlckRhdGEgaW5zdGVhZCxcbiAqIEBzZWUge0xheW91dFNlcnZpY2V9IC0gZmV0Y2hQbGFjZWhvbGRlckRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBwbGFjZWhvbGRlck5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBpdGVtUGF0aFxuICogQHBhcmFtIHtMYXlvdXRTZXJ2aWNlUmVxdWVzdE9wdGlvbnM8UGxhY2Vob2xkZXJEYXRhPn0gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8UGxhY2Vob2xkZXJEYXRhPn0gcGxhY2Vob2xkZXIgZGF0YVxuICovXG5mdW5jdGlvbiBmZXRjaFBsYWNlaG9sZGVyRGF0YShwbGFjZWhvbGRlck5hbWUsIGl0ZW1QYXRoLCBvcHRpb25zKSB7XG4gICAgdmFyIHF1ZXJ5c3RyaW5nUGFyYW1zID0gb3B0aW9ucy5xdWVyeXN0cmluZ1BhcmFtcywgbGF5b3V0U2VydmljZUNvbmZpZyA9IG9wdGlvbnMubGF5b3V0U2VydmljZUNvbmZpZztcbiAgICB2YXIgZmV0Y2hVcmwgPSByZXNvbHZlTGF5b3V0U2VydmljZVVybChsYXlvdXRTZXJ2aWNlQ29uZmlnLCAncGxhY2Vob2xkZXInKTtcbiAgICByZXR1cm4gZGF0YV9mZXRjaGVyXzEuZmV0Y2hEYXRhKGZldGNoVXJsLCBvcHRpb25zLmZldGNoZXIsIF9fYXNzaWduKHsgcGxhY2Vob2xkZXJOYW1lOiBwbGFjZWhvbGRlck5hbWUsIGl0ZW06IGl0ZW1QYXRoIH0sIHF1ZXJ5c3RyaW5nUGFyYW1zKSk7XG59XG5leHBvcnRzLmZldGNoUGxhY2Vob2xkZXJEYXRhID0gZmV0Y2hQbGFjZWhvbGRlckRhdGE7XG4vKipcbiAqIEZldGNoIGxheW91dCBkYXRhIHVzaW5nIHRoZSBTaXRlY29yZSBMYXlvdXQgU2VydmljZSBSRVNUIEFQSS5cbiAqIFVzZXMgQXhpb3MgYXMgdGhlIGRlZmF1bHQgZGF0YSBmZXRjaGVyIChAc2VlIEF4aW9zRGF0YUZldGNoZXIpLlxuICovXG52YXIgUmVzdExheW91dFNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc3RMYXlvdXRTZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc3RMYXlvdXRTZXJ2aWNlKHNlcnZpY2VDb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm92aWRlcyBmZXRjaCBvcHRpb25zIGluIG9yZGVyIHRvIGZldGNoIGRhdGFcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV0gbGFuZ3VhZ2Ugd2lsbCBiZSBhcHBsaWVkIHRvIGBzY19sYW5nYCBwYXJhbVxuICAgICAgICAgKiBAcmV0dXJucyB7RmV0Y2hPcHRpb25zfSBmZXRjaCBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5nZXRGZXRjaE9wdGlvbnMgPSBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgc2NfYXBpa2V5OiBfdGhpcy5zZXJ2aWNlQ29uZmlnLmFwaUtleSxcbiAgICAgICAgICAgICAgICBzY19zaXRlOiBfdGhpcy5zZXJ2aWNlQ29uZmlnLnNpdGVOYW1lLFxuICAgICAgICAgICAgICAgIHNjX2xhbmc6IGxhbmd1YWdlIHx8ICcnLFxuICAgICAgICAgICAgICAgIHRyYWNraW5nOiAoX2EgPSBfdGhpcy5zZXJ2aWNlQ29uZmlnLnRyYWNraW5nLCAoX2EgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGF5b3V0U2VydmljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICBob3N0OiBfdGhpcy5zZXJ2aWNlQ29uZmlnLmFwaUhvc3QsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb25OYW1lOiBfdGhpcy5zZXJ2aWNlQ29uZmlnLmNvbmZpZ3VyYXRpb25OYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdQYXJhbXM6IF9fYXNzaWduKHt9LCBwYXJhbXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGVzIGRlZmF1bHQgQHNlZSBBeGlvc0RhdGFGZXRjaGVyIGRhdGEgZmV0Y2hlclxuICAgICAgICAgKiBAcGFyYW0ge0luY29taW5nTWVzc2FnZX0gW3JlcV0gUmVxdWVzdCBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0ge1NlcnZlclJlc3BvbnNlfSBbcmVzXSBSZXNwb25zZSBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyBkZWZhdWx0IGZldGNoZXJcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmdldERlZmF1bHRGZXRjaGVyID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyOiBkZWJ1Z18xLmRlZmF1bHQubGF5b3V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZXEgJiYgcmVzKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLm9uUmVxID0gX3RoaXMuc2V0dXBSZXFIZWFkZXJzKHJlcSk7XG4gICAgICAgICAgICAgICAgY29uZmlnLm9uUmVzID0gX3RoaXMuc2V0dXBSZXNIZWFkZXJzKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXhpb3NGZXRjaGVyID0gbmV3IGF4aW9zX2ZldGNoZXJfMS5BeGlvc0RhdGFGZXRjaGVyKGNvbmZpZyk7XG4gICAgICAgICAgICB2YXIgZmV0Y2hlciA9IGZ1bmN0aW9uICh1cmwsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXhpb3NGZXRjaGVyLmZldGNoKHVybCwgZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoZXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggbGF5b3V0IGRhdGEgZm9yIGFuIGl0ZW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1QYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV1cbiAgICAgKiBAcGFyYW0ge0luY29taW5nTWVzc2FnZX0gW3JlcV0gUmVxdWVzdCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7U2VydmVyUmVzcG9uc2V9IFtyZXNdIFJlc3BvbnNlIGluc3RhbmNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TGF5b3V0U2VydmljZURhdGE+fSBsYXlvdXQgc2VydmljZSBkYXRhXG4gICAgICovXG4gICAgUmVzdExheW91dFNlcnZpY2UucHJvdG90eXBlLmZldGNoTGF5b3V0RGF0YSA9IGZ1bmN0aW9uIChpdGVtUGF0aCwgbGFuZ3VhZ2UsIHJlcSwgcmVzKSB7XG4gICAgICAgIHZhciBmZXRjaE9wdGlvbnMgPSB0aGlzLmdldEZldGNoT3B0aW9ucyhsYW5ndWFnZSk7XG4gICAgICAgIGRlYnVnXzEuZGVmYXVsdC5sYXlvdXQoJ2ZldGNoaW5nIGxheW91dCBkYXRhIGZvciAlcyAlcyAlcycsIGl0ZW1QYXRoLCBsYW5ndWFnZSwgdGhpcy5zZXJ2aWNlQ29uZmlnLnNpdGVOYW1lKTtcbiAgICAgICAgdmFyIGZldGNoZXIgPSB0aGlzLnNlcnZpY2VDb25maWcuZGF0YUZldGNoZXJSZXNvbHZlclxuICAgICAgICAgICAgPyB0aGlzLnNlcnZpY2VDb25maWcuZGF0YUZldGNoZXJSZXNvbHZlcihyZXEsIHJlcylcbiAgICAgICAgICAgIDogdGhpcy5nZXREZWZhdWx0RmV0Y2hlcihyZXEsIHJlcyk7XG4gICAgICAgIHJldHVybiBmZXRjaFJvdXRlRGF0YShpdGVtUGF0aCwgX19hc3NpZ24oeyBmZXRjaGVyOiBmZXRjaGVyIH0sIGZldGNoT3B0aW9ucykpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSBlcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cykgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIC8vIEFsaWduZWQgd2l0aCByZXNwb25zZSBvZiBHcmFwaFFMIExheW91dCBTZXJ2aWNlIGluIGNhc2UgaWYgbGF5b3V0IGlzIG5vdCBmb3VuZC5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIDQwNCBSZXN0IExheW91dCBTZXJ2aWNlIHJldHVybnNcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBzaXRlY29yZToge1xuICAgICAgICAgICAgICAgIC8vICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgcGFnZUVkaXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vICAgICAgIGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgLy8gICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gICAgIHJvdXRlOiBudWxsXG4gICAgICAgICAgICAgICAgLy8gICB9LFxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvci5yZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2ggbGF5b3V0IGRhdGEgZm9yIGEgcGFydGljdWxhciBwbGFjZWhvbGRlci5cbiAgICAgKiBNYWtlcyBhIHJlcXVlc3QgdG8gU2l0ZWNvcmUgTGF5b3V0IFNlcnZpY2UgZm9yIHRoZSBzcGVjaWZpZWQgcGxhY2Vob2xkZXIgaW5cbiAgICAgKiBhIHNwZWNpZmljIHJvdXRlIGl0ZW0uIEFsbG93cyB5b3UgdG8gcmV0cmlldmUgcmVuZGVyZWQgZGF0YSBmb3IgaW5kaXZpZHVhbCBwbGFjZWhvbGRlcnMgaW5zdGVhZCBvZiBlbnRpcmUgcm91dGVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwbGFjZWhvbGRlck5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXRlbVBhdGhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxuICAgICAqIEBwYXJhbSB7SW5jb21pbmdNZXNzYWdlfSBbcmVxXSBSZXF1ZXN0IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTZXJ2ZXJSZXNwb25zZX0gW3Jlc10gUmVzcG9uc2UgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQbGFjZWhvbGRlckRhdGE+fSBwbGFjZWhvbGRlciBkYXRhXG4gICAgICovXG4gICAgUmVzdExheW91dFNlcnZpY2UucHJvdG90eXBlLmZldGNoUGxhY2Vob2xkZXJEYXRhID0gZnVuY3Rpb24gKHBsYWNlaG9sZGVyTmFtZSwgaXRlbVBhdGgsIGxhbmd1YWdlLCByZXEsIHJlcykge1xuICAgICAgICB2YXIgZmV0Y2hPcHRpb25zID0gdGhpcy5nZXRGZXRjaE9wdGlvbnMobGFuZ3VhZ2UpO1xuICAgICAgICBkZWJ1Z18xLmRlZmF1bHQubGF5b3V0KCdmZXRjaGluZyBwbGFjZWhvbGRlciBkYXRhIGZvciAlcyAlcyAlcyAlcycsIHBsYWNlaG9sZGVyTmFtZSwgaXRlbVBhdGgsIGxhbmd1YWdlLCB0aGlzLnNlcnZpY2VDb25maWcuc2l0ZU5hbWUpO1xuICAgICAgICB2YXIgZmV0Y2hlciA9IHRoaXMuc2VydmljZUNvbmZpZy5kYXRhRmV0Y2hlclJlc29sdmVyXG4gICAgICAgICAgICA/IHRoaXMuc2VydmljZUNvbmZpZy5kYXRhRmV0Y2hlclJlc29sdmVyKHJlcSwgcmVzKVxuICAgICAgICAgICAgOiB0aGlzLmdldERlZmF1bHRGZXRjaGVyKHJlcSwgcmVzKTtcbiAgICAgICAgcmV0dXJuIGZldGNoUGxhY2Vob2xkZXJEYXRhKHBsYWNlaG9sZGVyTmFtZSwgaXRlbVBhdGgsIF9fYXNzaWduKHsgZmV0Y2hlcjogZmV0Y2hlciB9LCBmZXRjaE9wdGlvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHVwIHJlcXVlc3QgaGVhZGVyc1xuICAgICAqIEBwYXJhbSB7SW5jb21pbmdNZXNzYWdlfSByZXFcbiAgICAgKiBAcmV0dXJucyB7QXhpb3NSZXF1ZXN0Q29uZmlnfSBheGlvcyByZXF1ZXN0IGNvbmZpZ1xuICAgICAqL1xuICAgIFJlc3RMYXlvdXRTZXJ2aWNlLnByb3RvdHlwZS5zZXR1cFJlcUhlYWRlcnMgPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVxQ29uZmlnKSB7XG4gICAgICAgICAgICBkZWJ1Z18xLmRlZmF1bHQubGF5b3V0KCdwZXJmb3JtaW5nIHJlcXVlc3QgaGVhZGVyIHBhc3NpbmcnKTtcbiAgICAgICAgICAgIHJlcUNvbmZpZy5oZWFkZXJzLmNvbW1vbiA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXFDb25maWcuaGVhZGVycy5jb21tb24pLCAocmVxLmhlYWRlcnMuY29va2llICYmIHsgY29va2llOiByZXEuaGVhZGVycy5jb29raWUgfSkpLCAocmVxLmhlYWRlcnMucmVmZXJlciAmJiB7IHJlZmVyZXI6IHJlcS5oZWFkZXJzLnJlZmVyZXIgfSkpLCAocmVxLmhlYWRlcnNbJ3VzZXItYWdlbnQnXSAmJiB7ICd1c2VyLWFnZW50JzogcmVxLmhlYWRlcnNbJ3VzZXItYWdlbnQnXSB9KSksIChyZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzICYmIHsgJ1gtRm9yd2FyZGVkLUZvcic6IHJlcS5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3MgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcUNvbmZpZztcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHVwIHJlc3BvbnNlIGhlYWRlcnMgYmFzZWQgb24gcmVzcG9uc2UgZnJvbSBsYXlvdXQgc2VydmljZVxuICAgICAqIEBwYXJhbSB7U2VydmVyUmVzcG9uc2V9IHJlc1xuICAgICAqIEByZXR1cm5zIHtBeGlvc1Jlc3BvbnNlfSByZXNwb25zZVxuICAgICAqL1xuICAgIFJlc3RMYXlvdXRTZXJ2aWNlLnByb3RvdHlwZS5zZXR1cFJlc0hlYWRlcnMgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2VydmVyUmVzKSB7XG4gICAgICAgICAgICBkZWJ1Z18xLmRlZmF1bHQubGF5b3V0KCdwZXJmb3JtaW5nIHJlc3BvbnNlIGhlYWRlciBwYXNzaW5nJyk7XG4gICAgICAgICAgICBzZXJ2ZXJSZXMuaGVhZGVyc1snc2V0LWNvb2tpZSddICYmXG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcignc2V0LWNvb2tpZScsIHNlcnZlclJlcy5oZWFkZXJzWydzZXQtY29va2llJ10pO1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZlclJlcztcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBSZXN0TGF5b3V0U2VydmljZTtcbn0obGF5b3V0X3NlcnZpY2VfMS5MYXlvdXRTZXJ2aWNlQmFzZSkpO1xuZXhwb3J0cy5SZXN0TGF5b3V0U2VydmljZSA9IFJlc3RMYXlvdXRTZXJ2aWNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBwYXJhbSB7Q29tcG9uZW50UmVuZGVyaW5nIHwgRmllbGRzfSByZW5kZXJpbmdPckZpZWxkc1xuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZVxuICogQHBhcmFtIHtUfSBbZGVmYXVsdFZhbHVlXVxuICovXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKHJlbmRlcmluZ09yRmllbGRzLCBmaWVsZE5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICghcmVuZGVyaW5nT3JGaWVsZHMgfHwgIWZpZWxkTmFtZSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICB2YXIgZmllbGRzID0gcmVuZGVyaW5nT3JGaWVsZHM7XG4gICAgdmFyIGZpZWxkID0gZmllbGRzW2ZpZWxkTmFtZV07XG4gICAgaWYgKGZpZWxkICYmIHR5cGVvZiBmaWVsZC52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnZhbHVlO1xuICAgIH1cbiAgICB2YXIgcmVuZGVyaW5nID0gcmVuZGVyaW5nT3JGaWVsZHM7XG4gICAgaWYgKCFyZW5kZXJpbmcuZmllbGRzIHx8XG4gICAgICAgICFyZW5kZXJpbmcuZmllbGRzW2ZpZWxkTmFtZV0gfHxcbiAgICAgICAgdHlwZW9mIHJlbmRlcmluZy5maWVsZHNbZmllbGROYW1lXS52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmluZy5maWVsZHNbZmllbGROYW1lXS52YWx1ZTtcbn1cbmV4cG9ydHMuZ2V0RmllbGRWYWx1ZSA9IGdldEZpZWxkVmFsdWU7XG4vKipcbiAqIEdldHMgcmVuZGVyaW5nIGRlZmluaXRpb25zIGluIGEgZ2l2ZW4gY2hpbGQgcGxhY2Vob2xkZXIgdW5kZXIgYSBjdXJyZW50IHJlbmRlcmluZy5cbiAqIEBwYXJhbSB7Q29tcG9uZW50UmVuZGVyaW5nfSByZW5kZXJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwbGFjZWhvbGRlck5hbWVcbiAqIEByZXR1cm5zIHtBcnJheTxDb21wb25lbnRSZW5kZXJpbmcgfCBIdG1sRWxlbWVudFJlbmRlcmluZz59IGNoaWxkIHBsYWNlaG9sZGVyXG4gKi9cbmZ1bmN0aW9uIGdldENoaWxkUGxhY2Vob2xkZXIocmVuZGVyaW5nLCBwbGFjZWhvbGRlck5hbWUpIHtcbiAgICBpZiAoIXJlbmRlcmluZyB8fFxuICAgICAgICAhcGxhY2Vob2xkZXJOYW1lIHx8XG4gICAgICAgICFyZW5kZXJpbmcucGxhY2Vob2xkZXJzIHx8XG4gICAgICAgICFyZW5kZXJpbmcucGxhY2Vob2xkZXJzW3BsYWNlaG9sZGVyTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyaW5nLnBsYWNlaG9sZGVyc1twbGFjZWhvbGRlck5hbWVdO1xufVxuZXhwb3J0cy5nZXRDaGlsZFBsYWNlaG9sZGVyID0gZ2V0Q2hpbGRQbGFjZWhvbGRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHdoYXQgaXMgYGltcG9ydCB4ID0gcmVxdWlyZSgneCcpO2A/IGdyZWF0IHF1ZXN0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzUwNzNcbnZhciB1bmVzY2FwZSA9IHJlcXVpcmUoXCJsb2Rhc2gudW5lc2NhcGVcIik7XG52YXIgVVJMID0gcmVxdWlyZShcInVybC1wYXJzZVwiKTtcbi8vIGZpbmRzIGFuIGltZyB0YWcgd2l0aCBIVE1MIGF0dHJpYnV0ZXNcbnZhciBpbWdUYWdSZWdleCA9IC88aW1nKFtePl0rKVxcLz4vaTtcbi8vIGZpbmRzIGFsbCB0aGUgSFRNTCBhdHRyaWJ1dGVzIGluIGEgc3RyaW5nXG52YXIgaHRtbEF0dHJzUmVnZXggPSAvKFtePVxcc10rKSg9XCIoW15cIl0qKVwiKT8vZ2k7XG4vLyBmaW5kcyB0aGUgU2l0ZWNvcmUgbWVkaWEgVVJMIHByZWZpeFxudmFyIG1lZGlhVXJsUHJlZml4UmVnZXggPSAvXFwvKFstfl17MX0pXFwvbWVkaWFcXC8vaTtcbi8qKlxuICogTWFrZXMgYSByZXF1ZXN0IHRvIFNpdGVjb3JlIENvbnRlbnQgU2VydmljZSBmb3IgdGhlIHNwZWNpZmllZCBpdGVtIHBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ30gZWRpdG9yTWFya3VwXG4gKiBAcmV0dXJucyB7T2JqZWN0IHwgbnVsbH0gZm91bmQgaW1hZ2UgdGFnXG4gKi9cbmV4cG9ydHMuZmluZEVkaXRvckltYWdlVGFnID0gZnVuY3Rpb24gKGVkaXRvck1hcmt1cCkge1xuICAgIC8vIG1hdGNoIHRoZSB0YWdcbiAgICB2YXIgdGFnTWF0Y2ggPSBlZGl0b3JNYXJrdXAubWF0Y2goaW1nVGFnUmVnZXgpO1xuICAgIGlmICghdGFnTWF0Y2ggfHwgdGFnTWF0Y2gubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgYXR0cnMgYW5kIHR1cm4gdGhlbSBpbnRvIGEgTWFwXG4gICAgdmFyIGF0dHJzID0ge307XG4gICAgdmFyIG1hdGNoID0gaHRtbEF0dHJzUmVnZXguZXhlYyh0YWdNYXRjaFsxXSk7XG4gICAgd2hpbGUgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIGF0dHJzW21hdGNoWzFdXSA9IHVuZXNjYXBlKG1hdGNoWzNdKTtcbiAgICAgICAgbWF0Y2ggPSBodG1sQXR0cnNSZWdleC5leGVjKHRhZ01hdGNoWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW1nVGFnOiB0YWdNYXRjaFswXSxcbiAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgIH07XG59O1xuLyoqXG4gKiBHZXQgcmVxdWlyZWQgcXVlcnkgc3RyaW5nIHBhcmFtcyB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdXNlciBwYXJhbXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBxcyBsYXlvdXQgc2VydmljZSBwYXJzZWQgcXVlcnkgc3RyaW5nXG4gKiBAcmV0dXJucyB7b2JqZWN0fSByZXF1aXJlZFBhcmFtc1xuICovXG5leHBvcnRzLmdldFJlcXVpcmVkUGFyYW1zID0gZnVuY3Rpb24gKHFzKSB7XG4gICAgdmFyIHJldiA9IHFzLnJldiwgZGIgPSBxcy5kYiwgbGEgPSBxcy5sYSwgdnMgPSBxcy52cywgdHMgPSBxcy50cztcbiAgICByZXR1cm4geyByZXY6IHJldiwgZGI6IGRiLCBsYTogbGEsIHZzOiB2cywgdHM6IHRzIH07XG59O1xuLyoqXG4gKiBQcmVwYXJlcyBhIFNpdGVjb3JlIG1lZGlhIFVSTCB3aXRoIGBwYXJhbXNgIGZvciB1c2UgYnkgdGhlIEpTUyBtZWRpYSBoYW5kbGVyLlxuICogVGhpcyBpcyBkb25lIGJ5IHJlcGxhY2luZyBgL34vbWVkaWFgIG9yIGAvLS9tZWRpYWAgd2l0aCBgL34vanNzbWVkaWFgIG9yIGAvLS9qc3NtZWRpYWAsIHJlc3BlY3RpdmVseS5cbiAqIFByb3ZpZGVkIGBwYXJhbXNgIGFyZSB1c2VkIGFzIHRoZSBxdWVyeXN0cmluZyBwYXJhbWV0ZXJzIGZvciB0aGUgbWVkaWEgVVJMLlxuICogQ2FuIHVzZSBgbWVkaWFVcmxQcmVmaXhgIGluIG9yZGVyIHRvIHVzZSBhIGN1c3RvbSBwcmVmaXguXG4gKiBJZiBubyBgcGFyYW1zYCBhcmUgc2VudCwgdGhlIG9yaWdpbmFsIG1lZGlhIFVSTCBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXVxuICogQHBhcmFtIHtSZWdFeHB9IFttZWRpYVVybFByZWZpeD1tZWRpYVVybFByZWZpeFJlZ2V4XVxuICogQHJldHVybnMge3N0cmluZ30gdXJsXG4gKi9cbmV4cG9ydHMudXBkYXRlSW1hZ2VVcmwgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIG1lZGlhVXJsUHJlZml4KSB7XG4gICAgaWYgKG1lZGlhVXJsUHJlZml4ID09PSB2b2lkIDApIHsgbWVkaWFVcmxQcmVmaXggPSBtZWRpYVVybFByZWZpeFJlZ2V4OyB9XG4gICAgaWYgKCFwYXJhbXMgfHwgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gaWYgcGFyYW1zIGFyZW4ndCBzdXBwbGllZCwgbm8gbmVlZCB0byBydW4gaXQgdGhyb3VnaCBKU1MgbWVkaWEgaGFuZGxlclxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICAvLyBwb2x5ZmlsbCBub2RlIGBnbG9iYWxgIGluIGJyb3dzZXIgdG8gd29ya2Fyb3VuZCBodHRwczovL2dpdGh1Yi5jb20vdW5zaGlmdGlvL3VybC1wYXJzZS9pc3N1ZXMvMTUwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5nbG9iYWwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgd2luZG93Lmdsb2JhbCA9IHt9O1xuICAgIH1cbiAgICB2YXIgcGFyc2VkID0gVVJMKHVybCwge30sIHRydWUpO1xuICAgIHZhciByZXF1aXJlZFBhcmFtcyA9IGV4cG9ydHMuZ2V0UmVxdWlyZWRQYXJhbXMocGFyc2VkLnF1ZXJ5KTtcbiAgICB2YXIgcXVlcnkgPSBfX2Fzc2lnbih7fSwgcGFyYW1zKTtcbiAgICBPYmplY3QuZW50cmllcyhyZXF1aXJlZFBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGtleSA9IF9hWzBdLCBwYXJhbSA9IF9hWzFdO1xuICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBwYXJhbTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHBhcnNlZC5zZXQoJ3F1ZXJ5JywgcXVlcnkpO1xuICAgIHZhciBtYXRjaCA9IG1lZGlhVXJsUHJlZml4LmV4ZWMocGFyc2VkLnBhdGhuYW1lKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyByZWdleCB3aWxsIHByb3ZpZGUgdXMgd2l0aCAvLS8gb3IgL34vIHR5cGVcbiAgICAgICAgcGFyc2VkLnNldCgncGF0aG5hbWUnLCBwYXJzZWQucGF0aG5hbWUucmVwbGFjZShtZWRpYVVybFByZWZpeCwgXCIvXCIgKyBtYXRjaFsxXSArIFwiL2pzc21lZGlhL1wiKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQudG9TdHJpbmcoKTtcbn07XG4vKipcbiAqIFJlY2VpdmVzIGFuIGFycmF5IG9mIGBzcmNTZXRgIHBhcmFtZXRlcnMgdGhhdCBhcmUgaXRlcmF0ZWQgYW5kIHVzZWQgYXMgcGFyYW1ldGVycyB0byBnZW5lcmF0ZVxuICogYSBjb3JyZXNwb25kaW5nIHNldCBvZiB1cGRhdGVkIFNpdGVjb3JlIG1lZGlhIFVSTHMgdmlhIEBzZWUgdXBkYXRlSW1hZ2VVcmwuIFRoZSByZXN1bHQgaXMgYSBjb21tYS1kZWxpbWl0ZWRcbiAqIGxpc3Qgb2YgbWVkaWEgVVJMcyB3aXRoIHJlc3BlY3RpdmUgZGltZW5zaW9uIHBhcmFtZXRlcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIHJldHVybnMgJy9pcHN1bS5qcGc/aD0xMDAwJnc9MTAwMCAxMDAwdywgL2lwc3VtLmpwZz9taD0yNTAmbXc9MjUwIDI1MHcnXG4gKiBnZXRTcmNTZXQoJy9pcHN1bS5qcGcnLCBbeyBoOiAxMDAwLCB3OiAxMDAwIH0sIHsgbWg6IDI1MCwgbXc6IDI1MCB9IF0pXG4gKlxuICogTW9yZSBpbmZvcm1hdGlvbiBhYm91dCBgc3JjU2V0YDoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWd9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtBcnJheX0gc3JjU2V0XG4gKiBAcGFyYW0ge09iamVjdH0gW2ltYWdlUGFyYW1zXVxuICogQHBhcmFtIHtSZWdFeHB9IFttZWRpYVVybFByZWZpeF1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHNyYyBzZXRcbiAqL1xuZXhwb3J0cy5nZXRTcmNTZXQgPSBmdW5jdGlvbiAodXJsLCBzcmNTZXQsIGltYWdlUGFyYW1zLCBtZWRpYVVybFByZWZpeCkge1xuICAgIHJldHVybiBzcmNTZXRcbiAgICAgICAgLm1hcChmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW1hZ2VQYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB2YXIgaW1hZ2VXaWR0aCA9IG5ld1BhcmFtcy53IHx8IG5ld1BhcmFtcy5tdztcbiAgICAgICAgaWYgKCFpbWFnZVdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51cGRhdGVJbWFnZVVybCh1cmwsIG5ld1BhcmFtcywgbWVkaWFVcmxQcmVmaXgpICsgXCIgXCIgKyBpbWFnZVdpZHRoICsgXCJ3XCI7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9KVxuICAgICAgICAuam9pbignLCAnKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19zZXJ2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9pcy1zZXJ2ZXJcIikpO1xuZXhwb3J0cy5pc0V4cGVyaWVuY2VFZGl0b3JBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzX3NlcnZlcl8xLmRlZmF1bHQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHZhciBzYyA9IHdpbmRvdy5TaXRlY29yZTtcbiAgICByZXR1cm4gQm9vbGVhbihzYyAmJiBzYy5QYWdlTW9kZXMgJiYgc2MuUGFnZU1vZGVzLkNocm9tZU1hbmFnZXIpO1xufTtcbmV4cG9ydHMucmVzZXRFeHBlcmllbmNlRWRpdG9yQ2hyb21lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwb3J0cy5pc0V4cGVyaWVuY2VFZGl0b3JBY3RpdmUoKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgd2luZG93LlNpdGVjb3JlLlBhZ2VNb2Rlcy5DaHJvbWVNYW5hZ2VyLnJlc2V0Q2hyb21lcygpO1xuICAgIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19zZXJ2ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9pcy1zZXJ2ZXJcIikpO1xuZXhwb3J0cy5pc1NlcnZlciA9IGlzX3NlcnZlcl8xLmRlZmF1bHQ7XG52YXIgcmVzb2x2ZV91cmxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZXNvbHZlLXVybFwiKSk7XG5leHBvcnRzLnJlc29sdmVVcmwgPSByZXNvbHZlX3VybF8xLmRlZmF1bHQ7XG52YXIgZXhwZXJpZW5jZV9lZGl0b3JfMSA9IHJlcXVpcmUoXCIuL2V4cGVyaWVuY2UtZWRpdG9yXCIpO1xuZXhwb3J0cy5pc0V4cGVyaWVuY2VFZGl0b3JBY3RpdmUgPSBleHBlcmllbmNlX2VkaXRvcl8xLmlzRXhwZXJpZW5jZUVkaXRvckFjdGl2ZTtcbmV4cG9ydHMucmVzZXRFeHBlcmllbmNlRWRpdG9yQ2hyb21lcyA9IGV4cGVyaWVuY2VfZWRpdG9yXzEucmVzZXRFeHBlcmllbmNlRWRpdG9yQ2hyb21lcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQgaXMgc2VydmVyLXNpZGVcbiAqIEByZXR1cm5zIHRydWUgaWYgZXhlY3V0aW5nIHNlcnZlci1zaWRlXG4gKi9cbmZ1bmN0aW9uIGlzU2VydmVyKCkge1xuICAgIHJldHVybiAhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBpc1NlcnZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX3NlcnZlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2lzLXNlcnZlclwiKSk7XG4vKipcbiAqIG5vdGU6IGVuY29kZVVSSUNvbXBvbmVudCBpcyBhdmFpbGFibGUgdmlhIGJyb3dzZXIgKHdpbmRvdykgb3IgbmF0aXZlbHkgaW4gbm9kZS5qc1xuICogaWYgeW91IHVzZSBhbm90aGVyIGpzIGVuZ2luZSBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nIHlvdSBtYXkgbm90IGhhdmUgbmF0aXZlIGVuY29kZVVSSUNvbXBvbmVudFxuICogYW5kIHdvdWxkIHRoZW4gbmVlZCB0byBpbnN0YWxsIGEgcGFja2FnZSBmb3IgdGhhdCBmdW5jdGlvbmFsaXR5XG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIGdldFF1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhwYXJhbXNba10pKTsgfSlcbiAgICAgICAgLmpvaW4oJyYnKTtcbn1cbi8qKlxuICogUmVzb2x2ZXMgYSBiYXNlIFVSTCB0aGF0IG1heSBjb250YWluIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzIGFuZCBhbiBhZGRpdGlvbmFsIHNldCBvZiBxdWVyeVxuICogc3RyaW5nIHBhcmFtZXRlcnMgaW50byBhIHVuaWZpZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybEJhc2UgdGhlIGJhc2UgVVJMIHRoYXQgbWF5IGNvbnRhaW4gcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIGEgVVJMIHN0cmluZ1xuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gaWYgdGhlIHByb3ZpZGVkIHVybCBpcyBhbiBlbXB0eSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVVybCh1cmxCYXNlLCBwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cbiAgICBpZiAoIXVybEJhc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3VybCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIGEgYmV0dGVyIHdheSB0byB3b3JrIHdpdGggVVJMcyBzaW5jZSBpdCBoYW5kbGVzIGRpZmZlcmVudCB1c2VyIGlucHV0XG4gICAgLy8gZWRnZSBjYXNlcy4gVGhpcyB3b3JrcyBpbiBOb2RlIGFuZCBhbGwgYnJvd3NlciBleGNlcHQgSUUxMS5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJMXG4gICAgLy8gVE9ETzogVmVyaWZ5IG91ciBicm93c2VyIHN1cHBvcnQgcmVxdWlyZW1lbnRzLlxuICAgIGlmIChpc19zZXJ2ZXJfMS5kZWZhdWx0KCkpIHtcbiAgICAgICAgdmFyIHVybCA9IG5ldyBVUkwodXJsQmFzZSk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywga2V5KSkge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHBhcmFtc1trZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdF8xID0gdXJsLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiByZXN1bHRfMTtcbiAgICB9XG4gICAgdmFyIHFzID0gZ2V0UXVlcnlTdHJpbmcocGFyYW1zKTtcbiAgICB2YXIgcmVzdWx0ID0gdXJsQmFzZS5pbmRleE9mKCc/JykgIT09IC0xID8gdXJsQmFzZSArIFwiJlwiICsgcXMgOiB1cmxCYXNlICsgXCI/XCIgKyBxcztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcmVzb2x2ZVVybDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4dHJhY3RfZmlsZXNfMSA9IHJlcXVpcmUoXCJleHRyYWN0LWZpbGVzXCIpO1xudmFyIGZvcm1fZGF0YV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmb3JtLWRhdGFcIikpO1xuLyoqXG4gKiBEdWNrIHR5cGUgaWYgTm9kZUpTIHN0cmVhbVxuICogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9pcy1zdHJlYW0vYmxvYi8zNzUwNTA1YjA3MjdmNmRmNTQzMjQ3ODRmZTM2OTM2NWVmNzg4NDFlL2luZGV4LmpzI0wzXG4gKi9cbnZhciBpc0V4dHJhY3RhYmxlRmlsZUVuaGFuY2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RfZmlsZXNfMS5pc0V4dHJhY3RhYmxlRmlsZSh2YWx1ZSkgfHxcbiAgICAgICAgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnBpcGUgPT09ICdmdW5jdGlvbicpO1xufTtcbi8qKlxuICogUmV0dXJucyBNdWx0aXBhcnQgRm9ybSBpZiBib2R5IGNvbnRhaW5zIGZpbGVzXG4gKiAoaHR0cHM6Ly9naXRodWIuY29tL2pheWRlbnNlcmljL2dyYXBocWwtbXVsdGlwYXJ0LXJlcXVlc3Qtc3BlYylcbiAqIE90aGVyd2lzZSByZXR1cm5zIEpTT05cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdEJvZHkocXVlcnksIHZhcmlhYmxlcywgb3BlcmF0aW9uTmFtZSkge1xuICAgIHZhciBfYSA9IGV4dHJhY3RfZmlsZXNfMS5leHRyYWN0RmlsZXMoeyBxdWVyeTogcXVlcnksIHZhcmlhYmxlczogdmFyaWFibGVzLCBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb25OYW1lIH0sICcnLCBpc0V4dHJhY3RhYmxlRmlsZUVuaGFuY2VkKSwgY2xvbmUgPSBfYS5jbG9uZSwgZmlsZXMgPSBfYS5maWxlcztcbiAgICBpZiAoZmlsZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY2xvbmUpO1xuICAgIH1cbiAgICB2YXIgRm9ybSA9IHR5cGVvZiBGb3JtRGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyBmb3JtX2RhdGFfMS5kZWZhdWx0IDogRm9ybURhdGE7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybSgpO1xuICAgIGZvcm0uYXBwZW5kKCdvcGVyYXRpb25zJywgSlNPTi5zdHJpbmdpZnkoY2xvbmUpKTtcbiAgICB2YXIgbWFwID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKHBhdGhzKSB7XG4gICAgICAgIG1hcFsrK2ldID0gcGF0aHM7XG4gICAgfSk7XG4gICAgZm9ybS5hcHBlbmQoJ21hcCcsIEpTT04uc3RyaW5naWZ5KG1hcCkpO1xuICAgIGkgPSAwO1xuICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKHBhdGhzLCBmaWxlKSB7XG4gICAgICAgIGZvcm0uYXBwZW5kKFwiXCIgKyArK2ksIGZpbGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3JtO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlUmVxdWVzdEJvZHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVSZXF1ZXN0Qm9keS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdxbCA9IGV4cG9ydHMucmVxdWVzdCA9IGV4cG9ydHMucmF3UmVxdWVzdCA9IGV4cG9ydHMuR3JhcGhRTENsaWVudCA9IGV4cG9ydHMuQ2xpZW50RXJyb3IgPSB2b2lkIDA7XG52YXIgY3Jvc3NfZmV0Y2hfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiY3Jvc3MtZmV0Y2hcIikpLCBDcm9zc0ZldGNoID0gY3Jvc3NfZmV0Y2hfMTtcbnZhciBwcmludGVyXzEgPSByZXF1aXJlKFwiZ3JhcGhxbC9sYW5ndWFnZS9wcmludGVyXCIpO1xudmFyIGNyZWF0ZVJlcXVlc3RCb2R5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3JlYXRlUmVxdWVzdEJvZHlcIikpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciB0eXBlc18yID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5DbGllbnRFcnJvcjsgfSB9KTtcbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gaGVhZGVycyBjb25maWd1cmF0aW9uIGludG8gYSBwbGFpbiBvYmplY3QuXG4gKi9cbnZhciByZXNvbHZlSGVhZGVycyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgdmFyIG9IZWFkZXJzID0ge307XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgSGVhZGVycyAhPT0gJ3VuZGVmaW5lZCcgJiYgaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHx8XG4gICAgICAgICAgICBoZWFkZXJzIGluc3RhbmNlb2YgQ3Jvc3NGZXRjaC5IZWFkZXJzKSB7XG4gICAgICAgICAgICBvSGVhZGVycyA9IEhlYWRlcnNJbnN0YW5jZVRvUGxhaW5PYmplY3QoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgICAgICAgICAgb0hlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb0hlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvSGVhZGVycztcbn07XG4vKipcbiAqIEZldGNoIGRhdGEgdXNpbmcgUE9TVCBtZXRob2RcbiAqL1xudmFyIHBvc3QgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdXJsID0gX2EudXJsLCBxdWVyeSA9IF9hLnF1ZXJ5LCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIG9wZXJhdGlvbk5hbWUgPSBfYS5vcGVyYXRpb25OYW1lLCBoZWFkZXJzID0gX2EuaGVhZGVycywgZmV0Y2ggPSBfYS5mZXRjaCwgZmV0Y2hPcHRpb25zID0gX2EuZmV0Y2hPcHRpb25zO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9keTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGNyZWF0ZVJlcXVlc3RCb2R5XzEuZGVmYXVsdChxdWVyeSwgdmFyaWFibGVzLCBvcGVyYXRpb25OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2godXJsLCBfX2Fzc2lnbih7IG1ldGhvZDogJ1BPU1QnLCBoZWFkZXJzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyA/IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9IDoge30pKSwgaGVhZGVycyksIGJvZHk6IGJvZHkgfSwgZmV0Y2hPcHRpb25zKSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogRmV0Y2ggZGF0YSB1c2luZyBHRVQgbWV0aG9kXG4gKi9cbnZhciBnZXQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdXJsID0gX2EudXJsLCBxdWVyeSA9IF9hLnF1ZXJ5LCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIG9wZXJhdGlvbk5hbWUgPSBfYS5vcGVyYXRpb25OYW1lLCBoZWFkZXJzID0gX2EuaGVhZGVycywgZmV0Y2ggPSBfYS5mZXRjaCwgZmV0Y2hPcHRpb25zID0gX2EuZmV0Y2hPcHRpb25zO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VhcmNoO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBzZWFyY2ggPSBbXCJxdWVyeT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChxdWVyeS5yZXBsYWNlKC8oW1xccyxdfCNbXlxcblxccl0rKSsvZywgJyAnKS50cmltKCkpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoLnB1c2goXCJ2YXJpYWJsZXM9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkodmFyaWFibGVzKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2gucHVzaChcIm9wZXJhdGlvbk5hbWU9XCIgKyBlbmNvZGVVUklDb21wb25lbnQob3BlcmF0aW9uTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHVybCArIFwiP1wiICsgc2VhcmNoLmpvaW4oJyYnKSwgX19hc3NpZ24oeyBtZXRob2Q6ICdHRVQnLCBoZWFkZXJzOiBoZWFkZXJzIH0sIGZldGNoT3B0aW9ucykpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIHRvZG9cbiAqL1xudmFyIEdyYXBoUUxDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhRTENsaWVudCh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIEdyYXBoUUxDbGllbnQucHJvdG90eXBlLnJhd1JlcXVlc3QgPSBmdW5jdGlvbiAocXVlcnksIHZhcmlhYmxlcywgcmVxdWVzdEhlYWRlcnMpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBoZWFkZXJzID0gX2EuaGVhZGVycywgX2IgPSBfYS5mZXRjaCwgZmV0Y2ggPSBfYiA9PT0gdm9pZCAwID8gY3Jvc3NfZmV0Y2hfMS5kZWZhdWx0IDogX2IsIF9jID0gX2EubWV0aG9kLCBtZXRob2QgPSBfYyA9PT0gdm9pZCAwID8gJ1BPU1QnIDogX2MsIGZldGNoT3B0aW9ucyA9IF9fcmVzdChfYSwgW1wiaGVhZGVyc1wiLCBcImZldGNoXCIsIFwibWV0aG9kXCJdKTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMudXJsO1xuICAgICAgICByZXR1cm4gbWFrZVJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIGhlYWRlcnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXNvbHZlSGVhZGVycyhoZWFkZXJzKSksIHJlc29sdmVIZWFkZXJzKHJlcXVlc3RIZWFkZXJzKSksXG4gICAgICAgICAgICBvcGVyYXRpb25OYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBmZXRjaDogZmV0Y2gsXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBHcmFwaFFMIGRvY3VtZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgR3JhcGhRTENsaWVudC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChkb2N1bWVudCwgdmFyaWFibGVzLCByZXF1ZXN0SGVhZGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGhlYWRlcnMsIF9iLCBmZXRjaCwgX2MsIG1ldGhvZCwgZmV0Y2hPcHRpb25zLCB1cmwsIF9kLCBxdWVyeSwgb3BlcmF0aW9uTmFtZSwgZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5vcHRpb25zLCBoZWFkZXJzID0gX2EuaGVhZGVycywgX2IgPSBfYS5mZXRjaCwgZmV0Y2ggPSBfYiA9PT0gdm9pZCAwID8gY3Jvc3NfZmV0Y2hfMS5kZWZhdWx0IDogX2IsIF9jID0gX2EubWV0aG9kLCBtZXRob2QgPSBfYyA9PT0gdm9pZCAwID8gJ1BPU1QnIDogX2MsIGZldGNoT3B0aW9ucyA9IF9fcmVzdChfYSwgW1wiaGVhZGVyc1wiLCBcImZldGNoXCIsIFwibWV0aG9kXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMudXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSByZXNvbHZlUmVxdWVzdERvY3VtZW50KGRvY3VtZW50KSwgcXVlcnkgPSBfZC5xdWVyeSwgb3BlcmF0aW9uTmFtZSA9IF9kLm9wZXJhdGlvbk5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBtYWtlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcmVzb2x2ZUhlYWRlcnMoaGVhZGVycykpLCByZXNvbHZlSGVhZGVycyhyZXF1ZXN0SGVhZGVycykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaDogZmV0Y2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaE9wdGlvbnM6IGZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoX2Uuc2VudCgpKS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRhdGFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdyYXBoUUxDbGllbnQucHJvdG90eXBlLnNldEhlYWRlcnMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoIGEgaGVhZGVyIHRvIHRoZSBjbGllbnQuIEFsbCBzdWJzZXF1ZW50IHJlcXVlc3RzIHdpbGwgaGF2ZSB0aGlzIGhlYWRlci5cbiAgICAgKi9cbiAgICBHcmFwaFFMQ2xpZW50LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5vcHRpb25zLmhlYWRlcnM7XG4gICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICAvLyB0b2RvIHdoYXQgaWYgaGVhZGVycyBpcyBpbiBuZXN0ZWQgYXJyYXkgZm9ybS4uLiA/XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhlYWRlcnMgPSAoX2EgPSB7fSwgX2Fba2V5XSA9IHZhbHVlLCBfYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGhRTENsaWVudDtcbn0oKSk7XG5leHBvcnRzLkdyYXBoUUxDbGllbnQgPSBHcmFwaFFMQ2xpZW50O1xuZnVuY3Rpb24gbWFrZVJlcXVlc3QoX2EpIHtcbiAgICB2YXIgdXJsID0gX2EudXJsLCBxdWVyeSA9IF9hLnF1ZXJ5LCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIGhlYWRlcnMgPSBfYS5oZWFkZXJzLCBvcGVyYXRpb25OYW1lID0gX2Eub3BlcmF0aW9uTmFtZSwgZmV0Y2ggPSBfYS5mZXRjaCwgX2IgPSBfYS5tZXRob2QsIG1ldGhvZCA9IF9iID09PSB2b2lkIDAgPyAnUE9TVCcgOiBfYiwgZmV0Y2hPcHRpb25zID0gX2EuZmV0Y2hPcHRpb25zO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZldGNoZXIsIHJlc3BvbnNlLCByZXN1bHQsIGhlYWRlcnNfMSwgc3RhdHVzXzEsIGVycm9yUmVzdWx0O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBmZXRjaGVyID0gbWV0aG9kLnRvVXBwZXJDYXNlKCkgPT09ICdQT1NUJyA/IHBvc3QgOiBnZXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2g6IGZldGNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoT3B0aW9uczogZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdldFJlc3VsdChyZXNwb25zZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgIXJlc3VsdC5lcnJvcnMgJiYgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNfMSA9IHJlc3BvbnNlLmhlYWRlcnMsIHN0YXR1c18xID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9fYXNzaWduKF9fYXNzaWduKHt9LCByZXN1bHQpLCB7IGhlYWRlcnM6IGhlYWRlcnNfMSwgc3RhdHVzOiBzdGF0dXNfMSB9KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3VsdCA9IHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnID8geyBlcnJvcjogcmVzdWx0IH0gOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5DbGllbnRFcnJvcihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZXJyb3JSZXN1bHQpLCB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzIH0pLCB7IHF1ZXJ5OiBxdWVyeSwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogdG9kb1xuICovXG5mdW5jdGlvbiByYXdSZXF1ZXN0KHVybCwgcXVlcnksIHZhcmlhYmxlcywgcmVxdWVzdEhlYWRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbGllbnQ7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IG5ldyBHcmFwaFFMQ2xpZW50KHVybCk7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2xpZW50LnJhd1JlcXVlc3QocXVlcnksIHZhcmlhYmxlcywgcmVxdWVzdEhlYWRlcnMpXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJhd1JlcXVlc3QgPSByYXdSZXF1ZXN0O1xuLyoqXG4gKiBTZW5kIGEgR3JhcGhRTCBEb2N1bWVudCB0byB0aGUgR3JhcGhRTCBzZXJ2ZXIgZm9yIGV4ZWN0dWlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiAvLyBZb3UgY2FuIHBhc3MgYSByYXcgc3RyaW5nXG4gKlxuICogYXdhaXQgcmVxdWVzdCgnaHR0cHM6Ly9mb28uYmFyL2dyYXBocWwnLCBgXG4gKiAgIHtcbiAqICAgICBxdWVyeSB7XG4gKiAgICAgICB1c2Vyc1xuICogICAgIH1cbiAqICAgfVxuICogYClcbiAqXG4gKiAvLyBZb3UgY2FuIGFsc28gcGFzcyBhIEdyYXBoUUwgRG9jdW1lbnROb2RlLiBDb252ZW5pZW50IGlmIHlvdVxuICogLy8gYXJlIHVzaW5nIGdyYXBocWwtdGFnIHBhY2thZ2UuXG4gKlxuICogaW1wb3J0IGdxbCBmcm9tICdncmFwaHFsLXRhZydcbiAqXG4gKiBhd2FpdCByZXF1ZXN0KCdodHRwczovL2Zvby5iYXIvZ3JhcGhxbCcsIGdxbGAuLi5gKVxuICpcbiAqIC8vIElmIHlvdSBkb24ndCBhY3R1YWxseSBjYXJlIGFib3V0IHVzaW5nIERvY3VtZW50Tm9kZSBidXQganVzdFxuICogLy8gd2FudCB0aGUgdG9vbGluZyBzdXBwb3J0IGZvciBncWwgdGVtcGxhdGUgdGFnIGxpa2UgSURFIHN5bnRheFxuICogLy8gY29sb3JpbmcgYW5kIHByZXR0aWVyIGF1dG9mb3JtYXQgdGhlbiBub3RlIHlvdSBjYW4gdXNlIHRoZVxuICogLy8gcGFzc3Rocm91Z2ggZ3FsIHRhZyBzaGlwcGVkIHdpdGggZ3JhcGhxbC1yZXF1ZXN0IHRvIHNhdmUgYSBiaXRcbiAqIC8vIG9mIHBlcmZvcm1hbmNlIGFuZCBub3QgaGF2ZSB0byBpbnN0YWxsIGFub3RoZXIgZGVwIGludG8geW91ciBwcm9qZWN0LlxuICpcbiAqIGltcG9ydCB7IGdxbCB9IGZyb20gJ2dyYXBocWwtcmVxdWVzdCdcbiAqXG4gKiBhd2FpdCByZXF1ZXN0KCdodHRwczovL2Zvby5iYXIvZ3JhcGhxbCcsIGdxbGAuLi5gKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHJlcXVlc3QodXJsLCBkb2N1bWVudCwgdmFyaWFibGVzLCByZXF1ZXN0SGVhZGVycykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsaWVudDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgY2xpZW50ID0gbmV3IEdyYXBoUUxDbGllbnQodXJsKTtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjbGllbnQucmVxdWVzdChkb2N1bWVudCwgdmFyaWFibGVzLCByZXF1ZXN0SGVhZGVycyldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVxdWVzdCA9IHJlcXVlc3Q7XG5leHBvcnRzLmRlZmF1bHQgPSByZXF1ZXN0O1xuLyoqXG4gKiB0b2RvXG4gKi9cbmZ1bmN0aW9uIGdldFJlc3VsdChyZXNwb25zZSkge1xuICAgIHZhciBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuc3RhcnRzV2l0aCgnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH1cbn1cbi8qKlxuICogaGVscGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlUmVxdWVzdERvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4geyBxdWVyeTogZG9jdW1lbnQgfTtcbiAgICB2YXIgb3BlcmF0aW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgb3BlcmF0aW9uRGVmaW5pdGlvbnMgPSBkb2N1bWVudC5kZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHsgcmV0dXJuIGRlZmluaXRpb24ua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nOyB9KTtcbiAgICBpZiAob3BlcmF0aW9uRGVmaW5pdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG9wZXJhdGlvbk5hbWUgPSAoX2EgPSBvcGVyYXRpb25EZWZpbml0aW9uc1swXS5uYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB7IHF1ZXJ5OiBwcmludGVyXzEucHJpbnQoZG9jdW1lbnQpLCBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb25OYW1lIH07XG59XG4vKipcbiAqIENvbnZlbmllbmNlIHBhc3N0aHJvdWdoIHRlbXBsYXRlIHRhZyB0byBnZXQgdGhlIGJlbmVmaXRzIG9mIHRvb2xpbmcgZm9yIHRoZSBncWwgdGVtcGxhdGUgdGFnLiBUaGlzIGRvZXMgbm90IGFjdHVhbGx5IHBhcnNlIHRoZSBpbnB1dCBpbnRvIGEgR3JhcGhRTCBEb2N1bWVudE5vZGUgbGlrZSBncmFwaHFsLXRhZyBwYWNrYWdlIGRvZXMuIEl0IGp1c3QgcmV0dXJucyB0aGUgc3RyaW5nIHdpdGggYW55IHZhcmlhYmxlcyBnaXZlbiBpbnRlcnBvbGF0ZWQuIENhbiBzYXZlIHlvdSBhIGJpdCBvZiBwZXJmb3JtYW5jZSBhbmQgaGF2aW5nIHRvIGluc3RhbGwgYW5vdGhlciBwYWNrYWdlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHsgZ3FsIH0gZnJvbSAnZ3JhcGhxbC1yZXF1ZXN0J1xuICpcbiAqIGF3YWl0IHJlcXVlc3QoJ2h0dHBzOi8vZm9vLmJhci9ncmFwaHFsJywgZ3FsYC4uLmApXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBTZXZlcmFsIHRvb2xzIGluIHRoZSBOb2RlIEdyYXBoUUwgZWNvc3lzdGVtIGFyZSBoYXJkY29kZWQgdG8gc3BlY2lhbGx5IHRyZWF0IGFueSB0ZW1wbGF0ZSB0YWcgbmFtZWQgXCJncWxcIi4gRm9yIGV4YW1wbGUgc2VlIHRoaXMgcHJldHRpZXIgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9pc3N1ZXMvNDM2MC4gVXNpbmcgdGhpcyB0ZW1wbGF0ZSB0YWcgaGFzIG5vIHJ1bnRpbWUgZWZmZWN0IGJleW9uZCB2YXJpYWJsZSBpbnRlcnBvbGF0aW9uLlxuICovXG5mdW5jdGlvbiBncWwoY2h1bmtzKSB7XG4gICAgdmFyIHZhcmlhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhcmlhYmxlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBjaHVuaywgaW5kZXgpIHsgcmV0dXJuIFwiXCIgKyBhY2N1bXVsYXRvciArIGNodW5rICsgKGluZGV4IGluIHZhcmlhYmxlcyA/IHZhcmlhYmxlc1tpbmRleF0gOiAnJyk7IH0sICcnKTtcbn1cbmV4cG9ydHMuZ3FsID0gZ3FsO1xuLyoqXG4gKiBDb252ZXJ0IEhlYWRlcnMgaW5zdGFuY2UgaW50byByZWd1bGFyIG9iamVjdFxuICovXG5mdW5jdGlvbiBIZWFkZXJzSW5zdGFuY2VUb1BsYWluT2JqZWN0KGhlYWRlcnMpIHtcbiAgICB2YXIgbyA9IHt9O1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgICAgICBvW2tdID0gdjtcbiAgICB9KTtcbiAgICByZXR1cm4gbztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50RXJyb3IgPSB2b2lkIDA7XG52YXIgQ2xpZW50RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsaWVudEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENsaWVudEVycm9yKHJlc3BvbnNlLCByZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlID0gQ2xpZW50RXJyb3IuZXh0cmFjdE1lc3NhZ2UocmVzcG9uc2UpICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBDbGllbnRFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgLy8gdGhpcyBpcyBuZWVkZWQgYXMgU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCAuY2FwdHVyZVN0YWNrVHJhY2VcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIENsaWVudEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENsaWVudEVycm9yLmV4dHJhY3RNZXNzYWdlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZXJyb3JzWzBdLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkdyYXBoUUwgRXJyb3IgKENvZGU6IFwiICsgcmVzcG9uc2Uuc3RhdHVzICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDbGllbnRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQ2xpZW50RXJyb3IgPSBDbGllbnRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbG9yQ29udmVydCA9IHJlcXVpcmUoJ2NvbG9yLWNvbnZlcnQnKTtcblxuY29uc3Qgd3JhcEFuc2kxNiA9IChmbiwgb2Zmc2V0KSA9PiBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IGNvZGUgPSBmbi5hcHBseShjb2xvckNvbnZlcnQsIGFyZ3VtZW50cyk7XG5cdHJldHVybiBgXFx1MDAxQlske2NvZGUgKyBvZmZzZXR9bWA7XG59O1xuXG5jb25zdCB3cmFwQW5zaTI1NiA9IChmbiwgb2Zmc2V0KSA9PiBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IGNvZGUgPSBmbi5hcHBseShjb2xvckNvbnZlcnQsIGFyZ3VtZW50cyk7XG5cdHJldHVybiBgXFx1MDAxQlskezM4ICsgb2Zmc2V0fTs1OyR7Y29kZX1tYDtcbn07XG5cbmNvbnN0IHdyYXBBbnNpMTZtID0gKGZuLCBvZmZzZXQpID0+IGZ1bmN0aW9uICgpIHtcblx0Y29uc3QgcmdiID0gZm4uYXBwbHkoY29sb3JDb252ZXJ0LCBhcmd1bWVudHMpO1xuXHRyZXR1cm4gYFxcdTAwMUJbJHszOCArIG9mZnNldH07Mjske3JnYlswXX07JHtyZ2JbMV19OyR7cmdiWzJdfW1gO1xufTtcblxuZnVuY3Rpb24gYXNzZW1ibGVTdHlsZXMoKSB7XG5cdGNvbnN0IGNvZGVzID0gbmV3IE1hcCgpO1xuXHRjb25zdCBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXI6IHtcblx0XHRcdHJlc2V0OiBbMCwgMF0sXG5cdFx0XHQvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG5cdFx0XHRib2xkOiBbMSwgMjJdLFxuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yOiB7XG5cdFx0XHRibGFjazogWzMwLCAzOV0sXG5cdFx0XHRyZWQ6IFszMSwgMzldLFxuXHRcdFx0Z3JlZW46IFszMiwgMzldLFxuXHRcdFx0eWVsbG93OiBbMzMsIDM5XSxcblx0XHRcdGJsdWU6IFszNCwgMzldLFxuXHRcdFx0bWFnZW50YTogWzM1LCAzOV0sXG5cdFx0XHRjeWFuOiBbMzYsIDM5XSxcblx0XHRcdHdoaXRlOiBbMzcsIDM5XSxcblx0XHRcdGdyYXk6IFs5MCwgMzldLFxuXG5cdFx0XHQvLyBCcmlnaHQgY29sb3Jcblx0XHRcdHJlZEJyaWdodDogWzkxLCAzOV0sXG5cdFx0XHRncmVlbkJyaWdodDogWzkyLCAzOV0sXG5cdFx0XHR5ZWxsb3dCcmlnaHQ6IFs5MywgMzldLFxuXHRcdFx0Ymx1ZUJyaWdodDogWzk0LCAzOV0sXG5cdFx0XHRtYWdlbnRhQnJpZ2h0OiBbOTUsIDM5XSxcblx0XHRcdGN5YW5CcmlnaHQ6IFs5NiwgMzldLFxuXHRcdFx0d2hpdGVCcmlnaHQ6IFs5NywgMzldXG5cdFx0fSxcblx0XHRiZ0NvbG9yOiB7XG5cdFx0XHRiZ0JsYWNrOiBbNDAsIDQ5XSxcblx0XHRcdGJnUmVkOiBbNDEsIDQ5XSxcblx0XHRcdGJnR3JlZW46IFs0MiwgNDldLFxuXHRcdFx0YmdZZWxsb3c6IFs0MywgNDldLFxuXHRcdFx0YmdCbHVlOiBbNDQsIDQ5XSxcblx0XHRcdGJnTWFnZW50YTogWzQ1LCA0OV0sXG5cdFx0XHRiZ0N5YW46IFs0NiwgNDldLFxuXHRcdFx0YmdXaGl0ZTogWzQ3LCA0OV0sXG5cblx0XHRcdC8vIEJyaWdodCBjb2xvclxuXHRcdFx0YmdCbGFja0JyaWdodDogWzEwMCwgNDldLFxuXHRcdFx0YmdSZWRCcmlnaHQ6IFsxMDEsIDQ5XSxcblx0XHRcdGJnR3JlZW5CcmlnaHQ6IFsxMDIsIDQ5XSxcblx0XHRcdGJnWWVsbG93QnJpZ2h0OiBbMTAzLCA0OV0sXG5cdFx0XHRiZ0JsdWVCcmlnaHQ6IFsxMDQsIDQ5XSxcblx0XHRcdGJnTWFnZW50YUJyaWdodDogWzEwNSwgNDldLFxuXHRcdFx0YmdDeWFuQnJpZ2h0OiBbMTA2LCA0OV0sXG5cdFx0XHRiZ1doaXRlQnJpZ2h0OiBbMTA3LCA0OV1cblx0XHR9XG5cdH07XG5cblx0Ly8gRml4IGh1bWFuc1xuXHRzdHlsZXMuY29sb3IuZ3JleSA9IHN0eWxlcy5jb2xvci5ncmF5O1xuXG5cdGZvciAoY29uc3QgZ3JvdXBOYW1lIG9mIE9iamVjdC5rZXlzKHN0eWxlcykpIHtcblx0XHRjb25zdCBncm91cCA9IHN0eWxlc1tncm91cE5hbWVdO1xuXG5cdFx0Zm9yIChjb25zdCBzdHlsZU5hbWUgb2YgT2JqZWN0LmtleXMoZ3JvdXApKSB7XG5cdFx0XHRjb25zdCBzdHlsZSA9IGdyb3VwW3N0eWxlTmFtZV07XG5cblx0XHRcdHN0eWxlc1tzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiBgXFx1MDAxQlske3N0eWxlWzBdfW1gLFxuXHRcdFx0XHRjbG9zZTogYFxcdTAwMUJbJHtzdHlsZVsxXX1tYFxuXHRcdFx0fTtcblxuXHRcdFx0Z3JvdXBbc3R5bGVOYW1lXSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG5cdFx0XHRjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCAnY29kZXMnLCB7XG5cdFx0XHR2YWx1ZTogY29kZXMsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHRcdH0pO1xuXHR9XG5cblx0Y29uc3QgYW5zaTJhbnNpID0gbiA9PiBuO1xuXHRjb25zdCByZ2IycmdiID0gKHIsIGcsIGIpID0+IFtyLCBnLCBiXTtcblxuXHRzdHlsZXMuY29sb3IuY2xvc2UgPSAnXFx1MDAxQlszOW0nO1xuXHRzdHlsZXMuYmdDb2xvci5jbG9zZSA9ICdcXHUwMDFCWzQ5bSc7XG5cblx0c3R5bGVzLmNvbG9yLmFuc2kgPSB7XG5cdFx0YW5zaTogd3JhcEFuc2kxNihhbnNpMmFuc2ksIDApXG5cdH07XG5cdHN0eWxlcy5jb2xvci5hbnNpMjU2ID0ge1xuXHRcdGFuc2kyNTY6IHdyYXBBbnNpMjU2KGFuc2kyYW5zaSwgMClcblx0fTtcblx0c3R5bGVzLmNvbG9yLmFuc2kxNm0gPSB7XG5cdFx0cmdiOiB3cmFwQW5zaTE2bShyZ2IycmdiLCAwKVxuXHR9O1xuXG5cdHN0eWxlcy5iZ0NvbG9yLmFuc2kgPSB7XG5cdFx0YW5zaTogd3JhcEFuc2kxNihhbnNpMmFuc2ksIDEwKVxuXHR9O1xuXHRzdHlsZXMuYmdDb2xvci5hbnNpMjU2ID0ge1xuXHRcdGFuc2kyNTY6IHdyYXBBbnNpMjU2KGFuc2kyYW5zaSwgMTApXG5cdH07XG5cdHN0eWxlcy5iZ0NvbG9yLmFuc2kxNm0gPSB7XG5cdFx0cmdiOiB3cmFwQW5zaTE2bShyZ2IycmdiLCAxMClcblx0fTtcblxuXHRmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoY29sb3JDb252ZXJ0KSkge1xuXHRcdGlmICh0eXBlb2YgY29sb3JDb252ZXJ0W2tleV0gIT09ICdvYmplY3QnKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb25zdCBzdWl0ZSA9IGNvbG9yQ29udmVydFtrZXldO1xuXG5cdFx0aWYgKGtleSA9PT0gJ2Fuc2kxNicpIHtcblx0XHRcdGtleSA9ICdhbnNpJztcblx0XHR9XG5cblx0XHRpZiAoJ2Fuc2kxNicgaW4gc3VpdGUpIHtcblx0XHRcdHN0eWxlcy5jb2xvci5hbnNpW2tleV0gPSB3cmFwQW5zaTE2KHN1aXRlLmFuc2kxNiwgMCk7XG5cdFx0XHRzdHlsZXMuYmdDb2xvci5hbnNpW2tleV0gPSB3cmFwQW5zaTE2KHN1aXRlLmFuc2kxNiwgMTApO1xuXHRcdH1cblxuXHRcdGlmICgnYW5zaTI1NicgaW4gc3VpdGUpIHtcblx0XHRcdHN0eWxlcy5jb2xvci5hbnNpMjU2W2tleV0gPSB3cmFwQW5zaTI1NihzdWl0ZS5hbnNpMjU2LCAwKTtcblx0XHRcdHN0eWxlcy5iZ0NvbG9yLmFuc2kyNTZba2V5XSA9IHdyYXBBbnNpMjU2KHN1aXRlLmFuc2kyNTYsIDEwKTtcblx0XHR9XG5cblx0XHRpZiAoJ3JnYicgaW4gc3VpdGUpIHtcblx0XHRcdHN0eWxlcy5jb2xvci5hbnNpMTZtW2tleV0gPSB3cmFwQW5zaTE2bShzdWl0ZS5yZ2IsIDApO1xuXHRcdFx0c3R5bGVzLmJnQ29sb3IuYW5zaTE2bVtrZXldID0gd3JhcEFuc2kxNm0oc3VpdGUucmdiLCAxMCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuLy8gTWFrZSB0aGUgZXhwb3J0IGltbXV0YWJsZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGdldDogYXNzZW1ibGVTdHlsZXNcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjb25maWcuYXV0aC5wYXNzd29yZCkpIDogJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IodGltZW91dEVycm9yTWVzc2FnZSwgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdkYXRhJ107XG4gIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5JywgJ3BhcmFtcyddO1xuICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgJ2Jhc2VVUkwnLCAndHJhbnNmb3JtUmVxdWVzdCcsICd0cmFuc2Zvcm1SZXNwb25zZScsICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAndGltZW91dCcsICd0aW1lb3V0TWVzc2FnZScsICd3aXRoQ3JlZGVudGlhbHMnLCAnYWRhcHRlcicsICdyZXNwb25zZVR5cGUnLCAneHNyZkNvb2tpZU5hbWUnLFxuICAgICd4c3JmSGVhZGVyTmFtZScsICdvblVwbG9hZFByb2dyZXNzJywgJ29uRG93bmxvYWRQcm9ncmVzcycsICdkZWNvbXByZXNzJyxcbiAgICAnbWF4Q29udGVudExlbmd0aCcsICdtYXhCb2R5TGVuZ3RoJywgJ21heFJlZGlyZWN0cycsICd0cmFuc3BvcnQnLCAnaHR0cEFnZW50JyxcbiAgICAnaHR0cHNBZ2VudCcsICdjYW5jZWxUb2tlbicsICdzb2NrZXRQYXRoJywgJ3Jlc3BvbnNlRW5jb2RpbmcnXG4gIF07XG4gIHZhciBkaXJlY3RNZXJnZUtleXMgPSBbJ3ZhbGlkYXRlU3RhdHVzJ107XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB1dGlscy5mb3JFYWNoKHZhbHVlRnJvbUNvbmZpZzJLZXlzLCBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgdXRpbHMuZm9yRWFjaChkZWZhdWx0VG9Db25maWcyS2V5cywgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goZGlyZWN0TWVyZ2VLZXlzLCBmdW5jdGlvbiBtZXJnZShwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAuY29uY2F0KG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzKVxuICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpXG4gICAgLmNvbmNhdChkaXJlY3RNZXJnZUtleXMpO1xuXG4gIHZhciBvdGhlcktleXMgPSBPYmplY3RcbiAgICAua2V5cyhjb25maWcxKVxuICAgIC5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpXG4gICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zXG4gKlxuICogQHBhcmFtIHsqfSBwYXlsb2FkIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3MsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiAodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZXNjYXBlU3RyaW5nUmVnZXhwID0gcmVxdWlyZSgnZXNjYXBlLXN0cmluZy1yZWdleHAnKTtcbmNvbnN0IGFuc2lTdHlsZXMgPSByZXF1aXJlKCdhbnNpLXN0eWxlcycpO1xuY29uc3Qgc3Rkb3V0Q29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpLnN0ZG91dDtcblxuY29uc3QgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy5qcycpO1xuXG5jb25zdCBpc1NpbXBsZVdpbmRvd3NUZXJtID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAhKHByb2Nlc3MuZW52LlRFUk0gfHwgJycpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgneHRlcm0nKTtcblxuLy8gYHN1cHBvcnRzQ29sb3IubGV2ZWxgIOKGkiBgYW5zaVN0eWxlcy5jb2xvcltuYW1lXWAgbWFwcGluZ1xuY29uc3QgbGV2ZWxNYXBwaW5nID0gWydhbnNpJywgJ2Fuc2knLCAnYW5zaTI1NicsICdhbnNpMTZtJ107XG5cbi8vIGBjb2xvci1jb252ZXJ0YCBtb2RlbHMgdG8gZXhjbHVkZSBmcm9tIHRoZSBDaGFsayBBUEkgZHVlIHRvIGNvbmZsaWN0cyBhbmQgc3VjaFxuY29uc3Qgc2tpcE1vZGVscyA9IG5ldyBTZXQoWydncmF5J10pO1xuXG5jb25zdCBzdHlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBhcHBseU9wdGlvbnMob2JqLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdC8vIERldGVjdCBsZXZlbCBpZiBub3Qgc2V0IG1hbnVhbGx5XG5cdGNvbnN0IHNjTGV2ZWwgPSBzdGRvdXRDb2xvciA/IHN0ZG91dENvbG9yLmxldmVsIDogMDtcblx0b2JqLmxldmVsID0gb3B0aW9ucy5sZXZlbCA9PT0gdW5kZWZpbmVkID8gc2NMZXZlbCA6IG9wdGlvbnMubGV2ZWw7XG5cdG9iai5lbmFibGVkID0gJ2VuYWJsZWQnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuYWJsZWQgOiBvYmoubGV2ZWwgPiAwO1xufVxuXG5mdW5jdGlvbiBDaGFsayhvcHRpb25zKSB7XG5cdC8vIFdlIGNoZWNrIGZvciB0aGlzLnRlbXBsYXRlIGhlcmUgc2luY2UgY2FsbGluZyBgY2hhbGsuY29uc3RydWN0b3IoKWBcblx0Ly8gYnkgaXRzZWxmIHdpbGwgaGF2ZSBhIGB0aGlzYCBvZiBhIHByZXZpb3VzbHkgY29uc3RydWN0ZWQgY2hhbGsgb2JqZWN0XG5cdGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBDaGFsaykgfHwgdGhpcy50ZW1wbGF0ZSkge1xuXHRcdGNvbnN0IGNoYWxrID0ge307XG5cdFx0YXBwbHlPcHRpb25zKGNoYWxrLCBvcHRpb25zKTtcblxuXHRcdGNoYWxrLnRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBjaGFsa1RhZy5hcHBseShudWxsLCBbY2hhbGsudGVtcGxhdGVdLmNvbmNhdChhcmdzKSk7XG5cdFx0fTtcblxuXHRcdE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFsaywgQ2hhbGsucHJvdG90eXBlKTtcblx0XHRPYmplY3Quc2V0UHJvdG90eXBlT2YoY2hhbGsudGVtcGxhdGUsIGNoYWxrKTtcblxuXHRcdGNoYWxrLnRlbXBsYXRlLmNvbnN0cnVjdG9yID0gQ2hhbGs7XG5cblx0XHRyZXR1cm4gY2hhbGsudGVtcGxhdGU7XG5cdH1cblxuXHRhcHBseU9wdGlvbnModGhpcywgb3B0aW9ucyk7XG59XG5cbi8vIFVzZSBicmlnaHQgYmx1ZSBvbiBXaW5kb3dzIGFzIHRoZSBub3JtYWwgYmx1ZSBjb2xvciBpcyBpbGxlZ2libGVcbmlmIChpc1NpbXBsZVdpbmRvd3NUZXJtKSB7XG5cdGFuc2lTdHlsZXMuYmx1ZS5vcGVuID0gJ1xcdTAwMUJbOTRtJztcbn1cblxuZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYW5zaVN0eWxlcykpIHtcblx0YW5zaVN0eWxlc1trZXldLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzW2tleV0uY2xvc2UpLCAnZycpO1xuXG5cdHN0eWxlc1trZXldID0ge1xuXHRcdGdldCgpIHtcblx0XHRcdGNvbnN0IGNvZGVzID0gYW5zaVN0eWxlc1trZXldO1xuXHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzID8gdGhpcy5fc3R5bGVzLmNvbmNhdChjb2RlcykgOiBbY29kZXNdLCB0aGlzLl9lbXB0eSwga2V5KTtcblx0XHR9XG5cdH07XG59XG5cbnN0eWxlcy52aXNpYmxlID0ge1xuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzIHx8IFtdLCB0cnVlLCAndmlzaWJsZScpO1xuXHR9XG59O1xuXG5hbnNpU3R5bGVzLmNvbG9yLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzLmNvbG9yLmNsb3NlKSwgJ2cnKTtcbmZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LmtleXMoYW5zaVN0eWxlcy5jb2xvci5hbnNpKSkge1xuXHRpZiAoc2tpcE1vZGVscy5oYXMobW9kZWwpKSB7XG5cdFx0Y29udGludWU7XG5cdH1cblxuXHRzdHlsZXNbbW9kZWxdID0ge1xuXHRcdGdldCgpIHtcblx0XHRcdGNvbnN0IGxldmVsID0gdGhpcy5sZXZlbDtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbnN0IG9wZW4gPSBhbnNpU3R5bGVzLmNvbG9yW2xldmVsTWFwcGluZ1tsZXZlbF1dW21vZGVsXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRjb25zdCBjb2RlcyA9IHtcblx0XHRcdFx0XHRvcGVuLFxuXHRcdFx0XHRcdGNsb3NlOiBhbnNpU3R5bGVzLmNvbG9yLmNsb3NlLFxuXHRcdFx0XHRcdGNsb3NlUmU6IGFuc2lTdHlsZXMuY29sb3IuY2xvc2VSZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gYnVpbGQuY2FsbCh0aGlzLCB0aGlzLl9zdHlsZXMgPyB0aGlzLl9zdHlsZXMuY29uY2F0KGNvZGVzKSA6IFtjb2Rlc10sIHRoaXMuX2VtcHR5LCBtb2RlbCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcbn1cblxuYW5zaVN0eWxlcy5iZ0NvbG9yLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzLmJnQ29sb3IuY2xvc2UpLCAnZycpO1xuZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3Qua2V5cyhhbnNpU3R5bGVzLmJnQ29sb3IuYW5zaSkpIHtcblx0aWYgKHNraXBNb2RlbHMuaGFzKG1vZGVsKSkge1xuXHRcdGNvbnRpbnVlO1xuXHR9XG5cblx0Y29uc3QgYmdNb2RlbCA9ICdiZycgKyBtb2RlbFswXS50b1VwcGVyQ2FzZSgpICsgbW9kZWwuc2xpY2UoMSk7XG5cdHN0eWxlc1tiZ01vZGVsXSA9IHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCBsZXZlbCA9IHRoaXMubGV2ZWw7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjb25zdCBvcGVuID0gYW5zaVN0eWxlcy5iZ0NvbG9yW2xldmVsTWFwcGluZ1tsZXZlbF1dW21vZGVsXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRjb25zdCBjb2RlcyA9IHtcblx0XHRcdFx0XHRvcGVuLFxuXHRcdFx0XHRcdGNsb3NlOiBhbnNpU3R5bGVzLmJnQ29sb3IuY2xvc2UsXG5cdFx0XHRcdFx0Y2xvc2VSZTogYW5zaVN0eWxlcy5iZ0NvbG9yLmNsb3NlUmVcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzID8gdGhpcy5fc3R5bGVzLmNvbmNhdChjb2RlcykgOiBbY29kZXNdLCB0aGlzLl9lbXB0eSwgbW9kZWwpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH07XG59XG5cbmNvbnN0IHByb3RvID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoKCkgPT4ge30sIHN0eWxlcyk7XG5cbmZ1bmN0aW9uIGJ1aWxkKF9zdHlsZXMsIF9lbXB0eSwga2V5KSB7XG5cdGNvbnN0IGJ1aWxkZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGFwcGx5U3R5bGUuYXBwbHkoYnVpbGRlciwgYXJndW1lbnRzKTtcblx0fTtcblxuXHRidWlsZGVyLl9zdHlsZXMgPSBfc3R5bGVzO1xuXHRidWlsZGVyLl9lbXB0eSA9IF9lbXB0eTtcblxuXHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVpbGRlciwgJ2xldmVsJywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIHNlbGYubGV2ZWw7XG5cdFx0fSxcblx0XHRzZXQobGV2ZWwpIHtcblx0XHRcdHNlbGYubGV2ZWwgPSBsZXZlbDtcblx0XHR9XG5cdH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidWlsZGVyLCAnZW5hYmxlZCcsIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiBzZWxmLmVuYWJsZWQ7XG5cdFx0fSxcblx0XHRzZXQoZW5hYmxlZCkge1xuXHRcdFx0c2VsZi5lbmFibGVkID0gZW5hYmxlZDtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIFNlZSBiZWxvdyBmb3IgZml4IHJlZ2FyZGluZyBpbnZpc2libGUgZ3JleS9kaW0gY29tYmluYXRpb24gb24gV2luZG93c1xuXHRidWlsZGVyLmhhc0dyZXkgPSB0aGlzLmhhc0dyZXkgfHwga2V5ID09PSAnZ3JheScgfHwga2V5ID09PSAnZ3JleSc7XG5cblx0Ly8gYF9fcHJvdG9fX2AgaXMgdXNlZCBiZWNhdXNlIHdlIG11c3QgcmV0dXJuIGEgZnVuY3Rpb24sIGJ1dCB0aGVyZSBpc1xuXHQvLyBubyB3YXkgdG8gY3JlYXRlIGEgZnVuY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBwcm90b3R5cGVcblx0YnVpbGRlci5fX3Byb3RvX18gPSBwcm90bzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG5cdHJldHVybiBidWlsZGVyO1xufVxuXG5mdW5jdGlvbiBhcHBseVN0eWxlKCkge1xuXHQvLyBTdXBwb3J0IHZhcmFncywgYnV0IHNpbXBseSBjYXN0IHRvIHN0cmluZyBpbiBjYXNlIHRoZXJlJ3Mgb25seSBvbmUgYXJnXG5cdGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG5cdGNvbnN0IGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcblx0bGV0IHN0ciA9IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuXG5cdGlmIChhcmdzTGVuID09PSAwKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0aWYgKGFyZ3NMZW4gPiAxKSB7XG5cdFx0Ly8gRG9uJ3Qgc2xpY2UgYGFyZ3VtZW50c2AsIGl0IHByZXZlbnRzIFY4IG9wdGltaXphdGlvbnNcblx0XHRmb3IgKGxldCBhID0gMTsgYSA8IGFyZ3NMZW47IGErKykge1xuXHRcdFx0c3RyICs9ICcgJyArIGFyZ3NbYV07XG5cdFx0fVxuXHR9XG5cblx0aWYgKCF0aGlzLmVuYWJsZWQgfHwgdGhpcy5sZXZlbCA8PSAwIHx8ICFzdHIpIHtcblx0XHRyZXR1cm4gdGhpcy5fZW1wdHkgPyAnJyA6IHN0cjtcblx0fVxuXG5cdC8vIFR1cm5zIG91dCB0aGF0IG9uIFdpbmRvd3MgZGltbWVkIGdyYXkgdGV4dCBiZWNvbWVzIGludmlzaWJsZSBpbiBjbWQuZXhlLFxuXHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL2lzc3Vlcy81OFxuXHQvLyBJZiB3ZSdyZSBvbiBXaW5kb3dzIGFuZCB3ZSdyZSBkZWFsaW5nIHdpdGggYSBncmF5IGNvbG9yLCB0ZW1wb3JhcmlseSBtYWtlICdkaW0nIGEgbm9vcC5cblx0Y29uc3Qgb3JpZ2luYWxEaW0gPSBhbnNpU3R5bGVzLmRpbS5vcGVuO1xuXHRpZiAoaXNTaW1wbGVXaW5kb3dzVGVybSAmJiB0aGlzLmhhc0dyZXkpIHtcblx0XHRhbnNpU3R5bGVzLmRpbS5vcGVuID0gJyc7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGNvZGUgb2YgdGhpcy5fc3R5bGVzLnNsaWNlKCkucmV2ZXJzZSgpKSB7XG5cdFx0Ly8gUmVwbGFjZSBhbnkgaW5zdGFuY2VzIGFscmVhZHkgcHJlc2VudCB3aXRoIGEgcmUtb3BlbmluZyBjb2RlXG5cdFx0Ly8gb3RoZXJ3aXNlIG9ubHkgdGhlIHBhcnQgb2YgdGhlIHN0cmluZyB1bnRpbCBzYWlkIGNsb3NpbmcgY29kZVxuXHRcdC8vIHdpbGwgYmUgY29sb3JlZCwgYW5kIHRoZSByZXN0IHdpbGwgc2ltcGx5IGJlICdwbGFpbicuXG5cdFx0c3RyID0gY29kZS5vcGVuICsgc3RyLnJlcGxhY2UoY29kZS5jbG9zZVJlLCBjb2RlLm9wZW4pICsgY29kZS5jbG9zZTtcblxuXHRcdC8vIENsb3NlIHRoZSBzdHlsaW5nIGJlZm9yZSBhIGxpbmVicmVhayBhbmQgcmVvcGVuXG5cdFx0Ly8gYWZ0ZXIgbmV4dCBsaW5lIHRvIGZpeCBhIGJsZWVkIGlzc3VlIG9uIG1hY09TXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL3B1bGwvOTJcblx0XHRzdHIgPSBzdHIucmVwbGFjZSgvXFxyP1xcbi9nLCBgJHtjb2RlLmNsb3NlfSQmJHtjb2RlLm9wZW59YCk7XG5cdH1cblxuXHQvLyBSZXNldCB0aGUgb3JpZ2luYWwgYGRpbWAgaWYgd2UgY2hhbmdlZCBpdCB0byB3b3JrIGFyb3VuZCB0aGUgV2luZG93cyBkaW1tZWQgZ3JheSBpc3N1ZVxuXHRhbnNpU3R5bGVzLmRpbS5vcGVuID0gb3JpZ2luYWxEaW07XG5cblx0cmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gY2hhbGtUYWcoY2hhbGssIHN0cmluZ3MpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KHN0cmluZ3MpKSB7XG5cdFx0Ly8gSWYgY2hhbGsoKSB3YXMgY2FsbGVkIGJ5IGl0c2VsZiBvciB3aXRoIGEgc3RyaW5nLFxuXHRcdC8vIHJldHVybiB0aGUgc3RyaW5nIGl0c2VsZiBhcyBhIHN0cmluZy5cblx0XHRyZXR1cm4gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLmpvaW4oJyAnKTtcblx0fVxuXG5cdGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdGNvbnN0IHBhcnRzID0gW3N0cmluZ3MucmF3WzBdXTtcblxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRwYXJ0cy5wdXNoKFN0cmluZyhhcmdzW2kgLSAxXSkucmVwbGFjZSgvW3t9XFxcXF0vZywgJ1xcXFwkJicpKTtcblx0XHRwYXJ0cy5wdXNoKFN0cmluZyhzdHJpbmdzLnJhd1tpXSkpO1xuXHR9XG5cblx0cmV0dXJuIHRlbXBsYXRlKGNoYWxrLCBwYXJ0cy5qb2luKCcnKSk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYWxrLnByb3RvdHlwZSwgc3R5bGVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFsaygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbm1vZHVsZS5leHBvcnRzLnN1cHBvcnRzQ29sb3IgPSBzdGRvdXRDb2xvcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0czsgLy8gRm9yIFR5cGVTY3JpcHRcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzdGRvdXQ6IGZhbHNlLFxuXHRzdGRlcnI6IGZhbHNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgVEVNUExBVEVfUkVHRVggPSAvKD86XFxcXCh1W2EtZlxcZF17NH18eFthLWZcXGRdezJ9fC4pKXwoPzpcXHsofik/KFxcdysoPzpcXChbXildKlxcKSk/KD86XFwuXFx3Kyg/OlxcKFteKV0qXFwpKT8pKikoPzpbIFxcdF18KD89XFxyP1xcbikpKXwoXFx9KXwoKD86LnxbXFxyXFxuXFxmXSkrPykvZ2k7XG5jb25zdCBTVFlMRV9SRUdFWCA9IC8oPzpefFxcLikoXFx3KykoPzpcXCgoW14pXSopXFwpKT8vZztcbmNvbnN0IFNUUklOR19SRUdFWCA9IC9eKFsnXCJdKSgoPzpcXFxcLnwoPyFcXDEpW15cXFxcXSkqKVxcMSQvO1xuY29uc3QgRVNDQVBFX1JFR0VYID0gL1xcXFwodVthLWZcXGRdezR9fHhbYS1mXFxkXXsyfXwuKXwoW15cXFxcXSkvZ2k7XG5cbmNvbnN0IEVTQ0FQRVMgPSBuZXcgTWFwKFtcblx0WyduJywgJ1xcbiddLFxuXHRbJ3InLCAnXFxyJ10sXG5cdFsndCcsICdcXHQnXSxcblx0WydiJywgJ1xcYiddLFxuXHRbJ2YnLCAnXFxmJ10sXG5cdFsndicsICdcXHYnXSxcblx0WycwJywgJ1xcMCddLFxuXHRbJ1xcXFwnLCAnXFxcXCddLFxuXHRbJ2UnLCAnXFx1MDAxQiddLFxuXHRbJ2EnLCAnXFx1MDAwNyddXG5dKTtcblxuZnVuY3Rpb24gdW5lc2NhcGUoYykge1xuXHRpZiAoKGNbMF0gPT09ICd1JyAmJiBjLmxlbmd0aCA9PT0gNSkgfHwgKGNbMF0gPT09ICd4JyAmJiBjLmxlbmd0aCA9PT0gMykpIHtcblx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjLnNsaWNlKDEpLCAxNikpO1xuXHR9XG5cblx0cmV0dXJuIEVTQ0FQRVMuZ2V0KGMpIHx8IGM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKG5hbWUsIGFyZ3MpIHtcblx0Y29uc3QgcmVzdWx0cyA9IFtdO1xuXHRjb25zdCBjaHVua3MgPSBhcmdzLnRyaW0oKS5zcGxpdCgvXFxzKixcXHMqL2cpO1xuXHRsZXQgbWF0Y2hlcztcblxuXHRmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuXHRcdGlmICghaXNOYU4oY2h1bmspKSB7XG5cdFx0XHRyZXN1bHRzLnB1c2goTnVtYmVyKGNodW5rKSk7XG5cdFx0fSBlbHNlIGlmICgobWF0Y2hlcyA9IGNodW5rLm1hdGNoKFNUUklOR19SRUdFWCkpKSB7XG5cdFx0XHRyZXN1bHRzLnB1c2gobWF0Y2hlc1syXS5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgKG0sIGVzY2FwZSwgY2hyKSA9PiBlc2NhcGUgPyB1bmVzY2FwZShlc2NhcGUpIDogY2hyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBDaGFsayB0ZW1wbGF0ZSBzdHlsZSBhcmd1bWVudDogJHtjaHVua30gKGluIHN0eWxlICcke25hbWV9JylgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcGFyc2VTdHlsZShzdHlsZSkge1xuXHRTVFlMRV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuXG5cdGNvbnN0IHJlc3VsdHMgPSBbXTtcblx0bGV0IG1hdGNoZXM7XG5cblx0d2hpbGUgKChtYXRjaGVzID0gU1RZTEVfUkVHRVguZXhlYyhzdHlsZSkpICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgbmFtZSA9IG1hdGNoZXNbMV07XG5cblx0XHRpZiAobWF0Y2hlc1syXSkge1xuXHRcdFx0Y29uc3QgYXJncyA9IHBhcnNlQXJndW1lbnRzKG5hbWUsIG1hdGNoZXNbMl0pO1xuXHRcdFx0cmVzdWx0cy5wdXNoKFtuYW1lXS5jb25jYXQoYXJncykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHRzLnB1c2goW25hbWVdKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gYnVpbGRTdHlsZShjaGFsaywgc3R5bGVzKSB7XG5cdGNvbnN0IGVuYWJsZWQgPSB7fTtcblxuXHRmb3IgKGNvbnN0IGxheWVyIG9mIHN0eWxlcykge1xuXHRcdGZvciAoY29uc3Qgc3R5bGUgb2YgbGF5ZXIuc3R5bGVzKSB7XG5cdFx0XHRlbmFibGVkW3N0eWxlWzBdXSA9IGxheWVyLmludmVyc2UgPyBudWxsIDogc3R5bGUuc2xpY2UoMSk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGN1cnJlbnQgPSBjaGFsaztcblx0Zm9yIChjb25zdCBzdHlsZU5hbWUgb2YgT2JqZWN0LmtleXMoZW5hYmxlZCkpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShlbmFibGVkW3N0eWxlTmFtZV0pKSB7XG5cdFx0XHRpZiAoIShzdHlsZU5hbWUgaW4gY3VycmVudCkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIENoYWxrIHN0eWxlOiAke3N0eWxlTmFtZX1gKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGVuYWJsZWRbc3R5bGVOYW1lXS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50W3N0eWxlTmFtZV0uYXBwbHkoY3VycmVudCwgZW5hYmxlZFtzdHlsZU5hbWVdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50W3N0eWxlTmFtZV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGN1cnJlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGNoYWxrLCB0bXApID0+IHtcblx0Y29uc3Qgc3R5bGVzID0gW107XG5cdGNvbnN0IGNodW5rcyA9IFtdO1xuXHRsZXQgY2h1bmsgPSBbXTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuXHR0bXAucmVwbGFjZShURU1QTEFURV9SRUdFWCwgKG0sIGVzY2FwZUNoYXIsIGludmVyc2UsIHN0eWxlLCBjbG9zZSwgY2hyKSA9PiB7XG5cdFx0aWYgKGVzY2FwZUNoYXIpIHtcblx0XHRcdGNodW5rLnB1c2godW5lc2NhcGUoZXNjYXBlQ2hhcikpO1xuXHRcdH0gZWxzZSBpZiAoc3R5bGUpIHtcblx0XHRcdGNvbnN0IHN0ciA9IGNodW5rLmpvaW4oJycpO1xuXHRcdFx0Y2h1bmsgPSBbXTtcblx0XHRcdGNodW5rcy5wdXNoKHN0eWxlcy5sZW5ndGggPT09IDAgPyBzdHIgOiBidWlsZFN0eWxlKGNoYWxrLCBzdHlsZXMpKHN0cikpO1xuXHRcdFx0c3R5bGVzLnB1c2goe2ludmVyc2UsIHN0eWxlczogcGFyc2VTdHlsZShzdHlsZSl9KTtcblx0XHR9IGVsc2UgaWYgKGNsb3NlKSB7XG5cdFx0XHRpZiAoc3R5bGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGV4dHJhbmVvdXMgfSBpbiBDaGFsayB0ZW1wbGF0ZSBsaXRlcmFsJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNodW5rcy5wdXNoKGJ1aWxkU3R5bGUoY2hhbGssIHN0eWxlcykoY2h1bmsuam9pbignJykpKTtcblx0XHRcdGNodW5rID0gW107XG5cdFx0XHRzdHlsZXMucG9wKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNodW5rLnB1c2goY2hyKTtcblx0XHR9XG5cdH0pO1xuXG5cdGNodW5rcy5wdXNoKGNodW5rLmpvaW4oJycpKTtcblxuXHRpZiAoc3R5bGVzLmxlbmd0aCA+IDApIHtcblx0XHRjb25zdCBlcnJNc2cgPSBgQ2hhbGsgdGVtcGxhdGUgbGl0ZXJhbCBpcyBtaXNzaW5nICR7c3R5bGVzLmxlbmd0aH0gY2xvc2luZyBicmFja2V0JHtzdHlsZXMubGVuZ3RoID09PSAxID8gJycgOiAncyd9IChcXGB9XFxgKWA7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG5cdH1cblxuXHRyZXR1cm4gY2h1bmtzLmpvaW4oJycpO1xufTtcbiIsIi8qIE1JVCBsaWNlbnNlICovXG52YXIgY3NzS2V5d29yZHMgPSByZXF1aXJlKCdjb2xvci1uYW1lJyk7XG5cbi8vIE5PVEU6IGNvbnZlcnNpb25zIHNob3VsZCBvbmx5IHJldHVybiBwcmltaXRpdmUgdmFsdWVzIChpLmUuIGFycmF5cywgb3Jcbi8vICAgICAgIHZhbHVlcyB0aGF0IGdpdmUgY29ycmVjdCBgdHlwZW9mYCByZXN1bHRzKS5cbi8vICAgICAgIGRvIG5vdCB1c2UgYm94IHZhbHVlcyB0eXBlcyAoaS5lLiBOdW1iZXIoKSwgU3RyaW5nKCksIGV0Yy4pXG5cbnZhciByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAodmFyIGtleSBpbiBjc3NLZXl3b3Jkcykge1xuXHRpZiAoY3NzS2V5d29yZHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdHJldmVyc2VLZXl3b3Jkc1tjc3NLZXl3b3Jkc1trZXldXSA9IGtleTtcblx0fVxufVxuXG52YXIgY29udmVydCA9IG1vZHVsZS5leHBvcnRzID0ge1xuXHRyZ2I6IHtjaGFubmVsczogMywgbGFiZWxzOiAncmdiJ30sXG5cdGhzbDoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdoc2wnfSxcblx0aHN2OiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2hzdid9LFxuXHRod2I6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHdiJ30sXG5cdGNteWs6IHtjaGFubmVsczogNCwgbGFiZWxzOiAnY215ayd9LFxuXHR4eXo6IHtjaGFubmVsczogMywgbGFiZWxzOiAneHl6J30sXG5cdGxhYjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdsYWInfSxcblx0bGNoOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2xjaCd9LFxuXHRoZXg6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2hleCddfSxcblx0a2V5d29yZDoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsna2V5d29yZCddfSxcblx0YW5zaTE2OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydhbnNpMTYnXX0sXG5cdGFuc2kyNTY6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2Fuc2kyNTYnXX0sXG5cdGhjZzoge2NoYW5uZWxzOiAzLCBsYWJlbHM6IFsnaCcsICdjJywgJ2cnXX0sXG5cdGFwcGxlOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogWydyMTYnLCAnZzE2JywgJ2IxNiddfSxcblx0Z3JheToge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnZ3JheSddfVxufTtcblxuLy8gaGlkZSAuY2hhbm5lbHMgYW5kIC5sYWJlbHMgcHJvcGVydGllc1xuZm9yICh2YXIgbW9kZWwgaW4gY29udmVydCkge1xuXHRpZiAoY29udmVydC5oYXNPd25Qcm9wZXJ0eShtb2RlbCkpIHtcblx0XHRpZiAoISgnY2hhbm5lbHMnIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNoYW5uZWxzIHByb3BlcnR5OiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdGlmICghKCdsYWJlbHMnIGluIGNvbnZlcnRbbW9kZWxdKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNoYW5uZWwgbGFiZWxzIHByb3BlcnR5OiAnICsgbW9kZWwpO1xuXHRcdH1cblxuXHRcdGlmIChjb252ZXJ0W21vZGVsXS5sYWJlbHMubGVuZ3RoICE9PSBjb252ZXJ0W21vZGVsXS5jaGFubmVscykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdjaGFubmVsIGFuZCBsYWJlbCBjb3VudHMgbWlzbWF0Y2g6ICcgKyBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0dmFyIGNoYW5uZWxzID0gY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG5cdFx0dmFyIGxhYmVscyA9IGNvbnZlcnRbbW9kZWxdLmxhYmVscztcblx0XHRkZWxldGUgY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG5cdFx0ZGVsZXRlIGNvbnZlcnRbbW9kZWxdLmxhYmVscztcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFttb2RlbF0sICdjaGFubmVscycsIHt2YWx1ZTogY2hhbm5lbHN9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFttb2RlbF0sICdsYWJlbHMnLCB7dmFsdWU6IGxhYmVsc30pO1xuXHR9XG59XG5cbmNvbnZlcnQucmdiLmhzbCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG5cdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblx0dmFyIGg7XG5cdHZhciBzO1xuXHR2YXIgbDtcblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRoID0gMDtcblx0fSBlbHNlIGlmIChyID09PSBtYXgpIHtcblx0XHRoID0gKGcgLSBiKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuXHRcdGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuXHRcdGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXHR9XG5cblx0aCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGwgPSAobWluICsgbWF4KSAvIDI7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0cyA9IDA7XG5cdH0gZWxzZSBpZiAobCA8PSAwLjUpIHtcblx0XHRzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcblx0fSBlbHNlIHtcblx0XHRzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdH1cblxuXHRyZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IuaHN2ID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgcmRpZjtcblx0dmFyIGdkaWY7XG5cdHZhciBiZGlmO1xuXHR2YXIgaDtcblx0dmFyIHM7XG5cblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIHYgPSBNYXRoLm1heChyLCBnLCBiKTtcblx0dmFyIGRpZmYgPSB2IC0gTWF0aC5taW4ociwgZywgYik7XG5cdHZhciBkaWZmYyA9IGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICh2IC0gYykgLyA2IC8gZGlmZiArIDEgLyAyO1xuXHR9O1xuXG5cdGlmIChkaWZmID09PSAwKSB7XG5cdFx0aCA9IHMgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSBkaWZmIC8gdjtcblx0XHRyZGlmID0gZGlmZmMocik7XG5cdFx0Z2RpZiA9IGRpZmZjKGcpO1xuXHRcdGJkaWYgPSBkaWZmYyhiKTtcblxuXHRcdGlmIChyID09PSB2KSB7XG5cdFx0XHRoID0gYmRpZiAtIGdkaWY7XG5cdFx0fSBlbHNlIGlmIChnID09PSB2KSB7XG5cdFx0XHRoID0gKDEgLyAzKSArIHJkaWYgLSBiZGlmO1xuXHRcdH0gZWxzZSBpZiAoYiA9PT0gdikge1xuXHRcdFx0aCA9ICgyIC8gMykgKyBnZGlmIC0gcmRpZjtcblx0XHR9XG5cdFx0aWYgKGggPCAwKSB7XG5cdFx0XHRoICs9IDE7XG5cdFx0fSBlbHNlIGlmIChoID4gMSkge1xuXHRcdFx0aCAtPSAxO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBbXG5cdFx0aCAqIDM2MCxcblx0XHRzICogMTAwLFxuXHRcdHYgKiAxMDBcblx0XTtcbn07XG5cbmNvbnZlcnQucmdiLmh3YiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF07XG5cdHZhciBnID0gcmdiWzFdO1xuXHR2YXIgYiA9IHJnYlsyXTtcblx0dmFyIGggPSBjb252ZXJ0LnJnYi5oc2wocmdiKVswXTtcblx0dmFyIHcgPSAxIC8gMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpO1xuXG5cdGIgPSAxIC0gMSAvIDI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcblxuXHRyZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IuY215ayA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIGM7XG5cdHZhciBtO1xuXHR2YXIgeTtcblx0dmFyIGs7XG5cblx0ayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuXHRjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cdG0gPSAoMSAtIGcgLSBrKSAvICgxIC0gaykgfHwgMDtcblx0eSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXG5cdHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59O1xuXG4vKipcbiAqIFNlZSBodHRwczovL2VuLm0ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSNTcXVhcmVkX0V1Y2xpZGVhbl9kaXN0YW5jZVxuICogKi9cbmZ1bmN0aW9uIGNvbXBhcmF0aXZlRGlzdGFuY2UoeCwgeSkge1xuXHRyZXR1cm4gKFxuXHRcdE1hdGgucG93KHhbMF0gLSB5WzBdLCAyKSArXG5cdFx0TWF0aC5wb3coeFsxXSAtIHlbMV0sIDIpICtcblx0XHRNYXRoLnBvdyh4WzJdIC0geVsyXSwgMilcblx0KTtcbn1cblxuY29udmVydC5yZ2Iua2V5d29yZCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHJldmVyc2VkID0gcmV2ZXJzZUtleXdvcmRzW3JnYl07XG5cdGlmIChyZXZlcnNlZCkge1xuXHRcdHJldHVybiByZXZlcnNlZDtcblx0fVxuXG5cdHZhciBjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cdHZhciBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG5cblx0Zm9yICh2YXIga2V5d29yZCBpbiBjc3NLZXl3b3Jkcykge1xuXHRcdGlmIChjc3NLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShrZXl3b3JkKSkge1xuXHRcdFx0dmFyIHZhbHVlID0gY3NzS2V5d29yZHNba2V5d29yZF07XG5cblx0XHRcdC8vIENvbXB1dGUgY29tcGFyYXRpdmUgZGlzdGFuY2Vcblx0XHRcdHZhciBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7XG5cblx0XHRcdC8vIENoZWNrIGlmIGl0cyBsZXNzLCBpZiBzbyBzZXQgYXMgY2xvc2VzdFxuXHRcdFx0aWYgKGRpc3RhbmNlIDwgY3VycmVudENsb3Nlc3REaXN0YW5jZSkge1xuXHRcdFx0XHRjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0XHRcdGN1cnJlbnRDbG9zZXN0S2V5d29yZCA9IGtleXdvcmQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcbn07XG5cbmNvbnZlcnQua2V5d29yZC5yZ2IgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xuXHRyZXR1cm4gY3NzS2V5d29yZHNba2V5d29yZF07XG59O1xuXG5jb252ZXJ0LnJnYi54eXogPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdIC8gMjU1O1xuXHR2YXIgZyA9IHJnYlsxXSAvIDI1NTtcblx0dmFyIGIgPSByZ2JbMl0gLyAyNTU7XG5cblx0Ly8gYXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChyICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKHIgLyAxMi45Mik7XG5cdGcgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KCgoZyArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChnIC8gMTIuOTIpO1xuXHRiID0gYiA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoYiAvIDEyLjkyKTtcblxuXHR2YXIgeCA9IChyICogMC40MTI0KSArIChnICogMC4zNTc2KSArIChiICogMC4xODA1KTtcblx0dmFyIHkgPSAociAqIDAuMjEyNikgKyAoZyAqIDAuNzE1MikgKyAoYiAqIDAuMDcyMik7XG5cdHZhciB6ID0gKHIgKiAwLjAxOTMpICsgKGcgKiAwLjExOTIpICsgKGIgKiAwLjk1MDUpO1xuXG5cdHJldHVybiBbeCAqIDEwMCwgeSAqIDEwMCwgeiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5sYWIgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciB4eXogPSBjb252ZXJ0LnJnYi54eXoocmdiKTtcblx0dmFyIHggPSB4eXpbMF07XG5cdHZhciB5ID0geHl6WzFdO1xuXHR2YXIgeiA9IHh5elsyXTtcblx0dmFyIGw7XG5cdHZhciBhO1xuXHR2YXIgYjtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuXHR5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuXHR6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGwgPSAoMTE2ICogeSkgLSAxNjtcblx0YSA9IDUwMCAqICh4IC0geSk7XG5cdGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LmhzbC5yZ2IgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdHZhciBoID0gaHNsWzBdIC8gMzYwO1xuXHR2YXIgcyA9IGhzbFsxXSAvIDEwMDtcblx0dmFyIGwgPSBoc2xbMl0gLyAxMDA7XG5cdHZhciB0MTtcblx0dmFyIHQyO1xuXHR2YXIgdDM7XG5cdHZhciByZ2I7XG5cdHZhciB2YWw7XG5cblx0aWYgKHMgPT09IDApIHtcblx0XHR2YWwgPSBsICogMjU1O1xuXHRcdHJldHVybiBbdmFsLCB2YWwsIHZhbF07XG5cdH1cblxuXHRpZiAobCA8IDAuNSkge1xuXHRcdHQyID0gbCAqICgxICsgcyk7XG5cdH0gZWxzZSB7XG5cdFx0dDIgPSBsICsgcyAtIGwgKiBzO1xuXHR9XG5cblx0dDEgPSAyICogbCAtIHQyO1xuXG5cdHJnYiA9IFswLCAwLCAwXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHR0MyA9IGggKyAxIC8gMyAqIC0oaSAtIDEpO1xuXHRcdGlmICh0MyA8IDApIHtcblx0XHRcdHQzKys7XG5cdFx0fVxuXHRcdGlmICh0MyA+IDEpIHtcblx0XHRcdHQzLS07XG5cdFx0fVxuXG5cdFx0aWYgKDYgKiB0MyA8IDEpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuXHRcdH0gZWxzZSBpZiAoMiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDI7XG5cdFx0fSBlbHNlIGlmICgzICogdDMgPCAyKSB7XG5cdFx0XHR2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbCA9IHQxO1xuXHRcdH1cblxuXHRcdHJnYltpXSA9IHZhbCAqIDI1NTtcblx0fVxuXG5cdHJldHVybiByZ2I7XG59O1xuXG5jb252ZXJ0LmhzbC5oc3YgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdHZhciBoID0gaHNsWzBdO1xuXHR2YXIgcyA9IGhzbFsxXSAvIDEwMDtcblx0dmFyIGwgPSBoc2xbMl0gLyAxMDA7XG5cdHZhciBzbWluID0gcztcblx0dmFyIGxtaW4gPSBNYXRoLm1heChsLCAwLjAxKTtcblx0dmFyIHN2O1xuXHR2YXIgdjtcblxuXHRsICo9IDI7XG5cdHMgKj0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG5cdHNtaW4gKj0gbG1pbiA8PSAxID8gbG1pbiA6IDIgLSBsbWluO1xuXHR2ID0gKGwgKyBzKSAvIDI7XG5cdHN2ID0gbCA9PT0gMCA/ICgyICogc21pbikgLyAobG1pbiArIHNtaW4pIDogKDIgKiBzKSAvIChsICsgcyk7XG5cblx0cmV0dXJuIFtoLCBzdiAqIDEwMCwgdiAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmhzdi5yZ2IgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBoID0gaHN2WzBdIC8gNjA7XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblx0dmFyIGhpID0gTWF0aC5mbG9vcihoKSAlIDY7XG5cblx0dmFyIGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcblx0dmFyIHAgPSAyNTUgKiB2ICogKDEgLSBzKTtcblx0dmFyIHEgPSAyNTUgKiB2ICogKDEgLSAocyAqIGYpKTtcblx0dmFyIHQgPSAyNTUgKiB2ICogKDEgLSAocyAqICgxIC0gZikpKTtcblx0diAqPSAyNTU7XG5cblx0c3dpdGNoIChoaSkge1xuXHRcdGNhc2UgMDpcblx0XHRcdHJldHVybiBbdiwgdCwgcF07XG5cdFx0Y2FzZSAxOlxuXHRcdFx0cmV0dXJuIFtxLCB2LCBwXTtcblx0XHRjYXNlIDI6XG5cdFx0XHRyZXR1cm4gW3AsIHYsIHRdO1xuXHRcdGNhc2UgMzpcblx0XHRcdHJldHVybiBbcCwgcSwgdl07XG5cdFx0Y2FzZSA0OlxuXHRcdFx0cmV0dXJuIFt0LCBwLCB2XTtcblx0XHRjYXNlIDU6XG5cdFx0XHRyZXR1cm4gW3YsIHAsIHFdO1xuXHR9XG59O1xuXG5jb252ZXJ0Lmhzdi5oc2wgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBoID0gaHN2WzBdO1xuXHR2YXIgcyA9IGhzdlsxXSAvIDEwMDtcblx0dmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG5cdHZhciB2bWluID0gTWF0aC5tYXgodiwgMC4wMSk7XG5cdHZhciBsbWluO1xuXHR2YXIgc2w7XG5cdHZhciBsO1xuXG5cdGwgPSAoMiAtIHMpICogdjtcblx0bG1pbiA9ICgyIC0gcykgKiB2bWluO1xuXHRzbCA9IHMgKiB2bWluO1xuXHRzbCAvPSAobG1pbiA8PSAxKSA/IGxtaW4gOiAyIC0gbG1pbjtcblx0c2wgPSBzbCB8fCAwO1xuXHRsIC89IDI7XG5cblx0cmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG4vLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtY29sb3IvI2h3Yi10by1yZ2JcbmNvbnZlcnQuaHdiLnJnYiA9IGZ1bmN0aW9uIChod2IpIHtcblx0dmFyIGggPSBod2JbMF0gLyAzNjA7XG5cdHZhciB3aCA9IGh3YlsxXSAvIDEwMDtcblx0dmFyIGJsID0gaHdiWzJdIC8gMTAwO1xuXHR2YXIgcmF0aW8gPSB3aCArIGJsO1xuXHR2YXIgaTtcblx0dmFyIHY7XG5cdHZhciBmO1xuXHR2YXIgbjtcblxuXHQvLyB3aCArIGJsIGNhbnQgYmUgPiAxXG5cdGlmIChyYXRpbyA+IDEpIHtcblx0XHR3aCAvPSByYXRpbztcblx0XHRibCAvPSByYXRpbztcblx0fVxuXG5cdGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcblx0diA9IDEgLSBibDtcblx0ZiA9IDYgKiBoIC0gaTtcblxuXHRpZiAoKGkgJiAweDAxKSAhPT0gMCkge1xuXHRcdGYgPSAxIC0gZjtcblx0fVxuXG5cdG4gPSB3aCArIGYgKiAodiAtIHdoKTsgLy8gbGluZWFyIGludGVycG9sYXRpb25cblxuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXHRzd2l0Y2ggKGkpIHtcblx0XHRkZWZhdWx0OlxuXHRcdGNhc2UgNjpcblx0XHRjYXNlIDA6IHIgPSB2OyBnID0gbjsgYiA9IHdoOyBicmVhaztcblx0XHRjYXNlIDE6IHIgPSBuOyBnID0gdjsgYiA9IHdoOyBicmVhaztcblx0XHRjYXNlIDI6IHIgPSB3aDsgZyA9IHY7IGIgPSBuOyBicmVhaztcblx0XHRjYXNlIDM6IHIgPSB3aDsgZyA9IG47IGIgPSB2OyBicmVhaztcblx0XHRjYXNlIDQ6IHIgPSBuOyBnID0gd2g7IGIgPSB2OyBicmVhaztcblx0XHRjYXNlIDU6IHIgPSB2OyBnID0gd2g7IGIgPSBuOyBicmVhaztcblx0fVxuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0LmNteWsucmdiID0gZnVuY3Rpb24gKGNteWspIHtcblx0dmFyIGMgPSBjbXlrWzBdIC8gMTAwO1xuXHR2YXIgbSA9IGNteWtbMV0gLyAxMDA7XG5cdHZhciB5ID0gY215a1syXSAvIDEwMDtcblx0dmFyIGsgPSBjbXlrWzNdIC8gMTAwO1xuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXG5cdHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcblx0ZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuXHRiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQueHl6LnJnYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0dmFyIHggPSB4eXpbMF0gLyAxMDA7XG5cdHZhciB5ID0geHl6WzFdIC8gMTAwO1xuXHR2YXIgeiA9IHh5elsyXSAvIDEwMDtcblx0dmFyIHI7XG5cdHZhciBnO1xuXHR2YXIgYjtcblxuXHRyID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG5cdGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuXHRiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuXHQvLyBhc3N1bWUgc1JHQlxuXHRyID0gciA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KHIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiByICogMTIuOTI7XG5cblx0ZyA9IGcgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhnLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogZyAqIDEyLjkyO1xuXG5cdGIgPSBiID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IGIgKiAxMi45MjtcblxuXHRyID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuXHRnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuXHRiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0Lnh5ei5sYWIgPSBmdW5jdGlvbiAoeHl6KSB7XG5cdHZhciB4ID0geHl6WzBdO1xuXHR2YXIgeSA9IHh5elsxXTtcblx0dmFyIHogPSB4eXpbMl07XG5cdHZhciBsO1xuXHR2YXIgYTtcblx0dmFyIGI7XG5cblx0eCAvPSA5NS4wNDc7XG5cdHkgLz0gMTAwO1xuXHR6IC89IDEwOC44ODM7XG5cblx0eCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcblx0eSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcblx0eiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuXHRsID0gKDExNiAqIHkpIC0gMTY7XG5cdGEgPSA1MDAgKiAoeCAtIHkpO1xuXHRiID0gMjAwICogKHkgLSB6KTtcblxuXHRyZXR1cm4gW2wsIGEsIGJdO1xufTtcblxuY29udmVydC5sYWIueHl6ID0gZnVuY3Rpb24gKGxhYikge1xuXHR2YXIgbCA9IGxhYlswXTtcblx0dmFyIGEgPSBsYWJbMV07XG5cdHZhciBiID0gbGFiWzJdO1xuXHR2YXIgeDtcblx0dmFyIHk7XG5cdHZhciB6O1xuXG5cdHkgPSAobCArIDE2KSAvIDExNjtcblx0eCA9IGEgLyA1MDAgKyB5O1xuXHR6ID0geSAtIGIgLyAyMDA7XG5cblx0dmFyIHkyID0gTWF0aC5wb3coeSwgMyk7XG5cdHZhciB4MiA9IE1hdGgucG93KHgsIDMpO1xuXHR2YXIgejIgPSBNYXRoLnBvdyh6LCAzKTtcblx0eSA9IHkyID4gMC4wMDg4NTYgPyB5MiA6ICh5IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cdHggPSB4MiA+IDAuMDA4ODU2ID8geDIgOiAoeCAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXHR6ID0gejIgPiAwLjAwODg1NiA/IHoyIDogKHogLSAxNiAvIDExNikgLyA3Ljc4NztcblxuXHR4ICo9IDk1LjA0Nztcblx0eSAqPSAxMDA7XG5cdHogKj0gMTA4Ljg4MztcblxuXHRyZXR1cm4gW3gsIHksIHpdO1xufTtcblxuY29udmVydC5sYWIubGNoID0gZnVuY3Rpb24gKGxhYikge1xuXHR2YXIgbCA9IGxhYlswXTtcblx0dmFyIGEgPSBsYWJbMV07XG5cdHZhciBiID0gbGFiWzJdO1xuXHR2YXIgaHI7XG5cdHZhciBoO1xuXHR2YXIgYztcblxuXHRociA9IE1hdGguYXRhbjIoYiwgYSk7XG5cdGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuXG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0YyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblxuXHRyZXR1cm4gW2wsIGMsIGhdO1xufTtcblxuY29udmVydC5sY2gubGFiID0gZnVuY3Rpb24gKGxjaCkge1xuXHR2YXIgbCA9IGxjaFswXTtcblx0dmFyIGMgPSBsY2hbMV07XG5cdHZhciBoID0gbGNoWzJdO1xuXHR2YXIgYTtcblx0dmFyIGI7XG5cdHZhciBocjtcblxuXHRociA9IGggLyAzNjAgKiAyICogTWF0aC5QSTtcblx0YSA9IGMgKiBNYXRoLmNvcyhocik7XG5cdGIgPSBjICogTWF0aC5zaW4oaHIpO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgciA9IGFyZ3NbMF07XG5cdHZhciBnID0gYXJnc1sxXTtcblx0dmFyIGIgPSBhcmdzWzJdO1xuXHR2YXIgdmFsdWUgPSAxIGluIGFyZ3VtZW50cyA/IGFyZ3VtZW50c1sxXSA6IGNvbnZlcnQucmdiLmhzdihhcmdzKVsyXTsgLy8gaHN2IC0+IGFuc2kxNiBvcHRpbWl6YXRpb25cblxuXHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyA1MCk7XG5cblx0aWYgKHZhbHVlID09PSAwKSB7XG5cdFx0cmV0dXJuIDMwO1xuXHR9XG5cblx0dmFyIGFuc2kgPSAzMFxuXHRcdCsgKChNYXRoLnJvdW5kKGIgLyAyNTUpIDw8IDIpXG5cdFx0fCAoTWF0aC5yb3VuZChnIC8gMjU1KSA8PCAxKVxuXHRcdHwgTWF0aC5yb3VuZChyIC8gMjU1KSk7XG5cblx0aWYgKHZhbHVlID09PSAyKSB7XG5cdFx0YW5zaSArPSA2MDtcblx0fVxuXG5cdHJldHVybiBhbnNpO1xufTtcblxuY29udmVydC5oc3YuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Ly8gb3B0aW1pemF0aW9uIGhlcmU7IHdlIGFscmVhZHkga25vdyB0aGUgdmFsdWUgYW5kIGRvbid0IG5lZWQgdG8gZ2V0XG5cdC8vIGl0IGNvbnZlcnRlZCBmb3IgdXMuXG5cdHJldHVybiBjb252ZXJ0LnJnYi5hbnNpMTYoY29udmVydC5oc3YucmdiKGFyZ3MpLCBhcmdzWzJdKTtcbn07XG5cbmNvbnZlcnQucmdiLmFuc2kyNTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgciA9IGFyZ3NbMF07XG5cdHZhciBnID0gYXJnc1sxXTtcblx0dmFyIGIgPSBhcmdzWzJdO1xuXG5cdC8vIHdlIHVzZSB0aGUgZXh0ZW5kZWQgZ3JleXNjYWxlIHBhbGV0dGUgaGVyZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mXG5cdC8vIGJsYWNrIGFuZCB3aGl0ZS4gbm9ybWFsIHBhbGV0dGUgb25seSBoYXMgNCBncmV5c2NhbGUgc2hhZGVzLlxuXHRpZiAociA9PT0gZyAmJiBnID09PSBiKSB7XG5cdFx0aWYgKHIgPCA4KSB7XG5cdFx0XHRyZXR1cm4gMTY7XG5cdFx0fVxuXG5cdFx0aWYgKHIgPiAyNDgpIHtcblx0XHRcdHJldHVybiAyMzE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKChyIC0gOCkgLyAyNDcpICogMjQpICsgMjMyO1xuXHR9XG5cblx0dmFyIGFuc2kgPSAxNlxuXHRcdCsgKDM2ICogTWF0aC5yb3VuZChyIC8gMjU1ICogNSkpXG5cdFx0KyAoNiAqIE1hdGgucm91bmQoZyAvIDI1NSAqIDUpKVxuXHRcdCsgTWF0aC5yb3VuZChiIC8gMjU1ICogNSk7XG5cblx0cmV0dXJuIGFuc2k7XG59O1xuXG5jb252ZXJ0LmFuc2kxNi5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHR2YXIgY29sb3IgPSBhcmdzICUgMTA7XG5cblx0Ly8gaGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoY29sb3IgPT09IDAgfHwgY29sb3IgPT09IDcpIHtcblx0XHRpZiAoYXJncyA+IDUwKSB7XG5cdFx0XHRjb2xvciArPSAzLjU7XG5cdFx0fVxuXG5cdFx0Y29sb3IgPSBjb2xvciAvIDEwLjUgKiAyNTU7XG5cblx0XHRyZXR1cm4gW2NvbG9yLCBjb2xvciwgY29sb3JdO1xuXHR9XG5cblx0dmFyIG11bHQgPSAofn4oYXJncyA+IDUwKSArIDEpICogMC41O1xuXHR2YXIgciA9ICgoY29sb3IgJiAxKSAqIG11bHQpICogMjU1O1xuXHR2YXIgZyA9ICgoKGNvbG9yID4+IDEpICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0dmFyIGIgPSAoKChjb2xvciA+PiAyKSAmIDEpICogbXVsdCkgKiAyNTU7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQuYW5zaTI1Ni5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHQvLyBoYW5kbGUgZ3JleXNjYWxlXG5cdGlmIChhcmdzID49IDIzMikge1xuXHRcdHZhciBjID0gKGFyZ3MgLSAyMzIpICogMTAgKyA4O1xuXHRcdHJldHVybiBbYywgYywgY107XG5cdH1cblxuXHRhcmdzIC09IDE2O1xuXG5cdHZhciByZW07XG5cdHZhciByID0gTWF0aC5mbG9vcihhcmdzIC8gMzYpIC8gNSAqIDI1NTtcblx0dmFyIGcgPSBNYXRoLmZsb29yKChyZW0gPSBhcmdzICUgMzYpIC8gNikgLyA1ICogMjU1O1xuXHR2YXIgYiA9IChyZW0gJSA2KSAvIDUgKiAyNTU7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmhleCA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBpbnRlZ2VyID0gKChNYXRoLnJvdW5kKGFyZ3NbMF0pICYgMHhGRikgPDwgMTYpXG5cdFx0KyAoKE1hdGgucm91bmQoYXJnc1sxXSkgJiAweEZGKSA8PCA4KVxuXHRcdCsgKE1hdGgucm91bmQoYXJnc1syXSkgJiAweEZGKTtcblxuXHR2YXIgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn07XG5cbmNvbnZlcnQuaGV4LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBtYXRjaCA9IGFyZ3MudG9TdHJpbmcoMTYpLm1hdGNoKC9bYS1mMC05XXs2fXxbYS1mMC05XXszfS9pKTtcblx0aWYgKCFtYXRjaCkge1xuXHRcdHJldHVybiBbMCwgMCwgMF07XG5cdH1cblxuXHR2YXIgY29sb3JTdHJpbmcgPSBtYXRjaFswXTtcblxuXHRpZiAobWF0Y2hbMF0ubGVuZ3RoID09PSAzKSB7XG5cdFx0Y29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjaGFyKSB7XG5cdFx0XHRyZXR1cm4gY2hhciArIGNoYXI7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHR2YXIgaW50ZWdlciA9IHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG5cdHZhciByID0gKGludGVnZXIgPj4gMTYpICYgMHhGRjtcblx0dmFyIGcgPSAoaW50ZWdlciA+PiA4KSAmIDB4RkY7XG5cdHZhciBiID0gaW50ZWdlciAmIDB4RkY7XG5cblx0cmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmhjZyA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblx0dmFyIG1heCA9IE1hdGgubWF4KE1hdGgubWF4KHIsIGcpLCBiKTtcblx0dmFyIG1pbiA9IE1hdGgubWluKE1hdGgubWluKHIsIGcpLCBiKTtcblx0dmFyIGNocm9tYSA9IChtYXggLSBtaW4pO1xuXHR2YXIgZ3JheXNjYWxlO1xuXHR2YXIgaHVlO1xuXG5cdGlmIChjaHJvbWEgPCAxKSB7XG5cdFx0Z3JheXNjYWxlID0gbWluIC8gKDEgLSBjaHJvbWEpO1xuXHR9IGVsc2Uge1xuXHRcdGdyYXlzY2FsZSA9IDA7XG5cdH1cblxuXHRpZiAoY2hyb21hIDw9IDApIHtcblx0XHRodWUgPSAwO1xuXHR9IGVsc2Vcblx0aWYgKG1heCA9PT0gcikge1xuXHRcdGh1ZSA9ICgoZyAtIGIpIC8gY2hyb21hKSAlIDY7XG5cdH0gZWxzZVxuXHRpZiAobWF4ID09PSBnKSB7XG5cdFx0aHVlID0gMiArIChiIC0gcikgLyBjaHJvbWE7XG5cdH0gZWxzZSB7XG5cdFx0aHVlID0gNCArIChyIC0gZykgLyBjaHJvbWEgKyA0O1xuXHR9XG5cblx0aHVlIC89IDY7XG5cdGh1ZSAlPSAxO1xuXG5cdHJldHVybiBbaHVlICogMzYwLCBjaHJvbWEgKiAxMDAsIGdyYXlzY2FsZSAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhzbC5oY2cgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIGMgPSAxO1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKGwgPCAwLjUpIHtcblx0XHRjID0gMi4wICogcyAqIGw7XG5cdH0gZWxzZSB7XG5cdFx0YyA9IDIuMCAqIHMgKiAoMS4wIC0gbCk7XG5cdH1cblxuXHRpZiAoYyA8IDEuMCkge1xuXHRcdGYgPSAobCAtIDAuNSAqIGMpIC8gKDEuMCAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtoc2xbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xufTtcblxuY29udmVydC5oc3YuaGNnID0gZnVuY3Rpb24gKGhzdikge1xuXHR2YXIgcyA9IGhzdlsxXSAvIDEwMDtcblx0dmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG5cblx0dmFyIGMgPSBzICogdjtcblx0dmFyIGYgPSAwO1xuXG5cdGlmIChjIDwgMS4wKSB7XG5cdFx0ZiA9ICh2IC0gYykgLyAoMSAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtoc3ZbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cucmdiID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgaCA9IGhjZ1swXSAvIDM2MDtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG5cdGlmIChjID09PSAwLjApIHtcblx0XHRyZXR1cm4gW2cgKiAyNTUsIGcgKiAyNTUsIGcgKiAyNTVdO1xuXHR9XG5cblx0dmFyIHB1cmUgPSBbMCwgMCwgMF07XG5cdHZhciBoaSA9IChoICUgMSkgKiA2O1xuXHR2YXIgdiA9IGhpICUgMTtcblx0dmFyIHcgPSAxIC0gdjtcblx0dmFyIG1nID0gMDtcblxuXHRzd2l0Y2ggKE1hdGguZmxvb3IoaGkpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSB2OyBwdXJlWzJdID0gMDsgYnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0cHVyZVswXSA9IHc7IHB1cmVbMV0gPSAxOyBwdXJlWzJdID0gMDsgYnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0cHVyZVswXSA9IDA7IHB1cmVbMV0gPSAxOyBwdXJlWzJdID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0cHVyZVswXSA9IDA7IHB1cmVbMV0gPSB3OyBwdXJlWzJdID0gMTsgYnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0cHVyZVswXSA9IHY7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gMTsgYnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHB1cmVbMF0gPSAxOyBwdXJlWzFdID0gMDsgcHVyZVsyXSA9IHc7XG5cdH1cblxuXHRtZyA9ICgxLjAgLSBjKSAqIGc7XG5cblx0cmV0dXJuIFtcblx0XHQoYyAqIHB1cmVbMF0gKyBtZykgKiAyNTUsXG5cdFx0KGMgKiBwdXJlWzFdICsgbWcpICogMjU1LFxuXHRcdChjICogcHVyZVsyXSArIG1nKSAqIDI1NVxuXHRdO1xufTtcblxuY29udmVydC5oY2cuaHN2ID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0dmFyIHYgPSBjICsgZyAqICgxLjAgLSBjKTtcblx0dmFyIGYgPSAwO1xuXG5cdGlmICh2ID4gMC4wKSB7XG5cdFx0ZiA9IGMgLyB2O1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIGYgKiAxMDAsIHYgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cuaHNsID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0dmFyIGwgPSBnICogKDEuMCAtIGMpICsgMC41ICogYztcblx0dmFyIHMgPSAwO1xuXG5cdGlmIChsID4gMC4wICYmIGwgPCAwLjUpIHtcblx0XHRzID0gYyAvICgyICogbCk7XG5cdH0gZWxzZVxuXHRpZiAobCA+PSAwLjUgJiYgbCA8IDEuMCkge1xuXHRcdHMgPSBjIC8gKDIgKiAoMSAtIGwpKTtcblx0fVxuXG5cdHJldHVybiBbaGNnWzBdLCBzICogMTAwLCBsICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLmh3YiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0dmFyIGMgPSBoY2dbMV0gLyAxMDA7XG5cdHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXHR2YXIgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuXHRyZXR1cm4gW2hjZ1swXSwgKHYgLSBjKSAqIDEwMCwgKDEgLSB2KSAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmh3Yi5oY2cgPSBmdW5jdGlvbiAoaHdiKSB7XG5cdHZhciB3ID0gaHdiWzFdIC8gMTAwO1xuXHR2YXIgYiA9IGh3YlsyXSAvIDEwMDtcblx0dmFyIHYgPSAxIC0gYjtcblx0dmFyIGMgPSB2IC0gdztcblx0dmFyIGcgPSAwO1xuXG5cdGlmIChjIDwgMSkge1xuXHRcdGcgPSAodiAtIGMpIC8gKDEgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHdiWzBdLCBjICogMTAwLCBnICogMTAwXTtcbn07XG5cbmNvbnZlcnQuYXBwbGUucmdiID0gZnVuY3Rpb24gKGFwcGxlKSB7XG5cdHJldHVybiBbKGFwcGxlWzBdIC8gNjU1MzUpICogMjU1LCAoYXBwbGVbMV0gLyA2NTUzNSkgKiAyNTUsIChhcHBsZVsyXSAvIDY1NTM1KSAqIDI1NV07XG59O1xuXG5jb252ZXJ0LnJnYi5hcHBsZSA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0cmV0dXJuIFsocmdiWzBdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzFdIC8gMjU1KSAqIDY1NTM1LCAocmdiWzJdIC8gMjU1KSAqIDY1NTM1XTtcbn07XG5cbmNvbnZlcnQuZ3JheS5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHRyZXR1cm4gW2FyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTVdO1xufTtcblxuY29udmVydC5ncmF5LmhzbCA9IGNvbnZlcnQuZ3JheS5oc3YgPSBmdW5jdGlvbiAoYXJncykge1xuXHRyZXR1cm4gWzAsIDAsIGFyZ3NbMF1dO1xufTtcblxuY29udmVydC5ncmF5Lmh3YiA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbMCwgMTAwLCBncmF5WzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5jbXlrID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFswLCAwLCAwLCBncmF5WzBdXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5sYWIgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gW2dyYXlbMF0sIDAsIDBdO1xufTtcblxuY29udmVydC5ncmF5LmhleCA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHZhciB2YWwgPSBNYXRoLnJvdW5kKGdyYXlbMF0gLyAxMDAgKiAyNTUpICYgMHhGRjtcblx0dmFyIGludGVnZXIgPSAodmFsIDw8IDE2KSArICh2YWwgPDwgOCkgKyB2YWw7XG5cblx0dmFyIHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59O1xuXG5jb252ZXJ0LnJnYi5ncmF5ID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgdmFsID0gKHJnYlswXSArIHJnYlsxXSArIHJnYlsyXSkgLyAzO1xuXHRyZXR1cm4gW3ZhbCAvIDI1NSAqIDEwMF07XG59O1xuIiwidmFyIGNvbnZlcnNpb25zID0gcmVxdWlyZSgnLi9jb252ZXJzaW9ucycpO1xudmFyIHJvdXRlID0gcmVxdWlyZSgnLi9yb3V0ZScpO1xuXG52YXIgY29udmVydCA9IHt9O1xuXG52YXIgbW9kZWxzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMpO1xuXG5mdW5jdGlvbiB3cmFwUmF3KGZuKSB7XG5cdHZhciB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoYXJncykge1xuXHRcdGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm4oYXJncyk7XG5cdH07XG5cblx0Ly8gcHJlc2VydmUgLmNvbnZlcnNpb24gcHJvcGVydHkgaWYgdGhlcmUgaXMgb25lXG5cdGlmICgnY29udmVyc2lvbicgaW4gZm4pIHtcblx0XHR3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG5cdH1cblxuXHRyZXR1cm4gd3JhcHBlZEZuO1xufVxuXG5mdW5jdGlvbiB3cmFwUm91bmRlZChmbikge1xuXHR2YXIgd3JhcHBlZEZuID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmdzO1xuXHRcdH1cblxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlc3VsdCA9IGZuKGFyZ3MpO1xuXG5cdFx0Ly8gd2UncmUgYXNzdW1pbmcgdGhlIHJlc3VsdCBpcyBhbiBhcnJheSBoZXJlLlxuXHRcdC8vIHNlZSBub3RpY2UgaW4gY29udmVyc2lvbnMuanM7IGRvbid0IHVzZSBib3ggdHlwZXNcblx0XHQvLyBpbiBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cblx0XHRpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAodmFyIGxlbiA9IHJlc3VsdC5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gcHJlc2VydmUgLmNvbnZlcnNpb24gcHJvcGVydHkgaWYgdGhlcmUgaXMgb25lXG5cdGlmICgnY29udmVyc2lvbicgaW4gZm4pIHtcblx0XHR3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG5cdH1cblxuXHRyZXR1cm4gd3JhcHBlZEZuO1xufVxuXG5tb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG5cdGNvbnZlcnRbZnJvbU1vZGVsXSA9IHt9O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W2Zyb21Nb2RlbF0sICdjaGFubmVscycsIHt2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5jaGFubmVsc30pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnbGFiZWxzJywge3ZhbHVlOiBjb252ZXJzaW9uc1tmcm9tTW9kZWxdLmxhYmVsc30pO1xuXG5cdHZhciByb3V0ZXMgPSByb3V0ZShmcm9tTW9kZWwpO1xuXHR2YXIgcm91dGVNb2RlbHMgPSBPYmplY3Qua2V5cyhyb3V0ZXMpO1xuXG5cdHJvdXRlTW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKHRvTW9kZWwpIHtcblx0XHR2YXIgZm4gPSByb3V0ZXNbdG9Nb2RlbF07XG5cblx0XHRjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0gPSB3cmFwUm91bmRlZChmbik7XG5cdFx0Y29udmVydFtmcm9tTW9kZWxdW3RvTW9kZWxdLnJhdyA9IHdyYXBSYXcoZm4pO1xuXHR9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnQ7XG4iLCJ2YXIgY29udmVyc2lvbnMgPSByZXF1aXJlKCcuL2NvbnZlcnNpb25zJyk7XG5cbi8qXG5cdHRoaXMgZnVuY3Rpb24gcm91dGVzIGEgbW9kZWwgdG8gYWxsIG90aGVyIG1vZGVscy5cblxuXHRhbGwgZnVuY3Rpb25zIHRoYXQgYXJlIHJvdXRlZCBoYXZlIGEgcHJvcGVydHkgYC5jb252ZXJzaW9uYCBhdHRhY2hlZFxuXHR0byB0aGUgcmV0dXJuZWQgc3ludGhldGljIGZ1bmN0aW9uLiBUaGlzIHByb3BlcnR5IGlzIGFuIGFycmF5XG5cdG9mIHN0cmluZ3MsIGVhY2ggd2l0aCB0aGUgc3RlcHMgaW4gYmV0d2VlbiB0aGUgJ2Zyb20nIGFuZCAndG8nXG5cdGNvbG9yIG1vZGVscyAoaW5jbHVzaXZlKS5cblxuXHRjb252ZXJzaW9ucyB0aGF0IGFyZSBub3QgcG9zc2libGUgc2ltcGx5IGFyZSBub3QgaW5jbHVkZWQuXG4qL1xuXG5mdW5jdGlvbiBidWlsZEdyYXBoKCkge1xuXHR2YXIgZ3JhcGggPSB7fTtcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL29iamVjdC1rZXlzLXZzLWZvci1pbi13aXRoLWNsb3N1cmUvM1xuXHR2YXIgbW9kZWxzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMpO1xuXG5cdGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRncmFwaFttb2RlbHNbaV1dID0ge1xuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vMS12cy1pbmZpbml0eVxuXHRcdFx0Ly8gbWljcm8tb3B0LCBidXQgdGhpcyBpcyBzaW1wbGUuXG5cdFx0XHRkaXN0YW5jZTogLTEsXG5cdFx0XHRwYXJlbnQ6IG51bGxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGdyYXBoO1xufVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVhZHRoLWZpcnN0X3NlYXJjaFxuZnVuY3Rpb24gZGVyaXZlQkZTKGZyb21Nb2RlbCkge1xuXHR2YXIgZ3JhcGggPSBidWlsZEdyYXBoKCk7XG5cdHZhciBxdWV1ZSA9IFtmcm9tTW9kZWxdOyAvLyB1bnNoaWZ0IC0+IHF1ZXVlIC0+IHBvcFxuXG5cdGdyYXBoW2Zyb21Nb2RlbF0uZGlzdGFuY2UgPSAwO1xuXG5cdHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcblx0XHR2YXIgY3VycmVudCA9IHF1ZXVlLnBvcCgpO1xuXHRcdHZhciBhZGphY2VudHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9uc1tjdXJyZW50XSk7XG5cblx0XHRmb3IgKHZhciBsZW4gPSBhZGphY2VudHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgYWRqYWNlbnQgPSBhZGphY2VudHNbaV07XG5cdFx0XHR2YXIgbm9kZSA9IGdyYXBoW2FkamFjZW50XTtcblxuXHRcdFx0aWYgKG5vZGUuZGlzdGFuY2UgPT09IC0xKSB7XG5cdFx0XHRcdG5vZGUuZGlzdGFuY2UgPSBncmFwaFtjdXJyZW50XS5kaXN0YW5jZSArIDE7XG5cdFx0XHRcdG5vZGUucGFyZW50ID0gY3VycmVudDtcblx0XHRcdFx0cXVldWUudW5zaGlmdChhZGphY2VudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGdyYXBoO1xufVxuXG5mdW5jdGlvbiBsaW5rKGZyb20sIHRvKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuXHRcdHJldHVybiB0byhmcm9tKGFyZ3MpKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpIHtcblx0dmFyIHBhdGggPSBbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50LCB0b01vZGVsXTtcblx0dmFyIGZuID0gY29udmVyc2lvbnNbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcblxuXHR2YXIgY3VyID0gZ3JhcGhbdG9Nb2RlbF0ucGFyZW50O1xuXHR3aGlsZSAoZ3JhcGhbY3VyXS5wYXJlbnQpIHtcblx0XHRwYXRoLnVuc2hpZnQoZ3JhcGhbY3VyXS5wYXJlbnQpO1xuXHRcdGZuID0gbGluayhjb252ZXJzaW9uc1tncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuXHRcdGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuXHR9XG5cblx0Zm4uY29udmVyc2lvbiA9IHBhdGg7XG5cdHJldHVybiBmbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG5cdHZhciBncmFwaCA9IGRlcml2ZUJGUyhmcm9tTW9kZWwpO1xuXHR2YXIgY29udmVyc2lvbiA9IHt9O1xuXG5cdHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhncmFwaCk7XG5cdGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHR2YXIgdG9Nb2RlbCA9IG1vZGVsc1tpXTtcblx0XHR2YXIgbm9kZSA9IGdyYXBoW3RvTW9kZWxdO1xuXG5cdFx0aWYgKG5vZGUucGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHQvLyBubyBwb3NzaWJsZSBjb252ZXJzaW9uLCBvciB0aGlzIG5vZGUgaXMgdGhlIHNvdXJjZSBtb2RlbC5cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnZlcnNpb25bdG9Nb2RlbF0gPSB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCk7XG5cdH1cblxuXHRyZXR1cm4gY29udmVyc2lvbjtcbn07XG5cbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xyXG4iLCJ2YXIgX19zZWxmX18gPSAoZnVuY3Rpb24gKHJvb3QpIHtcbmZ1bmN0aW9uIEYoKSB7XG50aGlzLmZldGNoID0gZmFsc2U7XG50aGlzLkRPTUV4Y2VwdGlvbiA9IHJvb3QuRE9NRXhjZXB0aW9uXG59XG5GLnByb3RvdHlwZSA9IHJvb3Q7XG5yZXR1cm4gbmV3IEYoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcbihmdW5jdGlvbihzZWxmKSB7XG5cbnZhciBpcnJlbGV2YW50ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KHt9KSk7XG59KShfX3NlbGZfXyk7XG5kZWxldGUgX19zZWxmX18uZmV0Y2gucG9seWZpbGxcbmV4cG9ydHMgPSBfX3NlbGZfXy5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCBmZXRjaCBmcm9tICdjcm9zcy1mZXRjaCdcbmV4cG9ydHMuZGVmYXVsdCA9IF9fc2VsZl9fLmZldGNoIC8vIEZvciBUeXBlU2NyaXB0IGNvbnN1bWVycyB3aXRob3V0IGVzTW9kdWxlSW50ZXJvcC5cbmV4cG9ydHMuZmV0Y2ggPSBfX3NlbGZfXy5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCB7ZmV0Y2h9IGZyb20gJ2Nyb3NzLWZldGNoJ1xuZXhwb3J0cy5IZWFkZXJzID0gX19zZWxmX18uSGVhZGVyc1xuZXhwb3J0cy5SZXF1ZXN0ID0gX19zZWxmX18uUmVxdWVzdFxuZXhwb3J0cy5SZXNwb25zZSA9IF9fc2VsZl9fLlJlc3BvbnNlXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4gZW5hYmxlT3ZlcnJpZGUgPT09IG51bGwgPyBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSkgOiBlbmFibGVPdmVycmlkZSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiIWZ1bmN0aW9uKHQsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24odCxuLGUsaSxvKXtmb3Iobj1uLnNwbGl0P24uc3BsaXQoXCIuXCIpOm4saT0wO2k8bi5sZW5ndGg7aSsrKXQ9dD90W25baV1dOm87cmV0dXJuIHQ9PT1vP2U6dH06XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LG4sZSxpLG8pe2ZvcihuPW4uc3BsaXQ/bi5zcGxpdChcIi5cIik6bixpPTA7aTxuLmxlbmd0aDtpKyspdD10P3RbbltpXV06bztyZXR1cm4gdD09PW8/ZTp0fX0pOnQuZGx2PWZ1bmN0aW9uKHQsbixlLGksbyl7Zm9yKG49bi5zcGxpdD9uLnNwbGl0KFwiLlwiKTpuLGk9MDtpPG4ubGVuZ3RoO2krKyl0PXQ/dFtuW2ldXTpvO3JldHVybiB0PT09bz9lOnR9fSh0aGlzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRsdi51bWQuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdHJldHVybiBzdHIucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlLCAnXFxcXCQmJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFJlYWN0TmF0aXZlRmlsZShfcmVmKSB7XG4gIHZhciB1cmkgPSBfcmVmLnVyaSxcbiAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgIHR5cGUgPSBfcmVmLnR5cGU7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRJc0V4dHJhY3RhYmxlRmlsZSA9IHJlcXVpcmUoJy4vaXNFeHRyYWN0YWJsZUZpbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRyYWN0RmlsZXModmFsdWUsIHBhdGgsIGlzRXh0cmFjdGFibGVGaWxlKSB7XG4gIGlmIChwYXRoID09PSB2b2lkIDApIHtcbiAgICBwYXRoID0gJyc7XG4gIH1cblxuICBpZiAoaXNFeHRyYWN0YWJsZUZpbGUgPT09IHZvaWQgMCkge1xuICAgIGlzRXh0cmFjdGFibGVGaWxlID0gZGVmYXVsdElzRXh0cmFjdGFibGVGaWxlO1xuICB9XG5cbiAgdmFyIGNsb25lO1xuICB2YXIgZmlsZXMgPSBuZXcgTWFwKCk7XG5cbiAgZnVuY3Rpb24gYWRkRmlsZShwYXRocywgZmlsZSkge1xuICAgIHZhciBzdG9yZWRQYXRocyA9IGZpbGVzLmdldChmaWxlKTtcbiAgICBpZiAoc3RvcmVkUGF0aHMpIHN0b3JlZFBhdGhzLnB1c2guYXBwbHkoc3RvcmVkUGF0aHMsIHBhdGhzKTtcbiAgICBlbHNlIGZpbGVzLnNldChmaWxlLCBwYXRocyk7XG4gIH1cblxuICBpZiAoaXNFeHRyYWN0YWJsZUZpbGUodmFsdWUpKSB7XG4gICAgY2xvbmUgPSBudWxsO1xuICAgIGFkZEZpbGUoW3BhdGhdLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHByZWZpeCA9IHBhdGggPyBwYXRoICsgJy4nIDogJyc7XG4gICAgaWYgKHR5cGVvZiBGaWxlTGlzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBGaWxlTGlzdClcbiAgICAgIGNsb25lID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHZhbHVlLCBmdW5jdGlvbiAoZmlsZSwgaSkge1xuICAgICAgICBhZGRGaWxlKFsnJyArIHByZWZpeCArIGldLCBmaWxlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgIGNsb25lID0gdmFsdWUubWFwKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZXh0cmFjdEZpbGVzKGNoaWxkLCAnJyArIHByZWZpeCArIGksIGlzRXh0cmFjdGFibGVGaWxlKTtcbiAgICAgICAgcmVzdWx0LmZpbGVzLmZvckVhY2goYWRkRmlsZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY2xvbmU7XG4gICAgICB9KTtcbiAgICBlbHNlIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICBjbG9uZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpIGluIHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBleHRyYWN0RmlsZXModmFsdWVbaV0sICcnICsgcHJlZml4ICsgaSwgaXNFeHRyYWN0YWJsZUZpbGUpO1xuICAgICAgICByZXN1bHQuZmlsZXMuZm9yRWFjaChhZGRGaWxlKTtcbiAgICAgICAgY2xvbmVbaV0gPSByZXN1bHQuY2xvbmU7XG4gICAgICB9XG4gICAgfSBlbHNlIGNsb25lID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNsb25lOiBjbG9uZSxcbiAgICBmaWxlczogZmlsZXMsXG4gIH07XG59O1xuIiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWFjdE5hdGl2ZUZpbGUgfSBmcm9tICcuL1JlYWN0TmF0aXZlRmlsZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGV4dHJhY3RGaWxlcyB9IGZyb20gJy4vZXh0cmFjdEZpbGVzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaXNFeHRyYWN0YWJsZUZpbGUgfSBmcm9tICcuL2lzRXh0cmFjdGFibGVGaWxlLmpzJztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TmF0aXZlRmlsZSA9IHJlcXVpcmUoJy4vUmVhY3ROYXRpdmVGaWxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeHRyYWN0YWJsZUZpbGUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgRmlsZSkgfHxcbiAgICAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICB2YWx1ZSBpbnN0YW5jZW9mIFJlYWN0TmF0aXZlRmlsZVxuICApO1xufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyA/IHNlbGYuRm9ybURhdGEgOiB3aW5kb3cuRm9ybURhdGE7XG4iLCJpbXBvcnQgaW52YXJpYW50IGZyb20gXCIuL2ludmFyaWFudC5tanNcIjtcbmltcG9ydCBub2RlanNDdXN0b21JbnNwZWN0U3ltYm9sIGZyb20gXCIuL25vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2wubWpzXCI7XG4vKipcbiAqIFRoZSBgZGVmaW5lSW5zcGVjdCgpYCBmdW5jdGlvbiBkZWZpbmVzIGBpbnNwZWN0KClgIHByb3RvdHlwZSBtZXRob2QgYXMgYWxpYXMgb2YgYHRvSlNPTmBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZpbmVJbnNwZWN0KGNsYXNzT2JqZWN0KSB7XG4gIHZhciBmbiA9IGNsYXNzT2JqZWN0LnByb3RvdHlwZS50b0pTT047XG4gIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyB8fCBpbnZhcmlhbnQoMCk7XG4gIGNsYXNzT2JqZWN0LnByb3RvdHlwZS5pbnNwZWN0ID0gZm47IC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlIChTZWU6ICdodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLWpzL2lzc3Vlcy8yMzE3JylcblxuICBpZiAobm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICAgIGNsYXNzT2JqZWN0LnByb3RvdHlwZVtub2RlanNDdXN0b21JbnNwZWN0U3ltYm9sXSA9IGZuO1xuICB9XG59XG4iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIGZsb3d0eXBlL25vLXdlYWstdHlwZXMgKi9cbmltcG9ydCBub2RlanNDdXN0b21JbnNwZWN0U3ltYm9sIGZyb20gXCIuL25vZGVqc0N1c3RvbUluc3BlY3RTeW1ib2wubWpzXCI7XG52YXIgTUFYX0FSUkFZX0xFTkdUSCA9IDEwO1xudmFyIE1BWF9SRUNVUlNJVkVfREVQVEggPSAyO1xuLyoqXG4gKiBVc2VkIHRvIHByaW50IHZhbHVlcyBpbiBlcnJvciBtZXNzYWdlcy5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnNwZWN0KHZhbHVlKSB7XG4gIHJldHVybiBmb3JtYXRWYWx1ZSh2YWx1ZSwgW10pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgc2VlblZhbHVlcykge1xuICBzd2l0Y2ggKF90eXBlb2YodmFsdWUpKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gdmFsdWUubmFtZSA/IFwiW2Z1bmN0aW9uIFwiLmNvbmNhdCh2YWx1ZS5uYW1lLCBcIl1cIikgOiAnW2Z1bmN0aW9uXSc7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3JtYXRPYmplY3RWYWx1ZSh2YWx1ZSwgc2VlblZhbHVlcyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0T2JqZWN0VmFsdWUodmFsdWUsIHByZXZpb3VzbHlTZWVuVmFsdWVzKSB7XG4gIGlmIChwcmV2aW91c2x5U2VlblZhbHVlcy5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICB9XG5cbiAgdmFyIHNlZW5WYWx1ZXMgPSBbXS5jb25jYXQocHJldmlvdXNseVNlZW5WYWx1ZXMsIFt2YWx1ZV0pO1xuICB2YXIgY3VzdG9tSW5zcGVjdEZuID0gZ2V0Q3VzdG9tRm4odmFsdWUpO1xuXG4gIGlmIChjdXN0b21JbnNwZWN0Rm4gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjdXN0b21WYWx1ZSA9IGN1c3RvbUluc3BlY3RGbi5jYWxsKHZhbHVlKTsgLy8gY2hlY2sgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuXG4gICAgaWYgKGN1c3RvbVZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBjdXN0b21WYWx1ZSA9PT0gJ3N0cmluZycgPyBjdXN0b21WYWx1ZSA6IGZvcm1hdFZhbHVlKGN1c3RvbVZhbHVlLCBzZWVuVmFsdWVzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0QXJyYXkodmFsdWUsIHNlZW5WYWx1ZXMpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdE9iamVjdCh2YWx1ZSwgc2VlblZhbHVlcyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdChvYmplY3QsIHNlZW5WYWx1ZXMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAne30nO1xuICB9XG5cbiAgaWYgKHNlZW5WYWx1ZXMubGVuZ3RoID4gTUFYX1JFQ1VSU0lWRV9ERVBUSCkge1xuICAgIHJldHVybiAnWycgKyBnZXRPYmplY3RUYWcob2JqZWN0KSArICddJztcbiAgfVxuXG4gIHZhciBwcm9wZXJ0aWVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWx1ZSA9IGZvcm1hdFZhbHVlKG9iamVjdFtrZXldLCBzZWVuVmFsdWVzKTtcbiAgICByZXR1cm4ga2V5ICsgJzogJyArIHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuICd7ICcgKyBwcm9wZXJ0aWVzLmpvaW4oJywgJykgKyAnIH0nO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShhcnJheSwgc2VlblZhbHVlcykge1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdbXSc7XG4gIH1cblxuICBpZiAoc2VlblZhbHVlcy5sZW5ndGggPiBNQVhfUkVDVVJTSVZFX0RFUFRIKSB7XG4gICAgcmV0dXJuICdbQXJyYXldJztcbiAgfVxuXG4gIHZhciBsZW4gPSBNYXRoLm1pbihNQVhfQVJSQVlfTEVOR1RILCBhcnJheS5sZW5ndGgpO1xuICB2YXIgcmVtYWluaW5nID0gYXJyYXkubGVuZ3RoIC0gbGVuO1xuICB2YXIgaXRlbXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaXRlbXMucHVzaChmb3JtYXRWYWx1ZShhcnJheVtpXSwgc2VlblZhbHVlcykpO1xuICB9XG5cbiAgaWYgKHJlbWFpbmluZyA9PT0gMSkge1xuICAgIGl0ZW1zLnB1c2goJy4uLiAxIG1vcmUgaXRlbScpO1xuICB9IGVsc2UgaWYgKHJlbWFpbmluZyA+IDEpIHtcbiAgICBpdGVtcy5wdXNoKFwiLi4uIFwiLmNvbmNhdChyZW1haW5pbmcsIFwiIG1vcmUgaXRlbXNcIikpO1xuICB9XG5cbiAgcmV0dXJuICdbJyArIGl0ZW1zLmpvaW4oJywgJykgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIGdldEN1c3RvbUZuKG9iamVjdCkge1xuICB2YXIgY3VzdG9tSW5zcGVjdEZuID0gb2JqZWN0W1N0cmluZyhub2RlanNDdXN0b21JbnNwZWN0U3ltYm9sKV07XG5cbiAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0Rm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY3VzdG9tSW5zcGVjdEZuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmplY3QuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvYmplY3QuaW5zcGVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPYmplY3RUYWcob2JqZWN0KSB7XG4gIHZhciB0YWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5yZXBsYWNlKC9eXFxbb2JqZWN0IC8sICcnKS5yZXBsYWNlKC9dJC8sICcnKTtcblxuICBpZiAodGFnID09PSAnT2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG5hbWUgPSBvYmplY3QuY29uc3RydWN0b3IubmFtZTtcblxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZSAhPT0gJycpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWc7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIHZhciBib29sZWFuQ29uZGl0aW9uID0gQm9vbGVhbihjb25kaXRpb24pOyAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAoU2VlIHRyYW5zZm9ybWF0aW9uIGRvbmUgaW4gJy4vcmVzb3VyY2VzL2lubGluZUludmFyaWFudC5qcycpXG5cbiAgaWYgKCFib29sZWFuQ29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgIT0gbnVsbCA/IG1lc3NhZ2UgOiAnVW5leHBlY3RlZCBpbnZhcmlhbnQgdHJpZ2dlcmVkLicpO1xuICB9XG59XG4iLCIvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAoU2VlOiAnaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1qcy9pc3N1ZXMvMjMxNycpXG52YXIgbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuZXhwb3J0IGRlZmF1bHQgbm9kZWpzQ3VzdG9tSW5zcGVjdFN5bWJvbDtcbiIsImltcG9ydCBkZWZpbmVJbnNwZWN0IGZyb20gXCIuLi9qc3V0aWxzL2RlZmluZUluc3BlY3QubWpzXCI7XG5cbi8qKlxuICogQ29udGFpbnMgYSByYW5nZSBvZiBVVEYtOCBjaGFyYWN0ZXIgb2Zmc2V0cyBhbmQgdG9rZW4gcmVmZXJlbmNlcyB0aGF0XG4gKiBpZGVudGlmeSB0aGUgcmVnaW9uIG9mIHRoZSBzb3VyY2UgZnJvbSB3aGljaCB0aGUgQVNUIGRlcml2ZWQuXG4gKi9cbmV4cG9ydCB2YXIgTG9jYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoaXMgTm9kZSBlbmRzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIFRva2VuIGF0IHdoaWNoIHRoaXMgTm9kZSBiZWdpbnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgVG9rZW4gYXQgd2hpY2ggdGhpcyBOb2RlIGVuZHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgU291cmNlIGRvY3VtZW50IHRoZSBBU1QgcmVwcmVzZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIExvY2F0aW9uKHN0YXJ0VG9rZW4sIGVuZFRva2VuLCBzb3VyY2UpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnRUb2tlbi5zdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZFRva2VuLmVuZDtcbiAgICB0aGlzLnN0YXJ0VG9rZW4gPSBzdGFydFRva2VuO1xuICAgIHRoaXMuZW5kVG9rZW4gPSBlbmRUb2tlbjtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMb2NhdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICBlbmQ6IHRoaXMuZW5kXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gTG9jYXRpb247XG59KCk7IC8vIFByaW50IGEgc2ltcGxpZmllZCBmb3JtIHdoZW4gYXBwZWFyaW5nIGluIGBpbnNwZWN0YCBhbmQgYHV0aWwuaW5zcGVjdGAuXG5cbmRlZmluZUluc3BlY3QoTG9jYXRpb24pO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmFuZ2Ugb2YgY2hhcmFjdGVycyByZXByZXNlbnRlZCBieSBhIGxleGljYWwgdG9rZW5cbiAqIHdpdGhpbiBhIFNvdXJjZS5cbiAqL1xuXG5leHBvcnQgdmFyIFRva2VuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIFRoZSBraW5kIG9mIFRva2VuLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGNoYXJhY3RlciBvZmZzZXQgYXQgd2hpY2ggdGhpcyBOb2RlIGJlZ2lucy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBjaGFyYWN0ZXIgb2Zmc2V0IGF0IHdoaWNoIHRoaXMgTm9kZSBlbmRzLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIDEtaW5kZXhlZCBsaW5lIG51bWJlciBvbiB3aGljaCB0aGlzIFRva2VuIGFwcGVhcnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgMS1pbmRleGVkIGNvbHVtbiBudW1iZXIgYXQgd2hpY2ggdGhpcyBUb2tlbiBiZWdpbnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGb3Igbm9uLXB1bmN0dWF0aW9uIHRva2VucywgcmVwcmVzZW50cyB0aGUgaW50ZXJwcmV0ZWQgdmFsdWUgb2YgdGhlIHRva2VuLlxuICAgKi9cblxuICAvKipcbiAgICogVG9rZW5zIGV4aXN0IGFzIG5vZGVzIGluIGEgZG91YmxlLWxpbmtlZC1saXN0IGFtb25nc3QgYWxsIHRva2Vuc1xuICAgKiBpbmNsdWRpbmcgaWdub3JlZCB0b2tlbnMuIDxTT0Y+IGlzIGFsd2F5cyB0aGUgZmlyc3Qgbm9kZSBhbmQgPEVPRj5cbiAgICogdGhlIGxhc3QuXG4gICAqL1xuICBmdW5jdGlvbiBUb2tlbihraW5kLCBzdGFydCwgZW5kLCBsaW5lLCBjb2x1bW4sIHByZXYsIHZhbHVlKSB7XG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBUb2tlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgY29sdW1uOiB0aGlzLmNvbHVtblxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIFRva2VuO1xufSgpOyAvLyBQcmludCBhIHNpbXBsaWZpZWQgZm9ybSB3aGVuIGFwcGVhcmluZyBpbiBgaW5zcGVjdGAgYW5kIGB1dGlsLmluc3BlY3RgLlxuXG5kZWZpbmVJbnNwZWN0KFRva2VuKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZShtYXliZU5vZGUpIHtcbiAgcmV0dXJuIG1heWJlTm9kZSAhPSBudWxsICYmIHR5cGVvZiBtYXliZU5vZGUua2luZCA9PT0gJ3N0cmluZyc7XG59XG4vKipcbiAqIFRoZSBsaXN0IG9mIGFsbCBwb3NzaWJsZSBBU1Qgbm9kZSB0eXBlcy5cbiAqL1xuIiwiLyoqXG4gKiBQcm9kdWNlcyB0aGUgdmFsdWUgb2YgYSBibG9jayBzdHJpbmcgZnJvbSBpdHMgcGFyc2VkIHJhdyB2YWx1ZSwgc2ltaWxhciB0b1xuICogQ29mZmVlU2NyaXB0J3MgYmxvY2sgc3RyaW5nLCBQeXRob24ncyBkb2NzdHJpbmcgdHJpbSBvciBSdWJ5J3Mgc3RyaXBfaGVyZWRvYy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgdGhlIEdyYXBoUUwgc3BlYydzIEJsb2NrU3RyaW5nVmFsdWUoKSBzdGF0aWMgYWxnb3JpdGhtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVkZW50QmxvY2tTdHJpbmdWYWx1ZShyYXdTdHJpbmcpIHtcbiAgLy8gRXhwYW5kIGEgYmxvY2sgc3RyaW5nJ3MgcmF3IHZhbHVlIGludG8gaW5kZXBlbmRlbnQgbGluZXMuXG4gIHZhciBsaW5lcyA9IHJhd1N0cmluZy5zcGxpdCgvXFxyXFxufFtcXG5cXHJdL2cpOyAvLyBSZW1vdmUgY29tbW9uIGluZGVudGF0aW9uIGZyb20gYWxsIGxpbmVzIGJ1dCBmaXJzdC5cblxuICB2YXIgY29tbW9uSW5kZW50ID0gZ2V0QmxvY2tTdHJpbmdJbmRlbnRhdGlvbihyYXdTdHJpbmcpO1xuXG4gIGlmIChjb21tb25JbmRlbnQgIT09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldLnNsaWNlKGNvbW1vbkluZGVudCk7XG4gICAgfVxuICB9IC8vIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBibGFuayBsaW5lcy5cblxuXG4gIHZhciBzdGFydExpbmUgPSAwO1xuXG4gIHdoaWxlIChzdGFydExpbmUgPCBsaW5lcy5sZW5ndGggJiYgaXNCbGFuayhsaW5lc1tzdGFydExpbmVdKSkge1xuICAgICsrc3RhcnRMaW5lO1xuICB9XG5cbiAgdmFyIGVuZExpbmUgPSBsaW5lcy5sZW5ndGg7XG5cbiAgd2hpbGUgKGVuZExpbmUgPiBzdGFydExpbmUgJiYgaXNCbGFuayhsaW5lc1tlbmRMaW5lIC0gMV0pKSB7XG4gICAgLS1lbmRMaW5lO1xuICB9IC8vIFJldHVybiBhIHN0cmluZyBvZiB0aGUgbGluZXMgam9pbmVkIHdpdGggVSswMDBBLlxuXG5cbiAgcmV0dXJuIGxpbmVzLnNsaWNlKHN0YXJ0TGluZSwgZW5kTGluZSkuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIGlzQmxhbmsoc3RyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHN0cltpXSAhPT0gJyAnICYmIHN0cltpXSAhPT0gJ1xcdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmxvY2tTdHJpbmdJbmRlbnRhdGlvbih2YWx1ZSkge1xuICB2YXIgX2NvbW1vbkluZGVudDtcblxuICB2YXIgaXNGaXJzdExpbmUgPSB0cnVlO1xuICB2YXIgaXNFbXB0eUxpbmUgPSB0cnVlO1xuICB2YXIgaW5kZW50ID0gMDtcbiAgdmFyIGNvbW1vbkluZGVudCA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIHN3aXRjaCAodmFsdWUuY2hhckNvZGVBdChpKSkge1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgLy8gIFxcclxuICAgICAgICBpZiAodmFsdWUuY2hhckNvZGVBdChpICsgMSkgPT09IDEwKSB7XG4gICAgICAgICAgKytpOyAvLyBza2lwIFxcclxcbiBhcyBvbmUgc3ltYm9sXG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgICBjYXNlIDEwOlxuICAgICAgICAvLyAgXFxuXG4gICAgICAgIGlzRmlyc3RMaW5lID0gZmFsc2U7XG4gICAgICAgIGlzRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTogLy8gICBcXHRcblxuICAgICAgY2FzZSAzMjpcbiAgICAgICAgLy8gIDxzcGFjZT5cbiAgICAgICAgKytpbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaXNFbXB0eUxpbmUgJiYgIWlzRmlyc3RMaW5lICYmIChjb21tb25JbmRlbnQgPT09IG51bGwgfHwgaW5kZW50IDwgY29tbW9uSW5kZW50KSkge1xuICAgICAgICAgIGNvbW1vbkluZGVudCA9IGluZGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChfY29tbW9uSW5kZW50ID0gY29tbW9uSW5kZW50KSAhPT0gbnVsbCAmJiBfY29tbW9uSW5kZW50ICE9PSB2b2lkIDAgPyBfY29tbW9uSW5kZW50IDogMDtcbn1cbi8qKlxuICogUHJpbnQgYSBibG9jayBzdHJpbmcgaW4gdGhlIGluZGVudGVkIGJsb2NrIGZvcm0gYnkgYWRkaW5nIGEgbGVhZGluZyBhbmRcbiAqIHRyYWlsaW5nIGJsYW5rIGxpbmUuIEhvd2V2ZXIsIGlmIGEgYmxvY2sgc3RyaW5nIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UgYW5kIGlzXG4gKiBhIHNpbmdsZS1saW5lLCBhZGRpbmcgYSBsZWFkaW5nIGJsYW5rIGxpbmUgd291bGQgc3RyaXAgdGhhdCB3aGl0ZXNwYWNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludEJsb2NrU3RyaW5nKHZhbHVlKSB7XG4gIHZhciBpbmRlbnRhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gIHZhciBwcmVmZXJNdWx0aXBsZUxpbmVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIGlzU2luZ2xlTGluZSA9IHZhbHVlLmluZGV4T2YoJ1xcbicpID09PSAtMTtcbiAgdmFyIGhhc0xlYWRpbmdTcGFjZSA9IHZhbHVlWzBdID09PSAnICcgfHwgdmFsdWVbMF0gPT09ICdcXHQnO1xuICB2YXIgaGFzVHJhaWxpbmdRdW90ZSA9IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXCInO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXFxcXCc7XG4gIHZhciBwcmludEFzTXVsdGlwbGVMaW5lcyA9ICFpc1NpbmdsZUxpbmUgfHwgaGFzVHJhaWxpbmdRdW90ZSB8fCBoYXNUcmFpbGluZ1NsYXNoIHx8IHByZWZlck11bHRpcGxlTGluZXM7XG4gIHZhciByZXN1bHQgPSAnJzsgLy8gRm9ybWF0IGEgbXVsdGktbGluZSBibG9jayBxdW90ZSB0byBhY2NvdW50IGZvciBsZWFkaW5nIHNwYWNlLlxuXG4gIGlmIChwcmludEFzTXVsdGlwbGVMaW5lcyAmJiAhKGlzU2luZ2xlTGluZSAmJiBoYXNMZWFkaW5nU3BhY2UpKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nICsgaW5kZW50YXRpb247XG4gIH1cblxuICByZXN1bHQgKz0gaW5kZW50YXRpb24gPyB2YWx1ZS5yZXBsYWNlKC9cXG4vZywgJ1xcbicgKyBpbmRlbnRhdGlvbikgOiB2YWx1ZTtcblxuICBpZiAocHJpbnRBc011bHRpcGxlTGluZXMpIHtcbiAgICByZXN1bHQgKz0gJ1xcbic7XG4gIH1cblxuICByZXR1cm4gJ1wiXCJcIicgKyByZXN1bHQucmVwbGFjZSgvXCJcIlwiL2csICdcXFxcXCJcIlwiJykgKyAnXCJcIlwiJztcbn1cbiIsImltcG9ydCB7IHZpc2l0IH0gZnJvbSBcIi4vdmlzaXRvci5tanNcIjtcbmltcG9ydCB7IHByaW50QmxvY2tTdHJpbmcgfSBmcm9tIFwiLi9ibG9ja1N0cmluZy5tanNcIjtcbi8qKlxuICogQ29udmVydHMgYW4gQVNUIGludG8gYSBzdHJpbmcsIHVzaW5nIG9uZSBzZXQgb2YgcmVhc29uYWJsZVxuICogZm9ybWF0dGluZyBydWxlcy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnQoYXN0KSB7XG4gIHJldHVybiB2aXNpdChhc3QsIHtcbiAgICBsZWF2ZTogcHJpbnREb2NBU1RSZWR1Y2VyXG4gIH0pO1xufVxudmFyIE1BWF9MSU5FX0xFTkdUSCA9IDgwOyAvLyBUT0RPOiBwcm92aWRlIGJldHRlciB0eXBlIGNvdmVyYWdlIGluIGZ1dHVyZVxuXG52YXIgcHJpbnREb2NBU1RSZWR1Y2VyID0ge1xuICBOYW1lOiBmdW5jdGlvbiBOYW1lKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfSxcbiAgVmFyaWFibGU6IGZ1bmN0aW9uIFZhcmlhYmxlKG5vZGUpIHtcbiAgICByZXR1cm4gJyQnICsgbm9kZS5uYW1lO1xuICB9LFxuICAvLyBEb2N1bWVudFxuICBEb2N1bWVudDogZnVuY3Rpb24gRG9jdW1lbnQobm9kZSkge1xuICAgIHJldHVybiBqb2luKG5vZGUuZGVmaW5pdGlvbnMsICdcXG5cXG4nKSArICdcXG4nO1xuICB9LFxuICBPcGVyYXRpb25EZWZpbml0aW9uOiBmdW5jdGlvbiBPcGVyYXRpb25EZWZpbml0aW9uKG5vZGUpIHtcbiAgICB2YXIgb3AgPSBub2RlLm9wZXJhdGlvbjtcbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICB2YXIgdmFyRGVmcyA9IHdyYXAoJygnLCBqb2luKG5vZGUudmFyaWFibGVEZWZpbml0aW9ucywgJywgJyksICcpJyk7XG4gICAgdmFyIGRpcmVjdGl2ZXMgPSBqb2luKG5vZGUuZGlyZWN0aXZlcywgJyAnKTtcbiAgICB2YXIgc2VsZWN0aW9uU2V0ID0gbm9kZS5zZWxlY3Rpb25TZXQ7IC8vIEFub255bW91cyBxdWVyaWVzIHdpdGggbm8gZGlyZWN0aXZlcyBvciB2YXJpYWJsZSBkZWZpbml0aW9ucyBjYW4gdXNlXG4gICAgLy8gdGhlIHF1ZXJ5IHNob3J0IGZvcm0uXG5cbiAgICByZXR1cm4gIW5hbWUgJiYgIWRpcmVjdGl2ZXMgJiYgIXZhckRlZnMgJiYgb3AgPT09ICdxdWVyeScgPyBzZWxlY3Rpb25TZXQgOiBqb2luKFtvcCwgam9pbihbbmFtZSwgdmFyRGVmc10pLCBkaXJlY3RpdmVzLCBzZWxlY3Rpb25TZXRdLCAnICcpO1xuICB9LFxuICBWYXJpYWJsZURlZmluaXRpb246IGZ1bmN0aW9uIFZhcmlhYmxlRGVmaW5pdGlvbihfcmVmKSB7XG4gICAgdmFyIHZhcmlhYmxlID0gX3JlZi52YXJpYWJsZSxcbiAgICAgICAgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gX3JlZi5kZWZhdWx0VmFsdWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmLmRpcmVjdGl2ZXM7XG4gICAgcmV0dXJuIHZhcmlhYmxlICsgJzogJyArIHR5cGUgKyB3cmFwKCcgPSAnLCBkZWZhdWx0VmFsdWUpICsgd3JhcCgnICcsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSk7XG4gIH0sXG4gIFNlbGVjdGlvblNldDogZnVuY3Rpb24gU2VsZWN0aW9uU2V0KF9yZWYyKSB7XG4gICAgdmFyIHNlbGVjdGlvbnMgPSBfcmVmMi5zZWxlY3Rpb25zO1xuICAgIHJldHVybiBibG9jayhzZWxlY3Rpb25zKTtcbiAgfSxcbiAgRmllbGQ6IGZ1bmN0aW9uIEZpZWxkKF9yZWYzKSB7XG4gICAgdmFyIGFsaWFzID0gX3JlZjMuYWxpYXMsXG4gICAgICAgIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICBhcmdzID0gX3JlZjMuYXJndW1lbnRzLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjMuZGlyZWN0aXZlcyxcbiAgICAgICAgc2VsZWN0aW9uU2V0ID0gX3JlZjMuc2VsZWN0aW9uU2V0O1xuICAgIHZhciBwcmVmaXggPSB3cmFwKCcnLCBhbGlhcywgJzogJykgKyBuYW1lO1xuICAgIHZhciBhcmdzTGluZSA9IHByZWZpeCArIHdyYXAoJygnLCBqb2luKGFyZ3MsICcsICcpLCAnKScpO1xuXG4gICAgaWYgKGFyZ3NMaW5lLmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSCkge1xuICAgICAgYXJnc0xpbmUgPSBwcmVmaXggKyB3cmFwKCcoXFxuJywgaW5kZW50KGpvaW4oYXJncywgJ1xcbicpKSwgJ1xcbiknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gam9pbihbYXJnc0xpbmUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgc2VsZWN0aW9uU2V0XSwgJyAnKTtcbiAgfSxcbiAgQXJndW1lbnQ6IGZ1bmN0aW9uIEFyZ3VtZW50KF9yZWY0KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmNC5uYW1lLFxuICAgICAgICB2YWx1ZSA9IF9yZWY0LnZhbHVlO1xuICAgIHJldHVybiBuYW1lICsgJzogJyArIHZhbHVlO1xuICB9LFxuICAvLyBGcmFnbWVudHNcbiAgRnJhZ21lbnRTcHJlYWQ6IGZ1bmN0aW9uIEZyYWdtZW50U3ByZWFkKF9yZWY1KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmNS5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjUuZGlyZWN0aXZlcztcbiAgICByZXR1cm4gJy4uLicgKyBuYW1lICsgd3JhcCgnICcsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSk7XG4gIH0sXG4gIElubGluZUZyYWdtZW50OiBmdW5jdGlvbiBJbmxpbmVGcmFnbWVudChfcmVmNikge1xuICAgIHZhciB0eXBlQ29uZGl0aW9uID0gX3JlZjYudHlwZUNvbmRpdGlvbixcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWY2LmRpcmVjdGl2ZXMsXG4gICAgICAgIHNlbGVjdGlvblNldCA9IF9yZWY2LnNlbGVjdGlvblNldDtcbiAgICByZXR1cm4gam9pbihbJy4uLicsIHdyYXAoJ29uICcsIHR5cGVDb25kaXRpb24pLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIHNlbGVjdGlvblNldF0sICcgJyk7XG4gIH0sXG4gIEZyYWdtZW50RGVmaW5pdGlvbjogZnVuY3Rpb24gRnJhZ21lbnREZWZpbml0aW9uKF9yZWY3KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmNy5uYW1lLFxuICAgICAgICB0eXBlQ29uZGl0aW9uID0gX3JlZjcudHlwZUNvbmRpdGlvbixcbiAgICAgICAgdmFyaWFibGVEZWZpbml0aW9ucyA9IF9yZWY3LnZhcmlhYmxlRGVmaW5pdGlvbnMsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmNy5kaXJlY3RpdmVzLFxuICAgICAgICBzZWxlY3Rpb25TZXQgPSBfcmVmNy5zZWxlY3Rpb25TZXQ7XG4gICAgcmV0dXJuICgvLyBOb3RlOiBmcmFnbWVudCB2YXJpYWJsZSBkZWZpbml0aW9ucyBhcmUgZXhwZXJpbWVudGFsIGFuZCBtYXkgYmUgY2hhbmdlZFxuICAgICAgLy8gb3IgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAgXCJmcmFnbWVudCBcIi5jb25jYXQobmFtZSkuY29uY2F0KHdyYXAoJygnLCBqb2luKHZhcmlhYmxlRGVmaW5pdGlvbnMsICcsICcpLCAnKScpLCBcIiBcIikgKyBcIm9uIFwiLmNvbmNhdCh0eXBlQ29uZGl0aW9uLCBcIiBcIikuY29uY2F0KHdyYXAoJycsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgJyAnKSkgKyBzZWxlY3Rpb25TZXRcbiAgICApO1xuICB9LFxuICAvLyBWYWx1ZVxuICBJbnRWYWx1ZTogZnVuY3Rpb24gSW50VmFsdWUoX3JlZjgpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmOC52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIEZsb2F0VmFsdWU6IGZ1bmN0aW9uIEZsb2F0VmFsdWUoX3JlZjkpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmOS52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIFN0cmluZ1ZhbHVlOiBmdW5jdGlvbiBTdHJpbmdWYWx1ZShfcmVmMTAsIGtleSkge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYxMC52YWx1ZSxcbiAgICAgICAgaXNCbG9ja1N0cmluZyA9IF9yZWYxMC5ibG9jaztcbiAgICByZXR1cm4gaXNCbG9ja1N0cmluZyA/IHByaW50QmxvY2tTdHJpbmcodmFsdWUsIGtleSA9PT0gJ2Rlc2NyaXB0aW9uJyA/ICcnIDogJyAgJykgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH0sXG4gIEJvb2xlYW5WYWx1ZTogZnVuY3Rpb24gQm9vbGVhblZhbHVlKF9yZWYxMSkge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYxMS52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9LFxuICBOdWxsVmFsdWU6IGZ1bmN0aW9uIE51bGxWYWx1ZSgpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9LFxuICBFbnVtVmFsdWU6IGZ1bmN0aW9uIEVudW1WYWx1ZShfcmVmMTIpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmMTIudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBMaXN0VmFsdWU6IGZ1bmN0aW9uIExpc3RWYWx1ZShfcmVmMTMpIHtcbiAgICB2YXIgdmFsdWVzID0gX3JlZjEzLnZhbHVlcztcbiAgICByZXR1cm4gJ1snICsgam9pbih2YWx1ZXMsICcsICcpICsgJ10nO1xuICB9LFxuICBPYmplY3RWYWx1ZTogZnVuY3Rpb24gT2JqZWN0VmFsdWUoX3JlZjE0KSB7XG4gICAgdmFyIGZpZWxkcyA9IF9yZWYxNC5maWVsZHM7XG4gICAgcmV0dXJuICd7JyArIGpvaW4oZmllbGRzLCAnLCAnKSArICd9JztcbiAgfSxcbiAgT2JqZWN0RmllbGQ6IGZ1bmN0aW9uIE9iamVjdEZpZWxkKF9yZWYxNSkge1xuICAgIHZhciBuYW1lID0gX3JlZjE1Lm5hbWUsXG4gICAgICAgIHZhbHVlID0gX3JlZjE1LnZhbHVlO1xuICAgIHJldHVybiBuYW1lICsgJzogJyArIHZhbHVlO1xuICB9LFxuICAvLyBEaXJlY3RpdmVcbiAgRGlyZWN0aXZlOiBmdW5jdGlvbiBEaXJlY3RpdmUoX3JlZjE2KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMTYubmFtZSxcbiAgICAgICAgYXJncyA9IF9yZWYxNi5hcmd1bWVudHM7XG4gICAgcmV0dXJuICdAJyArIG5hbWUgKyB3cmFwKCcoJywgam9pbihhcmdzLCAnLCAnKSwgJyknKTtcbiAgfSxcbiAgLy8gVHlwZVxuICBOYW1lZFR5cGU6IGZ1bmN0aW9uIE5hbWVkVHlwZShfcmVmMTcpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYxNy5uYW1lO1xuICAgIHJldHVybiBuYW1lO1xuICB9LFxuICBMaXN0VHlwZTogZnVuY3Rpb24gTGlzdFR5cGUoX3JlZjE4KSB7XG4gICAgdmFyIHR5cGUgPSBfcmVmMTgudHlwZTtcbiAgICByZXR1cm4gJ1snICsgdHlwZSArICddJztcbiAgfSxcbiAgTm9uTnVsbFR5cGU6IGZ1bmN0aW9uIE5vbk51bGxUeXBlKF9yZWYxOSkge1xuICAgIHZhciB0eXBlID0gX3JlZjE5LnR5cGU7XG4gICAgcmV0dXJuIHR5cGUgKyAnISc7XG4gIH0sXG4gIC8vIFR5cGUgU3lzdGVtIERlZmluaXRpb25zXG4gIFNjaGVtYURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMjApIHtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IF9yZWYyMC5kaXJlY3RpdmVzLFxuICAgICAgICBvcGVyYXRpb25UeXBlcyA9IF9yZWYyMC5vcGVyYXRpb25UeXBlcztcbiAgICByZXR1cm4gam9pbihbJ3NjaGVtYScsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2sob3BlcmF0aW9uVHlwZXMpXSwgJyAnKTtcbiAgfSksXG4gIE9wZXJhdGlvblR5cGVEZWZpbml0aW9uOiBmdW5jdGlvbiBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbihfcmVmMjEpIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gX3JlZjIxLm9wZXJhdGlvbixcbiAgICAgICAgdHlwZSA9IF9yZWYyMS50eXBlO1xuICAgIHJldHVybiBvcGVyYXRpb24gKyAnOiAnICsgdHlwZTtcbiAgfSxcbiAgU2NhbGFyVHlwZURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMjIpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyMi5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjIyLmRpcmVjdGl2ZXM7XG4gICAgcmV0dXJuIGpvaW4oWydzY2FsYXInLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyldLCAnICcpO1xuICB9KSxcbiAgT2JqZWN0VHlwZURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMjMpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyMy5uYW1lLFxuICAgICAgICBpbnRlcmZhY2VzID0gX3JlZjIzLmludGVyZmFjZXMsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMjMuZGlyZWN0aXZlcyxcbiAgICAgICAgZmllbGRzID0gX3JlZjIzLmZpZWxkcztcbiAgICByZXR1cm4gam9pbihbJ3R5cGUnLCBuYW1lLCB3cmFwKCdpbXBsZW1lbnRzICcsIGpvaW4oaW50ZXJmYWNlcywgJyAmICcpKSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCBibG9jayhmaWVsZHMpXSwgJyAnKTtcbiAgfSksXG4gIEZpZWxkRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYyNCkge1xuICAgIHZhciBuYW1lID0gX3JlZjI0Lm5hbWUsXG4gICAgICAgIGFyZ3MgPSBfcmVmMjQuYXJndW1lbnRzLFxuICAgICAgICB0eXBlID0gX3JlZjI0LnR5cGUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMjQuZGlyZWN0aXZlcztcbiAgICByZXR1cm4gbmFtZSArIChoYXNNdWx0aWxpbmVJdGVtcyhhcmdzKSA/IHdyYXAoJyhcXG4nLCBpbmRlbnQoam9pbihhcmdzLCAnXFxuJykpLCAnXFxuKScpIDogd3JhcCgnKCcsIGpvaW4oYXJncywgJywgJyksICcpJykpICsgJzogJyArIHR5cGUgKyB3cmFwKCcgJywgam9pbihkaXJlY3RpdmVzLCAnICcpKTtcbiAgfSksXG4gIElucHV0VmFsdWVEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjI1KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMjUubmFtZSxcbiAgICAgICAgdHlwZSA9IF9yZWYyNS50eXBlLFxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBfcmVmMjUuZGVmYXVsdFZhbHVlLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjI1LmRpcmVjdGl2ZXM7XG4gICAgcmV0dXJuIGpvaW4oW25hbWUgKyAnOiAnICsgdHlwZSwgd3JhcCgnPSAnLCBkZWZhdWx0VmFsdWUpLCBqb2luKGRpcmVjdGl2ZXMsICcgJyldLCAnICcpO1xuICB9KSxcbiAgSW50ZXJmYWNlVHlwZURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMjYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYyNi5uYW1lLFxuICAgICAgICBpbnRlcmZhY2VzID0gX3JlZjI2LmludGVyZmFjZXMsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMjYuZGlyZWN0aXZlcyxcbiAgICAgICAgZmllbGRzID0gX3JlZjI2LmZpZWxkcztcbiAgICByZXR1cm4gam9pbihbJ2ludGVyZmFjZScsIG5hbWUsIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKGZpZWxkcyldLCAnICcpO1xuICB9KSxcbiAgVW5pb25UeXBlRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYyNykge1xuICAgIHZhciBuYW1lID0gX3JlZjI3Lm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMjcuZGlyZWN0aXZlcyxcbiAgICAgICAgdHlwZXMgPSBfcmVmMjcudHlwZXM7XG4gICAgcmV0dXJuIGpvaW4oWyd1bmlvbicsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgdHlwZXMgJiYgdHlwZXMubGVuZ3RoICE9PSAwID8gJz0gJyArIGpvaW4odHlwZXMsICcgfCAnKSA6ICcnXSwgJyAnKTtcbiAgfSksXG4gIEVudW1UeXBlRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYyOCkge1xuICAgIHZhciBuYW1lID0gX3JlZjI4Lm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMjguZGlyZWN0aXZlcyxcbiAgICAgICAgdmFsdWVzID0gX3JlZjI4LnZhbHVlcztcbiAgICByZXR1cm4gam9pbihbJ2VudW0nLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKHZhbHVlcyldLCAnICcpO1xuICB9KSxcbiAgRW51bVZhbHVlRGVmaW5pdGlvbjogYWRkRGVzY3JpcHRpb24oZnVuY3Rpb24gKF9yZWYyOSkge1xuICAgIHZhciBuYW1lID0gX3JlZjI5Lm5hbWUsXG4gICAgICAgIGRpcmVjdGl2ZXMgPSBfcmVmMjkuZGlyZWN0aXZlcztcbiAgICByZXR1cm4gam9pbihbbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpXSwgJyAnKTtcbiAgfSksXG4gIElucHV0T2JqZWN0VHlwZURlZmluaXRpb246IGFkZERlc2NyaXB0aW9uKGZ1bmN0aW9uIChfcmVmMzApIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYzMC5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjMwLmRpcmVjdGl2ZXMsXG4gICAgICAgIGZpZWxkcyA9IF9yZWYzMC5maWVsZHM7XG4gICAgcmV0dXJuIGpvaW4oWydpbnB1dCcsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKSwgYmxvY2soZmllbGRzKV0sICcgJyk7XG4gIH0pLFxuICBEaXJlY3RpdmVEZWZpbml0aW9uOiBhZGREZXNjcmlwdGlvbihmdW5jdGlvbiAoX3JlZjMxKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMzEubmFtZSxcbiAgICAgICAgYXJncyA9IF9yZWYzMS5hcmd1bWVudHMsXG4gICAgICAgIHJlcGVhdGFibGUgPSBfcmVmMzEucmVwZWF0YWJsZSxcbiAgICAgICAgbG9jYXRpb25zID0gX3JlZjMxLmxvY2F0aW9ucztcbiAgICByZXR1cm4gJ2RpcmVjdGl2ZSBAJyArIG5hbWUgKyAoaGFzTXVsdGlsaW5lSXRlbXMoYXJncykgPyB3cmFwKCcoXFxuJywgaW5kZW50KGpvaW4oYXJncywgJ1xcbicpKSwgJ1xcbiknKSA6IHdyYXAoJygnLCBqb2luKGFyZ3MsICcsICcpLCAnKScpKSArIChyZXBlYXRhYmxlID8gJyByZXBlYXRhYmxlJyA6ICcnKSArICcgb24gJyArIGpvaW4obG9jYXRpb25zLCAnIHwgJyk7XG4gIH0pLFxuICBTY2hlbWFFeHRlbnNpb246IGZ1bmN0aW9uIFNjaGVtYUV4dGVuc2lvbihfcmVmMzIpIHtcbiAgICB2YXIgZGlyZWN0aXZlcyA9IF9yZWYzMi5kaXJlY3RpdmVzLFxuICAgICAgICBvcGVyYXRpb25UeXBlcyA9IF9yZWYzMi5vcGVyYXRpb25UeXBlcztcbiAgICByZXR1cm4gam9pbihbJ2V4dGVuZCBzY2hlbWEnLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKG9wZXJhdGlvblR5cGVzKV0sICcgJyk7XG4gIH0sXG4gIFNjYWxhclR5cGVFeHRlbnNpb246IGZ1bmN0aW9uIFNjYWxhclR5cGVFeHRlbnNpb24oX3JlZjMzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMzMubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYzMy5kaXJlY3RpdmVzO1xuICAgIHJldHVybiBqb2luKFsnZXh0ZW5kIHNjYWxhcicsIG5hbWUsIGpvaW4oZGlyZWN0aXZlcywgJyAnKV0sICcgJyk7XG4gIH0sXG4gIE9iamVjdFR5cGVFeHRlbnNpb246IGZ1bmN0aW9uIE9iamVjdFR5cGVFeHRlbnNpb24oX3JlZjM0KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMzQubmFtZSxcbiAgICAgICAgaW50ZXJmYWNlcyA9IF9yZWYzNC5pbnRlcmZhY2VzLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjM0LmRpcmVjdGl2ZXMsXG4gICAgICAgIGZpZWxkcyA9IF9yZWYzNC5maWVsZHM7XG4gICAgcmV0dXJuIGpvaW4oWydleHRlbmQgdHlwZScsIG5hbWUsIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKGZpZWxkcyldLCAnICcpO1xuICB9LFxuICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiBmdW5jdGlvbiBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uKF9yZWYzNSkge1xuICAgIHZhciBuYW1lID0gX3JlZjM1Lm5hbWUsXG4gICAgICAgIGludGVyZmFjZXMgPSBfcmVmMzUuaW50ZXJmYWNlcyxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYzNS5kaXJlY3RpdmVzLFxuICAgICAgICBmaWVsZHMgPSBfcmVmMzUuZmllbGRzO1xuICAgIHJldHVybiBqb2luKFsnZXh0ZW5kIGludGVyZmFjZScsIG5hbWUsIHdyYXAoJ2ltcGxlbWVudHMgJywgam9pbihpbnRlcmZhY2VzLCAnICYgJykpLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKGZpZWxkcyldLCAnICcpO1xuICB9LFxuICBVbmlvblR5cGVFeHRlbnNpb246IGZ1bmN0aW9uIFVuaW9uVHlwZUV4dGVuc2lvbihfcmVmMzYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYzNi5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjM2LmRpcmVjdGl2ZXMsXG4gICAgICAgIHR5cGVzID0gX3JlZjM2LnR5cGVzO1xuICAgIHJldHVybiBqb2luKFsnZXh0ZW5kIHVuaW9uJywgbmFtZSwgam9pbihkaXJlY3RpdmVzLCAnICcpLCB0eXBlcyAmJiB0eXBlcy5sZW5ndGggIT09IDAgPyAnPSAnICsgam9pbih0eXBlcywgJyB8ICcpIDogJyddLCAnICcpO1xuICB9LFxuICBFbnVtVHlwZUV4dGVuc2lvbjogZnVuY3Rpb24gRW51bVR5cGVFeHRlbnNpb24oX3JlZjM3KSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMzcubmFtZSxcbiAgICAgICAgZGlyZWN0aXZlcyA9IF9yZWYzNy5kaXJlY3RpdmVzLFxuICAgICAgICB2YWx1ZXMgPSBfcmVmMzcudmFsdWVzO1xuICAgIHJldHVybiBqb2luKFsnZXh0ZW5kIGVudW0nLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKHZhbHVlcyldLCAnICcpO1xuICB9LFxuICBJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246IGZ1bmN0aW9uIElucHV0T2JqZWN0VHlwZUV4dGVuc2lvbihfcmVmMzgpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYzOC5uYW1lLFxuICAgICAgICBkaXJlY3RpdmVzID0gX3JlZjM4LmRpcmVjdGl2ZXMsXG4gICAgICAgIGZpZWxkcyA9IF9yZWYzOC5maWVsZHM7XG4gICAgcmV0dXJuIGpvaW4oWydleHRlbmQgaW5wdXQnLCBuYW1lLCBqb2luKGRpcmVjdGl2ZXMsICcgJyksIGJsb2NrKGZpZWxkcyldLCAnICcpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhZGREZXNjcmlwdGlvbihjYikge1xuICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gam9pbihbbm9kZS5kZXNjcmlwdGlvbiwgY2Iobm9kZSldLCAnXFxuJyk7XG4gIH07XG59XG4vKipcbiAqIEdpdmVuIG1heWJlQXJyYXksIHByaW50IGFuIGVtcHR5IHN0cmluZyBpZiBpdCBpcyBudWxsIG9yIGVtcHR5LCBvdGhlcndpc2VcbiAqIHByaW50IGFsbCBpdGVtcyB0b2dldGhlciBzZXBhcmF0ZWQgYnkgc2VwYXJhdG9yIGlmIHByb3ZpZGVkXG4gKi9cblxuXG5mdW5jdGlvbiBqb2luKG1heWJlQXJyYXkpIHtcbiAgdmFyIF9tYXliZUFycmF5JGZpbHRlciRqbztcblxuICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgcmV0dXJuIChfbWF5YmVBcnJheSRmaWx0ZXIkam8gPSBtYXliZUFycmF5ID09PSBudWxsIHx8IG1heWJlQXJyYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1heWJlQXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH0pLmpvaW4oc2VwYXJhdG9yKSkgIT09IG51bGwgJiYgX21heWJlQXJyYXkkZmlsdGVyJGpvICE9PSB2b2lkIDAgPyBfbWF5YmVBcnJheSRmaWx0ZXIkam8gOiAnJztcbn1cbi8qKlxuICogR2l2ZW4gYXJyYXksIHByaW50IGVhY2ggaXRlbSBvbiBpdHMgb3duIGxpbmUsIHdyYXBwZWQgaW4gYW5cbiAqIGluZGVudGVkIFwieyB9XCIgYmxvY2suXG4gKi9cblxuXG5mdW5jdGlvbiBibG9jayhhcnJheSkge1xuICByZXR1cm4gd3JhcCgne1xcbicsIGluZGVudChqb2luKGFycmF5LCAnXFxuJykpLCAnXFxufScpO1xufVxuLyoqXG4gKiBJZiBtYXliZVN0cmluZyBpcyBub3QgbnVsbCBvciBlbXB0eSwgdGhlbiB3cmFwIHdpdGggc3RhcnQgYW5kIGVuZCwgb3RoZXJ3aXNlIHByaW50IGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdyYXAoc3RhcnQsIG1heWJlU3RyaW5nKSB7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcnO1xuICByZXR1cm4gbWF5YmVTdHJpbmcgIT0gbnVsbCAmJiBtYXliZVN0cmluZyAhPT0gJycgPyBzdGFydCArIG1heWJlU3RyaW5nICsgZW5kIDogJyc7XG59XG5cbmZ1bmN0aW9uIGluZGVudChzdHIpIHtcbiAgcmV0dXJuIHdyYXAoJyAgJywgc3RyLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAnKSk7XG59XG5cbmZ1bmN0aW9uIGlzTXVsdGlsaW5lKHN0cikge1xuICByZXR1cm4gc3RyLmluZGV4T2YoJ1xcbicpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gaGFzTXVsdGlsaW5lSXRlbXMobWF5YmVBcnJheSkge1xuICByZXR1cm4gbWF5YmVBcnJheSAhPSBudWxsICYmIG1heWJlQXJyYXkuc29tZShpc011bHRpbGluZSk7XG59XG4iLCJpbXBvcnQgaW5zcGVjdCBmcm9tIFwiLi4vanN1dGlscy9pbnNwZWN0Lm1qc1wiO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSBcIi4vYXN0Lm1qc1wiO1xuLyoqXG4gKiBBIHZpc2l0b3IgaXMgcHJvdmlkZWQgdG8gdmlzaXQsIGl0IGNvbnRhaW5zIHRoZSBjb2xsZWN0aW9uIG9mXG4gKiByZWxldmFudCBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdmlzaXRvcidzIHRyYXZlcnNhbC5cbiAqL1xuXG5leHBvcnQgdmFyIFF1ZXJ5RG9jdW1lbnRLZXlzID0ge1xuICBOYW1lOiBbXSxcbiAgRG9jdW1lbnQ6IFsnZGVmaW5pdGlvbnMnXSxcbiAgT3BlcmF0aW9uRGVmaW5pdGlvbjogWyduYW1lJywgJ3ZhcmlhYmxlRGVmaW5pdGlvbnMnLCAnZGlyZWN0aXZlcycsICdzZWxlY3Rpb25TZXQnXSxcbiAgVmFyaWFibGVEZWZpbml0aW9uOiBbJ3ZhcmlhYmxlJywgJ3R5cGUnLCAnZGVmYXVsdFZhbHVlJywgJ2RpcmVjdGl2ZXMnXSxcbiAgVmFyaWFibGU6IFsnbmFtZSddLFxuICBTZWxlY3Rpb25TZXQ6IFsnc2VsZWN0aW9ucyddLFxuICBGaWVsZDogWydhbGlhcycsICduYW1lJywgJ2FyZ3VtZW50cycsICdkaXJlY3RpdmVzJywgJ3NlbGVjdGlvblNldCddLFxuICBBcmd1bWVudDogWyduYW1lJywgJ3ZhbHVlJ10sXG4gIEZyYWdtZW50U3ByZWFkOiBbJ25hbWUnLCAnZGlyZWN0aXZlcyddLFxuICBJbmxpbmVGcmFnbWVudDogWyd0eXBlQ29uZGl0aW9uJywgJ2RpcmVjdGl2ZXMnLCAnc2VsZWN0aW9uU2V0J10sXG4gIEZyYWdtZW50RGVmaW5pdGlvbjogWyduYW1lJywgLy8gTm90ZTogZnJhZ21lbnQgdmFyaWFibGUgZGVmaW5pdGlvbnMgYXJlIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGJlIGNoYW5nZWRcbiAgLy8gb3IgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAndmFyaWFibGVEZWZpbml0aW9ucycsICd0eXBlQ29uZGl0aW9uJywgJ2RpcmVjdGl2ZXMnLCAnc2VsZWN0aW9uU2V0J10sXG4gIEludFZhbHVlOiBbXSxcbiAgRmxvYXRWYWx1ZTogW10sXG4gIFN0cmluZ1ZhbHVlOiBbXSxcbiAgQm9vbGVhblZhbHVlOiBbXSxcbiAgTnVsbFZhbHVlOiBbXSxcbiAgRW51bVZhbHVlOiBbXSxcbiAgTGlzdFZhbHVlOiBbJ3ZhbHVlcyddLFxuICBPYmplY3RWYWx1ZTogWydmaWVsZHMnXSxcbiAgT2JqZWN0RmllbGQ6IFsnbmFtZScsICd2YWx1ZSddLFxuICBEaXJlY3RpdmU6IFsnbmFtZScsICdhcmd1bWVudHMnXSxcbiAgTmFtZWRUeXBlOiBbJ25hbWUnXSxcbiAgTGlzdFR5cGU6IFsndHlwZSddLFxuICBOb25OdWxsVHlwZTogWyd0eXBlJ10sXG4gIFNjaGVtYURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnZGlyZWN0aXZlcycsICdvcGVyYXRpb25UeXBlcyddLFxuICBPcGVyYXRpb25UeXBlRGVmaW5pdGlvbjogWyd0eXBlJ10sXG4gIFNjYWxhclR5cGVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnZGlyZWN0aXZlcyddLFxuICBPYmplY3RUeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2ludGVyZmFjZXMnLCAnZGlyZWN0aXZlcycsICdmaWVsZHMnXSxcbiAgRmllbGREZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ3R5cGUnLCAnZGlyZWN0aXZlcyddLFxuICBJbnB1dFZhbHVlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ3R5cGUnLCAnZGVmYXVsdFZhbHVlJywgJ2RpcmVjdGl2ZXMnXSxcbiAgSW50ZXJmYWNlVHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdpbnRlcmZhY2VzJywgJ2RpcmVjdGl2ZXMnLCAnZmllbGRzJ10sXG4gIFVuaW9uVHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJywgJ3R5cGVzJ10sXG4gIEVudW1UeXBlRGVmaW5pdGlvbjogWydkZXNjcmlwdGlvbicsICduYW1lJywgJ2RpcmVjdGl2ZXMnLCAndmFsdWVzJ10sXG4gIEVudW1WYWx1ZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJ10sXG4gIElucHV0T2JqZWN0VHlwZURlZmluaXRpb246IFsnZGVzY3JpcHRpb24nLCAnbmFtZScsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxuICBEaXJlY3RpdmVEZWZpbml0aW9uOiBbJ2Rlc2NyaXB0aW9uJywgJ25hbWUnLCAnYXJndW1lbnRzJywgJ2xvY2F0aW9ucyddLFxuICBTY2hlbWFFeHRlbnNpb246IFsnZGlyZWN0aXZlcycsICdvcGVyYXRpb25UeXBlcyddLFxuICBTY2FsYXJUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcyddLFxuICBPYmplY3RUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnaW50ZXJmYWNlcycsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxuICBJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnaW50ZXJmYWNlcycsICdkaXJlY3RpdmVzJywgJ2ZpZWxkcyddLFxuICBVbmlvblR5cGVFeHRlbnNpb246IFsnbmFtZScsICdkaXJlY3RpdmVzJywgJ3R5cGVzJ10sXG4gIEVudW1UeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcycsICd2YWx1ZXMnXSxcbiAgSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uOiBbJ25hbWUnLCAnZGlyZWN0aXZlcycsICdmaWVsZHMnXVxufTtcbmV4cG9ydCB2YXIgQlJFQUsgPSBPYmplY3QuZnJlZXplKHt9KTtcbi8qKlxuICogdmlzaXQoKSB3aWxsIHdhbGsgdGhyb3VnaCBhbiBBU1QgdXNpbmcgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwsIGNhbGxpbmdcbiAqIHRoZSB2aXNpdG9yJ3MgZW50ZXIgZnVuY3Rpb24gYXQgZWFjaCBub2RlIGluIHRoZSB0cmF2ZXJzYWwsIGFuZCBjYWxsaW5nIHRoZVxuICogbGVhdmUgZnVuY3Rpb24gYWZ0ZXIgdmlzaXRpbmcgdGhhdCBub2RlIGFuZCBhbGwgb2YgaXRzIGNoaWxkIG5vZGVzLlxuICpcbiAqIEJ5IHJldHVybmluZyBkaWZmZXJlbnQgdmFsdWVzIGZyb20gdGhlIGVudGVyIGFuZCBsZWF2ZSBmdW5jdGlvbnMsIHRoZVxuICogYmVoYXZpb3Igb2YgdGhlIHZpc2l0b3IgY2FuIGJlIGFsdGVyZWQsIGluY2x1ZGluZyBza2lwcGluZyBvdmVyIGEgc3ViLXRyZWUgb2ZcbiAqIHRoZSBBU1QgKGJ5IHJldHVybmluZyBmYWxzZSksIGVkaXRpbmcgdGhlIEFTVCBieSByZXR1cm5pbmcgYSB2YWx1ZSBvciBudWxsXG4gKiB0byByZW1vdmUgdGhlIHZhbHVlLCBvciB0byBzdG9wIHRoZSB3aG9sZSB0cmF2ZXJzYWwgYnkgcmV0dXJuaW5nIEJSRUFLLlxuICpcbiAqIFdoZW4gdXNpbmcgdmlzaXQoKSB0byBlZGl0IGFuIEFTVCwgdGhlIG9yaWdpbmFsIEFTVCB3aWxsIG5vdCBiZSBtb2RpZmllZCwgYW5kXG4gKiBhIG5ldyB2ZXJzaW9uIG9mIHRoZSBBU1Qgd2l0aCB0aGUgY2hhbmdlcyBhcHBsaWVkIHdpbGwgYmUgcmV0dXJuZWQgZnJvbSB0aGVcbiAqIHZpc2l0IGZ1bmN0aW9uLlxuICpcbiAqICAgICBjb25zdCBlZGl0ZWRBU1QgPSB2aXNpdChhc3QsIHtcbiAqICAgICAgIGVudGVyKG5vZGUsIGtleSwgcGFyZW50LCBwYXRoLCBhbmNlc3RvcnMpIHtcbiAqICAgICAgICAgLy8gQHJldHVyblxuICogICAgICAgICAvLyAgIHVuZGVmaW5lZDogbm8gYWN0aW9uXG4gKiAgICAgICAgIC8vICAgZmFsc2U6IHNraXAgdmlzaXRpbmcgdGhpcyBub2RlXG4gKiAgICAgICAgIC8vICAgdmlzaXRvci5CUkVBSzogc3RvcCB2aXNpdGluZyBhbHRvZ2V0aGVyXG4gKiAgICAgICAgIC8vICAgbnVsbDogZGVsZXRlIHRoaXMgbm9kZVxuICogICAgICAgICAvLyAgIGFueSB2YWx1ZTogcmVwbGFjZSB0aGlzIG5vZGUgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWVcbiAqICAgICAgIH0sXG4gKiAgICAgICBsZWF2ZShub2RlLCBrZXksIHBhcmVudCwgcGF0aCwgYW5jZXN0b3JzKSB7XG4gKiAgICAgICAgIC8vIEByZXR1cm5cbiAqICAgICAgICAgLy8gICB1bmRlZmluZWQ6IG5vIGFjdGlvblxuICogICAgICAgICAvLyAgIGZhbHNlOiBubyBhY3Rpb25cbiAqICAgICAgICAgLy8gICB2aXNpdG9yLkJSRUFLOiBzdG9wIHZpc2l0aW5nIGFsdG9nZXRoZXJcbiAqICAgICAgICAgLy8gICBudWxsOiBkZWxldGUgdGhpcyBub2RlXG4gKiAgICAgICAgIC8vICAgYW55IHZhbHVlOiByZXBsYWNlIHRoaXMgbm9kZSB3aXRoIHRoZSByZXR1cm5lZCB2YWx1ZVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIEFsdGVybmF0aXZlbHkgdG8gcHJvdmlkaW5nIGVudGVyKCkgYW5kIGxlYXZlKCkgZnVuY3Rpb25zLCBhIHZpc2l0b3IgY2FuXG4gKiBpbnN0ZWFkIHByb3ZpZGUgZnVuY3Rpb25zIG5hbWVkIHRoZSBzYW1lIGFzIHRoZSBraW5kcyBvZiBBU1Qgbm9kZXMsIG9yXG4gKiBlbnRlci9sZWF2ZSB2aXNpdG9ycyBhdCBhIG5hbWVkIGtleSwgbGVhZGluZyB0byBmb3VyIHBlcm11dGF0aW9ucyBvZiB0aGVcbiAqIHZpc2l0b3IgQVBJOlxuICpcbiAqIDEpIE5hbWVkIHZpc2l0b3JzIHRyaWdnZXJlZCB3aGVuIGVudGVyaW5nIGEgbm9kZSBvZiBhIHNwZWNpZmljIGtpbmQuXG4gKlxuICogICAgIHZpc2l0KGFzdCwge1xuICogICAgICAgS2luZChub2RlKSB7XG4gKiAgICAgICAgIC8vIGVudGVyIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiAyKSBOYW1lZCB2aXNpdG9ycyB0aGF0IHRyaWdnZXIgdXBvbiBlbnRlcmluZyBhbmQgbGVhdmluZyBhIG5vZGUgb2ZcbiAqICAgIGEgc3BlY2lmaWMga2luZC5cbiAqXG4gKiAgICAgdmlzaXQoYXN0LCB7XG4gKiAgICAgICBLaW5kOiB7XG4gKiAgICAgICAgIGVudGVyKG5vZGUpIHtcbiAqICAgICAgICAgICAvLyBlbnRlciB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgICAgICB9XG4gKiAgICAgICAgIGxlYXZlKG5vZGUpIHtcbiAqICAgICAgICAgICAvLyBsZWF2ZSB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiAzKSBHZW5lcmljIHZpc2l0b3JzIHRoYXQgdHJpZ2dlciB1cG9uIGVudGVyaW5nIGFuZCBsZWF2aW5nIGFueSBub2RlLlxuICpcbiAqICAgICB2aXNpdChhc3QsIHtcbiAqICAgICAgIGVudGVyKG5vZGUpIHtcbiAqICAgICAgICAgLy8gZW50ZXIgYW55IG5vZGVcbiAqICAgICAgIH0sXG4gKiAgICAgICBsZWF2ZShub2RlKSB7XG4gKiAgICAgICAgIC8vIGxlYXZlIGFueSBub2RlXG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiA0KSBQYXJhbGxlbCB2aXNpdG9ycyBmb3IgZW50ZXJpbmcgYW5kIGxlYXZpbmcgbm9kZXMgb2YgYSBzcGVjaWZpYyBraW5kLlxuICpcbiAqICAgICB2aXNpdChhc3QsIHtcbiAqICAgICAgIGVudGVyOiB7XG4gKiAgICAgICAgIEtpbmQobm9kZSkge1xuICogICAgICAgICAgIC8vIGVudGVyIHRoZSBcIktpbmRcIiBub2RlXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICBsZWF2ZToge1xuICogICAgICAgICBLaW5kKG5vZGUpIHtcbiAqICAgICAgICAgICAvLyBsZWF2ZSB0aGUgXCJLaW5kXCIgbm9kZVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmlzaXQocm9vdCwgdmlzaXRvcikge1xuICB2YXIgdmlzaXRvcktleXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFF1ZXJ5RG9jdW1lbnRLZXlzO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmLWluaXQgKi9cbiAgdmFyIHN0YWNrID0gdW5kZWZpbmVkO1xuICB2YXIgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkocm9vdCk7XG4gIHZhciBrZXlzID0gW3Jvb3RdO1xuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGVkaXRzID0gW107XG4gIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuICB2YXIgcGFyZW50ID0gdW5kZWZpbmVkO1xuICB2YXIgcGF0aCA9IFtdO1xuICB2YXIgYW5jZXN0b3JzID0gW107XG4gIHZhciBuZXdSb290ID0gcm9vdDtcbiAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZi1pbml0ICovXG5cbiAgZG8ge1xuICAgIGluZGV4Kys7XG4gICAgdmFyIGlzTGVhdmluZyA9IGluZGV4ID09PSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaXNFZGl0ZWQgPSBpc0xlYXZpbmcgJiYgZWRpdHMubGVuZ3RoICE9PSAwO1xuXG4gICAgaWYgKGlzTGVhdmluZykge1xuICAgICAga2V5ID0gYW5jZXN0b3JzLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBhbmNlc3RvcnMucG9wKCk7XG5cbiAgICAgIGlmIChpc0VkaXRlZCkge1xuICAgICAgICBpZiAoaW5BcnJheSkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNsaWNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNsb25lID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGtleXMyID0gT2JqZWN0LmtleXMobm9kZSk7IF9pMiA8IF9PYmplY3Qka2V5czIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgdmFyIGsgPSBfT2JqZWN0JGtleXMyW19pMl07XG4gICAgICAgICAgICBjbG9uZVtrXSA9IG5vZGVba107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZSA9IGNsb25lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRPZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBlZGl0cy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgICB2YXIgZWRpdEtleSA9IGVkaXRzW2lpXVswXTtcbiAgICAgICAgICB2YXIgZWRpdFZhbHVlID0gZWRpdHNbaWldWzFdO1xuXG4gICAgICAgICAgaWYgKGluQXJyYXkpIHtcbiAgICAgICAgICAgIGVkaXRLZXkgLT0gZWRpdE9mZnNldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5BcnJheSAmJiBlZGl0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuc3BsaWNlKGVkaXRLZXksIDEpO1xuICAgICAgICAgICAgZWRpdE9mZnNldCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlW2VkaXRLZXldID0gZWRpdFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbmRleCA9IHN0YWNrLmluZGV4O1xuICAgICAga2V5cyA9IHN0YWNrLmtleXM7XG4gICAgICBlZGl0cyA9IHN0YWNrLmVkaXRzO1xuICAgICAgaW5BcnJheSA9IHN0YWNrLmluQXJyYXk7XG4gICAgICBzdGFjayA9IHN0YWNrLnByZXY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHBhcmVudCA/IGluQXJyYXkgPyBpbmRleCA6IGtleXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgbm9kZSA9IHBhcmVudCA/IHBhcmVudFtrZXldIDogbmV3Um9vdDtcblxuICAgICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGlmICghaXNOb2RlKG5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQVNUIE5vZGU6IFwiLmNvbmNhdChpbnNwZWN0KG5vZGUpLCBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmlzaXRGbiA9IGdldFZpc2l0Rm4odmlzaXRvciwgbm9kZS5raW5kLCBpc0xlYXZpbmcpO1xuXG4gICAgICBpZiAodmlzaXRGbikge1xuICAgICAgICByZXN1bHQgPSB2aXNpdEZuLmNhbGwodmlzaXRvciwgbm9kZSwga2V5LCBwYXJlbnQsIHBhdGgsIGFuY2VzdG9ycyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGl0cy5wdXNoKFtrZXksIHJlc3VsdF0pO1xuXG4gICAgICAgICAgaWYgKCFpc0xlYXZpbmcpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGUocmVzdWx0KSkge1xuICAgICAgICAgICAgICBub2RlID0gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGlzRWRpdGVkKSB7XG4gICAgICBlZGl0cy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNMZWF2aW5nKSB7XG4gICAgICBwYXRoLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3Zpc2l0b3JLZXlzJG5vZGUka2luO1xuXG4gICAgICBzdGFjayA9IHtcbiAgICAgICAgaW5BcnJheTogaW5BcnJheSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBrZXlzOiBrZXlzLFxuICAgICAgICBlZGl0czogZWRpdHMsXG4gICAgICAgIHByZXY6IHN0YWNrXG4gICAgICB9O1xuICAgICAgaW5BcnJheSA9IEFycmF5LmlzQXJyYXkobm9kZSk7XG4gICAgICBrZXlzID0gaW5BcnJheSA/IG5vZGUgOiAoX3Zpc2l0b3JLZXlzJG5vZGUka2luID0gdmlzaXRvcktleXNbbm9kZS5raW5kXSkgIT09IG51bGwgJiYgX3Zpc2l0b3JLZXlzJG5vZGUka2luICE9PSB2b2lkIDAgPyBfdmlzaXRvcktleXMkbm9kZSRraW4gOiBbXTtcbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICBlZGl0cyA9IFtdO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgfVxuICB9IHdoaWxlIChzdGFjayAhPT0gdW5kZWZpbmVkKTtcblxuICBpZiAoZWRpdHMubGVuZ3RoICE9PSAwKSB7XG4gICAgbmV3Um9vdCA9IGVkaXRzW2VkaXRzLmxlbmd0aCAtIDFdWzFdO1xuICB9XG5cbiAgcmV0dXJuIG5ld1Jvb3Q7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmlzaXRvciBpbnN0YW5jZSB3aGljaCBkZWxlZ2F0ZXMgdG8gbWFueSB2aXNpdG9ycyB0byBydW4gaW5cbiAqIHBhcmFsbGVsLiBFYWNoIHZpc2l0b3Igd2lsbCBiZSB2aXNpdGVkIGZvciBlYWNoIG5vZGUgYmVmb3JlIG1vdmluZyBvbi5cbiAqXG4gKiBJZiBhIHByaW9yIHZpc2l0b3IgZWRpdHMgYSBub2RlLCBubyBmb2xsb3dpbmcgdmlzaXRvcnMgd2lsbCBzZWUgdGhhdCBub2RlLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB2aXNpdEluUGFyYWxsZWwodmlzaXRvcnMpIHtcbiAgdmFyIHNraXBwaW5nID0gbmV3IEFycmF5KHZpc2l0b3JzLmxlbmd0aCk7XG4gIHJldHVybiB7XG4gICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKG5vZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNraXBwaW5nW2ldID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm4gPSBnZXRWaXNpdEZuKHZpc2l0b3JzW2ldLCBub2RlLmtpbmQsXG4gICAgICAgICAgLyogaXNMZWF2aW5nICovXG4gICAgICAgICAgZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkodmlzaXRvcnNbaV0sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHNraXBwaW5nW2ldID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICBza2lwcGluZ1tpXSA9IEJSRUFLO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGVhdmU6IGZ1bmN0aW9uIGxlYXZlKG5vZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNraXBwaW5nW2ldID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm4gPSBnZXRWaXNpdEZuKHZpc2l0b3JzW2ldLCBub2RlLmtpbmQsXG4gICAgICAgICAgLyogaXNMZWF2aW5nICovXG4gICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh2aXNpdG9yc1tpXSwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgc2tpcHBpbmdbaV0gPSBCUkVBSztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChza2lwcGluZ1tpXSA9PT0gbm9kZSkge1xuICAgICAgICAgIHNraXBwaW5nW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogR2l2ZW4gYSB2aXNpdG9yIGluc3RhbmNlLCBpZiBpdCBpcyBsZWF2aW5nIG9yIG5vdCwgYW5kIGEgbm9kZSBraW5kLCByZXR1cm5cbiAqIHRoZSBmdW5jdGlvbiB0aGUgdmlzaXRvciBydW50aW1lIHNob3VsZCBjYWxsLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaXNpdEZuKHZpc2l0b3IsIGtpbmQsIGlzTGVhdmluZykge1xuICB2YXIga2luZFZpc2l0b3IgPSB2aXNpdG9yW2tpbmRdO1xuXG4gIGlmIChraW5kVmlzaXRvcikge1xuICAgIGlmICghaXNMZWF2aW5nICYmIHR5cGVvZiBraW5kVmlzaXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8geyBLaW5kKCkge30gfVxuICAgICAgcmV0dXJuIGtpbmRWaXNpdG9yO1xuICAgIH1cblxuICAgIHZhciBraW5kU3BlY2lmaWNWaXNpdG9yID0gaXNMZWF2aW5nID8ga2luZFZpc2l0b3IubGVhdmUgOiBraW5kVmlzaXRvci5lbnRlcjtcblxuICAgIGlmICh0eXBlb2Yga2luZFNwZWNpZmljVmlzaXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8geyBLaW5kOiB7IGVudGVyKCkge30sIGxlYXZlKCkge30gfSB9XG4gICAgICByZXR1cm4ga2luZFNwZWNpZmljVmlzaXRvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNwZWNpZmljVmlzaXRvciA9IGlzTGVhdmluZyA/IHZpc2l0b3IubGVhdmUgOiB2aXNpdG9yLmVudGVyO1xuXG4gICAgaWYgKHNwZWNpZmljVmlzaXRvcikge1xuICAgICAgaWYgKHR5cGVvZiBzcGVjaWZpY1Zpc2l0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8geyBlbnRlcigpIHt9LCBsZWF2ZSgpIHt9IH1cbiAgICAgICAgcmV0dXJuIHNwZWNpZmljVmlzaXRvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNwZWNpZmljS2luZFZpc2l0b3IgPSBzcGVjaWZpY1Zpc2l0b3Jba2luZF07XG5cbiAgICAgIGlmICh0eXBlb2Ygc3BlY2lmaWNLaW5kVmlzaXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyB7IGVudGVyOiB7IEtpbmQoKSB7fSB9LCBsZWF2ZTogeyBLaW5kKCkge30gfSB9XG4gICAgICAgIHJldHVybiBzcGVjaWZpY0tpbmRWaXNpdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOXwjOTYpOy9nLFxuICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xudmFyIGh0bWxVbmVzY2FwZXMgPSB7XG4gICcmYW1wOyc6ICcmJyxcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyYjMzk7JzogXCInXCIsXG4gICcmIzk2Oyc6ICdgJ1xufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xudmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGAmIzM5O2AsIGFuZCBgJiM5NjtgIGluIGBzdHJpbmdgIHRvXG4gKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gKlxuICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxuICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjYuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmVzY2FwZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gQ2FjaGUgKCkge1xuICB2YXIgX2NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIF9oaXRDb3VudCA9IDA7XG4gIHZhciBfbWlzc0NvdW50ID0gMDtcbiAgdmFyIF9zaXplID0gMDtcbiAgdmFyIF9kZWJ1ZyA9IGZhbHNlO1xuXG4gIHRoaXMucHV0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgdGltZSwgdGltZW91dENhbGxiYWNrKSB7XG4gICAgaWYgKF9kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coJ2NhY2hpbmc6ICVzID0gJWogKEAlcyknLCBrZXksIHZhbHVlLCB0aW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRpbWUgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgdGltZSAhPT0gJ251bWJlcicgfHwgaXNOYU4odGltZSkgfHwgdGltZSA8PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZSB0aW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aW1lb3V0Q2FsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0aW1lb3V0Q2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FjaGUgdGltZW91dCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkUmVjb3JkID0gX2NhY2hlW2tleV07XG4gICAgaWYgKG9sZFJlY29yZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KG9sZFJlY29yZC50aW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3NpemUrKztcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZXhwaXJlOiB0aW1lICsgRGF0ZS5ub3coKVxuICAgIH07XG5cbiAgICBpZiAoIWlzTmFOKHJlY29yZC5leHBpcmUpKSB7XG4gICAgICByZWNvcmQudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF9kZWwoa2V5KTtcbiAgICAgICAgaWYgKHRpbWVvdXRDYWxsYmFjaykge1xuICAgICAgICAgIHRpbWVvdXRDYWxsYmFjayhrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLCB0aW1lKTtcbiAgICB9XG5cbiAgICBfY2FjaGVba2V5XSA9IHJlY29yZDtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB0aGlzLmRlbCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBjYW5EZWxldGUgPSB0cnVlO1xuXG4gICAgdmFyIG9sZFJlY29yZCA9IF9jYWNoZVtrZXldO1xuICAgIGlmIChvbGRSZWNvcmQpIHtcbiAgICAgIGNsZWFyVGltZW91dChvbGRSZWNvcmQudGltZW91dCk7XG4gICAgICBpZiAoIWlzTmFOKG9sZFJlY29yZC5leHBpcmUpICYmIG9sZFJlY29yZC5leHBpcmUgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgIGNhbkRlbGV0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYW5EZWxldGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY2FuRGVsZXRlKSB7XG4gICAgICBfZGVsKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbkRlbGV0ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBfZGVsKGtleSl7XG4gICAgX3NpemUtLTtcbiAgICBkZWxldGUgX2NhY2hlW2tleV07XG4gIH1cblxuICB0aGlzLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIga2V5IGluIF9jYWNoZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KF9jYWNoZVtrZXldLnRpbWVvdXQpO1xuICAgIH1cbiAgICBfc2l6ZSA9IDA7XG4gICAgX2NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoX2RlYnVnKSB7XG4gICAgICBfaGl0Q291bnQgPSAwO1xuICAgICAgX21pc3NDb3VudCA9IDA7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGRhdGEgPSBfY2FjaGVba2V5XTtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGlzTmFOKGRhdGEuZXhwaXJlKSB8fCBkYXRhLmV4cGlyZSA+PSBEYXRlLm5vdygpKSB7XG4gICAgICAgIGlmIChfZGVidWcpIF9oaXRDb3VudCsrO1xuICAgICAgICByZXR1cm4gZGF0YS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZyZWUgc29tZSBzcGFjZVxuICAgICAgICBpZiAoX2RlYnVnKSBfbWlzc0NvdW50Kys7XG4gICAgICAgIF9zaXplLS07XG4gICAgICAgIGRlbGV0ZSBfY2FjaGVba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9kZWJ1Zykge1xuICAgICAgX21pc3NDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB0aGlzLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX3NpemU7XG4gIH07XG5cbiAgdGhpcy5tZW1zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNpemUgPSAwLFxuICAgICAga2V5O1xuICAgIGZvciAoa2V5IGluIF9jYWNoZSkge1xuICAgICAgc2l6ZSsrO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfTtcblxuICB0aGlzLmRlYnVnID0gZnVuY3Rpb24oYm9vbCkge1xuICAgIF9kZWJ1ZyA9IGJvb2w7XG4gIH07XG5cbiAgdGhpcy5oaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9oaXRDb3VudDtcbiAgfTtcblxuICB0aGlzLm1pc3NlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfbWlzc0NvdW50O1xuICB9O1xuXG4gIHRoaXMua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhfY2FjaGUpO1xuICB9O1xuXG4gIHRoaXMuZXhwb3J0SnNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwbGFpbkpzQ2FjaGUgPSB7fTtcblxuICAgIC8vIERpc2NhcmQgdGhlIGB0aW1lb3V0YCBwcm9wZXJ0eS5cbiAgICAvLyBOb3RlOiBKU09OIGRvZXNuJ3Qgc3VwcG9ydCBgTmFOYCwgc28gY29udmVydCBpdCB0byBgJ05hTidgLlxuICAgIGZvciAodmFyIGtleSBpbiBfY2FjaGUpIHtcbiAgICAgIHZhciByZWNvcmQgPSBfY2FjaGVba2V5XTtcbiAgICAgIHBsYWluSnNDYWNoZVtrZXldID0ge1xuICAgICAgICB2YWx1ZTogcmVjb3JkLnZhbHVlLFxuICAgICAgICBleHBpcmU6IHJlY29yZC5leHBpcmUgfHwgJ05hTicsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGFpbkpzQ2FjaGUpO1xuICB9O1xuXG4gIHRoaXMuaW1wb3J0SnNvbiA9IGZ1bmN0aW9uKGpzb25Ub0ltcG9ydCwgb3B0aW9ucykge1xuICAgIHZhciBjYWNoZVRvSW1wb3J0ID0gSlNPTi5wYXJzZShqc29uVG9JbXBvcnQpO1xuICAgIHZhciBjdXJyVGltZSA9IERhdGUubm93KCk7XG5cbiAgICB2YXIgc2tpcER1cGxpY2F0ZXMgPSBvcHRpb25zICYmIG9wdGlvbnMuc2tpcER1cGxpY2F0ZXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGVUb0ltcG9ydCkge1xuICAgICAgaWYgKGNhY2hlVG9JbXBvcnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoc2tpcER1cGxpY2F0ZXMpIHtcbiAgICAgICAgICB2YXIgZXhpc3RpbmdSZWNvcmQgPSBfY2FjaGVba2V5XTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdSZWNvcmQpIHtcbiAgICAgICAgICAgIGlmIChfZGVidWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1NraXBwaW5nIGR1cGxpY2F0ZSBpbXBvcnRlZCBrZXkgXFwnJXNcXCcnLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IGNhY2hlVG9JbXBvcnRba2V5XTtcblxuICAgICAgICAvLyByZWNvcmQuZXhwaXJlIGNvdWxkIGJlIGAnTmFOJ2AgaWYgbm8gZXhwaXJ5IHdhcyBzZXQuXG4gICAgICAgIC8vIFRyeSB0byBzdWJ0cmFjdCBmcm9tIGl0OyBhIHN0cmluZyBtaW51cyBhIG51bWJlciBpcyBgTmFOYCwgd2hpY2ggaXMgcGVyZmVjdGx5IGZpbmUgaGVyZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZ1RpbWUgPSByZWNvcmQuZXhwaXJlIC0gY3VyclRpbWU7XG5cbiAgICAgICAgaWYgKHJlbWFpbmluZ1RpbWUgPD0gMCkge1xuICAgICAgICAgIC8vIERlbGV0ZSBhbnkgcmVjb3JkIHRoYXQgbWlnaHQgZXhpc3Qgd2l0aCB0aGUgc2FtZSBrZXksIHNpbmNlIHRoaXMga2V5IGlzIGV4cGlyZWQuXG4gICAgICAgICAgdGhpcy5kZWwoa2V5KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbWFpbmluZyB0aW1lIG11c3Qgbm93IGJlIGVpdGhlciBwb3NpdGl2ZSBvciBgTmFOYCxcbiAgICAgICAgLy8gYnV0IGBwdXRgIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIGdpdmUgaXQgYE5hTmAuXG4gICAgICAgIHJlbWFpbmluZ1RpbWUgPSByZW1haW5pbmdUaW1lID4gMCA/IHJlbWFpbmluZ1RpbWUgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5wdXQoa2V5LCByZWNvcmQudmFsdWUsIHJlbWFpbmluZ1RpbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNpemUoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ2FjaGUoKTtcbm1vZHVsZS5leHBvcnRzLkNhY2hlID0gQ2FjaGU7XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZUVmZmVjdCwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCByb3NldHRhIGZyb20gJ3Jvc2V0dGEnO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgSTE4bkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG52YXIgSTE4biA9IGZ1bmN0aW9uIEkxOG4ocm9zZXR0YU9wdHMpIHtcbiAgdmFyIHIgPSByb3NldHRhKHJvc2V0dGFPcHRzKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhIHJlbmRlciBjeWNsZVxuICAgICAqL1xuICAgIF9vblVwZGF0ZTogZnVuY3Rpb24gX29uVXBkYXRlKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIHRyYW5zbGF0aW9uIHNlZ21lbnQgZm9yIHRoZSBhY3RpdmUgbGFuZ3VhZ2VcbiAgICAgKi9cbiAgICB0OiByLnQsXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRhYmxlIG9mIHRyYW5zbGF0aW9ucyBmb3IgYSBsYW5ndWFnZVxuICAgICAqL1xuICAgIHRhYmxlOiByLnRhYmxlLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIG9yIGV4dGVuZCB0aGUgbGFuZ3VhZ2UgdGFibGVcbiAgICAgKi9cbiAgICBzZXQ6IHIuc2V0LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgbG9jYWxlIG9yIHJldHVybnMgdGhlIGFjdGl2ZSBsb2NhbGVcbiAgICAgKi9cbiAgICBsb2NhbGU6IGZ1bmN0aW9uIGxvY2FsZShfbG9jYWxlKSB7XG4gICAgICBpZiAoX2xvY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByLmxvY2FsZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWN0aXZlbG9jYWxlID0gci5sb2NhbGUoX2xvY2FsZSk7XG5cbiAgICAgIHRoaXMuX29uVXBkYXRlKCk7XG5cbiAgICAgIHJldHVybiBhY3RpdmVsb2NhbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaTE4biBpbnN0YW5jZSB0aGF0IHRyZWF0cyBudW1iZXIgdmFsdWVzIGFzIHBsdXJhbGl6YXRpb25cbiAgICAgKi9cbiAgICB3aXRoUGx1cmFsOiBmdW5jdGlvbiB3aXRoUGx1cmFsKHBsdXJhbFJ1bGVzT3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHBsdXJhbFJ1bGVzT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBsdXJhbFJ1bGVzT3B0aW9ucyA9IHtcbiAgICAgICAgICB0eXBlOiAnb3JkaW5hbCdcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIFBSID0gbmV3IEludGwuUGx1cmFsUnVsZXMoci5sb2NhbGUoKSwgcGx1cmFsUnVsZXNPcHRpb25zKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1trXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBwa2V5ID0gUFIuc2VsZWN0KHBhcmFtc1trXSk7XG4gICAgICAgICAgICBwYXJhbXNba10gPSBfdGhpcy50KGsgKyBcIi5cIiArIHBrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcy50LmFwcGx5KF90aGlzLCBba2V5LCBwYXJhbXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIEkxOG5Qcm92aWRlcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBfcmVmJGxvY2FsZSA9IF9yZWYubG9jYWxlLFxuICAgICAgbG9jYWxlID0gX3JlZiRsb2NhbGUgPT09IHZvaWQgMCA/ICdlbicgOiBfcmVmJGxvY2FsZSxcbiAgICAgIGxuZ0RpY3QgPSBfcmVmLmxuZ0RpY3QsXG4gICAgICBpMThuSW5zdGFuY2UgPSBfcmVmLmkxOG5JbnN0YW5jZTtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoMCksXG4gICAgICBzZXRUaWNrID0gX3VzZVN0YXRlWzFdO1xuXG4gIHZhciBpMThuID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gaTE4bkluc3RhbmNlICE9IG51bGwgPyBpMThuSW5zdGFuY2UgOiBJMThuKCk7XG5cbiAgICBpbnN0YW5jZS5fb25VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2V0VGljayhmdW5jdGlvbiAodGljaykge1xuICAgICAgICByZXR1cm4gdGljayArIDE7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2Uuc2V0KGxvY2FsZSwgbG5nRGljdCk7XG4gICAgaW5zdGFuY2UubG9jYWxlKGxvY2FsZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtpMThuSW5zdGFuY2VdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpMThuLnNldChsb2NhbGUsIGxuZ0RpY3QpO1xuICAgIGkxOG4ubG9jYWxlKGxvY2FsZSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2xvY2FsZSwgbG5nRGljdF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSTE4bkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogX2V4dGVuZHMoe30sIGkxOG4pXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gdXNlSTE4bigpIHtcbiAgdmFyIGkxOG4gPSB1c2VDb250ZXh0KEkxOG5Db250ZXh0KTtcbiAgcmV0dXJuIGkxOG47XG59XG5cbmV4cG9ydCB7IEkxOG4sIEkxOG5Qcm92aWRlciwgdXNlSTE4biB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIGFzc2lnbj1PYmplY3QuYXNzaWduLmJpbmQoT2JqZWN0KTttb2R1bGUuZXhwb3J0cz1hc3NpZ247bW9kdWxlLmV4cG9ydHMuZGVmYXVsdD1tb2R1bGUuZXhwb3J0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC1hc3NpZ24uanMubWFwIiwiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9bWy4uLnBhdGhdXVwiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIkQ6XFxcXHByb2plY3RzXFxcXGpzc1xcXFxuZXh0anNvbmF6dXJlXFxcXHBhY2thZ2VzXFxcXGpzcy1uZXh0anMtYXBwXFxcXHNyY1xcXFxwYWdlc1xcXFxbWy4uLnBhdGhdXS50c3hcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICIsImltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBhZGRCYXNlUGF0aCxcbiAgYWRkTG9jYWxlLFxuICBpc0xvY2FsVVJMLFxuICBOZXh0Um91dGVyLFxuICBQcmVmZXRjaE9wdGlvbnMsXG4gIHJlc29sdmVIcmVmLFxufSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgdXNlSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi91c2UtaW50ZXJzZWN0aW9uJ1xuXG50eXBlIFVybCA9IHN0cmluZyB8IFVybE9iamVjdFxudHlwZSBSZXF1aXJlZEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IG5ldmVyIDogS1xufVtrZXlvZiBUXVxudHlwZSBPcHRpb25hbEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IEsgOiBuZXZlclxufVtrZXlvZiBUXVxuXG5leHBvcnQgdHlwZSBMaW5rUHJvcHMgPSB7XG4gIGhyZWY6IFVybFxuICBhcz86IFVybFxuICByZXBsYWNlPzogYm9vbGVhblxuICBzY3JvbGw/OiBib29sZWFuXG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuICBwcmVmZXRjaD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbn1cbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxMaW5rUHJvcHM+XG5cbmNvbnN0IHByZWZldGNoZWQ6IHsgW2NhY2hlS2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fVxuXG5mdW5jdGlvbiBwcmVmZXRjaChcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnNcbik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9KVxuICBjb25zdCBjdXJMb2NhbGUgPVxuICAgIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgPyBvcHRpb25zLmxvY2FsZVxuICAgICAgOiByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZVxuXG4gIC8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG4gIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV0gPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudDogUmVhY3QuTW91c2VFdmVudCkge1xuICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudFxuICByZXR1cm4gKFxuICAgICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnKSB8fFxuICAgIGV2ZW50Lm1ldGFLZXkgfHxcbiAgICBldmVudC5jdHJsS2V5IHx8XG4gICAgZXZlbnQuc2hpZnRLZXkgfHxcbiAgICBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICAoZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDIpXG4gIClcbn1cblxuZnVuY3Rpb24gbGlua0NsaWNrZWQoXG4gIGU6IFJlYWN0Lk1vdXNlRXZlbnQsXG4gIHJvdXRlcjogTmV4dFJvdXRlcixcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICByZXBsYWNlPzogYm9vbGVhbixcbiAgc2hhbGxvdz86IGJvb2xlYW4sXG4gIHNjcm9sbD86IGJvb2xlYW4sXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4pOiB2b2lkIHtcbiAgY29uc3QgeyBub2RlTmFtZSB9ID0gZS5jdXJyZW50VGFyZ2V0XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQScgJiYgKGlzTW9kaWZpZWRFdmVudChlKSB8fCAhaXNMb2NhbFVSTChocmVmKSkpIHtcbiAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICByZXR1cm5cbiAgfVxuXG4gIGUucHJldmVudERlZmF1bHQoKVxuXG4gIC8vICBhdm9pZCBzY3JvbGwgZm9yIHVybHMgd2l0aCBhbmNob3IgcmVmc1xuICBpZiAoc2Nyb2xsID09IG51bGwpIHtcbiAgICBzY3JvbGwgPSBhcy5pbmRleE9mKCcjJykgPCAwXG4gIH1cblxuICAvLyByZXBsYWNlIHN0YXRlIGluc3RlYWQgb2YgcHVzaCBpZiBwcm9wIGlzIHByZXNlbnRcbiAgcm91dGVyW3JlcGxhY2UgPyAncmVwbGFjZScgOiAncHVzaCddKGhyZWYsIGFzLCB7IHNoYWxsb3csIGxvY2FsZSB9KS50aGVuKFxuICAgIChzdWNjZXNzOiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAoIXN1Y2Nlc3MpIHJldHVyblxuICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpXG4gICAgICB9XG4gICAgfVxuICApXG59XG5cbmZ1bmN0aW9uIExpbmsocHJvcHM6IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPExpbmtQcm9wcz4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJnczoge1xuICAgICAga2V5OiBzdHJpbmdcbiAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgIGFjdHVhbDogc3RyaW5nXG4gICAgfSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgK1xuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgIDogJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNSZXF1aXJlZCwgdHJ1ZT4gPSB7XG4gICAgICBocmVmOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCByZXF1aXJlZFByb3BzOiBMaW5rUHJvcHNSZXF1aXJlZFtdID0gT2JqZWN0LmtleXMoXG4gICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzUmVxdWlyZWQpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSA9PSBudWxsIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICBhczogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgb3B0aW9uYWxQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNPcHRpb25hbFtdXG4gICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV1cblxuICAgICAgaWYgKGtleSA9PT0gJ2FzJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xvY2FsZScpIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAncmVwbGFjZScgfHxcbiAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICBrZXkgPT09ICdwYXNzSHJlZicgfHxcbiAgICAgICAga2V5ID09PSAncHJlZmV0Y2gnXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCBoYXNXYXJuZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpXG4gICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCdcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgY29uc3QgcCA9IHByb3BzLnByZWZldGNoICE9PSBmYWxzZVxuXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gIGNvbnN0IHBhdGhuYW1lID0gKHJvdXRlciAmJiByb3V0ZXIucGF0aG5hbWUpIHx8ICcvJ1xuXG4gIGNvbnN0IHsgaHJlZiwgYXMgfSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocGF0aG5hbWUsIHByb3BzLmhyZWYsIHRydWUpXG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHJlc29sdmVkSHJlZixcbiAgICAgIGFzOiBwcm9wcy5hc1xuICAgICAgICA/IHJlc29sdmVIcmVmKHBhdGhuYW1lLCBwcm9wcy5hcylcbiAgICAgICAgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZixcbiAgICB9XG4gIH0sIFtwYXRobmFtZSwgcHJvcHMuaHJlZiwgcHJvcHMuYXNdKVxuXG4gIGxldCB7IGNoaWxkcmVuLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSB9ID0gcHJvcHNcblxuICAvLyBEZXByZWNhdGVkLiBXYXJuaW5nIHNob3duIGJ5IHByb3BUeXBlIGNoZWNrLiBJZiB0aGUgY2hpbGRyZW4gcHJvdmlkZWQgaXMgYSBzdHJpbmcgKDxMaW5rPmV4YW1wbGU8L0xpbms+KSB3ZSB3cmFwIGl0IGluIGFuIDxhPiB0YWdcbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGlsZHJlbiA9IDxhPntjaGlsZHJlbn08L2E+XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgY29uc3QgY2hpbGQ6IGFueSA9IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gIGNvbnN0IGNoaWxkUmVmOiBhbnkgPSBjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZlxuXG4gIGNvbnN0IFtzZXRJbnRlcnNlY3Rpb25SZWYsIGlzVmlzaWJsZV0gPSB1c2VJbnRlcnNlY3Rpb24oe1xuICAgIHJvb3RNYXJnaW46ICcyMDBweCcsXG4gIH0pXG4gIGNvbnN0IHNldFJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChlbDogRWxlbWVudCkgPT4ge1xuICAgICAgc2V0SW50ZXJzZWN0aW9uUmVmKGVsKVxuICAgICAgaWYgKGNoaWxkUmVmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdmdW5jdGlvbicpIGNoaWxkUmVmKGVsKVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY2hpbGRSZWYuY3VycmVudCA9IGVsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtjaGlsZFJlZiwgc2V0SW50ZXJzZWN0aW9uUmVmXVxuICApXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkUHJlZmV0Y2ggPSBpc1Zpc2libGUgJiYgcCAmJiBpc0xvY2FsVVJMKGhyZWYpXG4gICAgY29uc3QgY3VyTG9jYWxlID1cbiAgICAgIHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGVcbiAgICBjb25zdCBpc1ByZWZldGNoZWQgPVxuICAgICAgcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXVxuICAgIGlmIChzaG91bGRQcmVmZXRjaCAmJiAhaXNQcmVmZXRjaGVkKSB7XG4gICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgIGxvY2FsZTogY3VyTG9jYWxlLFxuICAgICAgfSlcbiAgICB9XG4gIH0sIFthcywgaHJlZiwgaXNWaXNpYmxlLCBsb2NhbGUsIHAsIHJvdXRlcl0pXG5cbiAgY29uc3QgY2hpbGRQcm9wczoge1xuICAgIG9uTW91c2VFbnRlcj86IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgb25DbGljazogUmVhY3QuTW91c2VFdmVudEhhbmRsZXJcbiAgICBocmVmPzogc3RyaW5nXG4gICAgcmVmPzogYW55XG4gIH0gPSB7XG4gICAgcmVmOiBzZXRSZWYsXG4gICAgb25DbGljazogKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpXG4gICAgICB9XG4gICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwsIGxvY2FsZSlcbiAgICAgIH1cbiAgICB9LFxuICB9XG5cbiAgY2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIgPSAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKVxuICAgIH1cbiAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7IHByaW9yaXR5OiB0cnVlIH0pXG4gIH1cblxuICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgLy8gZGVmaW5lZCwgd2Ugc3BlY2lmeSB0aGUgY3VycmVudCAnaHJlZicsIHNvIHRoYXQgcmVwZXRpdGlvbiBpcyBub3QgbmVlZGVkIGJ5IHRoZSB1c2VyXG4gIGlmIChwcm9wcy5wYXNzSHJlZiB8fCAoY2hpbGQudHlwZSA9PT0gJ2EnICYmICEoJ2hyZWYnIGluIGNoaWxkLnByb3BzKSkpIHtcbiAgICBjaGlsZFByb3BzLmhyZWYgPSBhZGRCYXNlUGF0aChcbiAgICAgIGFkZExvY2FsZShcbiAgICAgICAgYXMsXG4gICAgICAgIHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGUsXG4gICAgICAgIHJvdXRlciAmJiByb3V0ZXIuZGVmYXVsdExvY2FsZVxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtcbiIsIi8qKlxuICogUmVtb3ZlcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGlmIHRoZXJlIGlzIG9uZS4gUHJlc2VydmVzIHRoZSByb290IHBhdGggYC9gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguZW5kc1dpdGgoJy8nKSAmJiBwYXRoICE9PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGhcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSB0cmFpbGluZyBzbGFzaCBvZiBhIHBhdGggYWNjb3JkaW5nIHRvIHRoZSBgdHJhaWxpbmdTbGFzaGAgb3B0aW9uXG4gKiBpbiBgbmV4dC5jb25maWcuanNgLlxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSBwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0hcbiAgPyAocGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIGlmICgvXFwuW14vXStcXC8/JC8udGVzdChwYXRoKSkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aClcbiAgICAgIH0gZWxzZSBpZiAocGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBwYXRoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvJ1xuICAgICAgfVxuICAgIH1cbiAgOiByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaFxuIiwidHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlID0gYW55XG50eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tPcHRpb25zID0ge1xuICB0aW1lb3V0OiBudW1iZXJcbn1cbnR5cGUgUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lID0ge1xuICByZWFkb25seSBkaWRUaW1lb3V0OiBib29sZWFuXG4gIHRpbWVSZW1haW5pbmc6ICgpID0+IG51bWJlclxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2s6IChcbiAgICAgIGNhbGxiYWNrOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZCxcbiAgICAgIG9wdHM/OiBSZXF1ZXN0SWRsZUNhbGxiYWNrT3B0aW9uc1xuICAgICkgPT4gUmVxdWVzdElkbGVDYWxsYmFja0hhbmRsZVxuICB9XG59XG5cbmNvbnN0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgPVxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjaykgfHxcbiAgZnVuY3Rpb24gKGNiOiAoZGVhZGxpbmU6IFJlcXVlc3RJZGxlQ2FsbGJhY2tEZWFkbGluZSkgPT4gdm9pZCkge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KClcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYih7XG4gICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0sIDEpXG4gIH1cblxuZXhwb3J0IGRlZmF1bHQgcmVxdWVzdElkbGVDYWxsYmFja1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBDbGllbnRCdWlsZE1hbmlmZXN0IH0gZnJvbSAnLi4vYnVpbGQvd2VicGFjay9wbHVnaW5zL2J1aWxkLW1hbmlmZXN0LXBsdWdpbidcbmltcG9ydCBnZXRBc3NldFBhdGhGcm9tUm91dGUgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlJ1xuaW1wb3J0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgZnJvbSAnLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2snXG5cbi8vIDMuOHMgd2FzIGFyYml0cmFyaWx5IGNob3NlbiBhcyBpdCdzIHdoYXQgaHR0cHM6Ly93ZWIuZGV2L2ludGVyYWN0aXZlXG4vLyBjb25zaWRlcnMgYXMgXCJHb29kXCIgdGltZS10by1pbnRlcmFjdGl2ZS4gV2UgbXVzdCBhc3N1bWUgc29tZXRoaW5nIHdlbnRcbi8vIHdyb25nIGJleW9uZCB0aGlzIHBvaW50LCBhbmQgdGhlbiBmYWxsLWJhY2sgdG8gYSBmdWxsIHBhZ2UgdHJhbnNpdGlvbiB0b1xuLy8gc2hvdyB0aGUgdXNlciBzb21ldGhpbmcgb2YgdmFsdWUuXG5jb25zdCBNU19NQVhfSURMRV9ERUxBWSA9IDM4MDBcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBfX0JVSUxEX01BTklGRVNUPzogQ2xpZW50QnVpbGRNYW5pZmVzdFxuICAgIF9fQlVJTERfTUFOSUZFU1RfQ0I/OiBGdW5jdGlvblxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3Mge1xuICBjb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgZXhwb3J0czogYW55XG59XG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZEVudHJ5cG9pbnRGYWlsdXJlIHtcbiAgZXJyb3I6IHVua25vd25cbn1cbmV4cG9ydCB0eXBlIFJvdXRlRW50cnlwb2ludCA9IExvYWRlZEVudHJ5cG9pbnRTdWNjZXNzIHwgTG9hZGVkRW50cnlwb2ludEZhaWx1cmVcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVN0eWxlU2hlZXQge1xuICBocmVmOiBzdHJpbmdcbiAgY29udGVudDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkUm91dGVTdWNjZXNzIGV4dGVuZHMgTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3Mge1xuICBzdHlsZXM6IFJvdXRlU3R5bGVTaGVldFtdXG59XG5leHBvcnQgaW50ZXJmYWNlIExvYWRlZFJvdXRlRmFpbHVyZSB7XG4gIGVycm9yOiB1bmtub3duXG59XG5leHBvcnQgdHlwZSBSb3V0ZUxvYWRlckVudHJ5ID0gTG9hZGVkUm91dGVTdWNjZXNzIHwgTG9hZGVkUm91dGVGYWlsdXJlXG5cbmV4cG9ydCB0eXBlIEZ1dHVyZTxWPiA9IHtcbiAgcmVzb2x2ZTogKGVudHJ5cG9pbnQ6IFYpID0+IHZvaWRcbiAgZnV0dXJlOiBQcm9taXNlPFY+XG59XG5mdW5jdGlvbiB3aXRoRnV0dXJlPFQ+KFxuICBrZXk6IHN0cmluZyxcbiAgbWFwOiBNYXA8c3RyaW5nLCBGdXR1cmU8VD4gfCBUPixcbiAgZ2VuZXJhdG9yPzogKCkgPT4gUHJvbWlzZTxUPlxuKTogUHJvbWlzZTxUPiB7XG4gIGxldCBlbnRyeTogRnV0dXJlPFQ+IHwgVCB8IHVuZGVmaW5lZCA9IG1hcC5nZXQoa2V5KVxuICBpZiAoZW50cnkpIHtcbiAgICBpZiAoJ2Z1dHVyZScgaW4gZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeS5mdXR1cmVcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlbnRyeSlcbiAgfVxuICBsZXQgcmVzb2x2ZXI6IChlbnRyeXBvaW50OiBUKSA9PiB2b2lkXG4gIGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSkgPT4ge1xuICAgIHJlc29sdmVyID0gcmVzb2x2ZVxuICB9KVxuICBtYXAuc2V0KGtleSwgKGVudHJ5ID0geyByZXNvbHZlOiByZXNvbHZlciEsIGZ1dHVyZTogcHJvbSB9KSlcbiAgcmV0dXJuIGdlbmVyYXRvclxuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgZ2VuZXJhdG9yKCkudGhlbigodmFsdWUpID0+IChyZXNvbHZlcih2YWx1ZSksIHZhbHVlKSlcbiAgICA6IHByb21cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZUxvYWRlciB7XG4gIHdoZW5FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlRW50cnlwb2ludD5cbiAgb25FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcsIGV4ZWN1dGU6ICgpID0+IHVua25vd24pOiB2b2lkXG4gIGxvYWRSb3V0ZShyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxSb3V0ZUxvYWRlckVudHJ5PlxuICBwcmVmZXRjaChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPlxufVxuXG5mdW5jdGlvbiBoYXNQcmVmZXRjaChsaW5rPzogSFRNTExpbmtFbGVtZW50KTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuICAgIHJldHVybiAoXG4gICAgICAvLyBkZXRlY3QgSUUxMSBzaW5jZSBpdCBzdXBwb3J0cyBwcmVmZXRjaCBidXQgaXNuJ3QgZGV0ZWN0ZWRcbiAgICAgIC8vIHdpdGggcmVsTGlzdC5zdXBwb3J0XG4gICAgICAoISF3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgISEoZG9jdW1lbnQgYXMgYW55KS5kb2N1bWVudE1vZGUpIHx8XG4gICAgICBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJylcbiAgICApXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmNvbnN0IGNhblByZWZldGNoOiBib29sZWFuID0gaGFzUHJlZmV0Y2goKVxuXG5mdW5jdGlvbiBwcmVmZXRjaFZpYURvbShcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICBsaW5rPzogSFRNTExpbmtFbGVtZW50XG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGxpbmtbcmVsPVwicHJlZmV0Y2hcIl1baHJlZl49XCIke2hyZWZ9XCJdYCkpIHtcbiAgICAgIHJldHVybiByZXMoKVxuICAgIH1cblxuICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcblxuICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWw6XG4gICAgaWYgKGFzKSBsaW5rIS5hcyA9IGFzXG4gICAgbGluayEucmVsID0gYHByZWZldGNoYFxuICAgIGxpbmshLmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTiFcbiAgICBsaW5rIS5vbmxvYWQgPSByZXNcbiAgICBsaW5rIS5vbmVycm9yID0gcmVqXG5cbiAgICAvLyBgaHJlZmAgc2hvdWxkIGFsd2F5cyBiZSBsYXN0OlxuICAgIGxpbmshLmhyZWYgPSBocmVmXG5cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspXG4gIH0pXG59XG5cbmNvbnN0IEFTU0VUX0xPQURfRVJST1IgPSBTeW1ib2woJ0FTU0VUX0xPQURfRVJST1InKVxuLy8gVE9ETzogdW5leHBvcnRcbmV4cG9ydCBmdW5jdGlvbiBtYXJrQXNzZXRFcnJvcihlcnI6IEVycm9yKTogRXJyb3Ige1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgQVNTRVRfTE9BRF9FUlJPUiwge30pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fzc2V0RXJyb3IoZXJyPzogRXJyb3IpIHtcbiAgcmV0dXJuIGVyciAmJiBBU1NFVF9MT0FEX0VSUk9SIGluIGVyclxufVxuXG5mdW5jdGlvbiBhcHBlbmRTY3JpcHQoXG4gIHNyYzogc3RyaW5nLFxuICBzY3JpcHQ/OiBIVE1MU2NyaXB0RWxlbWVudFxuKTogUHJvbWlzZTx1bmtub3duPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcblxuICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWwuXG4gICAgLy8gMS4gU2V0dXAgc3VjY2Vzcy9mYWlsdXJlIGhvb2tzIGluIGNhc2UgdGhlIGJyb3dzZXIgc3luY2hyb25vdXNseVxuICAgIC8vICAgIGV4ZWN1dGVzIHdoZW4gYHNyY2AgaXMgc2V0LlxuICAgIHNjcmlwdC5vbmxvYWQgPSByZXNvbHZlXG4gICAgc2NyaXB0Lm9uZXJyb3IgPSAoKSA9PlxuICAgICAgcmVqZWN0KG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc2NyaXB0OiAke3NyY31gKSkpXG5cbiAgICAvLyAyLiBDb25maWd1cmUgdGhlIGNyb3NzLW9yaWdpbiBhdHRyaWJ1dGUgYmVmb3JlIHNldHRpbmcgYHNyY2AgaW4gY2FzZSB0aGVcbiAgICAvLyAgICBicm93c2VyIGJlZ2lucyB0byBmZXRjaC5cbiAgICBzY3JpcHQuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOIVxuXG4gICAgLy8gMy4gRmluYWxseSwgc2V0IHRoZSBzb3VyY2UgYW5kIGluamVjdCBpbnRvIHRoZSBET00gaW4gY2FzZSB0aGUgY2hpbGRcbiAgICAvLyAgICBtdXN0IGJlIGFwcGVuZGVkIGZvciBmZXRjaGluZyB0byBzdGFydC5cbiAgICBzY3JpcHQuc3JjID0gc3JjXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlkbGVUaW1lb3V0PFQ+KG1zOiBudW1iZXIsIGVycjogRXJyb3IpOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QoZXJyKSwgbXMpKVxuICApXG59XG5cbi8vIFRPRE86IHN0b3AgZXhwb3J0aW5nIG9yIGNhY2hlIHRoZSBmYWlsdXJlXG4vLyBJdCdkIGJlIGJlc3QgdG8gc3RvcCBleHBvcnRpbmcgdGhpcy4gSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuIFdlJ3JlXG4vLyBvbmx5IGV4cG9ydGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWx0eSB3aXRoIHRoZSBgcGFnZS1sb2FkZXJgLlxuLy8gT25seSBjYWNoZSB0aGlzIHJlc3BvbnNlIGFzIGEgbGFzdCByZXNvcnQgaWYgd2UgY2Fubm90IGVsaW1pbmF0ZSBhbGwgb3RoZXJcbi8vIGNvZGUgYnJhbmNoZXMgdGhhdCB1c2UgdGhlIEJ1aWxkIE1hbmlmZXN0IENhbGxiYWNrIGFuZCBwdXNoIHRoZW0gdGhyb3VnaFxuLy8gdGhlIFJvdXRlIExvYWRlciBpbnRlcmZhY2UuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpOiBQcm9taXNlPENsaWVudEJ1aWxkTWFuaWZlc3Q+IHtcbiAgaWYgKHNlbGYuX19CVUlMRF9NQU5JRkVTVCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKVxuICB9XG5cbiAgY29uc3Qgb25CdWlsZE1hbmlmZXN0ID0gbmV3IFByb21pc2U8Q2xpZW50QnVpbGRNYW5pZmVzdD4oKHJlc29sdmUpID0+IHtcbiAgICAvLyBNYW5kYXRvcnkgYmVjYXVzZSB0aGlzIGlzIG5vdCBjb25jdXJyZW50IHNhZmU6XG4gICAgY29uc3QgY2IgPSBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0JcbiAgICBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0IgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVClcbiAgICAgIGNiICYmIGNiKClcbiAgICB9XG4gIH0pXG4gIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgIG9uQnVpbGRNYW5pZmVzdCxcbiAgICBpZGxlVGltZW91dDxDbGllbnRCdWlsZE1hbmlmZXN0PihcbiAgICAgIE1TX01BWF9JRExFX0RFTEFZLFxuICAgICAgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSlcbiAgICApLFxuICBdKVxufVxuXG5pbnRlcmZhY2UgUm91dGVGaWxlcyB7XG4gIHNjcmlwdHM6IHN0cmluZ1tdXG4gIGNzczogc3RyaW5nW11cbn1cbmZ1bmN0aW9uIGdldEZpbGVzRm9yUm91dGUoXG4gIGFzc2V0UHJlZml4OiBzdHJpbmcsXG4gIHJvdXRlOiBzdHJpbmdcbik6IFByb21pc2U8Um91dGVGaWxlcz4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHNjcmlwdHM6IFtcbiAgICAgICAgYXNzZXRQcmVmaXggK1xuICAgICAgICAgICcvX25leHQvc3RhdGljL2NodW5rcy9wYWdlcycgK1xuICAgICAgICAgIGVuY29kZVVSSShnZXRBc3NldFBhdGhGcm9tUm91dGUocm91dGUsICcuanMnKSksXG4gICAgICBdLFxuICAgICAgLy8gU3R5bGVzIGFyZSBoYW5kbGVkIGJ5IGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50OlxuICAgICAgY3NzOiBbXSxcbiAgICB9KVxuICB9XG4gIHJldHVybiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkudGhlbigobWFuaWZlc3QpID0+IHtcbiAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSlcbiAgICB9XG4gICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKFxuICAgICAgKGVudHJ5KSA9PiBhc3NldFByZWZpeCArICcvX25leHQvJyArIGVuY29kZVVSSShlbnRyeSlcbiAgICApXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmlwdHM6IGFsbEZpbGVzLmZpbHRlcigodikgPT4gdi5lbmRzV2l0aCgnLmpzJykpLFxuICAgICAgY3NzOiBhbGxGaWxlcy5maWx0ZXIoKHYpID0+IHYuZW5kc1dpdGgoJy5jc3MnKSksXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUxvYWRlcihhc3NldFByZWZpeDogc3RyaW5nKTogUm91dGVMb2FkZXIge1xuICBjb25zdCBlbnRyeXBvaW50czogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVFbnRyeXBvaW50PiB8IFJvdXRlRW50cnlwb2ludFxuICA+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IGxvYWRlZFNjcmlwdHM6IE1hcDxzdHJpbmcsIFByb21pc2U8dW5rbm93bj4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHN0eWxlU2hlZXRzOiBNYXA8c3RyaW5nLCBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHJvdXRlczogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVMb2FkZXJFbnRyeT4gfCBSb3V0ZUxvYWRlckVudHJ5XG4gID4gPSBuZXcgTWFwKClcblxuICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjOiBzdHJpbmcpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICBsZXQgcHJvbSA9IGxvYWRlZFNjcmlwdHMuZ2V0KHNyYylcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICAvLyBTa2lwIGV4ZWN1dGluZyBzY3JpcHQgaWYgaXQncyBhbHJlYWR5IGluIHRoZSBET006XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmNePVwiJHtzcmN9XCJdYCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGxvYWRlZFNjcmlwdHMuc2V0KHNyYywgKHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSkpXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoU3R5bGVTaGVldChocmVmOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4ge1xuICAgIGxldCBwcm9tID0gc3R5bGVTaGVldHMuZ2V0KGhyZWYpXG4gICAgaWYgKHByb20pIHtcbiAgICAgIHJldHVybiBwcm9tXG4gICAgfVxuXG4gICAgc3R5bGVTaGVldHMuc2V0KFxuICAgICAgaHJlZixcbiAgICAgIChwcm9tID0gZmV0Y2goaHJlZilcbiAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0eWxlc2hlZXQ6ICR7aHJlZn1gKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKCh0ZXh0KSA9PiAoeyBocmVmOiBocmVmLCBjb250ZW50OiB0ZXh0IH0pKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKGVycilcbiAgICAgICAgfSkpXG4gICAgKVxuICAgIHJldHVybiBwcm9tXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdoZW5FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiB3aXRoRnV0dXJlKHJvdXRlLCBlbnRyeXBvaW50cylcbiAgICB9LFxuICAgIG9uRW50cnlwb2ludChyb3V0ZSwgZXhlY3V0ZSkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKGV4ZWN1dGUpXG4gICAgICAgIC50aGVuKChmbikgPT4gZm4oKSlcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgKGV4cG9ydHM6IGFueSkgPT4gKHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogKGV4cG9ydHMgJiYgZXhwb3J0cy5kZWZhdWx0KSB8fCBleHBvcnRzLFxuICAgICAgICAgICAgZXhwb3J0czogZXhwb3J0cyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAoZXJyKSA9PiAoeyBlcnJvcjogZXJyIH0pXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKGlucHV0OiBSb3V0ZUVudHJ5cG9pbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpXG4gICAgICAgICAgZW50cnlwb2ludHMuc2V0KHJvdXRlLCBpbnB1dClcbiAgICAgICAgICBpZiAob2xkICYmICdyZXNvbHZlJyBpbiBvbGQpIG9sZC5yZXNvbHZlKGlucHV0KVxuICAgICAgICB9KVxuICAgIH0sXG4gICAgbG9hZFJvdXRlKHJvdXRlKSB7XG4gICAgICByZXR1cm4gd2l0aEZ1dHVyZTxSb3V0ZUxvYWRlckVudHJ5Pihyb3V0ZSwgcm91dGVzLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBzY3JpcHRzLCBjc3MgfSA9IGF3YWl0IGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKVxuICAgICAgICAgIGNvbnN0IFssIHN0eWxlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBlbnRyeXBvaW50cy5oYXMocm91dGUpXG4gICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgOiBQcm9taXNlLmFsbChzY3JpcHRzLm1hcChtYXliZUV4ZWN1dGVTY3JpcHQpKSxcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGNzcy5tYXAoZmV0Y2hTdHlsZVNoZWV0KSksXG4gICAgICAgICAgXSBhcyBjb25zdClcblxuICAgICAgICAgIGNvbnN0IGVudHJ5cG9pbnQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgdGhpcy53aGVuRW50cnlwb2ludChyb3V0ZSksXG4gICAgICAgICAgICBpZGxlVGltZW91dDxSb3V0ZUxvYWRlckVudHJ5PihcbiAgICAgICAgICAgICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgICAgICAgICAgIG1hcmtBc3NldEVycm9yKFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcihgUm91dGUgZGlkIG5vdCBjb21wbGV0ZSBsb2FkaW5nOiAke3JvdXRlfWApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSlcbiAgICAgICAgICBjb25zdCByZXM6IFJvdXRlTG9hZGVyRW50cnkgPSBPYmplY3QuYXNzaWduPFxuICAgICAgICAgICAgeyBzdHlsZXM6IFJvdXRlU3R5bGVTaGVldFtdIH0sXG4gICAgICAgICAgICBSb3V0ZUVudHJ5cG9pbnRcbiAgICAgICAgICA+KHsgc3R5bGVzIH0sIGVudHJ5cG9pbnQpXG4gICAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gZW50cnlwb2ludCA/IGVudHJ5cG9pbnQgOiByZXNcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGVyciB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBwcmVmZXRjaChyb3V0ZSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgbGV0IGNuXG4gICAgICBpZiAoKGNuID0gKG5hdmlnYXRvciBhcyBhbnkpLmNvbm5lY3Rpb24pKSB7XG4gICAgICAgIC8vIERvbid0IHByZWZldGNoIGlmIHVzaW5nIDJHIG9yIGlmIFNhdmUtRGF0YSBpcyBlbmFibGVkLlxuICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGaWxlc0ZvclJvdXRlKGFzc2V0UHJlZml4LCByb3V0ZSlcbiAgICAgICAgLnRoZW4oKG91dHB1dCkgPT5cbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIGNhblByZWZldGNoXG4gICAgICAgICAgICAgID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpID0+IHByZWZldGNoVmlhRG9tKHNjcmlwdCwgJ3NjcmlwdCcpKVxuICAgICAgICAgICAgICA6IFtdXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHRoaXMubG9hZFJvdXRlKHJvdXRlKSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKFxuICAgICAgICAgIC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAgICAgKCkgPT4ge31cbiAgICAgICAgKVxuICAgIH0sXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUm91dGVMb2FkZXJcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBSb3V0ZXIsIHsgTmV4dFJvdXRlciB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXItY29udGV4dCdcblxudHlwZSBDbGFzc0FyZ3VtZW50czxUPiA9IFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGluZmVyIFUpID0+IGFueSA/IFUgOiBhbnlcblxudHlwZSBSb3V0ZXJBcmdzID0gQ2xhc3NBcmd1bWVudHM8dHlwZW9mIFJvdXRlcj5cblxudHlwZSBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IFJvdXRlciB8IG51bGxcbiAgcmVhZHlDYWxsYmFja3M6IEFycmF5PCgpID0+IGFueT5cbiAgcmVhZHkoY2I6ICgpID0+IGFueSk6IHZvaWRcbn1cblxuZXhwb3J0IHsgUm91dGVyLCBOZXh0Um91dGVyIH1cblxuZXhwb3J0IHR5cGUgU2luZ2xldG9uUm91dGVyID0gU2luZ2xldG9uUm91dGVyQmFzZSAmIE5leHRSb3V0ZXJcblxuY29uc3Qgc2luZ2xldG9uUm91dGVyOiBTaW5nbGV0b25Sb3V0ZXJCYXNlID0ge1xuICByb3V0ZXI6IG51bGwsIC8vIGhvbGRzIHRoZSBhY3R1YWwgcm91dGVyIGluc3RhbmNlXG4gIHJlYWR5Q2FsbGJhY2tzOiBbXSxcbiAgcmVhZHkoY2I6ICgpID0+IHZvaWQpIHtcbiAgICBpZiAodGhpcy5yb3V0ZXIpIHJldHVybiBjYigpXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goY2IpXG4gICAgfVxuICB9LFxufVxuXG4vLyBDcmVhdGUgcHVibGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgb2YgdGhlIHJvdXRlciBpbiB0aGUgc2luZ2xldG9uUm91dGVyXG5jb25zdCB1cmxQcm9wZXJ0eUZpZWxkcyA9IFtcbiAgJ3BhdGhuYW1lJyxcbiAgJ3JvdXRlJyxcbiAgJ3F1ZXJ5JyxcbiAgJ2FzUGF0aCcsXG4gICdjb21wb25lbnRzJyxcbiAgJ2lzRmFsbGJhY2snLFxuICAnYmFzZVBhdGgnLFxuICAnbG9jYWxlJyxcbiAgJ2xvY2FsZXMnLFxuICAnZGVmYXVsdExvY2FsZScsXG5dXG5jb25zdCByb3V0ZXJFdmVudHMgPSBbXG4gICdyb3V0ZUNoYW5nZVN0YXJ0JyxcbiAgJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLFxuICAncm91dGVDaGFuZ2VDb21wbGV0ZScsXG4gICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgJ2hhc2hDaGFuZ2VTdGFydCcsXG4gICdoYXNoQ2hhbmdlQ29tcGxldGUnLFxuXVxuY29uc3QgY29yZU1ldGhvZEZpZWxkcyA9IFtcbiAgJ3B1c2gnLFxuICAncmVwbGFjZScsXG4gICdyZWxvYWQnLFxuICAnYmFjaycsXG4gICdwcmVmZXRjaCcsXG4gICdiZWZvcmVQb3BTdGF0ZScsXG5dXG5cbi8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsICdldmVudHMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gUm91dGVyLmV2ZW50c1xuICB9LFxufSlcblxudXJsUHJvcGVydHlGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVzZSBPYmplY3QuZGVmaW5lUHJvcGVydHkgYmVjYXVzZSwgd2UgbmVlZCB0byByZXR1cm5cbiAgLy8gdGhlIHByb3BlcnR5IGFzc2lnbmVkIHRvIHRoZSBhY3R1YWwgcm91dGVyXG4gIC8vIFRoZSB2YWx1ZSBtaWdodCBnZXQgY2hhbmdlZCBhcyB3ZSBjaGFuZ2Ugcm91dGVzIGFuZCB0aGlzIGlzIHRoZVxuICAvLyBwcm9wZXIgd2F5IHRvIGFjY2VzcyBpdFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCBmaWVsZCwge1xuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgICAgcmV0dXJuIHJvdXRlcltmaWVsZF0gYXMgc3RyaW5nXG4gICAgfSxcbiAgfSlcbn0pXG5cbmNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgLy8gV2UgZG9uJ3QgcmVhbGx5IGtub3cgdGhlIHR5cGVzIGhlcmUsIHNvIHdlIGFkZCB0aGVtIGxhdGVyIGluc3RlYWRcbiAgOyhzaW5nbGV0b25Sb3V0ZXIgYXMgYW55KVtmaWVsZF0gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKSBhcyBhbnlcbiAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSguLi5hcmdzKVxuICB9XG59KVxuXG5yb3V0ZXJFdmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5KCgpID0+IHtcbiAgICBSb3V0ZXIuZXZlbnRzLm9uKGV2ZW50LCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgZXZlbnRGaWVsZCA9IGBvbiR7ZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHtldmVudC5zdWJzdHJpbmcoXG4gICAgICAgIDFcbiAgICAgICl9YFxuICAgICAgY29uc3QgX3NpbmdsZXRvblJvdXRlciA9IHNpbmdsZXRvblJvdXRlciBhcyBhbnlcbiAgICAgIGlmIChfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmdzKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogJHtldmVudEZpZWxkfWApXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGdldFJvdXRlcigpOiBSb3V0ZXIge1xuICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICdObyByb3V0ZXIgaW5zdGFuY2UgZm91bmQuXFxuJyArXG4gICAgICAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gRXhwb3J0IHRoZSBzaW5nbGV0b25Sb3V0ZXIgYW5kIHRoaXMgaXMgdGhlIHB1YmxpYyBBUEkuXG5leHBvcnQgZGVmYXVsdCBzaW5nbGV0b25Sb3V0ZXIgYXMgU2luZ2xldG9uUm91dGVyXG5cbi8vIFJlZXhwb3J0IHRoZSB3aXRoUm91dGUgSE9DXG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhSb3V0ZXIgfSBmcm9tICcuL3dpdGgtcm91dGVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IE5leHRSb3V0ZXIge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KVxufVxuXG4vLyBJTlRFUk5BTCBBUElTXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAoZG8gbm90IHVzZSBmb2xsb3dpbmcgZXhwb3J0cyBpbnNpZGUgdGhlIGFwcClcblxuLy8gQ3JlYXRlIGEgcm91dGVyIGFuZCBhc3NpZ24gaXQgYXMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cbi8vIFRoaXMgaXMgdXNlZCBpbiBjbGllbnQgc2lkZSB3aGVuIHdlIGFyZSBpbml0aWxpemluZyB0aGUgYXBwLlxuLy8gVGhpcyBzaG91bGQgKipub3QqKiB1c2UgaW5zaWRlIHRoZSBzZXJ2ZXIuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyID0gKC4uLmFyZ3M6IFJvdXRlckFyZ3MpOiBSb3V0ZXIgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IFJvdXRlciguLi5hcmdzKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdXG5cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYHdpdGhSb3V0ZXJgIHJvdXRlciBpbnN0YW5jZVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXI6IFJvdXRlcik6IE5leHRSb3V0ZXIge1xuICBjb25zdCBfcm91dGVyID0gcm91dGVyIGFzIGFueVxuICBjb25zdCBpbnN0YW5jZSA9IHt9IGFzIGFueVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIF9yb3V0ZXJbcHJvcGVydHldID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgQXJyYXkuaXNBcnJheShfcm91dGVyW3Byb3BlcnR5XSkgPyBbXSA6IHt9LFxuICAgICAgICBfcm91dGVyW3Byb3BlcnR5XVxuICAgICAgKSAvLyBtYWtlcyBzdXJlIHF1ZXJ5IGlzIG5vdCBzdGF0ZWZ1bFxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBfcm91dGVyW3Byb3BlcnR5XVxuICB9XG5cbiAgLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuICBpbnN0YW5jZS5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGluc3RhbmNlW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgcmV0dXJuIF9yb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHJlcXVlc3RJZGxlQ2FsbGJhY2sgZnJvbSAnLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2snXG5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0ID0gUGljazxJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQsICdyb290TWFyZ2luJz5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uID0geyBkaXNhYmxlZD86IGJvb2xlYW4gfSAmIFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdFxudHlwZSBPYnNlcnZlQ2FsbGJhY2sgPSAoaXNWaXNpYmxlOiBib29sZWFuKSA9PiB2b2lkXG5cbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uPFQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gIHJvb3RNYXJnaW4sXG4gIGRpc2FibGVkLFxufTogVXNlSW50ZXJzZWN0aW9uKTogWyhlbGVtZW50OiBUIHwgbnVsbCkgPT4gdm9pZCwgYm9vbGVhbl0ge1xuICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyXG5cbiAgY29uc3QgdW5vYnNlcnZlID0gdXNlUmVmPEZ1bmN0aW9uPigpXG4gIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIGNvbnN0IHNldFJlZiA9IHVzZUNhbGxiYWNrKFxuICAgIChlbDogVCB8IG51bGwpID0+IHtcbiAgICAgIGlmICh1bm9ic2VydmUuY3VycmVudCkge1xuICAgICAgICB1bm9ic2VydmUuY3VycmVudCgpXG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVyblxuXG4gICAgICBpZiAoZWwgJiYgZWwudGFnTmFtZSkge1xuICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IG9ic2VydmUoXG4gICAgICAgICAgZWwsXG4gICAgICAgICAgKGlzVmlzaWJsZSkgPT4gaXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKSxcbiAgICAgICAgICB7IHJvb3RNYXJnaW4gfVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSxcbiAgICBbaXNEaXNhYmxlZCwgcm9vdE1hcmdpbiwgdmlzaWJsZV1cbiAgKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgaWYgKCF2aXNpYmxlKSByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+IHNldFZpc2libGUodHJ1ZSkpXG4gICAgfVxuICB9LCBbdmlzaWJsZV0pXG5cbiAgcmV0dXJuIFtzZXRSZWYsIHZpc2libGVdXG59XG5cbmZ1bmN0aW9uIG9ic2VydmUoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGNhbGxiYWNrOiBPYnNlcnZlQ2FsbGJhY2ssXG4gIG9wdGlvbnM6IFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdFxuKSB7XG4gIGNvbnN0IHsgaWQsIG9ic2VydmVyLCBlbGVtZW50cyB9ID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucylcbiAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrKVxuXG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudClcblxuICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGlkKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgTWFwPFxuICBzdHJpbmcsXG4gIHtcbiAgICBpZDogc3RyaW5nXG4gICAgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyXG4gICAgZWxlbWVudHM6IE1hcDxFbGVtZW50LCBPYnNlcnZlQ2FsbGJhY2s+XG4gIH1cbj4oKVxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9uczogVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0KSB7XG4gIGNvbnN0IGlkID0gb3B0aW9ucy5yb290TWFyZ2luIHx8ICcnXG4gIGxldCBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoaWQpXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZVxuICB9XG5cbiAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwPEVsZW1lbnQsIE9ic2VydmVDYWxsYmFjaz4oKVxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldClcbiAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMFxuICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpXG4gICAgICB9XG4gICAgfSlcbiAgfSwgb3B0aW9ucylcblxuICBvYnNlcnZlcnMuc2V0KFxuICAgIGlkLFxuICAgIChpbnN0YW5jZSA9IHtcbiAgICAgIGlkLFxuICAgICAgb2JzZXJ2ZXIsXG4gICAgICBlbGVtZW50cyxcbiAgICB9KVxuICApXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dENvbXBvbmVudFR5cGUsIE5leHRQYWdlQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi91dGlscydcbmltcG9ydCB7IE5leHRSb3V0ZXIsIHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuXG5leHBvcnQgdHlwZSBXaXRoUm91dGVyUHJvcHMgPSB7XG4gIHJvdXRlcjogTmV4dFJvdXRlclxufVxuXG5leHBvcnQgdHlwZSBFeGNsdWRlUm91dGVyUHJvcHM8UD4gPSBQaWNrPFxuICBQLFxuICBFeGNsdWRlPGtleW9mIFAsIGtleW9mIFdpdGhSb3V0ZXJQcm9wcz5cbj5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aFJvdXRlcjxcbiAgUCBleHRlbmRzIFdpdGhSb3V0ZXJQcm9wcyxcbiAgQyA9IE5leHRQYWdlQ29udGV4dFxuPihcbiAgQ29tcG9zZWRDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPEMsIGFueSwgUD5cbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8RXhjbHVkZVJvdXRlclByb3BzPFA+PiB7XG4gIGZ1bmN0aW9uIFdpdGhSb3V0ZXJXcmFwcGVyKHByb3BzOiBhbnkpIHtcbiAgICByZXR1cm4gPENvbXBvc2VkQ29tcG9uZW50IHJvdXRlcj17dXNlUm91dGVyKCl9IHsuLi5wcm9wc30gLz5cbiAgfVxuXG4gIFdpdGhSb3V0ZXJXcmFwcGVyLmdldEluaXRpYWxQcm9wcyA9IENvbXBvc2VkQ29tcG9uZW50LmdldEluaXRpYWxQcm9wc1xuICAvLyBUaGlzIGlzIG5lZWRlZCB0byBhbGxvdyBjaGVja2luZyBmb3IgY3VzdG9tIGdldEluaXRpYWxQcm9wcyBpbiBfYXBwXG4gIDsoV2l0aFJvdXRlcldyYXBwZXIgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzID0gKENvbXBvc2VkQ29tcG9uZW50IGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wc1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IG5hbWUgPVxuICAgICAgQ29tcG9zZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9zZWRDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbiAgICBXaXRoUm91dGVyV3JhcHBlci5kaXNwbGF5TmFtZSA9IGB3aXRoUm91dGVyKCR7bmFtZX0pYFxuICB9XG5cbiAgcmV0dXJuIFdpdGhSb3V0ZXJXcmFwcGVyXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVG9rZW5pemUgaW5wdXQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBsZXhlcihzdHIpIHtcbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHN0cltpXTtcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKlwiIHx8IGNoYXIgPT09IFwiK1wiIHx8IGNoYXIgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiTU9ESUZJRVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVTQ0FQRURfQ0hBUlwiLCBpbmRleDogaSsrLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJPUEVOXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDTE9TRVwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChqKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gYDAtOWBcbiAgICAgICAgICAgICAgICAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgQS1aYFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBgYS16YFxuICAgICAgICAgICAgICAgICAgICAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMikgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYF9gXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPT09IDk1KSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXJhbWV0ZXIgbmFtZSBhdCBcIiArIGkpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk5BTUVcIiwgaW5kZXg6IGksIHZhbHVlOiBuYW1lIH0pO1xuICAgICAgICAgICAgaSA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgaiA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0cltqXSA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0dGVybiBjYW5ub3Qgc3RhcnQgd2l0aCBcXFwiP1xcXCIgYXQgXCIgKyBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK10gKyBzdHJbaisrXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RyW2pdID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyW2ogKyAxXSAhPT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYXB0dXJpbmcgZ3JvdXBzIGFyZSBub3QgYWxsb3dlZCBhdCBcIiArIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuYmFsYW5jZWQgcGF0dGVybiBhdCBcIiArIGkpO1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNaXNzaW5nIHBhdHRlcm4gYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJQQVRURVJOXCIsIGluZGV4OiBpLCB2YWx1ZTogcGF0dGVybiB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkNIQVJcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICB9XG4gICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIkVORFwiLCBpbmRleDogaSwgdmFsdWU6IFwiXCIgfSk7XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICovXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciB0b2tlbnMgPSBsZXhlcihzdHIpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMucHJlZml4ZXMsIHByZWZpeGVzID0gX2EgPT09IHZvaWQgMCA/IFwiLi9cIiA6IF9hO1xuICAgIHZhciBkZWZhdWx0UGF0dGVybiA9IFwiW15cIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSArIFwiXSs/XCI7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXkgPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcGF0aCA9IFwiXCI7XG4gICAgdmFyIHRyeUNvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2ldLnR5cGUgPT09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW2krK10udmFsdWU7XG4gICAgfTtcbiAgICB2YXIgbXVzdENvbnN1bWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDb25zdW1lKHR5cGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFyIF9hID0gdG9rZW5zW2ldLCBuZXh0VHlwZSA9IF9hLnR5cGUsIGluZGV4ID0gX2EuaW5kZXg7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgbmV4dFR5cGUgKyBcIiBhdCBcIiArIGluZGV4ICsgXCIsIGV4cGVjdGVkIFwiICsgdHlwZSk7XG4gICAgfTtcbiAgICB2YXIgY29uc3VtZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB3aGlsZSAoKHZhbHVlID0gdHJ5Q29uc3VtZShcIkNIQVJcIikgfHwgdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgd2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFyID0gdHJ5Q29uc3VtZShcIkNIQVJcIik7XG4gICAgICAgIHZhciBuYW1lID0gdHJ5Q29uc3VtZShcIk5BTUVcIik7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdHJ5Q29uc3VtZShcIlBBVFRFUk5cIik7XG4gICAgICAgIGlmIChuYW1lIHx8IHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjaGFyIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAocHJlZml4ZXMuaW5kZXhPZihwcmVmaXgpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4gfHwgZGVmYXVsdFBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZSA9IGNoYXIgfHwgdHJ5Q29uc3VtZShcIkVTQ0FQRURfQ0hBUlwiKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBwYXRoICs9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZW4gPSB0cnlDb25zdW1lKFwiT1BFTlwiKTtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjb25zdW1lVGV4dCgpO1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgcGF0dGVybl8xID0gdHJ5Q29uc3VtZShcIlBBVFRFUk5cIikgfHwgXCJcIjtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBjb25zdW1lVGV4dCgpO1xuICAgICAgICAgICAgbXVzdENvbnN1bWUoXCJDTE9TRVwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXzEgfHwgKHBhdHRlcm5fMSA/IGtleSsrIDogXCJcIiksXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbmFtZV8xICYmICFwYXR0ZXJuXzEgPyBkZWZhdWx0UGF0dGVybiA6IHBhdHRlcm5fMSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogdHJ5Q29uc3VtZShcIk1PRElGSUVSXCIpIHx8IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbXVzdENvbnN1bWUoXCJFTkRcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciByZUZsYWdzID0gZmxhZ3Mob3B0aW9ucyk7XG4gICAgdmFyIF9hID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hLCBfYiA9IG9wdGlvbnMudmFsaWRhdGUsIHZhbGlkYXRlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgICB2YXIgbWF0Y2hlcyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSRcIiwgcmVGbGFncyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHBhdGggPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHBhdGggKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhID8gZGF0YVt0b2tlbi5uYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBvcHRpb25hbCA9IHRva2VuLm1vZGlmaWVyID09PSBcIj9cIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIqXCI7XG4gICAgICAgICAgICB2YXIgcmVwZWF0ID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIitcIjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGUgJiYgIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGFsbCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZShTdHJpbmcodmFsdWUpLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFxcXCJcIiArIHRva2VuLm5hbWUgKyBcIlxcXCIgdG8gbWF0Y2ggXFxcIlwiICsgdG9rZW4ucGF0dGVybiArIFwiXFxcIiwgYnV0IGdvdCBcXFwiXCIgKyBzZWdtZW50ICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdHlwZU9mTWVzc2FnZSA9IHJlcGVhdCA/IFwiYW4gYXJyYXlcIiA6IFwiYSBzdHJpbmdcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIGJlIFwiICsgdHlwZU9mTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbn1cbmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb247XG4vKipcbiAqIENyZWF0ZSBwYXRoIG1hdGNoIGZ1bmN0aW9uIGZyb20gYHBhdGgtdG8tcmVnZXhwYCBzcGVjLlxuICovXG5mdW5jdGlvbiBtYXRjaChzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHZhciByZSA9IHBhdGhUb1JlZ2V4cChzdHIsIGtleXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbi8qKlxuICogQ3JlYXRlIGEgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgb3V0cHV0LlxuICovXG5mdW5jdGlvbiByZWdleHBUb0Z1bmN0aW9uKHJlLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBvcHRpb25zLmRlY29kZSwgZGVjb2RlID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2E7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICB2YXIgbSA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBwYXRoID0gbVswXSwgaW5kZXggPSBtLmluZGV4O1xuICAgICAgICB2YXIgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBpZiAobVtpXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpIC0gMV07XG4gICAgICAgICAgICBpZiAoa2V5Lm1vZGlmaWVyID09PSBcIipcIiB8fCBrZXkubW9kaWZpZXIgPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IG1baV0uc3BsaXQoa2V5LnByZWZpeCArIGtleS5zdWZmaXgpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZSh2YWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBkZWNvZGUobVtpXSwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHBhdGg6IHBhdGgsIGluZGV4OiBpbmRleCwgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5yZWdleHBUb0Z1bmN0aW9uID0gcmVnZXhwVG9GdW5jdGlvbjtcbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBmbGFncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyBcIlwiIDogXCJpXCI7XG59XG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cykge1xuICAgIGlmICgha2V5cylcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG4gICAgaWYgKGdyb3Vwcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBpLFxuICAgICAgICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBzdWZmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IFwiXCIsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwKHBhdGhzLCBrZXlzLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnRzID0gcGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBwYXRoVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykuc291cmNlOyB9KTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/OlwiICsgcGFydHMuam9pbihcInxcIikgKyBcIilcIiwgZmxhZ3Mob3B0aW9ucykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb1JlZ2V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucyk7XG59XG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnZXhwKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5zdHJpY3QsIHN0cmljdCA9IF9hID09PSB2b2lkIDAgPyBmYWxzZSA6IF9hLCBfYiA9IG9wdGlvbnMuc3RhcnQsIHN0YXJ0ID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgX2MgPSBvcHRpb25zLmVuZCwgZW5kID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgX2QgPSBvcHRpb25zLmVuY29kZSwgZW5jb2RlID0gX2QgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9IDogX2Q7XG4gICAgdmFyIGVuZHNXaXRoID0gXCJbXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5lbmRzV2l0aCB8fCBcIlwiKSArIFwiXXwkXCI7XG4gICAgdmFyIGRlbGltaXRlciA9IFwiW1wiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8IFwiLyM/XCIpICsgXCJdXCI7XG4gICAgdmFyIHJvdXRlID0gc3RhcnQgPyBcIl5cIiA6IFwiXCI7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgICBmb3IgKHZhciBfaSA9IDAsIHRva2Vuc18xID0gdG9rZW5zOyBfaSA8IHRva2Vuc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNfMVtfaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnByZWZpeCkpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4uc3VmZml4KSk7XG4gICAgICAgICAgICBpZiAodG9rZW4ucGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzKVxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggfHwgc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5tb2RpZmllciA9PT0gXCIrXCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kID0gdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiID8gXCI/XCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIFwiKCg/OlwiICsgdG9rZW4ucGF0dGVybiArIFwiKSg/OlwiICsgc3VmZml4ICsgcHJlZml4ICsgXCIoPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikpKilcIiArIHN1ZmZpeCArIFwiKVwiICsgbW9kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIFwiKFwiICsgdG9rZW4ucGF0dGVybiArIFwiKVwiICsgc3VmZml4ICsgXCIpXCIgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpXCIgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3V0ZSArPSBcIig/OlwiICsgcHJlZml4ICsgc3VmZml4ICsgXCIpXCIgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIGlmICghc3RyaWN0KVxuICAgICAgICAgICAgcm91dGUgKz0gZGVsaW1pdGVyICsgXCI/XCI7XG4gICAgICAgIHJvdXRlICs9ICFvcHRpb25zLmVuZHNXaXRoID8gXCIkXCIgOiBcIig/PVwiICsgZW5kc1dpdGggKyBcIilcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlbmRUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBpc0VuZERlbGltaXRlZCA9IHR5cGVvZiBlbmRUb2tlbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBkZWxpbWl0ZXIuaW5kZXhPZihlbmRUb2tlbltlbmRUb2tlbi5sZW5ndGggLSAxXSkgPiAtMVxuICAgICAgICAgICAgOiAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICBlbmRUb2tlbiA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIGRlbGltaXRlciArIFwiKD89XCIgKyBlbmRzV2l0aCArIFwiKSk/XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VuZERlbGltaXRlZCkge1xuICAgICAgICAgICAgcm91dGUgKz0gXCIoPz1cIiArIGRlbGltaXRlciArIFwifFwiICsgZW5kc1dpdGggKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyb3V0ZSwgZmxhZ3Mob3B0aW9ucykpO1xufVxuZXhwb3J0cy50b2tlbnNUb1JlZ2V4cCA9IHRva2Vuc1RvUmVnZXhwO1xuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpXG4gICAgICAgIHJldHVybiBhcnJheVRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzdHJpbmdUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucGF0aFRvUmVnZXhwID0gcGF0aFRvUmVnZXhwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgQW1wU3RhdGVDb250ZXh0OiBSZWFjdC5Db250ZXh0PGFueT4gPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBBbXBTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnQW1wU3RhdGVDb250ZXh0J1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQW1wU3RhdGVDb250ZXh0IH0gZnJvbSAnLi9hbXAtY29udGV4dCdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5BbXBNb2RlKHtcbiAgYW1wRmlyc3QgPSBmYWxzZSxcbiAgaHlicmlkID0gZmFsc2UsXG4gIGhhc1F1ZXJ5ID0gZmFsc2UsXG59ID0ge30pOiBib29sZWFuIHtcbiAgcmV0dXJuIGFtcEZpcnN0IHx8IChoeWJyaWQgJiYgaGFzUXVlcnkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbXAoKTogYm9vbGVhbiB7XG4gIC8vIERvbid0IGFzc2lnbiB0aGUgY29udGV4dCB2YWx1ZSB0byBhIHZhcmlhYmxlIHRvIHNhdmUgYnl0ZXNcbiAgcmV0dXJuIGlzSW5BbXBNb2RlKFJlYWN0LnVzZUNvbnRleHQoQW1wU3RhdGVDb250ZXh0KSlcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEhlYWRNYW5hZ2VyQ29udGV4dDogUmVhY3QuQ29udGV4dDx7XG4gIHVwZGF0ZUhlYWQ/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBtb3VudGVkSW5zdGFuY2VzPzogYW55XG59PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEhlYWRNYW5hZ2VyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdIZWFkTWFuYWdlckNvbnRleHQnXG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IEVmZmVjdCBmcm9tICcuL3NpZGUtZWZmZWN0J1xuaW1wb3J0IHsgQW1wU3RhdGVDb250ZXh0IH0gZnJvbSAnLi9hbXAtY29udGV4dCdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4vaGVhZC1tYW5hZ2VyLWNvbnRleHQnXG5pbXBvcnQgeyBpc0luQW1wTW9kZSB9IGZyb20gJy4vYW1wJ1xuXG50eXBlIFdpdGhJbkFtcE1vZGUgPSB7XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRIZWFkKGluQW1wTW9kZSA9IGZhbHNlKTogSlNYLkVsZW1lbnRbXSB7XG4gIGNvbnN0IGhlYWQgPSBbPG1ldGEgY2hhclNldD1cInV0Zi04XCIgLz5dXG4gIGlmICghaW5BbXBNb2RlKSB7XG4gICAgaGVhZC5wdXNoKDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGhcIiAvPilcbiAgfVxuICByZXR1cm4gaGVhZFxufVxuXG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KFxuICBsaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIGNoaWxkOiBSZWFjdC5SZWFjdENoaWxkXG4pOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4ge1xuICAvLyBSZWFjdCBjaGlsZHJlbiBjYW4gYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiIGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlbSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gIGlmIChjaGlsZC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdChcbiAgICAgIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZShcbiAgICAgICAgKFxuICAgICAgICAgIGZyYWdtZW50TGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgICAgICAgIGZyYWdtZW50Q2hpbGQ6IFJlYWN0LlJlYWN0Q2hpbGRcbiAgICAgICAgKTogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+ID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKVxuICAgICAgICB9LFxuICAgICAgICBbXVxuICAgICAgKVxuICAgIClcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoY2hpbGQpXG59XG5cbmNvbnN0IE1FVEFUWVBFUyA9IFsnbmFtZScsICdodHRwRXF1aXYnLCAnY2hhclNldCcsICdpdGVtUHJvcCddXG5cbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qL1xuZnVuY3Rpb24gdW5pcXVlKCkge1xuICBjb25zdCBrZXlzID0gbmV3IFNldCgpXG4gIGNvbnN0IHRhZ3MgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YVR5cGVzID0gbmV3IFNldCgpXG4gIGNvbnN0IG1ldGFDYXRlZ29yaWVzOiB7IFttZXRhdHlwZTogc3RyaW5nXTogU2V0PHN0cmluZz4gfSA9IHt9XG5cbiAgcmV0dXJuIChoOiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PikgPT4ge1xuICAgIGxldCBpc1VuaXF1ZSA9IHRydWVcblxuICAgIGlmIChoLmtleSAmJiB0eXBlb2YgaC5rZXkgIT09ICdudW1iZXInICYmIGgua2V5LmluZGV4T2YoJyQnKSA+IDApIHtcbiAgICAgIGNvbnN0IGtleSA9IGgua2V5LnNsaWNlKGgua2V5LmluZGV4T2YoJyQnKSArIDEpXG4gICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLmFkZChrZXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgIHN3aXRjaCAoaC50eXBlKSB7XG4gICAgICBjYXNlICd0aXRsZSc6XG4gICAgICBjYXNlICdiYXNlJzpcbiAgICAgICAgaWYgKHRhZ3MuaGFzKGgudHlwZSkpIHtcbiAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFncy5hZGQoaC50eXBlKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtZXRhJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1FVEFUWVBFUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IG1ldGF0eXBlID0gTUVUQVRZUEVTW2ldXG4gICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWVcblxuICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gJ2NoYXJTZXQnKSB7XG4gICAgICAgICAgICBpZiAobWV0YVR5cGVzLmhhcyhtZXRhdHlwZSkpIHtcbiAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWV0YVR5cGVzLmFkZChtZXRhdHlwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBoLnByb3BzW21ldGF0eXBlXVxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSB8fCBuZXcgU2V0KClcbiAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzLmhhcyhjYXRlZ29yeSkpIHtcbiAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2F0ZWdvcmllcy5hZGQoY2F0ZWdvcnkpXG4gICAgICAgICAgICAgIG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSA9IGNhdGVnb3JpZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNVbmlxdWVcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gaGVhZEVsZW1lbnRzIExpc3Qgb2YgbXVsdGlwbGUgPEhlYWQ+IGluc3RhbmNlc1xuICovXG5mdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzKFxuICBoZWFkRWxlbWVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgcHJvcHM6IFdpdGhJbkFtcE1vZGVcbikge1xuICByZXR1cm4gaGVhZEVsZW1lbnRzXG4gICAgLnJlZHVjZShcbiAgICAgIChsaXN0OiBSZWFjdC5SZWFjdENoaWxkW10sIGhlYWRFbGVtZW50OiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PikgPT4ge1xuICAgICAgICBjb25zdCBoZWFkRWxlbWVudENoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShcbiAgICAgICAgICBoZWFkRWxlbWVudC5wcm9wcy5jaGlsZHJlblxuICAgICAgICApXG4gICAgICAgIHJldHVybiBsaXN0LmNvbmNhdChoZWFkRWxlbWVudENoaWxkcmVuKVxuICAgICAgfSxcbiAgICAgIFtdXG4gICAgKVxuICAgIC5yZWR1Y2Uob25seVJlYWN0RWxlbWVudCwgW10pXG4gICAgLnJldmVyc2UoKVxuICAgIC5jb25jYXQoZGVmYXVsdEhlYWQocHJvcHMuaW5BbXBNb2RlKSlcbiAgICAuZmlsdGVyKHVuaXF1ZSgpKVxuICAgIC5yZXZlcnNlKClcbiAgICAubWFwKChjOiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PiwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBjLmtleSB8fCBpXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVpFX0ZPTlRTICYmICFwcm9wcy5pbkFtcE1vZGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGMudHlwZSA9PT0gJ2xpbmsnICYmXG4gICAgICAgICAgYy5wcm9wc1snaHJlZiddICYmXG4gICAgICAgICAgLy8gVE9ETyhwcmF0ZWVrYmhAKTogUmVwbGFjZSB0aGlzIHdpdGggY29uc3QgZnJvbSBgY29uc3RhbnRzYCB3aGVuIHRoZSB0cmVlIHNoYWtpbmcgd29ya3MuXG4gICAgICAgICAgWydodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzcyddLnNvbWUoKHVybCkgPT5cbiAgICAgICAgICAgIGMucHJvcHNbJ2hyZWYnXS5zdGFydHNXaXRoKHVybClcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5ld1Byb3BzID0geyAuLi4oYy5wcm9wcyB8fCB7fSkgfVxuICAgICAgICAgIG5ld1Byb3BzWydkYXRhLWhyZWYnXSA9IG5ld1Byb3BzWydocmVmJ11cbiAgICAgICAgICBuZXdQcm9wc1snaHJlZiddID0gdW5kZWZpbmVkXG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCBuZXdQcm9wcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjLCB7IGtleSB9KVxuICAgIH0pXG59XG5cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIEhlYWQoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICBjb25zdCBhbXBTdGF0ZSA9IHVzZUNvbnRleHQoQW1wU3RhdGVDb250ZXh0KVxuICBjb25zdCBoZWFkTWFuYWdlciA9IHVzZUNvbnRleHQoSGVhZE1hbmFnZXJDb250ZXh0KVxuICByZXR1cm4gKFxuICAgIDxFZmZlY3RcbiAgICAgIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlPXtyZWR1Y2VDb21wb25lbnRzfVxuICAgICAgaGVhZE1hbmFnZXI9e2hlYWRNYW5hZ2VyfVxuICAgICAgaW5BbXBNb2RlPXtpc0luQW1wTW9kZShhbXBTdGF0ZSl9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvRWZmZWN0PlxuICApXG59XG5cbi8vIFRPRE86IFJlbW92ZSBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5IZWFkLnJld2luZCA9ICgpID0+IHt9XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRcbiIsImV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGVQYXRoKFxuICBwYXRobmFtZTogc3RyaW5nLFxuICBsb2NhbGVzPzogc3RyaW5nW11cbik6IHtcbiAgZGV0ZWN0ZWRMb2NhbGU/OiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xufSB7XG4gIGxldCBkZXRlY3RlZExvY2FsZTogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIC8vIGZpcnN0IGl0ZW0gd2lsbCBiZSBlbXB0eSBzdHJpbmcgZnJvbSBzcGxpdHRpbmcgYXQgZmlyc3QgY2hhclxuICBjb25zdCBwYXRobmFtZVBhcnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKVxuXG4gIDsobG9jYWxlcyB8fCBbXSkuc29tZSgobG9jYWxlKSA9PiB7XG4gICAgaWYgKHBhdGhuYW1lUGFydHNbMV0udG9Mb3dlckNhc2UoKSA9PT0gbG9jYWxlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGRldGVjdGVkTG9jYWxlID0gbG9jYWxlXG4gICAgICBwYXRobmFtZVBhcnRzLnNwbGljZSgxLCAxKVxuICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZVBhcnRzLmpvaW4oJy8nKSB8fCAnLydcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgZGV0ZWN0ZWRMb2NhbGUsXG4gIH1cbn1cbiIsIi8qXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIEphc29uIE1pbGxlciAoaHR0cHM6Ly9qYXNvbmZvcm1hdC5jb20vKVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG4vLyBUaGlzIGZpbGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9taXR0L2Jsb2IvdjEuMS4zL3NyYy9pbmRleC5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCBmb3IgdGhlIG5lZWRzIG9mIHRoaXMgc2NyaXB0XG4vLyBTZWUgdGhlIExJQ0VOU0UgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZVxuXG50eXBlIEhhbmRsZXIgPSAoLi4uZXZ0czogYW55W10pID0+IHZvaWRcblxuZXhwb3J0IHR5cGUgTWl0dEVtaXR0ZXIgPSB7XG4gIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKTogdm9pZFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaXR0KCk6IE1pdHRFbWl0dGVyIHtcbiAgY29uc3QgYWxsOiB7IFtzOiBzdHJpbmddOiBIYW5kbGVyW10gfSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICByZXR1cm4ge1xuICAgIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgOyhhbGxbdHlwZV0gfHwgKGFsbFt0eXBlXSA9IFtdKSkucHVzaChoYW5kbGVyKVxuICAgIH0sXG5cbiAgICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICBpZiAoYWxsW3R5cGVdKSB7XG4gICAgICAgIGFsbFt0eXBlXS5zcGxpY2UoYWxsW3R5cGVdLmluZGV4T2YoaGFuZGxlcikgPj4+IDAsIDEpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgOyhhbGxbdHlwZV0gfHwgW10pLnNsaWNlKCkubWFwKChoYW5kbGVyOiBIYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbmRsZXIoLi4uZXZ0cylcbiAgICAgIH0pXG4gICAgfSxcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcblxuZXhwb3J0IGNvbnN0IFJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5leHRSb3V0ZXI+KG51bGwgYXMgYW55KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1JvdXRlckNvbnRleHQnXG59XG4iLCIvKiBnbG9iYWwgX19ORVhUX0RBVEFfXyAqL1xuLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoLFxuICByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCxcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaCdcbmltcG9ydCB7IEdvb2RQYWdlQ2FjaGUsIFN0eWxlU2hlZXRUdXBsZSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9wYWdlLWxvYWRlcidcbmltcG9ydCB7XG4gIGdldENsaWVudEJ1aWxkTWFuaWZlc3QsXG4gIGlzQXNzZXRFcnJvcixcbiAgbWFya0Fzc2V0RXJyb3IsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXInXG5pbXBvcnQgeyBkZW5vcm1hbGl6ZVBhZ2VQYXRoIH0gZnJvbSAnLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aCdcbmltcG9ydCBtaXR0LCB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB7XG4gIEFwcENvbnRleHRUeXBlLFxuICBmb3JtYXRXaXRoVmFsaWRhdGlvbixcbiAgZ2V0TG9jYXRpb25PcmlnaW4sXG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTmV4dFBhZ2VDb250ZXh0LFxuICBTVCxcbn0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgZXNjYXBlUGF0aERlbGltaXRlcnMgZnJvbSAnLi91dGlscy9lc2NhcGUtcGF0aC1kZWxpbWl0ZXJzJ1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQgeyBwYXJzZVJlbGF0aXZlVXJsIH0gZnJvbSAnLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi91dGlscy9xdWVyeXN0cmluZydcbmltcG9ydCByZXNvbHZlUmV3cml0ZXMgZnJvbSAnLi91dGlscy9yZXNvbHZlLXJld3JpdGVzJ1xuaW1wb3J0IHsgZ2V0Um91dGVNYXRjaGVyIH0gZnJvbSAnLi91dGlscy9yb3V0ZS1tYXRjaGVyJ1xuaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vdXRpbHMvcm91dGUtcmVnZXgnXG5cbmludGVyZmFjZSBUcmFuc2l0aW9uT3B0aW9ucyB7XG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG59XG5cbmludGVyZmFjZSBOZXh0SGlzdG9yeVN0YXRlIHtcbiAgdXJsOiBzdHJpbmdcbiAgYXM6IHN0cmluZ1xuICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xufVxuXG50eXBlIEhpc3RvcnlTdGF0ZSA9IG51bGwgfCB7IF9fTjogZmFsc2UgfSB8ICh7IF9fTjogdHJ1ZSB9ICYgTmV4dEhpc3RvcnlTdGF0ZSlcblxuY29uc3QgYmFzZVBhdGggPSAocHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCBhcyBzdHJpbmcpIHx8ICcnXG5cbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICBjYW5jZWxsZWQ6IHRydWUsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZFBhdGhQcmVmaXgocGF0aDogc3RyaW5nLCBwcmVmaXg/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHByZWZpeCAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nKVxuICAgID8gcGF0aCA9PT0gJy8nXG4gICAgICA/IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKHByZWZpeClcbiAgICAgIDogYCR7cHJlZml4fSR7cGF0aH1gXG4gICAgOiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMb2NhbGUoXG4gIHBhdGg6IHN0cmluZyxcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2UsXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgIHJldHVybiBsb2NhbGUgJiZcbiAgICAgIGxvY2FsZSAhPT0gZGVmYXVsdExvY2FsZSAmJlxuICAgICAgIXBhdGguc3RhcnRzV2l0aCgnLycgKyBsb2NhbGUgKyAnLycpICYmXG4gICAgICBwYXRoICE9PSAnLycgKyBsb2NhbGVcbiAgICAgID8gYWRkUGF0aFByZWZpeChwYXRoLCAnLycgKyBsb2NhbGUpXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsTG9jYWxlKHBhdGg6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIGxvY2FsZSAmJlxuICAgICAgKHBhdGguc3RhcnRzV2l0aCgnLycgKyBsb2NhbGUgKyAnLycpIHx8IHBhdGggPT09ICcvJyArIGxvY2FsZSlcbiAgICAgID8gcGF0aC5zdWJzdHIobG9jYWxlLmxlbmd0aCArIDEpIHx8ICcvJ1xuICAgICAgOiBwYXRoXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gcGF0aCA9PT0gYmFzZVBhdGggfHwgcGF0aC5zdGFydHNXaXRoKGJhc2VQYXRoICsgJy8nKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gd2Ugb25seSBhZGQgdGhlIGJhc2VwYXRoIG9uIHJlbGF0aXZlIHVybHNcbiAgcmV0dXJuIGFkZFBhdGhQcmVmaXgocGF0aCwgYmFzZVBhdGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aC5zbGljZShiYXNlUGF0aC5sZW5ndGgpIHx8ICcvJ1xufVxuXG4vKipcbiAqIERldGVjdHMgd2hldGhlciBhIGdpdmVuIHVybCBpcyByb3V0YWJsZSBieSB0aGUgTmV4dC5qcyByb3V0ZXIgKGJyb3dzZXIgb25seSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsVVJMKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnLycpKSByZXR1cm4gdHJ1ZVxuICB0cnkge1xuICAgIC8vIGFic29sdXRlIHVybHMgY2FuIGJlIGxvY2FsIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG9yaWdpblxuICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICAgIGNvbnN0IHJlc29sdmVkID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uT3JpZ2luKVxuICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmIGhhc0Jhc2VQYXRoKHJlc29sdmVkLnBhdGhuYW1lKVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxudHlwZSBVcmwgPSBVcmxPYmplY3QgfCBzdHJpbmdcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlQXMoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGFzUGF0aG5hbWU6IHN0cmluZyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pIHtcbiAgbGV0IGludGVycG9sYXRlZFJvdXRlID0gJydcblxuICBjb25zdCBkeW5hbWljUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICBjb25zdCBkeW5hbWljR3JvdXBzID0gZHluYW1pY1JlZ2V4Lmdyb3Vwc1xuICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9XG4gICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBkeW5hbWljIHJvdXRlIGFnYWluc3QgdGhlIGFzUGF0aFxuICAgIChhc1BhdGhuYW1lICE9PSByb3V0ZSA/IGdldFJvdXRlTWF0Y2hlcihkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogJycpIHx8XG4gICAgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5XG5cbiAgaW50ZXJwb2xhdGVkUm91dGUgPSByb3V0ZVxuICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhkeW5hbWljR3JvdXBzKVxuXG4gIGlmIChcbiAgICAhcGFyYW1zLmV2ZXJ5KChwYXJhbSkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gZHluYW1pY01hdGNoZXNbcGFyYW1dIHx8ICcnXG4gICAgICBjb25zdCB7IHJlcGVhdCwgb3B0aW9uYWwgfSA9IGR5bmFtaWNHcm91cHNbcGFyYW1dXG5cbiAgICAgIC8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxuICAgICAgbGV0IHJlcGxhY2VkID0gYFske3JlcGVhdCA/ICcuLi4nIDogJyd9JHtwYXJhbX1dYFxuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHJlcGxhY2VkID0gYCR7IXZhbHVlID8gJy8nIDogJyd9WyR7cmVwbGFjZWR9XWBcbiAgICAgIH1cbiAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFt2YWx1ZV1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKG9wdGlvbmFsIHx8IHBhcmFtIGluIGR5bmFtaWNNYXRjaGVzKSAmJlxuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbiAgICAgICAgKGludGVycG9sYXRlZFJvdXRlID1cbiAgICAgICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSEucmVwbGFjZShcbiAgICAgICAgICAgIHJlcGxhY2VkLFxuICAgICAgICAgICAgcmVwZWF0XG4gICAgICAgICAgICAgID8gKHZhbHVlIGFzIHN0cmluZ1tdKS5tYXAoZXNjYXBlUGF0aERlbGltaXRlcnMpLmpvaW4oJy8nKVxuICAgICAgICAgICAgICA6IGVzY2FwZVBhdGhEZWxpbWl0ZXJzKHZhbHVlIGFzIHN0cmluZylcbiAgICAgICAgICApIHx8ICcvJylcbiAgICAgIClcbiAgICB9KVxuICApIHtcbiAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG5cbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZSxcbiAgfVxufVxuXG5mdW5jdGlvbiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnk6IFBhcnNlZFVybFF1ZXJ5LCBwYXJhbXM6IHN0cmluZ1tdKSB7XG4gIGNvbnN0IGZpbHRlcmVkUXVlcnk6IFBhcnNlZFVybFF1ZXJ5ID0ge31cblxuICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKCFwYXJhbXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgZmlsdGVyZWRRdWVyeVtrZXldID0gcXVlcnlba2V5XVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGZpbHRlcmVkUXVlcnlcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhIGdpdmVuIGh5cGVybGluayB3aXRoIGEgY2VydGFpbiByb3V0ZXIgc3RhdGUgKGJhc2VQYXRoIG5vdCBpbmNsdWRlZCkuXG4gKiBQcmVzZXJ2ZXMgYWJzb2x1dGUgdXJscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVIcmVmKFxuICBjdXJyZW50UGF0aDogc3RyaW5nLFxuICBocmVmOiBVcmwsXG4gIHJlc29sdmVBcz86IGJvb2xlYW5cbik6IHN0cmluZyB7XG4gIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gIGNvbnN0IGJhc2UgPSBuZXcgVVJMKGN1cnJlbnRQYXRoLCAnaHR0cDovL24nKVxuICBjb25zdCB1cmxBc1N0cmluZyA9XG4gICAgdHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnID8gaHJlZiA6IGZvcm1hdFdpdGhWYWxpZGF0aW9uKGhyZWYpXG4gIC8vIFJldHVybiBiZWNhdXNlIGl0IGNhbm5vdCBiZSByb3V0ZWQgYnkgdGhlIE5leHQuanMgcm91dGVyXG4gIGlmICghaXNMb2NhbFVSTCh1cmxBc1N0cmluZykpIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsQXNTdHJpbmcsIGJhc2UpXG4gICAgZmluYWxVcmwucGF0aG5hbWUgPSBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChmaW5hbFVybC5wYXRobmFtZSlcbiAgICBsZXQgaW50ZXJwb2xhdGVkQXMgPSAnJ1xuXG4gICAgaWYgKFxuICAgICAgaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmXG4gICAgICBmaW5hbFVybC5zZWFyY2hQYXJhbXMgJiZcbiAgICAgIHJlc29sdmVBc1xuICAgICkge1xuICAgICAgY29uc3QgcXVlcnkgPSBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KGZpbmFsVXJsLnNlYXJjaFBhcmFtcylcblxuICAgICAgY29uc3QgeyByZXN1bHQsIHBhcmFtcyB9ID0gaW50ZXJwb2xhdGVBcyhcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lLFxuICAgICAgICBxdWVyeVxuICAgICAgKVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGludGVycG9sYXRlZEFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgIHBhdGhuYW1lOiByZXN1bHQsXG4gICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgY29uc3QgcmVzb2x2ZWRIcmVmID1cbiAgICAgIGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW5cbiAgICAgICAgPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpXG4gICAgICAgIDogZmluYWxVcmwuaHJlZlxuXG4gICAgcmV0dXJuIChyZXNvbHZlQXNcbiAgICAgID8gW3Jlc29sdmVkSHJlZiwgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXVxuICAgICAgOiByZXNvbHZlZEhyZWYpIGFzIHN0cmluZ1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIChyZXNvbHZlQXMgPyBbdXJsQXNTdHJpbmddIDogdXJsQXNTdHJpbmcpIGFzIHN0cmluZ1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXI6IE5leHRSb3V0ZXIsIHVybDogVXJsLCBhczogVXJsKSB7XG4gIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICByZXR1cm4ge1xuICAgIHVybDogYWRkQmFzZVBhdGgocmVzb2x2ZUhyZWYocm91dGVyLnBhdGhuYW1lLCB1cmwpKSxcbiAgICBhczogYXMgPyBhZGRCYXNlUGF0aChyZXNvbHZlSHJlZihyb3V0ZXIucGF0aG5hbWUsIGFzKSkgOiBhcyxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBCYXNlUm91dGVyID0ge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE5leHRSb3V0ZXIgPSBCYXNlUm91dGVyICZcbiAgUGljazxcbiAgICBSb3V0ZXIsXG4gICAgfCAncHVzaCdcbiAgICB8ICdyZXBsYWNlJ1xuICAgIHwgJ3JlbG9hZCdcbiAgICB8ICdiYWNrJ1xuICAgIHwgJ3ByZWZldGNoJ1xuICAgIHwgJ2JlZm9yZVBvcFN0YXRlJ1xuICAgIHwgJ2V2ZW50cydcbiAgICB8ICdpc0ZhbGxiYWNrJ1xuICA+XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoT3B0aW9ucyA9IHtcbiAgcHJpb3JpdHk/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG59XG5cbmV4cG9ydCB0eXBlIFByaXZhdGVSb3V0ZUluZm8gPVxuICB8IChPbWl0PENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ3N0eWxlU2hlZXRzJz4gJiB7IGluaXRpYWw6IHRydWUgfSlcbiAgfCBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm9cblxuZXhwb3J0IHR5cGUgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0ge1xuICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBlcnI/OiBFcnJvclxuICBlcnJvcj86IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wcyA9IFBpY2s8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvLCAnQ29tcG9uZW50JyB8ICdlcnInPiAmIHtcbiAgcm91dGVyOiBSb3V0ZXJcbn0gJiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5leHBvcnQgdHlwZSBBcHBDb21wb25lbnQgPSBDb21wb25lbnRUeXBlPEFwcFByb3BzPlxuXG50eXBlIFN1YnNjcmlwdGlvbiA9IChkYXRhOiBQcml2YXRlUm91dGVJbmZvLCBBcHA6IEFwcENvbXBvbmVudCkgPT4gUHJvbWlzZTx2b2lkPlxuXG50eXBlIEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgPSAoc3RhdGU6IE5leHRIaXN0b3J5U3RhdGUpID0+IGJvb2xlYW5cblxudHlwZSBDb21wb25lbnRMb2FkQ2FuY2VsID0gKCgpID0+IHZvaWQpIHwgbnVsbFxuXG50eXBlIEhpc3RvcnlNZXRob2QgPSAncmVwbGFjZVN0YXRlJyB8ICdwdXNoU3RhdGUnXG5cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJlxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAnc2Nyb2xsUmVzdG9yYXRpb24nIGluIHdpbmRvdy5oaXN0b3J5XG5cbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORF9FUlJPUiA9ICdTU0cgRGF0YSBOT1RfRk9VTkQnXG5cbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsOiBzdHJpbmcsIGF0dGVtcHRzOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgLy9cbiAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgLy8gPiBvcHRpb24uXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgIC8vXG4gICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICB9KS50aGVuKChyZXMpID0+IHtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSlcbiAgICAgIH1cbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIHJlbG9hZGluZyBpbiBkZXZlbG9wbWVudCBmcm9tIGZhbGxiYWNrIHJldHVybmluZyAyMDBcbiAgICAgICAgLy8gdG8gb24tZGVtYW5kLWVudHJ5LWhhbmRsZXIgY2F1c2luZyBpdCB0byByZWxvYWQgcGVyaW9kaWNhbGx5XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihTU0dfREFUQV9OT1RfRk9VTkRfRVJST1IpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApXG4gICAgfVxuICAgIHJldHVybiByZXMuanNvbigpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEoZGF0YUhyZWY6IHN0cmluZywgaXNTZXJ2ZXJSZW5kZXI6IGJvb2xlYW4pIHtcbiAgcmV0dXJuIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEpLmNhdGNoKChlcnI6IEVycm9yKSA9PiB7XG4gICAgLy8gV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXMgY2F1c2VkXG4gICAgLy8gb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG8gYW4gaW5maW5pdGVcbiAgICAvLyBsb29wLlxuXG4gICAgaWYgKCFpc1NlcnZlclJlbmRlcikge1xuICAgICAgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgIH1cbiAgICB0aHJvdyBlcnJcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGVyIGltcGxlbWVudHMgQmFzZVJvdXRlciB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgYWxsIGNvbXBvbmVudHMgbG9hZGVkIGluIGBSb3V0ZXJgXG4gICAqL1xuICBjb21wb25lbnRzOiB7IFtwYXRobmFtZTogc3RyaW5nXTogUHJpdmF0ZVJvdXRlSW5mbyB9XG4gIC8vIFN0YXRpYyBEYXRhIENhY2hlXG4gIHNkYzogeyBbYXNQYXRoOiBzdHJpbmddOiBvYmplY3QgfSA9IHt9XG4gIHN1YjogU3Vic2NyaXB0aW9uXG4gIGNsYzogQ29tcG9uZW50TG9hZENhbmNlbFxuICBwYWdlTG9hZGVyOiBhbnlcbiAgX2JwczogQmVmb3JlUG9wU3RhdGVDYWxsYmFjayB8IHVuZGVmaW5lZFxuICBldmVudHM6IE1pdHRFbWl0dGVyXG4gIF93cmFwQXBwOiAoQXBwOiBBcHBDb21wb25lbnQpID0+IGFueVxuICBpc1NzcjogYm9vbGVhblxuICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gIF9pbkZsaWdodFJvdXRlPzogc3RyaW5nXG4gIF9zaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcblxuICBzdGF0aWMgZXZlbnRzOiBNaXR0RW1pdHRlciA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgICAgbG9jYWxlLFxuICAgICAgbG9jYWxlcyxcbiAgICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgfToge1xuICAgICAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb25cbiAgICAgIGluaXRpYWxQcm9wczogYW55XG4gICAgICBwYWdlTG9hZGVyOiBhbnlcbiAgICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgQXBwOiBBcHBDb21wb25lbnRcbiAgICAgIHdyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gICAgICBlcnI/OiBFcnJvclxuICAgICAgaXNGYWxsYmFjazogYm9vbGVhblxuICAgICAgbG9jYWxlPzogc3RyaW5nXG4gICAgICBsb2NhbGVzPzogc3RyaW5nW11cbiAgICAgIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgICB9XG4gICkge1xuICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgIHRoaXMucm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgZXJyLFxuICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICBDb21wb25lbnQ6IEFwcCBhcyBDb21wb25lbnRUeXBlLFxuICAgICAgc3R5bGVTaGVldHM6IFtcbiAgICAgICAgLyogL19hcHAgZG9lcyBub3QgbmVlZCBpdHMgc3R5bGVzaGVldHMgbWFuYWdlZCAqL1xuICAgICAgXSxcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIHRoaXMuYXNQYXRoID1cbiAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBfX05FWFRfREFUQV9fLmF1dG9FeHBvcnQgPyBwYXRobmFtZSA6IGFzXG4gICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoXG4gICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb25cbiAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcFxuICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgIHRoaXMuaXNTc3IgPSB0cnVlXG5cbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBpc0ZhbGxiYWNrXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVcbiAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXNcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgaWYgKGFzLnN1YnN0cigwLCAyKSAhPT0gJy8vJykge1xuICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksIHF1ZXJ5IH0pLFxuICAgICAgICAgIGdldFVSTCgpLFxuICAgICAgICAgIHsgbG9jYWxlIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpXG5cbiAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCdcblxuICAgICAgICAgIGxldCBzY3JvbGxEZWJvdW5jZVRpbWVvdXQ6IHVuZGVmaW5lZCB8IE5vZGVKUy5UaW1lb3V0XG5cbiAgICAgICAgICBjb25zdCBkZWJvdW5jZWRTY3JvbGxTYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjcm9sbERlYm91bmNlVGltZW91dCkgY2xlYXJUaW1lb3V0KHNjcm9sbERlYm91bmNlVGltZW91dClcblxuICAgICAgICAgICAgc2Nyb2xsRGVib3VuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgdXJsLCBhczogY3VyQXMsIG9wdGlvbnMgfSA9IGhpc3Rvcnkuc3RhdGVcbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgY3VyQXMsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgX05fWDogd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICBfTl9ZOiB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9LCAxMClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgZGVib3VuY2VkU2Nyb2xsU2F2ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUG9wU3RhdGUgPSAoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZSBhcyBIaXN0b3J5U3RhdGVcblxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gdGhpc1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgIGdldFVSTCgpXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zIH0gPSBzdGF0ZVxuXG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gdGhpcy5hc1BhdGggJiYgcGF0aG5hbWUgPT09IHRoaXMucGF0aG5hbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlKFxuICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICB1cmwsXG4gICAgICBhcyxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICByZWxvYWQoKTogdm9pZCB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gIH1cblxuICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqL1xuICBiYWNrKCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICBwdXNoKHVybDogVXJsLCBhczogVXJsID0gdXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHJlcGxhY2UodXJsOiBVcmwsIGFzOiBVcmwgPSB1cmwsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pIHtcbiAgICA7KHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKVxuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGNoYW5nZShcbiAgICBtZXRob2Q6IEhpc3RvcnlNZXRob2QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXM6IHN0cmluZyxcbiAgICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIWlzTG9jYWxVUkwodXJsKSkge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmxcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBsZXQgbG9jYWxlQ2hhbmdlID0gb3B0aW9ucy5sb2NhbGUgIT09IHRoaXMubG9jYWxlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgdGhpcy5sb2NhbGUgPVxuICAgICAgICBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2VcbiAgICAgICAgICA/IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgIDogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5sb2NhbGVcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSB0aGlzLmxvY2FsZVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgsXG4gICAgICB9ID0gcmVxdWlyZSgnLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpXG5cbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChoYXNCYXNlUGF0aChhcykgPyBkZWxCYXNlUGF0aChhcykgOiBhcylcbiAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICApXG4gICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGVcbiAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgobG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZSlcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIGxvY2FsZSBpc24ndCBjb25maWd1cmVkIGhhcmQgbmF2aWdhdGUgdG8gc2hvdyA0MDQgcGFnZVxuICAgICAgaWYgKCF0aGlzLmxvY2FsZXM/LmluY2x1ZGVzKHRoaXMubG9jYWxlISkpIHtcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBhZGRMb2NhbGUocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlKVxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEob3B0aW9ucyBhcyBhbnkpLl9oKSB7XG4gICAgICB0aGlzLmlzU3NyID0gZmFsc2VcbiAgICB9XG4gICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgIGlmIChTVCkge1xuICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlKSB7XG4gICAgICB0aGlzLmFib3J0Q29tcG9uZW50TG9hZCh0aGlzLl9pbkZsaWdodFJvdXRlKVxuICAgIH1cblxuICAgIGFzID0gYWRkQmFzZVBhdGgoXG4gICAgICBhZGRMb2NhbGUoXG4gICAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgICBvcHRpb25zLmxvY2FsZSxcbiAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICApXG4gICAgKVxuICAgIGNvbnN0IGNsZWFuZWRBcyA9IGRlbExvY2FsZShcbiAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgdGhpcy5sb2NhbGVcbiAgICApXG4gICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzXG5cbiAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cblxuICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgaWYgKCEob3B0aW9ucyBhcyBhbnkpLl9oICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykpIHtcbiAgICAgIHRoaXMuYXNQYXRoID0gY2xlYW5lZEFzXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzKVxuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKVxuICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdKVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkXG5cbiAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICBsZXQgcGFnZXM6IGFueSwgcmV3cml0ZXM6IGFueVxuICAgIHRyeSB7XG4gICAgICBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG4gICAgICA7KHsgX19yZXdyaXRlczogcmV3cml0ZXMgfSA9IGF3YWl0IGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgLy8gZG8gYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uOlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcGFyc2VkID0gdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkLCBwYWdlcykgYXMgdHlwZW9mIHBhcnNlZFxuXG4gICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG4gICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgfVxuXG4gICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgIHBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgID8gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goZGVsQmFzZVBhdGgocGF0aG5hbWUpKVxuICAgICAgOiBwYXRobmFtZVxuXG4gICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSdcbiAgICB9XG5cbiAgICBsZXQgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSB9ID0gb3B0aW9uc1xuXG4gICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgIHJlc29sdmVkQXMgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgIHBhcnNlUmVsYXRpdmVVcmwoYXMpLnBhdGhuYW1lLFxuICAgICAgICBwYWdlcyxcbiAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgIHJld3JpdGVzLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgKHA6IHN0cmluZykgPT4gdGhpcy5fcmVzb2x2ZUhyZWYoeyBwYXRobmFtZTogcCB9LCBwYWdlcykucGF0aG5hbWUhXG4gICAgICApXG5cbiAgICAgIGlmIChyZXNvbHZlZEFzICE9PSBhcykge1xuICAgICAgICBjb25zdCBwb3RlbnRpYWxIcmVmID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goXG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZUhyZWYoXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWQsIHsgcGF0aG5hbWU6IHJlc29sdmVkQXMgfSksXG4gICAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKS5wYXRobmFtZSFcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKHBvdGVudGlhbEhyZWYpKSB7XG4gICAgICAgICAgcm91dGUgPSBwb3RlbnRpYWxIcmVmXG4gICAgICAgICAgcGF0aG5hbWUgPSBwb3RlbnRpYWxIcmVmXG4gICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZWRBcyA9IGRlbExvY2FsZShkZWxCYXNlUGF0aChyZXNvbHZlZEFzKSwgdGhpcy5sb2NhbGUpXG5cbiAgICBpZiAoaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwocmVzb2x2ZWRBcylcbiAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZVxuXG4gICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSlcbiAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWVcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgPyBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSlcbiAgICAgICAgOiAoe30gYXMgeyByZXN1bHQ6IHVuZGVmaW5lZDsgcGFyYW1zOiB1bmRlZmluZWQgfSlcblxuICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IChzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSkge1xuICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcihcbiAgICAgICAgICAocGFyYW0pID0+ICFxdWVyeVtwYXJhbV1cbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyBgSW50ZXJwb2xhdGluZyBocmVmYFxuICAgICAgICAgICAgICAgICAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgXG4gICAgICAgICAgICAgIH0gZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgYCArXG4gICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgKHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgID8gYFRoZSBwcm92aWRlZCBcXGBocmVmXFxgICgke3VybH0pIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzICgke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgXG4gICAgICAgICAgICAgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgK1xuICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy8ke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJ1xuICAgICAgICAgICAgICAgICAgOiAnaW5jb21wYXRpYmxlLWhyZWYtYXMnXG4gICAgICAgICAgICAgIH1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMhKSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKVxuICAgICAgfVxuICAgIH1cblxuICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgc2hhbGxvd1xuICAgICAgKVxuICAgICAgbGV0IHsgZXJyb3IsIHByb3BzLCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm9cblxuICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICBpZiAoXG4gICAgICAgIChfX05fU1NHIHx8IF9fTl9TU1ApICYmXG4gICAgICAgIHByb3BzICYmXG4gICAgICAgIChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcyAmJlxuICAgICAgICAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUXG5cbiAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkSHJlZiA9IHBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pXG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkSHJlZiwgcGFnZXMsIGZhbHNlKVxuXG4gICAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKHBhcnNlZEhyZWYucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsLCBhczogbmV3QXMgfSA9IHByZXBhcmVVcmxBcyhcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCBuZXdVcmwsIG5ld0FzLCBvcHRpb25zKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gZGVzdGluYXRpb25cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcylcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBhcHBDb21wOiBhbnkgPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50XG4gICAgICAgIDsod2luZG93IGFzIGFueSkubmV4dC5pc1ByZXJlbmRlcmVkID1cbiAgICAgICAgICBhcHBDb21wLmdldEluaXRpYWxQcm9wcyA9PT0gYXBwQ29tcC5vcmlnR2V0SW5pdGlhbFByb3BzICYmXG4gICAgICAgICAgIShyb3V0ZUluZm8uQ29tcG9uZW50IGFzIGFueSkuZ2V0SW5pdGlhbFByb3BzXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuc2V0KHJvdXRlLCBwYXRobmFtZSEsIHF1ZXJ5LCBjbGVhbmVkQXMsIHJvdXRlSW5mbykuY2F0Y2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSBlcnJvciA9IGVycm9yIHx8IGVcbiAgICAgICAgICBlbHNlIHRocm93IGVcbiAgICAgICAgfVxuICAgICAgKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcylcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uICYmICdfTl9YJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKChvcHRpb25zIGFzIGFueSkuX05fWCwgKG9wdGlvbnMgYXMgYW55KS5fTl9ZKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gdGhpcy5sb2NhbGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMpXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNoYW5nZVN0YXRlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge31cbiAgKTogdm9pZCB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkuJHttZXRob2R9IGlzIG5vdCBhdmFpbGFibGVgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCBnZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3dcbiAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oXG4gICAgICAgIHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgIH0gYXMgSGlzdG9yeVN0YXRlLFxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgJycsXG4gICAgICAgIGFzXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgZXJyOiBFcnJvciAmIHsgY29kZTogYW55OyBjYW5jZWxsZWQ6IGJvb2xlYW4gfSxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIGxvYWRFcnJvckZhaWw/OiBib29sZWFuXG4gICk6IFByb21pc2U8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvPiB7XG4gICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoaXNBc3NldEVycm9yKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBhcylcblxuICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG5cbiAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuXG4gICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgbGV0IHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICAgICAgbGV0IHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkXG4gICAgICBjb25zdCBzc2c0MDQgPSBlcnIubWVzc2FnZSA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EX0VSUk9SXG5cbiAgICAgIGlmIChzc2c0MDQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgbW9kOiBhbnlcbiAgICAgICAgICA7KHsgcGFnZTogQ29tcG9uZW50LCBzdHlsZVNoZWV0cywgbW9kIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFxuICAgICAgICAgICAgJy80MDQnXG4gICAgICAgICAgKSlcblxuICAgICAgICAgIC8vIFRPRE86IHNob3VsZCB3ZSB0b2xlcmF0ZSB0aGVzZSBwcm9wcyBtaXNzaW5nIGFuZCBzdGlsbCByZW5kZXIgdGhlXG4gICAgICAgICAgLy8gcGFnZSBpbnN0ZWFkIG9mIGZhbGxpbmcgYmFjayB0byBfZXJyb3I/XG4gICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19OX1NTRykge1xuICAgICAgICAgICAgcHJvcHMgPSBhd2FpdCB0aGlzLl9nZXRTdGF0aWNEYXRhKFxuICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoJy80MDQnLCAnLzQwNCcsIHRydWUsIHRoaXMubG9jYWxlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIC8vIG5vbi1mYXRhbCBmYWxsYmFjayB0byBfZXJyb3JcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBDb21wb25lbnQhID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygc3R5bGVTaGVldHMhID09PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIDsoeyBwYWdlOiBDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFxuICAgICAgICAgICcvX2Vycm9yJ1xuICAgICAgICApKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgIGVycjogc3NnNDA0ID8gdW5kZWZpbmVkIDogZXJyLFxuICAgICAgICBlcnJvcjogc3NnNDA0ID8gdW5kZWZpbmVkIDogZXJyLFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB9IGFzIGFueSlcbiAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJywgZ2lwRXJyKVxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3Iocm91dGVJbmZvRXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFJvdXRlSW5mbyhcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IGFueSxcbiAgICBhczogc3RyaW5nLFxuICAgIHNoYWxsb3c6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPFByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdSb3V0ZUluZm86IFByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPSB0aGlzLmNvbXBvbmVudHNbXG4gICAgICAgIHJvdXRlXG4gICAgICBdXG4gICAgICBpZiAoc2hhbGxvdyAmJiBleGlzdGluZ1JvdXRlSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdSb3V0ZUluZm9cbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FjaGVkUm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPVxuICAgICAgICBleGlzdGluZ1JvdXRlSW5mbyAmJiAnaW5pdGlhbCcgaW4gZXhpc3RpbmdSb3V0ZUluZm9cbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogZXhpc3RpbmdSb3V0ZUluZm9cbiAgICAgIGNvbnN0IHJvdXRlSW5mbzogQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvXG4gICAgICAgID8gY2FjaGVkUm91dGVJbmZvXG4gICAgICAgIDogYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKSA9PiAoe1xuICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgfSkpXG5cbiAgICAgIGNvbnN0IHsgQ29tcG9uZW50LCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm9cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoJ3JlYWN0LWlzJylcbiAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGFIcmVmOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgICAgaWYgKF9fTl9TU0cgfHwgX19OX1NTUCkge1xuICAgICAgICBkYXRhSHJlZiA9IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZihcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgICBkZWxCYXNlUGF0aChhcyksXG4gICAgICAgICAgX19OX1NTRyxcbiAgICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+KCgpID0+XG4gICAgICAgIF9fTl9TU0dcbiAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogX19OX1NTUFxuICAgICAgICAgID8gdGhpcy5fZ2V0U2VydmVyRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiB0aGlzLmdldEluaXRpYWxQcm9wcyhcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgfSBhcyBhbnlcbiAgICAgICAgICAgIClcbiAgICAgIClcblxuICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHNcbiAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm9cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKGVyciwgcGF0aG5hbWUsIHF1ZXJ5LCBhcylcbiAgICB9XG4gIH1cblxuICBzZXQoXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIGRhdGE6IFByaXZhdGVSb3V0ZUluZm9cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pc0ZhbGxiYWNrID0gZmFsc2VcblxuICAgIHRoaXMucm91dGUgPSByb3V0ZVxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIHRoaXMuYXNQYXRoID0gYXNcbiAgICByZXR1cm4gdGhpcy5ub3RpZnkoZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgYmVmb3JlUG9wU3RhdGUoY2I6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9icHMgPSBjYlxuICB9XG5cbiAgb25seUFIYXNoQ2hhbmdlKGFzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJylcbiAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJylcblxuICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2hcbiAgfVxuXG4gIHNjcm9sbFRvSGFzaChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgWywgaGFzaF0gPSBhcy5zcGxpdCgnIycpXG4gICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlXG4gICAgaWYgKGhhc2ggPT09ICcnKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKGlkRWwpIHtcbiAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdXG4gICAgaWYgKG5hbWVFbCkge1xuICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG4gIH1cblxuICB1cmxJc05ldyhhc1BhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoXG4gIH1cblxuICBfcmVzb2x2ZUhyZWYocGFyc2VkSHJlZjogVXJsT2JqZWN0LCBwYWdlczogc3RyaW5nW10sIGFwcGx5QmFzZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VkSHJlZlxuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChcbiAgICAgIGRlbm9ybWFsaXplUGFnZVBhdGgoYXBwbHlCYXNlUGF0aCA/IGRlbEJhc2VQYXRoKHBhdGhuYW1lISkgOiBwYXRobmFtZSEpXG4gICAgKVxuXG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09ICcvNDA0JyB8fCBjbGVhblBhdGhuYW1lID09PSAnL19lcnJvcicpIHtcbiAgICAgIHJldHVybiBwYXJzZWRIcmVmXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSEpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICBwYWdlcy5zb21lKChwYWdlKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0R5bmFtaWNSb3V0ZShwYWdlKSAmJlxuICAgICAgICAgIGdldFJvdXRlUmVnZXgocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lISlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IGFwcGx5QmFzZVBhdGggPyBhZGRCYXNlUGF0aChwYWdlKSA6IHBhZ2VcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkSHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi9cbiAgYXN5bmMgcHJlZmV0Y2goXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXNQYXRoOiBzdHJpbmcgPSB1cmwsXG4gICAgb3B0aW9uczogUHJlZmV0Y2hPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgbGV0IHsgcGF0aG5hbWUgfSA9IHBhcnNlZFxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZUxvY2FsZVBhdGggPSByZXF1aXJlKCcuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpXG4gICAgICAgIC5ub3JtYWxpemVMb2NhbGVQYXRoIGFzIHR5cGVvZiBpbXBvcnQoJy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJykubm9ybWFsaXplTG9jYWxlUGF0aFxuXG4gICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHBhdGhuYW1lID0gbm9ybWFsaXplTG9jYWxlUGF0aCEocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWVcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuXG4gICAgICAgIGxldCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKVxuICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aCEoXG4gICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgIClcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lXG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgYXNQYXRoID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuXG4gICAgcGFyc2VkID0gdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkLCBwYWdlcywgZmFsc2UpIGFzIHR5cGVvZiBwYXJzZWRcblxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHVybCkudGhlbigoaXNTc2c6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgcmV0dXJuIGlzU3NnXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKFxuICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzUGF0aCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5sb2NhbGVcbiAgICAgICAgICAgICAgICAgIDogdGhpcy5sb2NhbGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLFxuICAgIF0pXG4gIH1cblxuICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxHb29kUGFnZUNhY2hlPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpXG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKFxuICAgICAgICBgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYFxuICAgICAgKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdFxuICB9XG5cbiAgX2dldERhdGE8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfVxuICAgIHRoaXMuY2xjID0gY2FuY2VsXG4gICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKVxuICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFN0YXRpY0RhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgdGhpcy5zZGNbY2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RjW2NhY2hlS2V5XSlcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHRoaXMuc2RjW2NhY2hlS2V5XSA9IGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKVxuICB9XG5cbiAgZ2V0SW5pdGlhbFByb3BzKFxuICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZSxcbiAgICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXVxuICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCBhcyBBcHBDb21wb25lbnQpXG4gICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlXG4gICAgcmV0dXJuIGxvYWRHZXRJbml0aWFsUHJvcHM8QXBwQ29udGV4dFR5cGU8Um91dGVyPj4oQXBwLCB7XG4gICAgICBBcHBUcmVlLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgY3R4LFxuICAgIH0pXG4gIH1cblxuICBhYm9ydENvbXBvbmVudExvYWQoYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCBhcylcbiAgICAgIHRoaXMuY2xjKClcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIG5vdGlmeShkYXRhOiBQcml2YXRlUm91dGVJbmZvKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQgYXMgQXBwQ29tcG9uZW50KVxuICB9XG59XG4iLCIvLyBlc2NhcGUgZGVsaW1pdGVycyB1c2VkIGJ5IHBhdGgtdG8tcmVnZXhwXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlc2NhcGVQYXRoRGVsaW1pdGVycyhzZWdtZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc2VnbWVudC5yZXBsYWNlKC9bLyM/XS9nLCAoY2hhcjogc3RyaW5nKSA9PiBlbmNvZGVVUklDb21wb25lbnQoY2hhcikpXG59XG4iLCIvLyBGb3JtYXQgZnVuY3Rpb24gbW9kaWZpZWQgZnJvbSBub2RlanNcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAnLi9xdWVyeXN0cmluZydcblxuY29uc3Qgc2xhc2hlZFByb3RvY29scyA9IC9odHRwcz98ZnRwfGdvcGhlcnxmaWxlL1xuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VXJsKHVybE9iajogVXJsT2JqZWN0KSB7XG4gIGxldCB7IGF1dGgsIGhvc3RuYW1lIH0gPSB1cmxPYmpcbiAgbGV0IHByb3RvY29sID0gdXJsT2JqLnByb3RvY29sIHx8ICcnXG4gIGxldCBwYXRobmFtZSA9IHVybE9iai5wYXRobmFtZSB8fCAnJ1xuICBsZXQgaGFzaCA9IHVybE9iai5oYXNoIHx8ICcnXG4gIGxldCBxdWVyeSA9IHVybE9iai5xdWVyeSB8fCAnJ1xuICBsZXQgaG9zdDogc3RyaW5nIHwgZmFsc2UgPSBmYWxzZVxuXG4gIGF1dGggPSBhdXRoID8gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpLnJlcGxhY2UoLyUzQS9pLCAnOicpICsgJ0AnIDogJydcblxuICBpZiAodXJsT2JqLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0XG4gIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh+aG9zdG5hbWUuaW5kZXhPZignOicpID8gYFske2hvc3RuYW1lfV1gIDogaG9zdG5hbWUpXG4gICAgaWYgKHVybE9iai5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHVybE9iai5wb3J0XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXJ5ICYmIHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICBxdWVyeSA9IFN0cmluZyhxdWVyeXN0cmluZy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zKHF1ZXJ5IGFzIFBhcnNlZFVybFF1ZXJ5KSlcbiAgfVxuXG4gIGxldCBzZWFyY2ggPSB1cmxPYmouc2VhcmNoIHx8IChxdWVyeSAmJiBgPyR7cXVlcnl9YCkgfHwgJydcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOidcblxuICBpZiAoXG4gICAgdXJsT2JqLnNsYXNoZXMgfHxcbiAgICAoKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xzLnRlc3QocHJvdG9jb2wpKSAmJiBob3N0ICE9PSBmYWxzZSlcbiAgKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJylcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWVbMF0gIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnXG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoWzBdICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaFxuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBlbmNvZGVVUklDb21wb25lbnQpXG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpXG5cbiAgcmV0dXJuIGAke3Byb3RvY29sfSR7aG9zdH0ke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1gXG59XG4iLCIvLyBUcmFuc2xhdGVzIGEgbG9naWNhbCByb3V0ZSBpbnRvIGl0cyBwYWdlcyBhc3NldCBwYXRoIChyZWxhdGl2ZSBmcm9tIGEgY29tbW9uIHByZWZpeClcbi8vIFwiYXNzZXQgcGF0aFwiIGJlaW5nIGl0cyBqYXZhc2NyaXB0IGZpbGUsIGRhdGEgZmlsZSwgcHJlcmVuZGVyZWQgaHRtbCwuLi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFzc2V0UGF0aEZyb21Sb3V0ZShcbiAgcm91dGU6IHN0cmluZyxcbiAgZXh0OiBzdHJpbmcgPSAnJ1xuKTogc3RyaW5nIHtcbiAgY29uc3QgcGF0aCA9XG4gICAgcm91dGUgPT09ICcvJ1xuICAgICAgPyAnL2luZGV4J1xuICAgICAgOiAvXlxcL2luZGV4KFxcL3wkKS8udGVzdChyb3V0ZSlcbiAgICAgID8gYC9pbmRleCR7cm91dGV9YFxuICAgICAgOiBgJHtyb3V0ZX1gXG4gIHJldHVybiBwYXRoICsgZXh0XG59XG4iLCIvLyBJZGVudGlmeSAvW3BhcmFtXS8gaW4gcm91dGUgc3RyaW5nXG5jb25zdCBURVNUX1JPVVRFID0gL1xcL1xcW1teL10rP1xcXSg/PVxcL3wkKS9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY1JvdXRlKHJvdXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSlcbn1cbiIsImltcG9ydCB7IGdldExvY2F0aW9uT3JpZ2luIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeXN0cmluZydcblxuLyoqXG4gKiBQYXJzZXMgcGF0aC1yZWxhdGl2ZSB1cmxzIChlLmcuIGAvaGVsbG8vd29ybGQ/Zm9vPWJhcmApLiBJZiB1cmwgaXNuJ3QgcGF0aC1yZWxhdGl2ZVxuICogKGUuZy4gYC4vaGVsbG9gKSB0aGVuIGF0IGxlYXN0IGJhc2UgbXVzdCBiZS5cbiAqIEFic29sdXRlIHVybHMgYXJlIHJlamVjdGVkIHdpdGggb25lIGV4Y2VwdGlvbiwgaW4gdGhlIGJyb3dzZXIsIGFic29sdXRlIHVybHMgdGhhdCBhcmUgb25cbiAqIHRoZSBjdXJyZW50IG9yaWdpbiB3aWxsIGJlIHBhcnNlZCBhcyByZWxhdGl2ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWxhdGl2ZVVybCh1cmw6IHN0cmluZywgYmFzZT86IHN0cmluZykge1xuICBjb25zdCBnbG9iYWxCYXNlID0gbmV3IFVSTChcbiAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIClcbiAgY29uc3QgcmVzb2x2ZWRCYXNlID0gYmFzZSA/IG5ldyBVUkwoYmFzZSwgZ2xvYmFsQmFzZSkgOiBnbG9iYWxCYXNlXG4gIGNvbnN0IHsgcGF0aG5hbWUsIHNlYXJjaFBhcmFtcywgc2VhcmNoLCBoYXNoLCBocmVmLCBvcmlnaW4gfSA9IG5ldyBVUkwoXG4gICAgdXJsLFxuICAgIHJlc29sdmVkQmFzZVxuICApXG4gIGlmIChvcmlnaW4gIT09IGdsb2JhbEJhc2Uub3JpZ2luKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQ6IGludmFsaWQgcmVsYXRpdmUgVVJMJylcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIHF1ZXJ5OiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcyksXG4gICAgc2VhcmNoLFxuICAgIGhhc2gsXG4gICAgaHJlZjogaHJlZi5zbGljZShnbG9iYWxCYXNlLm9yaWdpbi5sZW5ndGgpLFxuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBwYXRoVG9SZWdleHAgZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwJ1xuXG5leHBvcnQgeyBwYXRoVG9SZWdleHAgfVxuXG5leHBvcnQgY29uc3QgbWF0Y2hlck9wdGlvbnM6IHBhdGhUb1JlZ2V4cC5Ub2tlbnNUb1JlZ2V4cE9wdGlvbnMgJlxuICBwYXRoVG9SZWdleHAuUGFyc2VPcHRpb25zID0ge1xuICBzZW5zaXRpdmU6IGZhbHNlLFxuICBkZWxpbWl0ZXI6ICcvJyxcbn1cblxuZXhwb3J0IGNvbnN0IGN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnM6IHBhdGhUb1JlZ2V4cC5Ub2tlbnNUb1JlZ2V4cE9wdGlvbnMgJlxuICBwYXRoVG9SZWdleHAuUGFyc2VPcHRpb25zID0ge1xuICAuLi5tYXRjaGVyT3B0aW9ucyxcbiAgc3RyaWN0OiB0cnVlLFxufVxuXG5leHBvcnQgZGVmYXVsdCAoY3VzdG9tUm91dGUgPSBmYWxzZSkgPT4ge1xuICByZXR1cm4gKHBhdGg6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGtleXM6IHBhdGhUb1JlZ2V4cC5LZXlbXSA9IFtdXG4gICAgY29uc3QgbWF0Y2hlclJlZ2V4ID0gcGF0aFRvUmVnZXhwLnBhdGhUb1JlZ2V4cChcbiAgICAgIHBhdGgsXG4gICAgICBrZXlzLFxuICAgICAgY3VzdG9tUm91dGUgPyBjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zIDogbWF0Y2hlck9wdGlvbnNcbiAgICApXG4gICAgY29uc3QgbWF0Y2hlciA9IHBhdGhUb1JlZ2V4cC5yZWdleHBUb0Z1bmN0aW9uKG1hdGNoZXJSZWdleCwga2V5cylcblxuICAgIHJldHVybiAocGF0aG5hbWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQsIHBhcmFtcz86IGFueSkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gcGF0aG5hbWUgPT0gbnVsbCA/IGZhbHNlIDogbWF0Y2hlcihwYXRobmFtZSlcbiAgICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoY3VzdG9tUm91dGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAgIC8vIHVubmFtZWQgcGFyYW1zIHNob3VsZCBiZSByZW1vdmVkIGFzIHRoZXlcbiAgICAgICAgICAvLyBhcmUgbm90IGFsbG93ZWQgdG8gYmUgdXNlZCBpbiB0aGUgZGVzdGluYXRpb25cbiAgICAgICAgICBpZiAodHlwZW9mIGtleS5uYW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZGVsZXRlIChyZXMucGFyYW1zIGFzIGFueSlba2V5Lm5hbWVdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IC4uLnBhcmFtcywgLi4ucmVzLnBhcmFtcyB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vcXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBwYXJzZVJlbGF0aXZlVXJsIH0gZnJvbSAnLi9wYXJzZS1yZWxhdGl2ZS11cmwnXG5pbXBvcnQgKiBhcyBwYXRoVG9SZWdleHAgZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwJ1xuXG50eXBlIFBhcmFtcyA9IHsgW3BhcmFtOiBzdHJpbmddOiBhbnkgfVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZU5vblBhdGgodmFsdWU6IHN0cmluZywgcGFyYW1zOiBQYXJhbXMpOiBzdHJpbmcge1xuICBpZiAoIXZhbHVlLmluY2x1ZGVzKCc6JykpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUuaW5jbHVkZXMoYDoke2tleX1gKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICBuZXcgUmVnRXhwKGA6JHtrZXl9XFxcXCpgLCAnZycpLFxuICAgICAgICAgIGA6JHtrZXl9LS1FU0NBUEVEX1BBUkFNX0FTVEVSSVNLU2BcbiAgICAgICAgKVxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICBuZXcgUmVnRXhwKGA6JHtrZXl9XFxcXD9gLCAnZycpLFxuICAgICAgICAgIGA6JHtrZXl9LS1FU0NBUEVEX1BBUkFNX1FVRVNUSU9OYFxuICAgICAgICApXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYDoke2tleX1cXFxcK2AsICdnJyksIGA6JHtrZXl9LS1FU0NBUEVEX1BBUkFNX1BMVVNgKVxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICBuZXcgUmVnRXhwKGA6JHtrZXl9KD8hXFxcXHcpYCwgJ2cnKSxcbiAgICAgICAgICBgLS1FU0NBUEVEX1BBUkFNX0NPTE9OJHtrZXl9YFxuICAgICAgICApXG4gICAgfVxuICB9XG4gIHZhbHVlID0gdmFsdWVcbiAgICAucmVwbGFjZSgvKDp8XFwqfFxcP3xcXCt8XFwofFxcKXxcXHt8XFx9KS9nLCAnXFxcXCQxJylcbiAgICAucmVwbGFjZSgvLS1FU0NBUEVEX1BBUkFNX1BMVVMvZywgJysnKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fQ09MT04vZywgJzonKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fUVVFU1RJT04vZywgJz8nKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fQVNURVJJU0tTL2csICcqJylcblxuICAvLyB0aGUgdmFsdWUgbmVlZHMgdG8gc3RhcnQgd2l0aCBhIGZvcndhcmQtc2xhc2ggdG8gYmUgY29tcGlsZWRcbiAgLy8gY29ycmVjdGx5XG4gIHJldHVybiBwYXRoVG9SZWdleHBcbiAgICAuY29tcGlsZShgLyR7dmFsdWV9YCwgeyB2YWxpZGF0ZTogZmFsc2UgfSkocGFyYW1zKVxuICAgIC5zdWJzdHIoMSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJlcGFyZURlc3RpbmF0aW9uKFxuICBkZXN0aW5hdGlvbjogc3RyaW5nLFxuICBwYXJhbXM6IFBhcmFtcyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICBhcHBlbmRQYXJhbXNUb1F1ZXJ5OiBib29sZWFuLFxuICBiYXNlUGF0aDogc3RyaW5nXG4pIHtcbiAgbGV0IHBhcnNlZERlc3RpbmF0aW9uOiB7XG4gICAgcXVlcnk/OiBQYXJzZWRVcmxRdWVyeVxuICAgIHByb3RvY29sPzogc3RyaW5nXG4gICAgaG9zdG5hbWU/OiBzdHJpbmdcbiAgICBwb3J0Pzogc3RyaW5nXG4gIH0gJiBSZXR1cm5UeXBlPHR5cGVvZiBwYXJzZVJlbGF0aXZlVXJsPiA9IHt9IGFzIGFueVxuXG4gIC8vIGNsb25lIHF1ZXJ5IHNvIHdlIGRvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWxcbiAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCBxdWVyeSlcbiAgY29uc3QgaGFkTG9jYWxlID0gcXVlcnkuX19uZXh0TG9jYWxlXG4gIGRlbGV0ZSBxdWVyeS5fX25leHRMb2NhbGVcbiAgZGVsZXRlIHF1ZXJ5Ll9fbmV4dERlZmF1bHRMb2NhbGVcblxuICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgcGFyc2VkRGVzdGluYXRpb24gPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoUGFyYW1zLFxuICAgICAgaGFzaCxcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgcG9ydCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9ID0gbmV3IFVSTChkZXN0aW5hdGlvbilcblxuICAgIHBhcnNlZERlc3RpbmF0aW9uID0ge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBxdWVyeTogc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpLFxuICAgICAgaGFzaCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgaG9zdG5hbWUsXG4gICAgICBwb3J0LFxuICAgICAgc2VhcmNoLFxuICAgICAgaHJlZixcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXN0UXVlcnkgPSBwYXJzZWREZXN0aW5hdGlvbi5xdWVyeVxuICBjb25zdCBkZXN0UGF0aCA9IGAke3BhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lIX0ke1xuICAgIHBhcnNlZERlc3RpbmF0aW9uLmhhc2ggfHwgJydcbiAgfWBcbiAgY29uc3QgZGVzdFBhdGhQYXJhbUtleXM6IHBhdGhUb1JlZ2V4cC5LZXlbXSA9IFtdXG4gIHBhdGhUb1JlZ2V4cC5wYXRoVG9SZWdleHAoZGVzdFBhdGgsIGRlc3RQYXRoUGFyYW1LZXlzKVxuXG4gIGNvbnN0IGRlc3RQYXRoUGFyYW1zID0gZGVzdFBhdGhQYXJhbUtleXMubWFwKChrZXkpID0+IGtleS5uYW1lKVxuXG4gIGxldCBkZXN0aW5hdGlvbkNvbXBpbGVyID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUoXG4gICAgZGVzdFBhdGgsXG4gICAgLy8gd2UgZG9uJ3QgdmFsaWRhdGUgd2hpbGUgY29tcGlsaW5nIHRoZSBkZXN0aW5hdGlvbiBzaW5jZSB3ZSBzaG91bGRcbiAgICAvLyBoYXZlIGFscmVhZHkgdmFsaWRhdGVkIGJlZm9yZSB3ZSBnb3QgdG8gdGhpcyBwb2ludCBhbmQgdmFsaWRhdGluZ1xuICAgIC8vIGJyZWFrcyBjb21waWxpbmcgZGVzdGluYXRpb25zIHdpdGggbmFtZWQgcGF0dGVybiBwYXJhbXMgZnJvbSB0aGUgc291cmNlXG4gICAgLy8gZS5nLiAvc29tZXRoaW5nOmhlbGxvKC4qKSAtPiAvYW5vdGhlci86aGVsbG8gaXMgYnJva2VuIHdpdGggdmFsaWRhdGlvblxuICAgIC8vIHNpbmNlIGNvbXBpbGUgdmFsaWRhdGlvbiBpcyBtZWFudCBmb3IgcmV2ZXJzaW5nIGFuZCBub3QgZm9yIGluc2VydGluZ1xuICAgIC8vIHBhcmFtcyBmcm9tIGEgc2VwYXJhdGUgcGF0aC1yZWdleCBpbnRvIGFub3RoZXJcbiAgICB7IHZhbGlkYXRlOiBmYWxzZSB9XG4gIClcbiAgbGV0IG5ld1VybFxuXG4gIC8vIHVwZGF0ZSBhbnkgcGFyYW1zIGluIHF1ZXJ5IHZhbHVlc1xuICBmb3IgKGNvbnN0IFtrZXksIHN0ck9yQXJyYXldIG9mIE9iamVjdC5lbnRyaWVzKGRlc3RRdWVyeSkpIHtcbiAgICBsZXQgdmFsdWUgPSBBcnJheS5pc0FycmF5KHN0ck9yQXJyYXkpID8gc3RyT3JBcnJheVswXSA6IHN0ck9yQXJyYXlcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIC8vIHRoZSB2YWx1ZSBuZWVkcyB0byBzdGFydCB3aXRoIGEgZm9yd2FyZC1zbGFzaCB0byBiZSBjb21waWxlZFxuICAgICAgLy8gY29ycmVjdGx5XG4gICAgICB2YWx1ZSA9IGNvbXBpbGVOb25QYXRoKHZhbHVlLCBwYXJhbXMpXG4gICAgfVxuICAgIGRlc3RRdWVyeVtrZXldID0gdmFsdWVcbiAgfVxuXG4gIC8vIGFkZCBwYXRoIHBhcmFtcyB0byBxdWVyeSBpZiBpdCdzIG5vdCBhIHJlZGlyZWN0IGFuZCBub3RcbiAgLy8gYWxyZWFkeSBkZWZpbmVkIGluIGRlc3RpbmF0aW9uIHF1ZXJ5IG9yIHBhdGhcbiAgbGV0IHBhcmFtS2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtcylcblxuICAvLyByZW1vdmUgaW50ZXJuYWwgcGFyYW0gZm9yIGkxOG5cbiAgaWYgKGhhZExvY2FsZSkge1xuICAgIHBhcmFtS2V5cyA9IHBhcmFtS2V5cy5maWx0ZXIoKG5hbWUpID0+IG5hbWUgIT09ICduZXh0SW50ZXJuYWxMb2NhbGUnKVxuICB9XG5cbiAgaWYgKFxuICAgIGFwcGVuZFBhcmFtc1RvUXVlcnkgJiZcbiAgICAhcGFyYW1LZXlzLnNvbWUoKGtleSkgPT4gZGVzdFBhdGhQYXJhbXMuaW5jbHVkZXMoa2V5KSlcbiAgKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgcGFyYW1LZXlzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gZGVzdFF1ZXJ5KSkge1xuICAgICAgICBkZXN0UXVlcnlba2V5XSA9IHBhcmFtc1trZXldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2hvdWxkQWRkQmFzZVBhdGggPSBkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiYgYmFzZVBhdGhcblxuICB0cnkge1xuICAgIG5ld1VybCA9IGAke3Nob3VsZEFkZEJhc2VQYXRoID8gYmFzZVBhdGggOiAnJ30ke2Rlc3RpbmF0aW9uQ29tcGlsZXIoXG4gICAgICBwYXJhbXNcbiAgICApfWBcblxuICAgIGNvbnN0IFtwYXRobmFtZSwgaGFzaF0gPSBuZXdVcmwuc3BsaXQoJyMnKVxuICAgIHBhcnNlZERlc3RpbmF0aW9uLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5oYXNoID0gYCR7aGFzaCA/ICcjJyA6ICcnfSR7aGFzaCB8fCAnJ31gXG4gICAgZGVsZXRlIChwYXJzZWREZXN0aW5hdGlvbiBhcyBhbnkpLnNlYXJjaFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UubWF0Y2goL0V4cGVjdGVkIC4qPyB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5LykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRvIHVzZSBhIG11bHRpLW1hdGNoIGluIHRoZSBkZXN0aW5hdGlvbiB5b3UgbXVzdCBhZGQgXFxgKlxcYCBhdCB0aGUgZW5kIG9mIHRoZSBwYXJhbSBuYW1lIHRvIHNpZ25pZnkgaXQgc2hvdWxkIHJlcGVhdC4gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvaW52YWxpZC1tdWx0aS1tYXRjaGBcbiAgICAgIClcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBRdWVyeSBtZXJnZSBvcmRlciBsb3dlc3QgcHJpb3JpdHkgdG8gaGlnaGVzdFxuICAvLyAxLiBpbml0aWFsIFVSTCBxdWVyeSB2YWx1ZXNcbiAgLy8gMi4gcGF0aCBzZWdtZW50IHZhbHVlc1xuICAvLyAzLiBkZXN0aW5hdGlvbiBzcGVjaWZpZWQgcXVlcnkgdmFsdWVzXG4gIHBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5ID0ge1xuICAgIC4uLnF1ZXJ5LFxuICAgIC4uLnBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5LFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuZXdVcmwsXG4gICAgcGFyc2VkRGVzdGluYXRpb24sXG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgOyhxdWVyeVtrZXldIGFzIHN0cmluZ1tdKS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0gYXMgc3RyaW5nLCB2YWx1ZV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fFxuICAgICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkpIHx8XG4gICAgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhcbiAgdXJsUXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4gcmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpID0+IHtcbiAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSkgPT4gdGFyZ2V0LmRlbGV0ZShrZXkpKVxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpKVxuICB9KVxuICByZXR1cm4gdGFyZ2V0XG59XG4iLCJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHBhdGhNYXRjaCBmcm9tICcuL3BhdGgtbWF0Y2gnXG5pbXBvcnQgcHJlcGFyZURlc3RpbmF0aW9uIGZyb20gJy4vcHJlcGFyZS1kZXN0aW5hdGlvbidcbmltcG9ydCB7IFJld3JpdGUgfSBmcm9tICcuLi8uLi8uLi8uLi9saWIvbG9hZC1jdXN0b20tcm91dGVzJ1xuaW1wb3J0IHsgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2ggfSBmcm9tICcuLi8uLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoJ1xuXG5jb25zdCBjdXN0b21Sb3V0ZU1hdGNoZXIgPSBwYXRoTWF0Y2godHJ1ZSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzb2x2ZVJld3JpdGVzKFxuICBhc1BhdGg6IHN0cmluZyxcbiAgcGFnZXM6IHN0cmluZ1tdLFxuICBiYXNlUGF0aDogc3RyaW5nLFxuICByZXdyaXRlczogUmV3cml0ZVtdLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gIHJlc29sdmVIcmVmOiAocGF0aDogc3RyaW5nKSA9PiBzdHJpbmdcbikge1xuICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGFzUGF0aCkpIHtcbiAgICBmb3IgKGNvbnN0IHJld3JpdGUgb2YgcmV3cml0ZXMpIHtcbiAgICAgIGNvbnN0IG1hdGNoZXIgPSBjdXN0b21Sb3V0ZU1hdGNoZXIocmV3cml0ZS5zb3VyY2UpXG4gICAgICBjb25zdCBwYXJhbXMgPSBtYXRjaGVyKGFzUGF0aClcblxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBpZiAoIXJld3JpdGUuZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgcHJveGllZCByZXdyaXRlIHdoaWNoIGlzbid0IGhhbmRsZWQgb24gdGhlIGNsaWVudFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzdFJlcyA9IHByZXBhcmVEZXN0aW5hdGlvbihcbiAgICAgICAgICByZXdyaXRlLmRlc3RpbmF0aW9uLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIHJld3JpdGUuYmFzZVBhdGggPT09IGZhbHNlID8gJycgOiBiYXNlUGF0aFxuICAgICAgICApXG4gICAgICAgIGFzUGF0aCA9IGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUhXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucXVlcnkpXG5cbiAgICAgICAgaWYgKHBhZ2VzLmluY2x1ZGVzKHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGFzUGF0aCkpKSB7XG4gICAgICAgICAgLy8gY2hlY2sgaWYgd2Ugbm93IG1hdGNoIGEgcGFnZSBhcyB0aGlzIG1lYW5zIHdlIGFyZSBkb25lXG4gICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZSByZXdyaXRlc1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBtYXRjaCBhIGR5bmFtaWMtcm91dGUsIGlmIHNvIHdlIGJyZWFrIHRoZSByZXdyaXRlcyBjaGFpblxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSByZXNvbHZlSHJlZihhc1BhdGgpXG5cbiAgICAgICAgaWYgKHJlc29sdmVkSHJlZiAhPT0gYXNQYXRoICYmIHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhc1BhdGhcbn1cbiIsImltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3JvdXRlLXJlZ2V4J1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXg6IFJldHVyblR5cGU8dHlwZW9mIGdldFJvdXRlUmVnZXg+KSB7XG4gIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleFxuICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgY29uc3Qgcm91dGVNYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUhKVxuICAgIGlmICghcm91dGVNYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlID0gKHBhcmFtOiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pXG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIGNvbnN0IGVycjogRXJyb3IgJiB7IGNvZGU/OiBzdHJpbmcgfSA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnZmFpbGVkIHRvIGRlY29kZSBwYXJhbSdcbiAgICAgICAgKVxuICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJ1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOiB7IFtwYXJhbU5hbWU6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIH0gPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzKS5mb3JFYWNoKChzbHVnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXVxuICAgICAgY29uc3QgbSA9IHJvdXRlTWF0Y2hbZy5wb3NdXG4gICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB+bS5pbmRleE9mKCcvJylcbiAgICAgICAgICA/IG0uc3BsaXQoJy8nKS5tYXAoKGVudHJ5KSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgIDogZy5yZXBlYXRcbiAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgOiBkZWNvZGUobSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxufVxuIiwiaW50ZXJmYWNlIEdyb3VwIHtcbiAgcG9zOiBudW1iZXJcbiAgcmVwZWF0OiBib29sZWFuXG4gIG9wdGlvbmFsOiBib29sZWFuXG59XG5cbi8vIHRoaXMgaXNuJ3QgaW1wb3J0aW5nIHRoZSBlc2NhcGUtc3RyaW5nLXJlZ2V4IG1vZHVsZVxuLy8gdG8gcmVkdWNlIGJ5dGVzXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKCdbJykgJiYgcGFyYW0uZW5kc1dpdGgoJ10nKVxuICBpZiAob3B0aW9uYWwpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDEsIC0xKVxuICB9XG4gIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoJy4uLicpXG4gIGlmIChyZXBlYXQpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDMpXG4gIH1cbiAgcmV0dXJuIHsga2V5OiBwYXJhbSwgcmVwZWF0LCBvcHRpb25hbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KFxuICBub3JtYWxpemVkUm91dGU6IHN0cmluZ1xuKToge1xuICByZTogUmVnRXhwXG4gIG5hbWVkUmVnZXg/OiBzdHJpbmdcbiAgcm91dGVLZXlzPzogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9XG4gIGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9XG59IHtcbiAgY29uc3Qgc2VnbWVudHMgPSAobm9ybWFsaXplZFJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKVxuICAgIC5zbGljZSgxKVxuICAgIC5zcGxpdCgnLycpXG5cbiAgY29uc3QgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH0gPSB7fVxuICBsZXQgZ3JvdXBJbmRleCA9IDFcbiAgY29uc3QgcGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgZ3JvdXBzW2tleV0gPSB7IHBvczogZ3JvdXBJbmRleCsrLCByZXBlYXQsIG9wdGlvbmFsIH1cbiAgICAgICAgcmV0dXJuIHJlcGVhdCA/IChvcHRpb25hbCA/ICcoPzovKC4rPykpPycgOiAnLyguKz8pJykgOiAnLyhbXi9dKz8pJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignJylcblxuICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgIGxldCByb3V0ZUtleUNoYXJMZW5ndGggPSAxXG5cbiAgICAvLyBidWlsZHMgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gKCkgPT4ge1xuICAgICAgbGV0IHJvdXRlS2V5ID0gJydcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZUtleUNoYXJMZW5ndGg7IGkrKykge1xuICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJvdXRlS2V5Q2hhckNvZGUpXG4gICAgICAgIHJvdXRlS2V5Q2hhckNvZGUrK1xuXG4gICAgICAgIGlmIChyb3V0ZUtleUNoYXJDb2RlID4gMTIyKSB7XG4gICAgICAgICAgcm91dGVLZXlDaGFyTGVuZ3RoKytcbiAgICAgICAgICByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdXRlS2V5XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVLZXlzOiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuXG4gICAgbGV0IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgICAgICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgICAgICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csICcnKVxuICAgICAgICAgIGxldCBpbnZhbGlkS2V5ID0gZmFsc2VcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgICAgICAgIC8vIHNhZmUga2V5XG4gICAgICAgICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zdWJzdHIoMCwgMSkpKSkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0ga2V5XG4gICAgICAgICAgcmV0dXJuIHJlcGVhdFxuICAgICAgICAgICAgPyBvcHRpb25hbFxuICAgICAgICAgICAgICA/IGAoPzovKD88JHtjbGVhbmVkS2V5fT4uKz8pKT9gXG4gICAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9Pi4rPylgXG4gICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT5bXi9dKz8pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oJycpXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgICBncm91cHMsXG4gICAgICByb3V0ZUtleXMsXG4gICAgICBuYW1lZFJlZ2V4OiBgXiR7bmFtZWRQYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGAsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICBncm91cHMsXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcblxuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuXG50eXBlIFN0YXRlID0gSlNYLkVsZW1lbnRbXSB8IHVuZGVmaW5lZFxuXG50eXBlIFNpZGVFZmZlY3RQcm9wcyA9IHtcbiAgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6IDxUPihcbiAgICBjb21wb25lbnRzOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gICAgcHJvcHM6IFRcbiAgKSA9PiBTdGF0ZVxuICBoYW5kbGVTdGF0ZUNoYW5nZT86IChzdGF0ZTogU3RhdGUpID0+IHZvaWRcbiAgaGVhZE1hbmFnZXI6IGFueVxuICBpbkFtcE1vZGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50PFNpZGVFZmZlY3RQcm9wcz4ge1xuICBwcml2YXRlIF9oYXNIZWFkTWFuYWdlcjogYm9vbGVhblxuXG4gIGVtaXRDaGFuZ2UgPSAoKTogdm9pZCA9PiB7XG4gICAgaWYgKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKSB7XG4gICAgICB0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLnVwZGF0ZUhlYWQoXG4gICAgICAgIHRoaXMucHJvcHMucmVkdWNlQ29tcG9uZW50c1RvU3RhdGUoXG4gICAgICAgICAgWy4uLnRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlc10sXG4gICAgICAgICAgdGhpcy5wcm9wc1xuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IGFueSkge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuX2hhc0hlYWRNYW5hZ2VyID1cbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIgJiYgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzXG5cbiAgICBpZiAoaXNTZXJ2ZXIgJiYgdGhpcy5faGFzSGVhZE1hbmFnZXIpIHtcbiAgICAgIHRoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcy5hZGQodGhpcylcbiAgICAgIHRoaXMuZW1pdENoYW5nZSgpXG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmFkZCh0aGlzKVxuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLl9oYXNIZWFkTWFuYWdlcikge1xuICAgICAgdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmRlbGV0ZSh0aGlzKVxuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsImltcG9ydCB7IEluY29taW5nTWVzc2FnZSwgU2VydmVyUmVzcG9uc2UgfSBmcm9tICdodHRwJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IGZvcm1hdFVybCB9IGZyb20gJy4vcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBNYW5pZmVzdEl0ZW0gfSBmcm9tICcuLi9zZXJ2ZXIvbG9hZC1jb21wb25lbnRzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IEVudiB9IGZyb20gJ0BuZXh0L2VudidcbmltcG9ydCB7IEJ1aWxkTWFuaWZlc3QgfSBmcm9tICcuLi9zZXJ2ZXIvZ2V0LXBhZ2UtZmlsZXMnXG5cbi8qKlxuICogVHlwZXMgdXNlZCBieSBib3RoIG5leHQgYW5kIG5leHQtc2VydmVyXG4gKi9cblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+ID0gQ29tcG9uZW50VHlwZTxQPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGN0eCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDKTogSVAgfCBQcm9taXNlPElQPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPiAmIHtcbiAgcmVuZGVyRG9jdW1lbnQoXG4gICAgRG9jdW1lbnQ6IERvY3VtZW50VHlwZSxcbiAgICBwcm9wczogRG9jdW1lbnRQcm9wc1xuICApOiBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgQXBwVHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgQXBwSW5pdGlhbFByb3BzLFxuICBBcHBQcm9wc1R5cGVcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG4vKipcbiAqIFdlYiB2aXRhbHMgcHJvdmlkZWQgdG8gX2FwcC5yZXBvcnRXZWJWaXRhbHMgYnkgQ29yZSBXZWIgVml0YWxzIHBsdWdpbiBkZXZlbG9wZWQgYnkgR29vZ2xlIENocm9tZSB0ZWFtLlxuICogaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC05LTQjaW50ZWdyYXRlZC13ZWItdml0YWxzLXJlcG9ydGluZ1xuICovXG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIGxhYmVsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBSZW5kZXJQYWdlUmVzdWx0IHwgUHJvbWlzZTxSZW5kZXJQYWdlUmVzdWx0PlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGR5bmFtaWNJZHM/OiBzdHJpbmdbXVxuICBlcnI/OiBFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wcyA9IHtcbiAgcGFnZVByb3BzOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFAgPSB7fVxuPiA9IEFwcEluaXRpYWxQcm9wcyAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgUD5cbiAgcm91dGVyOiBSXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgUmVhY3QuUmVhY3RGcmFnbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiB7XG4gIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICBkYW5nZXJvdXNBc1BhdGg6IHN0cmluZ1xuICBkb2NDb21wb25lbnRzUmVuZGVyZWQ6IHtcbiAgICBIdG1sPzogYm9vbGVhblxuICAgIE1haW4/OiBib29sZWFuXG4gICAgSGVhZD86IGJvb2xlYW5cbiAgICBOZXh0U2NyaXB0PzogYm9vbGVhblxuICB9XG4gIGJ1aWxkTWFuaWZlc3Q6IEJ1aWxkTWFuaWZlc3RcbiAgYW1wUGF0aDogc3RyaW5nXG4gIGluQW1wTW9kZTogYm9vbGVhblxuICBoeWJyaWRBbXA6IGJvb2xlYW5cbiAgaXNEZXZlbG9wbWVudDogYm9vbGVhblxuICBkeW5hbWljSW1wb3J0czogTWFuaWZlc3RJdGVtW11cbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgY2Fub25pY2FsQmFzZTogc3RyaW5nXG4gIGhlYWRUYWdzOiBhbnlbXVxuICB1bnN0YWJsZV9ydW50aW1lSlM/OiBmYWxzZVxuICBkZXZPbmx5Q2FjaGVCdXN0ZXJRdWVyeVN0cmluZzogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZ1xufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVxdWVzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRBcGlSZXF1ZXN0IGV4dGVuZHMgSW5jb21pbmdNZXNzYWdlIHtcbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgcXVlcnlgIHZhbHVlcyBmcm9tIHVybFxuICAgKi9cbiAgcXVlcnk6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYGNvb2tpZXNgIGZyb20gaGVhZGVyXG4gICAqL1xuICBjb29raWVzOiB7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH1cblxuICBib2R5OiBhbnlcblxuICBlbnY6IEVudlxuXG4gIHByZXZpZXc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQcmV2aWV3IGRhdGEgc2V0IG9uIHRoZSByZXF1ZXN0LCBpZiBhbnlcbiAgICogKi9cbiAgcHJldmlld0RhdGE/OiBhbnlcbn1cblxuLyoqXG4gKiBTZW5kIGJvZHkgb2YgcmVzcG9uc2VcbiAqL1xudHlwZSBTZW5kPFQ+ID0gKGJvZHk6IFQpID0+IHZvaWRcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlSZXNwb25zZTxUID0gYW55PiA9IFNlcnZlclJlc3BvbnNlICYge1xuICAvKipcbiAgICogU2VuZCBkYXRhIGBhbnlgIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIHNlbmQ6IFNlbmQ8VD5cbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBganNvbmAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAganNvbjogU2VuZDxUPlxuICBzdGF0dXM6IChzdGF0dXNDb2RlOiBudW1iZXIpID0+IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdCh1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuICByZWRpcmVjdChzdGF0dXM6IG51bWJlciwgdXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8VD5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIGNsZWFyUHJldmlld0RhdGE6ICgpID0+IE5leHRBcGlSZXNwb25zZTxUPlxufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgaGFuZGxlclxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpSGFuZGxlcjxUID0gYW55PiA9IChcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2U8VD5cbikgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cblxuLyoqXG4gKiBVdGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY09uY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gUmV0dXJuVHlwZTxUPj4oXG4gIGZuOiBUXG4pOiBUIHtcbiAgbGV0IHVzZWQgPSBmYWxzZVxuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPFQ+XG5cbiAgcmV0dXJuICgoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBpZiAoIXVzZWQpIHtcbiAgICAgIHVzZWQgPSB0cnVlXG4gICAgICByZXN1bHQgPSBmbiguLi5hcmdzKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pIGFzIFRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uXG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gJzonICsgcG9ydCA6ICcnfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgY29uc3QgeyBocmVmIH0gPSB3aW5kb3cubG9jYXRpb25cbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lPFA+KENvbXBvbmVudDogQ29tcG9uZW50VHlwZTxQPikge1xuICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZydcbiAgICA/IENvbXBvbmVudFxuICAgIDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXNTZW50KHJlczogU2VydmVyUmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlcy5maW5pc2hlZCB8fCByZXMuaGVhZGVyc1NlbnRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRHZXRJbml0aWFsUHJvcHM8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCB1cmxPYmplY3RLZXlzID0gW1xuICAnYXV0aCcsXG4gICdoYXNoJyxcbiAgJ2hvc3QnLFxuICAnaG9zdG5hbWUnLFxuICAnaHJlZicsXG4gICdwYXRoJyxcbiAgJ3BhdGhuYW1lJyxcbiAgJ3BvcnQnLFxuICAncHJvdG9jb2wnLFxuICAncXVlcnknLFxuICAnc2VhcmNoJyxcbiAgJ3NsYXNoZXMnLFxuXVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0V2l0aFZhbGlkYXRpb24odXJsOiBVcmxPYmplY3QpOiBzdHJpbmcge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBpZiAodXJsICE9PSBudWxsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyh1cmwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAodXJsT2JqZWN0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFVua25vd24ga2V5IHBhc3NlZCB2aWEgdXJsT2JqZWN0IGludG8gdXJsLmZvcm1hdDogJHtrZXl9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybWF0VXJsKHVybClcbn1cblxuZXhwb3J0IGNvbnN0IFNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJ1xuZXhwb3J0IGNvbnN0IFNUID1cbiAgU1AgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbidcbiIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMubm9ybWFsaXplUGF0aFNlcD1ub3JtYWxpemVQYXRoU2VwO2V4cG9ydHMuZGVub3JtYWxpemVQYWdlUGF0aD1kZW5vcm1hbGl6ZVBhZ2VQYXRoO2Z1bmN0aW9uIG5vcm1hbGl6ZVBhdGhTZXAocGF0aCl7cmV0dXJuIHBhdGgucmVwbGFjZSgvXFxcXC9nLCcvJyk7fWZ1bmN0aW9uIGRlbm9ybWFsaXplUGFnZVBhdGgocGFnZSl7cGFnZT1ub3JtYWxpemVQYXRoU2VwKHBhZ2UpO2lmKHBhZ2Uuc3RhcnRzV2l0aCgnL2luZGV4LycpKXtwYWdlPXBhZ2Uuc2xpY2UoNik7fWVsc2UgaWYocGFnZT09PScvaW5kZXgnKXtwYWdlPScvJzt9cmV0dXJuIHBhZ2U7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9saW5rJylcbiIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlczsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbnZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3RcIik7XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzczsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn0iLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufSIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59IiwiaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZlwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImltcG9ydCBfdHlwZW9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2ZcIjtcbmltcG9ydCBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRob3V0SG9sZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIjtcbmltcG9ydCBub25JdGVyYWJsZVNwcmVhZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWRcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn0iLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICByZXR1cm4gY2FjaGU7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpO1xuXG4gIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgfVxuXG4gIHZhciBuZXdPYmogPSB7fTtcbiAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcblxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDsiLCJmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgdW5kZWY7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGVuY29kZSBhIGdpdmVuIGlucHV0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGVuY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/IyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGNhc2UgaWYgZmFpbGVkIGRlY29kaW5nLCB3ZSB3YW50IHRvIG9taXQgdGhlIGtleS92YWx1ZSBwYWlyc1xuICAgIC8vIGZyb20gdGhlIHJlc3VsdC5cbiAgICAvL1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwgfHwga2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXVxuICAgICwgdmFsdWVcbiAgICAsIGtleTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAvL1xuICAgICAgLy8gRWRnZSBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvIGVuY29kZSB0aGUgdmFsdWUgdG8gYW4gZW1wdHlcbiAgICAgIC8vIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICBpZiAoIXZhbHVlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWYgfHwgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBlbmNvZGUoa2V5KTtcbiAgICAgIHZhbHVlID0gZW5jb2RlKHZhbHVlKTtcblxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBlbmNvZGUgdGhlIHN0cmluZ3MsIHdlIHNob3VsZCBiYWlsIG91dCBhcyB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBhZGQgaW52YWxpZCBzdHJpbmdzIHRvIHRoZSBxdWVyeS5cbiAgICAgIC8vXG4gICAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsnPScrIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjFcbiAqIHJlYWN0LWRvbS1zZXJ2ZXIuYnJvd3Nlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMgd2l0aFxuLy8gdGVtcGxhdGUgbGl0ZXJhbCBzdHJpbmdzLiBUaGUgbWVzc2FnZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGVycm9yIGNvZGVzXG4vLyBkdXJpbmcgYnVpbGQuXG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgdmFyIHVybCA9ICdodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHVybCArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tpXSk7XG4gIH1cblxuICByZXR1cm4gXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIgKyBjb2RlICsgXCI7IHZpc2l0IFwiICsgdXJsICsgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgXCIgKyAndXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCAnICsgJ2hlbHBmdWwgd2FybmluZ3MuJztcbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMSc7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyID0gZmFsc2U7XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxue1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG59XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5mdW5jdGlvbiBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KSB7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcblxuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG5cbiAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgfVxuXG4gIHJldHVybiBtYXNrZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAge1xuICAgIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgJ0NvbXBvbmVudCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCkge1xuICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBzbG90cyBpbiB0aGlzIGNvbnRleHQgdG8gc3RvcmUgdGhpcyB0aHJlYWRJRCxcbiAgLy8gZmlsbCBpdCBpbiB3aXRob3V0IGxlYXZpbmcgYW55IGhvbGVzIHRvIGVuc3VyZSB0aGF0IHRoZSBWTSBvcHRpbWl6ZXNcbiAgLy8gdGhpcyBhcyBub24taG9sZXkgaW5kZXggcHJvcGVydGllcy5cbiAgLy8gKE5vdGU6IElmIGByZWFjdGAgcGFja2FnZSBpcyA8IDE2LjYsIF90aHJlYWRDb3VudCBpcyB1bmRlZmluZWQuKVxuICBmb3IgKHZhciBpID0gY29udGV4dC5fdGhyZWFkQ291bnQgfCAwOyBpIDw9IHRocmVhZElEOyBpKyspIHtcbiAgICAvLyBXZSBhc3N1bWUgdGhhdCB0aGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBkZWZhdWx0VmFsdWUgd2hpY2ggbWlnaHQgbm90IGJlXG4gICAgLy8gdHJ1ZSBpZiB3ZSdyZSByZW5kZXJpbmcgaW5zaWRlIGEgc2Vjb25kYXJ5IHJlbmRlcmVyIGJ1dCB0aGV5IGFyZVxuICAgIC8vIHNlY29uZGFyeSBiZWNhdXNlIHRoZXNlIHVzZSBjYXNlcyBhcmUgdmVyeSByYXJlLlxuICAgIGNvbnRleHRbaV0gPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gaSArIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NDb250ZXh0KHR5cGUsIGNvbnRleHQsIHRocmVhZElELCBpc0NsYXNzKSB7XG4gIGlmIChpc0NsYXNzKSB7XG4gICAgdmFyIGNvbnRleHRUeXBlID0gdHlwZS5jb250ZXh0VHlwZTtcblxuICAgIHtcbiAgICAgIGlmICgnY29udGV4dFR5cGUnIGluIHR5cGUpIHtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgJiYgY29udGV4dFR5cGUuX2NvbnRleHQgPT09IHVuZGVmaW5lZDsgLy8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkICYmICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZCh0eXBlKTtcbiAgICAgICAgICB2YXIgYWRkZW5kdW0gPSAnJztcblxuICAgICAgICAgIGlmIChjb250ZXh0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgJyArIHR5cGVvZiBjb250ZXh0VHlwZSArICcuJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgKyAnY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXMnLCBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnLCBhZGRlbmR1bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHRUeXBlLCB0aHJlYWRJRCk7XG4gICAgICByZXR1cm4gY29udGV4dFR5cGVbdGhyZWFkSURdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbWFza0NvbnRleHQodHlwZSwgY29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgY2hlY2tDb250ZXh0VHlwZXModHlwZS5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHZhciBfbWFza2VkQ29udGV4dCA9IG1hc2tDb250ZXh0KHR5cGUsIGNvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgIGNoZWNrQ29udGV4dFR5cGVzKHR5cGUuY29udGV4dFR5cGVzLCBfbWFza2VkQ29udGV4dCwgJ2NvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX21hc2tlZENvbnRleHQ7XG4gICAgfVxuICB9XG59XG5cbnZhciBuZXh0QXZhaWxhYmxlVGhyZWFkSURzID0gbmV3IFVpbnQxNkFycmF5KDE2KTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbaV0gPSBpICsgMTtcbn1cblxubmV4dEF2YWlsYWJsZVRocmVhZElEc1sxNV0gPSAwO1xuXG5mdW5jdGlvbiBncm93VGhyZWFkQ291bnRBbmRSZXR1cm5OZXh0QXZhaWxhYmxlKCkge1xuICB2YXIgb2xkQXJyYXkgPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzO1xuICB2YXIgb2xkU2l6ZSA9IG9sZEFycmF5Lmxlbmd0aDtcbiAgdmFyIG5ld1NpemUgPSBvbGRTaXplICogMjtcblxuICBpZiAoIShuZXdTaXplIDw9IDB4MTAwMDApKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiTWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCBSZWFjdCByZW5kZXJlcnMgZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5vdCBwcm9wZXJseSBkZXN0cm95aW5nIHRoZSBSZWFkYWJsZSBwcm92aWRlZCBieSBSZWFjdC4gRW5zdXJlIHRoYXQgeW91IGNhbGwgLmRlc3Ryb3koKSBvbiBpdCBpZiB5b3Ugbm8gbG9uZ2VyIHdhbnQgdG8gcmVhZCBmcm9tIGl0LCBhbmQgZGlkIG5vdCByZWFkIHRvIHRoZSBlbmQuIElmIHlvdSB1c2UgLnBpcGUoKSB0aGlzIHNob3VsZCBiZSBhdXRvbWF0aWMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3QXJyYXkgPSBuZXcgVWludDE2QXJyYXkobmV3U2l6ZSk7XG4gIG5ld0FycmF5LnNldChvbGRBcnJheSk7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHMgPSBuZXdBcnJheTtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXSA9IG9sZFNpemUgKyAxO1xuXG4gIGZvciAodmFyIF9pID0gb2xkU2l6ZTsgX2kgPCBuZXdTaXplIC0gMTsgX2krKykge1xuICAgIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbX2ldID0gX2kgKyAxO1xuICB9XG5cbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tuZXdTaXplIC0gMV0gPSAwO1xuICByZXR1cm4gb2xkU2l6ZTtcbn1cblxuZnVuY3Rpb24gYWxsb2NUaHJlYWRJRCgpIHtcbiAgdmFyIG5leHRJRCA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF07XG5cbiAgaWYgKG5leHRJRCA9PT0gMCkge1xuICAgIHJldHVybiBncm93VGhyZWFkQ291bnRBbmRSZXR1cm5OZXh0QXZhaWxhYmxlKCk7XG4gIH1cblxuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdID0gbmV4dEF2YWlsYWJsZVRocmVhZElEc1tuZXh0SURdO1xuICByZXR1cm4gbmV4dElEO1xufVxuZnVuY3Rpb24gZnJlZVRocmVhZElEKGlkKSB7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbaWRdID0gbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXTtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXSA9IGlkO1xufVxuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7IC8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxuXG52YXIgU1RSSU5HID0gMTsgLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7IC8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuXG52YXIgQk9PTEVBTiA9IDM7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgTlVNRVJJQyA9IDU7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuXG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuXG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcblxuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuXG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwsIHJlbW92ZUVtcHR5U3RyaW5nKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG4gIHRoaXMucmVtb3ZlRW1wdHlTdHJpbmcgPSByZW1vdmVFbXB0eVN0cmluZztcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cbnZhciByZXNlcnZlZFByb3BzID0gWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsIC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddO1xucmVzZXJ2ZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsIC8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5cblsnY2hlY2tlZCcsIC8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnMuXG5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbicgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTtcbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcblxudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59OyAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCBhdHRyaWJ1dGUgZmlsdGVyLlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuXG5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG5cbnZhciB4bGlua0hyZWYgPSAneGxpbmtIcmVmJztcbnByb3BlcnRpZXNbeGxpbmtIcmVmXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIHRydWUsIC8vIHNhbml0aXplVVJMXG5mYWxzZSk7XG5bJ3NyYycsICdocmVmJywgJ2FjdGlvbicsICdmb3JtQWN0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuICB0cnVlKTtcbn0pO1xuXG4vLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2VcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qXFw6L2k7XG52YXIgZGlkV2FybiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpIHtcbiAgICAgIGRpZFdhcm4gPSB0cnVlO1xuXG4gICAgICBlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnICsgJ1VzZSBldmVudCBoYW5kbGVycyBpbnN0ZWFkIGlmIHlvdSBjYW4uIElmIHlvdSBuZWVkIHRvIGdlbmVyYXRlIHVuc2FmZSBIVE1MIHRyeSAnICsgJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJywgSlNPTi5zdHJpbmdpZnkodXJsKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuLyoqXG4gKiBFc2NhcGVzIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgSFRNTCBlbnRpdGllcyBpbiBhIGdpdmVuIGh0bWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIEhUTUwgc3RyaW5nIHRvIGVzY2FwZSBmb3IgbGF0ZXIgaW5zZXJ0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4O1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufSAvLyBlbmQgY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkge1xuICBpZiAodHlwZW9mIHRleHQgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyB0aGlzIHNob3J0Y2lyY3VpdCBoZWxwcyBwZXJmIGZvciB0eXBlcyB0aGF0IHdlIGtub3cgd2lsbCBuZXZlciBoYXZlXG4gICAgLy8gc3BlY2lhbCBjaGFyYWN0ZXJzLCBlc3BlY2lhbGx5IGdpdmVuIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIG9mdGVuXG4gICAgLy8gZm9yIG51bWVyaWMgZG9tIGlkcy5cbiAgICByZXR1cm4gJycgKyB0ZXh0O1xuICB9XG5cbiAgcmV0dXJuIGVzY2FwZUh0bWwodGV4dCk7XG59XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JSb290KCkge1xuICByZXR1cm4gUk9PVF9BVFRSSUJVVEVfTkFNRSArICc9XCJcIic7XG59XG4vKipcbiAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgdmFyIHR5cGUgPSBwcm9wZXJ0eUluZm8udHlwZTtcblxuICAgIGlmICh0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTiAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgc2FuaXRpemVVUkwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBjdXN0b20gcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBpcyBhIHJlLXJlbmRlcmVkIGhvb2tcblxudmFyIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBkdXJpbmcgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyIHBhc3MuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIExhemlseSBjcmVhdGVkIG1hcCBvZiByZW5kZXItcGhhc2UgdXBkYXRlc1xuXG52YXIgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDsgLy8gQ291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xudmFyIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlOyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG5mdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICBpZiAoIShjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGlzSW5Ib29rVXNlckNvZGVJbkRldikge1xuICAgICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlclwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGlmIChmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlO1xuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVXNlSG9va3MoY29tcG9uZW50SWRlbnRpdHkpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gY29tcG9uZW50SWRlbnRpdHk7XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9IC8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG4gIC8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgLy8gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIC8vIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbn1cbmZ1bmN0aW9uIGZpbmlzaEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuLCByZWZPckNvbnRleHQpIHtcbiAgLy8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBldmVyeSBmdW5jdGlvbiBjb21wb25lbnQgdG8gcHJldmVudCBob29rcyBmcm9tXG4gIC8vIGJlaW5nIHVzZWQgaW4gY2xhc3Nlcy5cbiAgd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBVcGRhdGVzIHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGV5IGFyZSBzdG9yZWQgaW5cbiAgICAvLyB0aGUgYHJlbmRlclBoYXNlVXBkYXRlc2AgbWFwLiBDYWxsIHRoZSBjb21wb25lbnQgYWdhaW4sIHJldXNpbmcgdGhlXG4gICAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rcyBhbmQgYXBwbHlpbmcgdGhlIGFkZGl0aW9uYWwgdXBkYXRlcyBvbiB0b3AuIEtlZXBcbiAgICAvLyByZXN0YXJ0aW5nIHVudGlsIG5vIG1vcmUgdXBkYXRlcyBhcmUgc2NoZWR1bGVkLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxOyAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgcmVmT3JDb250ZXh0KTtcbiAgfVxuXG4gIHJlc2V0SG9va3NTdGF0ZSgpO1xuICByZXR1cm4gY2hpbGRyZW47XG59IC8vIFJlc2V0IHRoZSBpbnRlcm5hbCBob29rcyBzdGF0ZSBpZiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgcmVuZGVyaW5nIGEgY29tcG9uZW50XG5cbmZ1bmN0aW9uIHJlc2V0SG9va3NTdGF0ZSgpIHtcbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciB0aHJlYWRJRCA9IGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIudGhyZWFkSUQ7XG4gIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCk7XG5cbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udGV4dFt0aHJlYWRJRF07XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgfVxuXG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgdmFyIHRocmVhZElEID0gY3VycmVudFBhcnRpYWxSZW5kZXJlci50aHJlYWRJRDtcbiAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcbiAgcmV0dXJuIGNvbnRleHRbdGhyZWFkSURdO1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gIH1cblxuICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgLy8gdXNlUmVkdWNlciBoYXMgYSBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBsYXp5IHVzZVN0YXRlIGluaXRpYWxpemVyc1xuICBpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHtcbiAgICBpZiAocmVkdWNlciAhPT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGlzUmVSZW5kZXIpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAgIC8vIGN1cnJlbnQgaG9vay5cbiAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzICE9PSBudWxsKSB7XG4gICAgICAvLyBSZW5kZXIgcGhhc2UgdXBkYXRlcyBhcmUgc3RvcmVkIGluIGEgbWFwIG9mIHF1ZXVlIC0+IGxpbmtlZCBsaXN0XG4gICAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUocXVldWUpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyByZW5kZXIncy5cbiAgICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7XG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgICBpZiAocmVkdWNlciA9PT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYHVzZVN0YXRlYC5cbiAgICAgIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBpbml0aWFsQXJnID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbEFyZygpIDogaW5pdGlhbEFyZztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdCAhPT0gdW5kZWZpbmVkID8gaW5pdChpbml0aWFsQXJnKSA6IGluaXRpYWxBcmc7XG4gICAgfVxuXG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cbiAgICB2YXIgX3F1ZXVlID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0ge1xuICAgICAgbGFzdDogbnVsbCxcbiAgICAgIGRpc3BhdGNoOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBfZGlzcGF0Y2ggPSBfcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCwgX3F1ZXVlKTtcblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIF9kaXNwYXRjaF07XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHByZXZpb3VzUmVmID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZpb3VzUmVmID09PSBudWxsKSB7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICAgIH07XG5cbiAgICB7XG4gICAgICBPYmplY3Quc2VhbChyZWYpO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICAgIHJldHVybiByZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZXZpb3VzUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGlucHV0cykge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcblxuICAgIGVycm9yKCd1c2VMYXlvdXRFZmZlY3QgZG9lcyBub3RoaW5nIG9uIHRoZSBzZXJ2ZXIsIGJlY2F1c2UgaXRzIGVmZmVjdCBjYW5ub3QgJyArIFwiYmUgZW5jb2RlZCBpbnRvIHRoZSBzZXJ2ZXIgcmVuZGVyZXIncyBvdXRwdXQgZm9ybWF0LiBUaGlzIHdpbGwgbGVhZCBcIiArICd0byBhIG1pc21hdGNoIGJldHdlZW4gdGhlIGluaXRpYWwsIG5vbi1oeWRyYXRlZCBVSSBhbmQgdGhlIGludGVuZGVkICcgKyAnVUkuIFRvIGF2b2lkIHRoaXMsIHVzZUxheW91dEVmZmVjdCBzaG91bGQgb25seSBiZSB1c2VkIGluICcgKyAnY29tcG9uZW50cyB0aGF0IHJlbmRlciBleGNsdXNpdmVseSBvbiB0aGUgY2xpZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdXNlbGF5b3V0ZWZmZWN0LXNzciBmb3IgY29tbW9uIGZpeGVzLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKGNvbXBvbmVudElkZW50aXR5LCBxdWV1ZSwgYWN0aW9uKSB7XG4gIGlmICghKG51bWJlck9mUmVSZW5kZXJzIDwgUkVfUkVOREVSX0xJTUlUKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuXG4gICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSwgZGVwcyk7XG59IC8vIFRPRE8gRGVjaWRlIG9uIGhvdyB0byBpbXBsZW1lbnQgdGhpcyBob29rIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuLy8gSWYgYSBtdXRhdGlvbiBvY2N1cnMgZHVyaW5nIHJlbmRlciwgY29uc2lkZXIgdHJpZ2dlcmluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4vLyBhbmQgZmFsbGluZyBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXG5cbmZ1bmN0aW9uIHVzZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIGdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKTtcbn1cblxuZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuXG4gIHZhciBzdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xuXG4gIHJldHVybiBbc3RhcnRUcmFuc2l0aW9uLCBmYWxzZV07XG59XG5cbmZ1bmN0aW9uIHVzZU9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIHJldHVybiAoY3VycmVudFBhcnRpYWxSZW5kZXJlci5pZGVudGlmaWVyUHJlZml4IHx8ICcnKSArICdSOicgKyAoY3VycmVudFBhcnRpYWxSZW5kZXJlci51bmlxdWVJRCsrKS50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgY3VycmVudFBhcnRpYWxSZW5kZXJlciA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50UGFydGlhbFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gIGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIgPSByZW5kZXJlcjtcbn1cbnZhciBEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIHVzZUxheW91dEVmZmVjdDogdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2ssXG4gIC8vIHVzZUltcGVyYXRpdmVIYW5kbGUgaXMgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IG5vb3AsXG4gIC8vIEVmZmVjdHMgYXJlIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlRWZmZWN0OiBub29wLFxuICAvLyBEZWJ1Z2dpbmcgZWZmZWN0XG4gIHVzZURlYnVnVmFsdWU6IG5vb3AsXG4gIHVzZURlZmVycmVkVmFsdWU6IHVzZURlZmVycmVkVmFsdWUsXG4gIHVzZVRyYW5zaXRpb246IHVzZVRyYW5zaXRpb24sXG4gIHVzZU9wYXF1ZUlkZW50aWZpZXI6IHVzZU9wYXF1ZUlkZW50aWZpZXIsXG4gIC8vIFN1YnNjcmlwdGlvbnMgYXJlIG5vdCBzZXR1cCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlTXV0YWJsZVNvdXJjZTogdXNlTXV0YWJsZVNvdXJjZVxufTtcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07IC8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cblxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuXG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cblxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfSAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cblxuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICBidXR0b246IHRydWUsXG4gIGNoZWNrYm94OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgaGlkZGVuOiB0cnVlLFxuICByYWRpbzogdHJ1ZSxcbiAgcmVzZXQ6IHRydWUsXG4gIHN1Ym1pdDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHModGFnTmFtZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICghKGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMub25JbnB1dCB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy52YWx1ZSA9PSBudWxsKSkge1xuICAgICAgZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuXG4gICAgaWYgKCEocHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuY2hlY2tlZCA9PSBudWxsKSkge1xuICAgICAgZXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIGxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxuXG59O1xuXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfSAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuXG5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1t0YWddKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggdGFnICsgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKCFwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgJiYgcHJvcHMuY29udGVudEVkaXRhYmxlICYmIHByb3BzLmNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIiApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107IC8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuICB2YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgLy8gQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAvLyBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyBhbGxvd2VkIGF0dHJpYnV0ZSBsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY2xhc3M6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6ICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBlbnRlcmtleWhpbnQ6ICdlbnRlcktleUhpbnQnLFxuICBmb3I6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9tb2R1bGU6ICdub01vZHVsZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIGVycm9yKCdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cblxuXG4gICAgaWYgKGV2ZW50UmVnaXN0cnkgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSBldmVudFJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG4gICAgICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IGV2ZW50UmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcblxuXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgZXJyb3IoJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2FyaWEnKSB7XG4gICAgICBlcnJvcignVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuICcgKyAnUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgdHlwZW9mIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIG5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgICB2YXIgaXNSZXNlcnZlZCA9IHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQ7IC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG5cbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZCAmJiBuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICBlcnJvcignUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4nLCBuYW1lLCBsb3dlckNhc2VkTmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG5cblxuICAgIGlmIChpc1Jlc2VydmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG5cblxuICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBXYXJuIHdoZW4gcGFzc2luZyB0aGUgc3RyaW5ncyAnZmFsc2UnIG9yICd0cnVlJyBpbnRvIGEgYm9vbGVhbiBwcm9wXG5cblxuICAgIGlmICgodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJykgJiYgcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgdGhlIHN0cmluZyBgJXNgIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC4gJyArICclcyAnICsgJ0RpZCB5b3UgbWVhbiAlcz17JXN9PycsIHZhbHVlLCBuYW1lLCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdUaGUgYnJvd3NlciB3aWxsIGludGVycHJldCBpdCBhcyBhIHRydXRoeSB2YWx1ZS4nIDogJ0FsdGhvdWdoIHRoaXMgd29ya3MsIGl0IHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaWYgeW91IHBhc3MgdGhlIHN0cmluZyBcImZhbHNlXCIuJywgbmFtZSwgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAge1xuICAgIHZhciB1bmtub3duUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5LCBwcm9wc1trZXldLCBldmVudFJlZ2lzdHJ5KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gICAgfSkuam9pbignLCAnKTtcblxuICAgIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KTtcbn1cblxudmFyIHRvQXJyYXkgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5OyAvLyBUaGlzIGlzIG9ubHkgdXNlZCBpbiBERVYuXG4vLyBFYWNoIGVudHJ5IGlzIGB0aGlzLnN0YWNrYCBmcm9tIGEgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXJlciBpbnN0YW5jZS5cbi8vIChUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBiZWNhdXNlIFJlYWN0RE9NU2VydmVyIGlzIHJlZW50cmFudCkuXG4vLyBFYWNoIHN0YWNrIGlzIGFuIGFycmF5IG9mIGZyYW1lcyB3aGljaCBtYXkgY29udGFpbiBuZXN0ZWQgc3RhY2tzIG9mIGVsZW1lbnRzLlxuXG52YXIgY3VycmVudERlYnVnU3RhY2tzID0gW107XG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDE7XG52YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBudWxsO1xuXG52YXIgZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICcnO1xufTtcblxudmFyIGRlc2NyaWJlU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiAnJztcbn07XG5cbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7fTtcblxudmFyIHB1c2hDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uIChzdGFjaykge307XG5cbnZhciBwdXNoRWxlbWVudFRvRGVidWdTdGFjayA9IGZ1bmN0aW9uIChlbGVtZW50KSB7fTtcblxudmFyIHBvcEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTtcblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG4gIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgbnVsbCk7XG4gIH07XG5cbiAgZGVzY3JpYmVTdGFja0ZyYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBudWxsKTtcbiAgfTtcblxuICBwdXNoQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICBjdXJyZW50RGVidWdTdGFja3MucHVzaChzdGFjayk7XG5cbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gV2UgYXJlIGVudGVyaW5nIGEgc2VydmVyIHJlbmRlcmVyLlxuICAgICAgLy8gUmVtZW1iZXIgdGhlIHByZXZpb3VzIChlLmcuIGNsaWVudCkgZ2xvYmFsIHN0YWNrIGltcGxlbWVudGF0aW9uLlxuICAgICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTZXJ2ZXJTdGFja0ltcGw7XG4gICAgfVxuICB9O1xuXG4gIHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBGb3IgdGhlIGlubmVybW9zdCBleGVjdXRpbmcgUmVhY3RET01TZXJ2ZXIgY2FsbCxcbiAgICB2YXIgc3RhY2sgPSBjdXJyZW50RGVidWdTdGFja3NbY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCAtIDFdOyAvLyBUYWtlIHRoZSBpbm5lcm1vc3QgZXhlY3V0aW5nIGZyYW1lIChlLmcuIDxGb28+KSxcblxuICAgIHZhciBmcmFtZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdOyAvLyBhbmQgcmVjb3JkIHRoYXQgaXQgaGFzIG9uZSBtb3JlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuXG4gICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sucHVzaChlbGVtZW50KTsgLy8gV2Ugb25seSBuZWVkIHRoaXMgYmVjYXVzZSB3ZSB0YWlsLW9wdGltaXplIHNpbmdsZS1lbGVtZW50XG4gICAgLy8gY2hpbGRyZW4gYW5kIGRpcmVjdGx5IGhhbmRsZSB0aGVtIGluIGFuIGlubmVyIGxvb3AgaW5zdGVhZCBvZlxuICAgIC8vIGNyZWF0aW5nIHNlcGFyYXRlIGZyYW1lcyBmb3IgdGhlbS5cbiAgfTtcblxuICBwb3BDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50RGVidWdTdGFja3MucG9wKCk7XG5cbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gV2UgYXJlIGV4aXRpbmcgdGhlIHNlcnZlciByZW5kZXJlci5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIChlLmcuIGNsaWVudCkgZ2xvYmFsIHN0YWNrIGltcGxlbWVudGF0aW9uLlxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2tJbXBsO1xuICAgICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBnZXRDdXJyZW50U2VydmVyU3RhY2tJbXBsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSByZW5kZXJpbmcuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBSZWFjdERPTVNlcnZlciBpcyByZWVudHJhbnQgc28gdGhlcmUgbWF5IGJlIG11bHRpcGxlIGNhbGxzIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gVGFrZSB0aGUgZnJhbWVzIGZyb20gdGhlIGlubmVybW9zdCBjYWxsIHdoaWNoIGlzIHRoZSBsYXN0IGluIHRoZSBhcnJheS5cblxuXG4gICAgdmFyIGZyYW1lcyA9IGN1cnJlbnREZWJ1Z1N0YWNrc1tjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoIC0gMV07XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEdvIHRocm91Z2ggZXZlcnkgZnJhbWUgaW4gdGhlIHN0YWNrIGZyb20gdGhlIGlubmVybW9zdCBvbmUuXG5cbiAgICBmb3IgKHZhciBpID0gZnJhbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbaV07IC8vIEV2ZXJ5IGZyYW1lIG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBkZWJ1ZyBlbGVtZW50IHN0YWNrIGVudHJ5IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBzaW5nbGUtY2hpbGQgbmVzdGluZyBkb2Vzbid0IGNyZWF0ZSBtYXRlcmlhbGl6ZWQgZnJhbWVzLlxuICAgICAgLy8gSW5zdGVhZCBpdCB3b3VsZCBwdXNoIHRoZW0gdGhyb3VnaCBgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2soKWAuXG5cbiAgICAgIHZhciBkZWJ1Z0VsZW1lbnRTdGFjayA9IGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrO1xuXG4gICAgICBmb3IgKHZhciBpaSA9IGRlYnVnRWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgICAgc3RhY2sgKz0gZGVzY3JpYmVTdGFja0ZyYW1lKGRlYnVnRWxlbWVudFN0YWNrW2lpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG52YXIgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IHt9O1xudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgbGlzdGluZzogdHJ1ZSxcbiAgcHJlOiB0cnVlLFxuICB0ZXh0YXJlYTogdHJ1ZVxufTsgLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcblxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIXZhbGlkYXRlZFRhZ0NhY2hlLmhhc093blByb3BlcnR5KHRhZykpIHtcbiAgICBpZiAoIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCB0YWc6IFwiICsgdGFnICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxudmFyIHN0eWxlTmFtZUNhY2hlID0ge307XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICBpZiAoc3R5bGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgIHJldHVybiBzdHlsZU5hbWVDYWNoZVtzdHlsZU5hbWVdO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xuICBzdHlsZU5hbWVDYWNoZVtzdHlsZU5hbWVdID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHN0eWxlcykge1xuICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICB2YXIgZGVsaW1pdGVyID0gJyc7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcblxuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyAoaXNDdXN0b21Qcm9wZXJ0eSA/IHN0eWxlTmFtZSA6IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSkgKyAnOic7XG4gICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICAgIGRlbGltaXRlciA9ICc7JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIGdldENvbXBvbmVudE5hbWUoX2NvbnN0cnVjdG9yKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uQ2hpbGRyZW5Jbm5lck1hcmt1cChwcm9wcykge1xuICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlubmVySFRNTC5fX2h0bWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuVG9wTGV2ZWxDaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHJldHVybiB0b0FycmF5KGNoaWxkcmVuKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY2hpbGRyZW47XG5cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHJldHVybiBbZWxlbWVudF07XG4gIH1cblxuICB2YXIgZnJhZ21lbnRDaGlsZHJlbiA9IGVsZW1lbnQucHJvcHMuY2hpbGRyZW47XG5cbiAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChmcmFnbWVudENoaWxkcmVuKSkge1xuICAgIHJldHVybiB0b0FycmF5KGZyYWdtZW50Q2hpbGRyZW4pO1xuICB9XG5cbiAgdmFyIGZyYWdtZW50Q2hpbGRFbGVtZW50ID0gZnJhZ21lbnRDaGlsZHJlbjtcbiAgcmV0dXJuIFtmcmFnbWVudENoaWxkRWxlbWVudF07XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciBjb250ZW50ID0gJyc7IC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBjaGlsZDtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiAmJiB0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBjaGlsZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogbnVsbCxcbiAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiBudWxsXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVPcGVuVGFnTWFya3VwKHRhZ1ZlcmJhdGltLCB0YWdMb3dlcmNhc2UsIHByb3BzLCBuYW1lc3BhY2UsIG1ha2VTdGF0aWNNYXJrdXAsIGlzUm9vdEVsZW1lbnQpIHtcbiAgdmFyIHJldCA9ICc8JyArIHRhZ1ZlcmJhdGltO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnQkMSA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZ0xvd2VyY2FzZSwgcHJvcHMpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5JDIuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBwcm9wVmFsdWUgPSBjcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgbWFya3VwID0gbnVsbDtcblxuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudCQxKSB7XG4gICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIG1hcmt1cCA9IGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrdXAgPSBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChtYXJrdXApIHtcbiAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgfVxuICB9IC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAvLyBieXRlcy5cblxuXG4gIGlmIChtYWtlU3RhdGljTWFya3VwKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmIChpc1Jvb3RFbGVtZW50KSB7XG4gICAgcmV0ICs9ICcgJyArIGNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVuZGVyUmVzdWx0KGNoaWxkLCB0eXBlKSB7XG4gIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggKGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCcpICsgXCIoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKGNoaWxkLCBjb250ZXh0LCB0aHJlYWRJRCkge1xuICB3aGlsZSAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgLy8gU2FmZSBiZWNhdXNlIHdlIGp1c3QgY2hlY2tlZCBpdCdzIGFuIGVsZW1lbnQuXG4gICAgdmFyIGVsZW1lbnQgPSBjaGlsZDtcbiAgICB2YXIgQ29tcG9uZW50ID0gZWxlbWVudC50eXBlO1xuXG4gICAge1xuICAgICAgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2soZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByb2Nlc3NDaGlsZChlbGVtZW50LCBDb21wb25lbnQpO1xuICB9IC8vIEV4dHJhIGNsb3N1cmUgc28gcXVldWUgYW5kIHJlcGxhY2UgY2FuIGJlIGNhcHR1cmVkIHByb3Blcmx5XG5cblxuICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGQoZWxlbWVudCwgQ29tcG9uZW50KSB7XG4gICAgdmFyIGlzQ2xhc3MgPSBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gcHJvY2Vzc0NvbnRleHQoQ29tcG9uZW50LCBjb250ZXh0LCB0aHJlYWRJRCwgaXNDbGFzcyk7XG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHJlcGxhY2UgPSBmYWxzZTtcbiAgICB2YXIgdXBkYXRlciA9IHtcbiAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICAgICAgcmVwbGFjZSA9IHRydWU7XG4gICAgICAgIHF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgICAgfSxcbiAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjdXJyZW50UGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLnB1c2goY3VycmVudFBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgaW5zdDtcblxuICAgIGlmIChpc0NsYXNzKSB7XG4gICAgICBpbnN0ID0gbmV3IENvbXBvbmVudChlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVyKTtcblxuICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaW5zdC5zdGF0ZSA9PT0gbnVsbCB8fCBpbnN0LnN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0LnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuY2FsbChudWxsLCBlbGVtZW50LnByb3BzLCBpbnN0LnN0YXRlKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZVtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZVtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIGluc3Quc3RhdGUgPSBfYXNzaWduKHt9LCBpbnN0LnN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgICAgIGVycm9yKFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyKTtcblxuICAgICAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnRJZGVudGl0eSA9IHt9O1xuICAgICAgcHJlcGFyZVRvVXNlSG9va3MoY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgaW5zdCA9IENvbXBvbmVudChlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVyKTtcbiAgICAgIGluc3QgPSBmaW5pc2hIb29rcyhDb21wb25lbnQsIGVsZW1lbnQucHJvcHMsIGluc3QsIHB1YmxpY0NvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3QgaXQgd291bGQgY3Jhc2ggbGF0ZXIsIHdlIHdhbnQgdG8gc2hvdyBhIGdvb2QgbWVzc2FnZSBpbiBERVYgZmlyc3QuXG4gICAgICAgIGlmIChpbnN0ICE9IG51bGwgJiYgaW5zdC5yZW5kZXIgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lMywgX2NvbXBvbmVudE5hbWUzLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB0aGUgZmxhZyBpcyBvbiwgZXZlcnl0aGluZyBpcyBhc3N1bWVkIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50LlxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBhbHNvIGRvIHRoZSB1bmZvcnR1bmF0ZSBkeW5hbWljIGNoZWNrcy5cblxuXG4gICAgICBpZiAoIGluc3QgPT0gbnVsbCB8fCBpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkID0gaW5zdDtcbiAgICAgICAgdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIENvbXBvbmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0LnByb3BzID0gZWxlbWVudC5wcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3Quc3RhdGU7XG5cbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCBpbnN0LmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWU0ID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgICAgICAgd2FybiggLy8ga2VlcCB0aGlzIHdhcm5pbmcgaW4gc3luYyB3aXRoIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmcuanNcbiAgICAgICAgICAgICAgJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpICcgKyAnb3IgdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX2NvbXBvbmVudE5hbWU0KTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAgICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBhbnkgY29tcG9uZW50IHdpdGggdGhlIG5ldyBnRFNGUC5cblxuXG4gICAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgYW55IGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgZ0RTRlAuXG4gICAgICAgIGluc3QuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvbGRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICB2YXIgb2xkUmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgICAgIHF1ZXVlID0gbnVsbDtcbiAgICAgICAgcmVwbGFjZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvbGRSZXBsYWNlICYmIG9sZFF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGluc3Quc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gb2xkUmVwbGFjZSA/IG9sZFF1ZXVlWzBdIDogaW5zdC5zdGF0ZTtcbiAgICAgICAgICB2YXIgZG9udE11dGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gb2xkUmVwbGFjZSA/IDEgOiAwOyBpIDwgb2xkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gb2xkUXVldWVbaV07XG5cbiAgICAgICAgICAgIHZhciBfcGFydGlhbFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0KSA6IHBhcnRpYWw7XG5cbiAgICAgICAgICAgIGlmIChfcGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGRvbnRNdXRhdGUpIHtcbiAgICAgICAgICAgICAgICBkb250TXV0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gX2Fzc2lnbih7fSwgbmV4dFN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfYXNzaWduKG5leHRTdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBpbnN0LnJlbmRlcigpO1xuXG4gICAge1xuICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgIGNoaWxkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgQ29tcG9uZW50KTtcbiAgICB2YXIgY2hpbGRDb250ZXh0O1xuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0LmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgX2NoaWxkQ29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX2NoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBfY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggKGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bicpICsgXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIgKyBjb250ZXh0S2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IF9hc3NpZ24oe30sIGNvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaGlsZDogY2hpbGQsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9O1xufVxuXG52YXIgUmVhY3RET01TZXJ2ZXJSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIFRPRE86IHR5cGUgdGhpcyBtb3JlIHN0cmljdGx5OlxuICAvLyBERVYtb25seVxuICBmdW5jdGlvbiBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGNoaWxkcmVuLCBtYWtlU3RhdGljTWFya3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGZsYXRDaGlsZHJlbiA9IGZsYXR0ZW5Ub3BMZXZlbENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB2YXIgdG9wRnJhbWUgPSB7XG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgLy8gQXNzdW1lIGFsbCB0cmVlcyBzdGFydCBpbiB0aGUgSFRNTCBuYW1lc3BhY2UgKG5vdCB0b3RhbGx5IHRydWUsIGJ1dFxuICAgICAgLy8gdGhpcyBpcyB3aGF0IHdlIGRpZCBoaXN0b3JpY2FsbHkpXG4gICAgICBkb21OYW1lc3BhY2U6IE5hbWVzcGFjZXMuaHRtbCxcbiAgICAgIGNoaWxkcmVuOiBmbGF0Q2hpbGRyZW4sXG4gICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgY29udGV4dDogZW1wdHlPYmplY3QsXG4gICAgICBmb290ZXI6ICcnXG4gICAgfTtcblxuICAgIHtcbiAgICAgIHRvcEZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgfVxuXG4gICAgdGhpcy50aHJlYWRJRCA9IGFsbG9jVGhyZWFkSUQoKTtcbiAgICB0aGlzLnN0YWNrID0gW3RvcEZyYW1lXTtcbiAgICB0aGlzLmV4aGF1c3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICB0aGlzLm1ha2VTdGF0aWNNYXJrdXAgPSBtYWtlU3RhdGljTWFya3VwO1xuICAgIHRoaXMuc3VzcGVuc2VEZXB0aCA9IDA7IC8vIENvbnRleHQgKG5ldyBBUEkpXG5cbiAgICB0aGlzLmNvbnRleHRJbmRleCA9IC0xO1xuICAgIHRoaXMuY29udGV4dFN0YWNrID0gW107XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFjayA9IFtdOyAvLyB1c2VPcGFxdWVJZGVudGlmaWVyIElEXG5cbiAgICB0aGlzLnVuaXF1ZUlEID0gMDtcbiAgICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zICYmIG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCB8fCAnJztcblxuICAgIHtcbiAgICAgIHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2sgPSBbXTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3RET01TZXJ2ZXJSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5leGhhdXN0ZWQpIHtcbiAgICAgIHRoaXMuZXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2xlYXJQcm92aWRlcnMoKTtcbiAgICAgIGZyZWVUaHJlYWRJRCh0aGlzLnRocmVhZElEKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5vdGU6IFdlIHVzZSBqdXN0IHR3byBzdGFja3MgcmVnYXJkbGVzcyBvZiBob3cgbWFueSBjb250ZXh0IHByb3ZpZGVycyB5b3UgaGF2ZS5cbiAgICogUHJvdmlkZXJzIGFyZSBhbHdheXMgcG9wcGVkIGluIHRoZSByZXZlcnNlIG9yZGVyIHRvIGhvdyB0aGV5IHdlcmUgcHVzaGVkXG4gICAqIHNvIHdlIGFsd2F5cyBrbm93IG9uIHRoZSB3YXkgZG93biB3aGljaCBwcm92aWRlciB5b3UnbGwgZW5jb3VudGVyIG5leHQgb24gdGhlIHdheSB1cC5cbiAgICogT24gdGhlIHdheSBkb3duLCB3ZSBwdXNoIHRoZSBjdXJyZW50IHByb3ZpZGVyLCBhbmQgaXRzIGNvbnRleHQgdmFsdWUgKmJlZm9yZSpcbiAgICogd2UgbXV0YXRlZCBpdCwgb250byB0aGUgc3RhY2tzLiBUaGVyZWZvcmUsIG9uIHRoZSB3YXkgdXAsIHdlIGFsd2F5cyBrbm93IHdoaWNoXG4gICAqIHByb3ZpZGVyIG5lZWRzIHRvIGJlIFwicmVzdG9yZWRcIiB0byB3aGljaCB2YWx1ZS5cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTI5ODUjaXNzdWVjb21tZW50LTM5NjMwMTI0OFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wdXNoUHJvdmlkZXIgPSBmdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICB2YXIgaW5kZXggPSArK3RoaXMuY29udGV4dEluZGV4O1xuICAgIHZhciBjb250ZXh0ID0gcHJvdmlkZXIudHlwZS5fY29udGV4dDtcbiAgICB2YXIgdGhyZWFkSUQgPSB0aGlzLnRocmVhZElEO1xuICAgIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCk7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBjb250ZXh0W3RocmVhZElEXTsgLy8gUmVtZW1iZXIgd2hpY2ggdmFsdWUgdG8gcmVzdG9yZSB0aGlzIGNvbnRleHQgdG8gb24gb3VyIHdheSB1cC5cblxuICAgIHRoaXMuY29udGV4dFN0YWNrW2luZGV4XSA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF0gPSBwcmV2aW91c1ZhbHVlO1xuXG4gICAge1xuICAgICAgLy8gT25seSB1c2VkIGZvciBwdXNoL3BvcCBtaXNtYXRjaCB3YXJuaW5ncy5cbiAgICAgIHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2tbaW5kZXhdID0gcHJvdmlkZXI7XG4gICAgfSAvLyBNdXRhdGUgdGhlIGN1cnJlbnQgdmFsdWUuXG5cblxuICAgIGNvbnRleHRbdGhyZWFkSURdID0gcHJvdmlkZXIucHJvcHMudmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLnBvcFByb3ZpZGVyID0gZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHRJbmRleDtcblxuICAgIHtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgcHJvdmlkZXIgIT09IHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFN0YWNrW2luZGV4XTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdOyAvLyBcIkhpZGVcIiB0aGVzZSBudWxsIGFzc2lnbm1lbnRzIGZyb20gRmxvdyBieSB1c2luZyBgYW55YFxuICAgIC8vIGJlY2F1c2UgY29uY2VwdHVhbGx5IHRoZXkgYXJlIGRlbGV0aW9ucy0tYXMgbG9uZyBhcyB3ZVxuICAgIC8vIHByb21pc2UgdG8gbmV2ZXIgYWNjZXNzIHZhbHVlcyBiZXlvbmQgYHRoaXMuY29udGV4dEluZGV4YC5cblxuICAgIHRoaXMuY29udGV4dFN0YWNrW2luZGV4XSA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dEluZGV4LS07IC8vIFJlc3RvcmUgdG8gdGhlIHByZXZpb3VzIHZhbHVlIHdlIHN0b3JlZCBhcyB3ZSB3ZXJlIHdhbGtpbmcgZG93bi5cbiAgICAvLyBXZSd2ZSBhbHJlYWR5IHZlcmlmaWVkIHRoYXQgdGhpcyBjb250ZXh0IGhhcyBiZWVuIGV4cGFuZGVkIHRvIGFjY29tbW9kYXRlXG4gICAgLy8gdGhpcyB0aHJlYWQgaWQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gaXQgYWdhaW4uXG5cbiAgICBjb250ZXh0W3RoaXMudGhyZWFkSURdID0gcHJldmlvdXNWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJQcm92aWRlcnMgPSBmdW5jdGlvbiBjbGVhclByb3ZpZGVycygpIHtcbiAgICAvLyBSZXN0b3JlIGFueSByZW1haW5pbmcgcHJvdmlkZXJzIG9uIHRoZSBzdGFjayB0byBwcmV2aW91cyB2YWx1ZXNcbiAgICBmb3IgKHZhciBpbmRleCA9IHRoaXMuY29udGV4dEluZGV4OyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFN0YWNrW2luZGV4XTtcbiAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF07XG4gICAgICBjb250ZXh0W3RoaXMudGhyZWFkSURdID0gcHJldmlvdXNWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlYWQgPSBmdW5jdGlvbiByZWFkKGJ5dGVzKSB7XG4gICAgaWYgKHRoaXMuZXhoYXVzdGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcHJldlBhcnRpYWxSZW5kZXJlciA9IGN1cnJlbnRQYXJ0aWFsUmVuZGVyZXI7XG4gICAgc2V0Q3VycmVudFBhcnRpYWxSZW5kZXJlcih0aGlzKTtcbiAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IERpc3BhdGNoZXI7XG5cbiAgICB0cnkge1xuICAgICAgLy8gTWFya3VwIGdlbmVyYXRlZCB3aXRoaW4gPFN1c3BlbnNlPiBlbmRzIHVwIGJ1ZmZlcmVkIHVudGlsIHdlIGtub3dcbiAgICAgIC8vIG5vdGhpbmcgaW4gdGhhdCBib3VuZGFyeSBzdXNwZW5kZWRcbiAgICAgIHZhciBvdXQgPSBbJyddO1xuICAgICAgdmFyIHN1c3BlbmRlZCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAob3V0WzBdLmxlbmd0aCA8IGJ5dGVzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuZXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICBmcmVlVGhyZWFkSUQodGhpcy50aHJlYWRJRCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHN1c3BlbmRlZCB8fCBmcmFtZS5jaGlsZEluZGV4ID49IGZyYW1lLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBmb290ZXIgPSBmcmFtZS5mb290ZXI7XG5cbiAgICAgICAgICBpZiAoZm9vdGVyICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcblxuICAgICAgICAgIGlmIChmcmFtZS50eXBlID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZSAhPSBudWxsICYmIGZyYW1lLnR5cGUudHlwZSAhPSBudWxsICYmIGZyYW1lLnR5cGUudHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gZnJhbWUudHlwZTtcbiAgICAgICAgICAgIHRoaXMucG9wUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWUudHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSkge1xuICAgICAgICAgICAgdGhpcy5zdXNwZW5zZURlcHRoLS07XG4gICAgICAgICAgICB2YXIgYnVmZmVyZWQgPSBvdXQucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChzdXNwZW5kZWQpIHtcbiAgICAgICAgICAgICAgc3VzcGVuZGVkID0gZmFsc2U7IC8vIElmIHJlbmRlcmluZyB3YXMgc3VzcGVuZGVkIGF0IHRoaXMgYm91bmRhcnksIHJlbmRlciB0aGUgZmFsbGJhY2tGcmFtZVxuXG4gICAgICAgICAgICAgIHZhciBmYWxsYmFja0ZyYW1lID0gZnJhbWUuZmFsbGJhY2tGcmFtZTtcblxuICAgICAgICAgICAgICBpZiAoIWZhbGxiYWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0cnVlID8gXCJSZWFjdERPTVNlcnZlciBkaWQgbm90IGZpbmQgYW4gaW50ZXJuYWwgZmFsbGJhY2sgZnJhbWUgZm9yIFN1c3BlbnNlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiA6IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzAzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZhbGxiYWNrRnJhbWUpO1xuICAgICAgICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSAnPCEtLSQhLS0+JzsgLy8gU2tpcCBmbHVzaGluZyBvdXRwdXQgc2luY2Ugd2UncmUgc3dpdGNoaW5nIHRvIHRoZSBmYWxsYmFja1xuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gYnVmZmVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBGbHVzaCBvdXRwdXRcblxuXG4gICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gZm9vdGVyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZnJhbWUuY2hpbGRyZW5bZnJhbWUuY2hpbGRJbmRleCsrXTtcbiAgICAgICAgdmFyIG91dEJ1ZmZlciA9ICcnO1xuXG4gICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrKHRoaXMuc3RhY2spOyAvLyBXZSdyZSBzdGFydGluZyB3b3JrIG9uIHRoaXMgZnJhbWUsIHNvIHJlc2V0IGl0cyBpbm5lciBzdGFjay5cblxuICAgICAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dEJ1ZmZlciArPSB0aGlzLnJlbmRlcihjaGlsZCwgZnJhbWUuY29udGV4dCwgZnJhbWUuZG9tTmFtZXNwYWNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsICYmIHR5cGVvZiBlcnIudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgaWYgKCEodGhpcy5zdXNwZW5zZURlcHRoID4gMCkpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0cnVlID8gXCJBIFJlYWN0IGNvbXBvbmVudCBzdXNwZW5kZWQgd2hpbGUgcmVuZGVyaW5nLCBidXQgbm8gZmFsbGJhY2sgVUkgd2FzIHNwZWNpZmllZC5cXG5cXG5BZGQgYSA8U3VzcGVuc2UgZmFsbGJhY2s9Li4uPiBjb21wb25lbnQgaGlnaGVyIGluIHRoZSB0cmVlIHRvIHByb3ZpZGUgYSBsb2FkaW5nIGluZGljYXRvciBvciBwbGFjZWhvbGRlciB0byBkaXNwbGF5LlwiIDogZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFmYWxzZSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRydWUgPyBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IFN1c3BlbnNlLlwiIDogZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOTQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgcG9wQ3VycmVudERlYnVnU3RhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0Lmxlbmd0aCA8PSB0aGlzLnN1c3BlbnNlRGVwdGgpIHtcbiAgICAgICAgICBvdXQucHVzaCgnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSBvdXRCdWZmZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRbMF07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICBzZXRDdXJyZW50UGFydGlhbFJlbmRlcmVyKHByZXZQYXJ0aWFsUmVuZGVyZXIpO1xuICAgICAgcmVzZXRIb29rc1N0YXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY2hpbGQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB0ZXh0ID0gJycgKyBjaGlsZDtcblxuICAgICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWFrZVN0YXRpY01hcmt1cCkge1xuICAgICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUpIHtcbiAgICAgICAgcmV0dXJuICc8IS0tIC0tPicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRDaGlsZDtcblxuICAgICAgdmFyIF9yZXNvbHZlID0gcmVzb2x2ZShjaGlsZCwgY29udGV4dCwgdGhpcy50aHJlYWRJRCk7XG5cbiAgICAgIG5leHRDaGlsZCA9IF9yZXNvbHZlLmNoaWxkO1xuICAgICAgY29udGV4dCA9IF9yZXNvbHZlLmNvbnRleHQ7XG5cbiAgICAgIGlmIChuZXh0Q2hpbGQgPT09IG51bGwgfHwgbmV4dENoaWxkID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IGVsc2UgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXh0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBuZXh0Q2hpbGQuJCR0eXBlb2YgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENhdGNoIHVuZXhwZWN0ZWQgc3BlY2lhbCB0eXBlcyBlYXJseS5cbiAgICAgICAgICB2YXIgJCR0eXBlb2YgPSBuZXh0Q2hpbGQuJCR0eXBlb2Y7XG5cbiAgICAgICAgICBpZiAoISgkJHR5cGVvZiAhPT0gUkVBQ1RfUE9SVEFMX1RZUEUpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlBvcnRhbHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgcmVuZGVyZXIuIFJlbmRlciB0aGVtIGNvbmRpdGlvbmFsbHkgc28gdGhhdCB0aGV5IG9ubHkgYXBwZWFyIG9uIHRoZSBjbGllbnQgcmVuZGVyLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBDYXRjaC1hbGwgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIGlmIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoKSBzdXBwb3J0cyBzb21lIG5ldyB0eXBlLlxuXG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gZWxlbWVudC1saWtlIG9iamVjdCB0eXBlOiBcIiArICQkdHlwZW9mLnRvU3RyaW5nKCkgKyBcIi4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRvQXJyYXkobmV4dENoaWxkKTtcbiAgICAgICAgdmFyIGZyYW1lID0ge1xuICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgY2hpbGRyZW46IG5leHRDaGlsZHJlbixcbiAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZyYW1lKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSAvLyBTYWZlIGJlY2F1c2Ugd2UganVzdCBjaGVja2VkIGl0J3MgYW4gZWxlbWVudC5cblxuXG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGQ7XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSBuZXh0RWxlbWVudC50eXBlO1xuXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJET00obmV4dEVsZW1lbnQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZWxlbWVudFR5cGUpIHtcbiAgICAgICAgLy8gVE9ETzogTGVnYWN5SGlkZGVuIGFjdHMgdGhlIHNhbWUgYXMgYSBmcmFnbWVudC4gVGhpcyBvbmx5IHdvcmtzXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgY3VycmVudGx5IGFzc3VtZSB0aGF0IGV2ZXJ5IGluc3RhbmNlIG9mIExlZ2FjeUhpZGRlbiBpc1xuICAgICAgICAvLyBhY2NvbXBhbmllZCBieSBhIGhvc3QgY29tcG9uZW50IHdyYXBwZXIuIEluIHRoZSBoaWRkZW4gbW9kZSwgdGhlIGhvc3RcbiAgICAgICAgLy8gY29tcG9uZW50IGlzIGdpdmVuIGEgYGhpZGRlbmAgYXR0cmlidXRlLCB3aGljaCBlbnN1cmVzIHRoYXQgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgSFRNTCBpcyBub3QgdmlzaWJsZS4gVG8gc3VwcG9ydCB0aGUgdXNlIG9mIExlZ2FjeUhpZGRlbiBhcyBhXG4gICAgICAgIC8vIHRydWUgZnJhZ21lbnQsIHdpdGhvdXQgYW4gZXh0cmEgRE9NIG5vZGUsIHdlIHdvdWxkIGhhdmUgdG8gaGlkZSB0aGVcbiAgICAgICAgLy8gaW5pdGlhbCBIVE1MIGluIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW4gPSB0b0FycmF5KG5leHRDaGlsZC5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIHZhciBfZnJhbWUgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbixcbiAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfZnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBTdXNwZW5zZS5cIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAgICAgIHtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnRUeXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IG5leHRDaGlsZDtcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjU7XG5cbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudElkZW50aXR5ID0ge307XG4gICAgICAgICAgICAgIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjUgPSBlbGVtZW50VHlwZS5yZW5kZXIoZWxlbWVudC5wcm9wcywgZWxlbWVudC5yZWYpO1xuICAgICAgICAgICAgICBfbmV4dENoaWxkcmVuNSA9IGZpbmlzaEhvb2tzKGVsZW1lbnRUeXBlLnJlbmRlciwgZWxlbWVudC5wcm9wcywgX25leHRDaGlsZHJlbjUsIGVsZW1lbnQucmVmKTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjUgPSB0b0FycmF5KF9uZXh0Q2hpbGRyZW41KTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjUsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTUpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9lbGVtZW50ID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjYgPSBbUmVhY3QuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZS50eXBlLCBfYXNzaWduKHtcbiAgICAgICAgICAgICAgICByZWY6IF9lbGVtZW50LnJlZlxuICAgICAgICAgICAgICB9LCBfZWxlbWVudC5wcm9wcykpXTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTYgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjYsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNi5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTYpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHByb3ZpZGVyLnByb3BzO1xuXG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuNyA9IHRvQXJyYXkobmV4dFByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgICB2YXIgX2ZyYW1lNyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm92aWRlcixcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjcsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNy5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5wdXNoUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lNyk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcmVhY3RDb250ZXh0ID0gbmV4dENoaWxkLnR5cGU7IC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAgICAgICAgICAgICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAgICAgICAgICAgICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgICAgICAgICAgICAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgICAgICAgICAgICAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgICAgICAgICAgICAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gICAgICAgICAgICAgIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWN0Q29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgICAgICAgICAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgICAgICAgICAgICAgIGlmIChyZWFjdENvbnRleHQgIT09IHJlYWN0Q29udGV4dC5Db25zdW1lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlYWN0Q29udGV4dCA9IHJlYWN0Q29udGV4dC5fY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX25leHRQcm9wcyA9IG5leHRDaGlsZC5wcm9wcztcbiAgICAgICAgICAgICAgdmFyIHRocmVhZElEID0gdGhpcy50aHJlYWRJRDtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKHJlYWN0Q29udGV4dCwgdGhyZWFkSUQpO1xuICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gcmVhY3RDb250ZXh0W3RocmVhZElEXTtcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjggPSB0b0FycmF5KF9uZXh0UHJvcHMuY2hpbGRyZW4obmV4dFZhbHVlKSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTggPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbmV4dENoaWxkLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuOCxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU4LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lOCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRTpcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgdGhlIGZ1bmRhbWVudGFsIEFQSS5cIiApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfZWxlbWVudDIgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gbmV4dENoaWxkLnR5cGU7IC8vIEF0dGVtcHQgdG8gaW5pdGlhbGl6ZSBsYXp5IGNvbXBvbmVudCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlXG4gICAgICAgICAgICAgIC8vIHN1c3BlbnNlIHNlcnZlci1zaWRlIHJlbmRlcmVyIGlzIGVuYWJsZWQgc28gc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAvLyByZXNvbHZlZCBjb25zdHJ1Y3RvcnMgYXJlIHN1cHBvcnRlZC5cblxuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuMTAgPSBbUmVhY3QuY3JlYXRlRWxlbWVudChyZXN1bHQsIF9hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHJlZjogX2VsZW1lbnQyLnJlZlxuICAgICAgICAgICAgICB9LCBfZWxlbWVudDIucHJvcHMpKV07XG4gICAgICAgICAgICAgIHZhciBfZnJhbWUxMCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuMTAsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lMTAuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWUxMCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICB7XG4gICAgICAgIHZhciBvd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGVsZW1lbnRUeXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBcIiArICduYW1lZCBpbXBvcnRzLic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICsgKGVsZW1lbnRUeXBlID09IG51bGwgPyBlbGVtZW50VHlwZSA6IHR5cGVvZiBlbGVtZW50VHlwZSkgKyBcIi5cIiArIGluZm8gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyRE9NID0gZnVuY3Rpb24gcmVuZGVyRE9NKGVsZW1lbnQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAgIHZhciB0YWcgPSBlbGVtZW50LnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuXG4gICAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICBuYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBOYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICAgIGlmICh0YWcgIT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgZWxlbWVudC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gICAgdmFyIHByb3BzID0gZWxlbWVudC5wcm9wcztcblxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnaW5wdXQnLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSkge1xuICAgICAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gX2Fzc2lnbih7XG4gICAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgICAgfSwgcHJvcHMsIHtcbiAgICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgIGNoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygndGV4dGFyZWEnLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSkge1xuICAgICAgICAgIGVycm9yKCdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gICAgICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTsgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cblxuICAgICAgICB2YXIgdGV4dGFyZWFDaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIGlmICh0ZXh0YXJlYUNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEoZGVmYXVsdFZhbHVlID09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIklmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHRhcmVhQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBpZiAoISh0ZXh0YXJlYUNoaWxkcmVuLmxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dGFyZWFDaGlsZHJlbiA9IHRleHRhcmVhQ2hpbGRyZW5bMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyB0ZXh0YXJlYUNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hpbGRyZW46ICcnICsgaW5pdGlhbFZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcblxuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG5cbiAgICAgICAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJywgcHJvcE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLicsIHByb3BOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSkge1xuICAgICAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZSA9IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIHByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdvcHRpb24nKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgdmFyIHNlbGVjdFZhbHVlID0gdGhpcy5jdXJyZW50U2VsZWN0VmFsdWU7XG4gICAgICB2YXIgb3B0aW9uQ2hpbGRyZW4gPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlICsgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25DaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtqXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzID0gX2Fzc2lnbih7XG4gICAgICAgICAgc2VsZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gICAgICAgIH0sIHByb3BzLCB7XG4gICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgICAgIGNoaWxkcmVuOiBvcHRpb25DaGlsZHJlblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcHJvcHMpO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcyk7XG4gICAgdmFyIG91dCA9IGNyZWF0ZU9wZW5UYWdNYXJrdXAoZWxlbWVudC50eXBlLCB0YWcsIHByb3BzLCBuYW1lc3BhY2UsIHRoaXMubWFrZVN0YXRpY01hcmt1cCwgdGhpcy5zdGFjay5sZW5ndGggPT09IDEpO1xuICAgIHZhciBmb290ZXIgPSAnJztcblxuICAgIGlmIChvbWl0dGVkQ2xvc2VUYWdzLmhhc093blByb3BlcnR5KHRhZykpIHtcbiAgICAgIG91dCArPSAnLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJz4nO1xuICAgICAgZm9vdGVyID0gJzwvJyArIGVsZW1lbnQudHlwZSArICc+JztcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW47XG4gICAgdmFyIGlubmVyTWFya3VwID0gZ2V0Tm9uQ2hpbGRyZW5Jbm5lck1hcmt1cChwcm9wcyk7XG5cbiAgICBpZiAoaW5uZXJNYXJrdXAgIT0gbnVsbCkge1xuICAgICAgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzLmhhc093blByb3BlcnR5KHRhZykgJiYgaW5uZXJNYXJrdXAuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgICBvdXQgKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIG91dCArPSBpbm5lck1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW4gPSB0b0FycmF5KHByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWUgPSB7XG4gICAgICBkb21OYW1lc3BhY2U6IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgZWxlbWVudC50eXBlKSxcbiAgICAgIHR5cGU6IHRhZyxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgZm9vdGVyOiBmb290ZXJcbiAgICB9O1xuXG4gICAge1xuICAgICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnB1c2goZnJhbWUpO1xuICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IGZhbHNlO1xuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0RE9NU2VydmVyUmVuZGVyZXI7XG59KCk7XG5cbi8qKlxuICogUmVuZGVyIGEgUmVhY3RFbGVtZW50IHRvIGl0cyBpbml0aWFsIEhUTUwuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiB0aGVcbiAqIHNlcnZlci5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvc3RyaW5nXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihlbGVtZW50LCBmYWxzZSwgb3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbWFya3VwID0gcmVuZGVyZXIucmVhZChJbmZpbml0eSk7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSBmaW5hbGx5IHtcbiAgICByZW5kZXJlci5kZXN0cm95KCk7XG4gIH1cbn1cbi8qKlxuICogU2ltaWxhciB0byByZW5kZXJUb1N0cmluZywgZXhjZXB0IHRoaXMgZG9lc24ndCBjcmVhdGUgZXh0cmEgRE9NIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgZGF0YS1yZWFjdC1pZCB0aGF0IFJlYWN0IHVzZXMgaW50ZXJuYWxseS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvc3RhdGljbWFya3VwXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNNYXJrdXAoZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihlbGVtZW50LCB0cnVlLCBvcHRpb25zKTtcblxuICB0cnkge1xuICAgIHZhciBtYXJrdXAgPSByZW5kZXJlci5yZWFkKEluZmluaXR5KTtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJUb05vZGVTdHJlYW0oKSB7XG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTVNlcnZlci5yZW5kZXJUb05vZGVTdHJlYW0oKTogVGhlIHN0cmVhbWluZyBBUEkgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3Nlci4gVXNlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgaW5zdGVhZC5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0oKSB7XG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0oKTogVGhlIHN0cmVhbWluZyBBUEkgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3Nlci4gVXNlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKCkgaW5zdGVhZC5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLnJlbmRlclRvTm9kZVN0cmVhbSA9IHJlbmRlclRvTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbmV4cG9ydHMucmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtID0gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtO1xuZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IHJlbmRlclRvU3RyaW5nO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIuYnJvd3Nlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLmJyb3dzZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMVxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuanN4REVWID0ganN4REVWJDE7XG4gIH0pKCk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMVxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMSc7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gMHhlYWNjO1xuZXhwb3J0cy5Qcm9maWxlciA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xuZXhwb3J0cy5TdXNwZW5zZSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIGV4cG9ydHMuU3RyaWN0TW9kZSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgZXhwb3J0cy5Qcm9maWxlciA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IDBcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBleHBvcnRzLlByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3RyaWN0TW9kZTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IGRlZmF1bHRFeHBvcnQ7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IC0xLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHJlbmRlci5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBleHBvcnRzLlByb2ZpbGVyIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IGV4cG9ydHMuU3RyaWN0TW9kZSB8fCB0eXBlID09PSBleHBvcnRzLlN1c3BlbnNlIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIGlmICh1bnN0YWJsZV9vYnNlcnZlZEJpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycgOiAnJyk7XG4gICAgfSAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbntcblxuICB0cnkge1xuICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tmcm96ZW5PYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbZnJvemVuT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuIiwiaW1wb3J0IGRsdiBmcm9tICdkbHYnO1xuaW1wb3J0IHRtcGwgZnJvbSAndGVtcGxpdGUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAob2JqKSB7XG5cdHZhciBsb2NhbGU9JycsIHRyZWUgPSBvYmogfHwge307XG5cblx0cmV0dXJuIHtcblx0XHRzZXQobGFuZywgdGFibGUpIHtcblx0XHRcdHRyZWVbbGFuZ10gPSBPYmplY3QuYXNzaWduKHRyZWVbbGFuZ10gfHwge30sIHRhYmxlKTtcblx0XHR9LFxuXG5cdFx0bG9jYWxlKGxhbmcpIHtcblx0XHRcdHJldHVybiAobG9jYWxlID0gbGFuZyB8fCBsb2NhbGUpO1xuXHRcdH0sXG5cblx0XHR0YWJsZShsYW5nKSB7XG5cdFx0XHRyZXR1cm4gdHJlZVtsYW5nXTtcblx0XHR9LFxuXG5cdFx0dChrZXksIHBhcmFtcywgbGFuZykge1xuXHRcdFx0dmFyIHZhbCA9IGRsdih0cmVlW2xhbmcgfHwgbG9jYWxlXSwga2V5LCAnJyk7XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbChwYXJhbXMpO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSByZXR1cm4gdG1wbCh2YWwsIHBhcmFtcyk7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0fTtcbn1cbiIsIlxuXG4vKjo6IHR5cGUgQXR0ciA9IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVtYmVyIH0gKi9cbi8qOjogdHlwZSBPcHRzID0geyBwcmVzZXJ2ZU51bWJlcnM6ID9ib29sZWFuIH0gKi9cblxuLypcblxuc3R5bGUtYXR0clxuPT09PVxuXG5WZXJ5IHNpbXBsZSBwYXJzaW5nIGFuZCBzdHJpbmdpZnlpbmcgb2Ygc3R5bGUgYXR0cmlidXRlcy5cblxuYHBhcnNlYFxuLS0tLVxuXG5Db252ZXJ0IGEgc3R5bGUgYXR0cmlidXRlIHN0cmluZyB0byBhbiBvYmplY3QuXG5cbiovXG5cbi8qOjogZGVjbGFyZSBmdW5jdGlvbiBwYXJzZSAocmF3OiBzdHJpbmcsIG9wdHM6ID9PcHRzKTogQXR0ciAqL1xuZnVuY3Rpb24gcGFyc2UocmF3LCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwcmVzZXJ2ZU51bWJlcnMgPSBvcHRzLnByZXNlcnZlTnVtYmVycztcbiAgdmFyIHRyaW0gPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnRyaW0oKTtcbiAgfTtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGdldEtleVZhbHVlQ2h1bmtzKHJhdykubWFwKHRyaW0pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgLy8gc3BsaXQgd2l0aCBgLmluZGV4T2ZgIHJhdGhlciB0aGFuIGAuc3BsaXRgIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBhbHNvIGNvbnRhaW4gY29sb25zLlxuICAgIHZhciBwb3MgPSBpdGVtLmluZGV4T2YoJzonKTtcbiAgICB2YXIga2V5ID0gaXRlbS5zdWJzdHIoMCwgcG9zKS50cmltKCk7XG4gICAgdmFyIHZhbCA9IGl0ZW0uc3Vic3RyKHBvcyArIDEpLnRyaW0oKTtcbiAgICBpZiAocHJlc2VydmVOdW1iZXJzICYmIGlzTnVtZXJpYyh2YWwpKSB7XG4gICAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgICB9XG5cbiAgICBvYmpba2V5XSA9IHZhbDtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLypcblxuYGlzTnVtZXJpY2Bcbi0tLS1cblxuQ2hlY2sgaWYgYSB2YWx1ZSBpcyBudW1lcmljLlxuVmlhOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTgzMDg0NC85MzI0XG5cbiovXG5cbi8qOjogZGVjbGFyZSBmdW5jdGlvbiBpc051bWVyaWMgKG46IGFueSk6IGJvb2xlYW4gKi9cblxuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLypcblxuYGdldEtleVZhbHVlQ2h1bmtzYFxuLS0tLVxuXG5TcGxpdCBhIHN0cmluZyBpbnRvIGNodW5rcyBtYXRjaGluZyBgPGtleT46IDx2YWx1ZT5gXG5cbiovXG4vKjo6IGRlY2xhcmUgZnVuY3Rpb24gZ2V0S2V5VmFsdWVDaHVua3MgKHJhdzogc3RyaW5nKTogQXJyYXk8c3RyaW5nPiAqL1xuZnVuY3Rpb24gZ2V0S2V5VmFsdWVDaHVua3MocmF3KSB7XG4gIHZhciBjaHVua3MgPSBbXTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBzZXAgPSAnOyc7XG4gIHZhciBoYXNVbmNsb3NlZFVybCA9IC91cmxcXChbXlxcKV0rJC87XG4gIHZhciBjaHVuayA9ICcnO1xuICB2YXIgbmV4dFNwbGl0O1xuICB3aGlsZSAob2Zmc2V0IDwgcmF3Lmxlbmd0aCkge1xuICAgIG5leHRTcGxpdCA9IHJhdy5pbmRleE9mKHNlcCwgb2Zmc2V0KTtcbiAgICBpZiAobmV4dFNwbGl0ID09PSAtMSkge1xuICAgICAgbmV4dFNwbGl0ID0gcmF3Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBjaHVuayArPSByYXcuc3Vic3RyaW5nKG9mZnNldCwgbmV4dFNwbGl0KTtcblxuICAgIC8vIGRhdGEgVVJJcyBjYW4gY29udGFpbiBzZW1pY29sb25zLCBzbyBtYWtlIHN1cmUgd2UgZ2V0IHRoZSB3aG9sZSB0aGluZ1xuICAgIGlmIChoYXNVbmNsb3NlZFVybC50ZXN0KGNodW5rKSkge1xuICAgICAgY2h1bmsgKz0gJzsnO1xuICAgICAgb2Zmc2V0ID0gbmV4dFNwbGl0ICsgMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICBjaHVuayA9ICcnO1xuICAgIG9mZnNldCA9IG5leHRTcGxpdCArIDE7XG4gIH1cblxuICByZXR1cm4gY2h1bmtzO1xufVxuXG4vKlxuXG5gc3RyaW5naWZ5YFxuLS0tLVxuXG5Db252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIGF0dHJpYnV0ZSBzdHJpbmdcblxuKi9cbi8qOjogZGVjbGFyZSBmdW5jdGlvbiBzdHJpbmdpZnkgKG9iajogQXR0cik6IHN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkgKyAnOicgKyBvYmpba2V5XTtcbiAgfSkuam9pbignOycpO1xufVxuXG4vKlxuXG5gbm9ybWFsaXplYFxuLS0tLVxuXG5Ob3JtYWxpemUgYW4gYXR0cmlidXRlIHN0cmluZyAoZWcuIGNvbGxhcHNlIGR1cGxpY2F0ZXMpXG5cbiovXG4vKjo6IGRlY2xhcmUgZnVuY3Rpb24gbm9ybWFsaXplIChzdHI6IHN0cmluZywgb3B0czogP09wdHMpOiBzdHJpbmcgKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIHN0cmluZ2lmeShwYXJzZShzdHIsIG9wdHMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTsiLCJjb25zdCBSR1ggPSAve3soLio/KX19L2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgbWl4KSB7XG5cdHJldHVybiBzdHIucmVwbGFjZShSR1gsICh4LCBrZXksIHkpID0+IHtcblx0XHR4ID0gMDtcblx0XHR5ID0gbWl4O1xuXHRcdGtleSA9IGtleS50cmltKCkuc3BsaXQoJy4nKTtcblx0XHR3aGlsZSAoeSAmJiB4IDwga2V5Lmxlbmd0aCkge1xuXHRcdFx0eSA9IHlba2V5W3grK11dO1xuXHRcdH1cblx0XHRyZXR1cm4geSAhPSBudWxsID8geSA6ICcnO1xuXHR9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvL1xuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxcXC9dKyk/KFtcXFNcXHNdKikvaVxuICAsIHdpbmRvd3NEcml2ZUxldHRlciA9IC9eW2EtekEtWl06L1xuICAsIHdoaXRlc3BhY2UgPSAnW1xcXFx4MDlcXFxceDBBXFxcXHgwQlxcXFx4MENcXFxceDBEXFxcXHgyMFxcXFx4QTBcXFxcdTE2ODBcXFxcdTE4MEVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMEFcXFxcdTIwMkZcXFxcdTIwNUZcXFxcdTMwMDBcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdUZFRkZdJ1xuICAsIGxlZnQgPSBuZXcgUmVnRXhwKCdeJysgd2hpdGVzcGFjZSArJysnKTtcblxuLyoqXG4gKiBUcmltIGEgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRyaW0uXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gKHN0ciA/IHN0ciA6ICcnKS50b1N0cmluZygpLnJlcGxhY2UobGVmdCwgJycpO1xufVxuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzLCB1cmwpIHsgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/IGFkZHJlc3MucmVwbGFjZSgvXFxcXC9nLCAnLycpIDogYWRkcmVzcztcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBnbG9iYWxWYXI7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBnbG9iYWw7XG4gIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gc2VsZjtcbiAgZWxzZSBnbG9iYWxWYXIgPSB7fTtcblxuICB2YXIgbG9jYXRpb24gPSBnbG9iYWxWYXIubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgcHJvdG9jb2wgc2NoZW1lIGlzIHNwZWNpYWwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFRoZSBwcm90b2NvbCBzY2hlbWUgb2YgdGhlIFVSTFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm90b2NvbCBzY2hlbWUgaXMgc3BlY2lhbCwgZWxzZSBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1NwZWNpYWwoc2NoZW1lKSB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1lID09PSAnZmlsZTonIHx8XG4gICAgc2NoZW1lID09PSAnZnRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwczonIHx8XG4gICAgc2NoZW1lID09PSAnd3M6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ3dzczonXG4gICk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb25cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MsIGxvY2F0aW9uKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcbiAgbG9jYXRpb24gPSBsb2NhdGlvbiB8fCB7fTtcblxuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG4gIHZhciBwcm90b2NvbCA9IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnO1xuICB2YXIgZm9yd2FyZFNsYXNoZXMgPSAhIW1hdGNoWzJdO1xuICB2YXIgb3RoZXJTbGFzaGVzID0gISFtYXRjaFszXTtcbiAgdmFyIHNsYXNoZXNDb3VudCA9IDA7XG4gIHZhciByZXN0O1xuXG4gIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgIGlmIChvdGhlclNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbMl0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAob3RoZXJTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gbWF0Y2hbM10gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzNdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdCA9IG1hdGNoWzRdXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgaWYgKHNsYXNoZXNDb3VudCA+PSAyKSB7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZSgyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTcGVjaWFsKHByb3RvY29sKSkge1xuICAgIHJlc3QgPSBtYXRjaFs0XTtcbiAgfSBlbHNlIGlmIChwcm90b2NvbCkge1xuICAgIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNsYXNoZXNDb3VudCA+PSAyICYmIGlzU3BlY2lhbChsb2NhdGlvbi5wcm90b2NvbCkpIHtcbiAgICByZXN0ID0gbWF0Y2hbNF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBzbGFzaGVzOiBmb3J3YXJkU2xhc2hlcyB8fCBpc1NwZWNpYWwocHJvdG9jb2wpLFxuICAgIHNsYXNoZXNDb3VudDogc2xhc2hlc0NvdW50LFxuICAgIHJlc3Q6IHJlc3RcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIGlmIChyZWxhdGl2ZSA9PT0gJycpIHJldHVybiBiYXNlO1xuXG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW3BhcnNlcl0gUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnLCBsb2NhdGlvbik7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoXG4gICAgZXh0cmFjdGVkLnByb3RvY29sID09PSAnZmlsZTonICYmIChcbiAgICAgIGV4dHJhY3RlZC5zbGFzaGVzQ291bnQgIT09IDIgfHwgd2luZG93c0RyaXZlTGV0dGVyLnRlc3QoYWRkcmVzcykpIHx8XG4gICAgKCFleHRyYWN0ZWQuc2xhc2hlcyAmJlxuICAgICAgKGV4dHJhY3RlZC5wcm90b2NvbCB8fFxuICAgICAgICBleHRyYWN0ZWQuc2xhc2hlc0NvdW50IDwgMiB8fFxuICAgICAgICAhaXNTcGVjaWFsKHVybC5wcm90b2NvbCkpKVxuICApIHtcbiAgICBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcbiAgfVxuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcywgdXJsKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIERlZmF1bHQgdG8gYSAvIGZvciBwYXRobmFtZSBpZiBub25lIGV4aXN0cy4gVGhpcyBub3JtYWxpemVzIHRoZSBVUkxcbiAgLy8gdG8gYWx3YXlzIGhhdmUgYSAvXG4gIC8vXG4gIGlmICh1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwucGF0aG5hbWUgPSAnLycgKyB1cmwucGF0aG5hbWU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdFxuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICE9PSAnZmlsZTonICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpICYmIHVybC5ob3N0XG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzIHx8IGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcclxuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcclxuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VJMThuIH0gZnJvbSAnbmV4dC1sb2NhbGl6YXRpb24nO1xyXG5pbXBvcnQgeyBnZXRQdWJsaWNVcmwgfSBmcm9tICdsaWIvdXRpbCc7XHJcbmltcG9ydCB7XHJcbiAgUGxhY2Vob2xkZXIsXHJcbiAgVmlzaXRvcklkZW50aWZpY2F0aW9uLFxyXG4gIHVzZVNpdGVjb3JlQ29udGV4dCxcclxufSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgeyBTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0VmFsdWUgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbi8vIFByZWZpeCBwdWJsaWMgYXNzZXRzIHdpdGggYSBwdWJsaWMgVVJMIHRvIGVuYWJsZSBjb21wYXRpYmlsaXR5IHdpdGggU2l0ZWNvcmUgRXhwZXJpZW5jZSBFZGl0b3IuXHJcbi8vIElmIHlvdSdyZSBub3Qgc3VwcG9ydGluZyB0aGUgRXhwZXJpZW5jZSBFZGl0b3IsIHlvdSBjYW4gcmVtb3ZlIHRoaXMuXHJcbmNvbnN0IHB1YmxpY1VybCA9IGdldFB1YmxpY1VybCgpO1xyXG5cclxuLy8gVGhpcyBpcyBib2lsZXJwbGF0ZSBuYXZpZ2F0aW9uIGZvciBzYW1wbGUgcHVycG9zZXMuIE1vc3QgYXBwcyBzaG91bGQgdGhyb3cgdGhpcyBhd2F5IGFuZCB1c2UgdGhlaXIgb3duIG5hdmlnYXRpb24gaW1wbGVtZW50YXRpb24uXHJcbi8vIE1vc3QgYXBwcyBtYXkgYWxzbyB3aXNoIHRvIHVzZSBHcmFwaFFMIGZvciB0aGVpciBuYXZpZ2F0aW9uIGNvbnN0cnVjdGlvbjsgdGhpcyBzYW1wbGUgZG9lcyBub3Qgc2ltcGx5IHRvIHN1cHBvcnQgZGlzY29ubmVjdGVkIG1vZGUuXHJcbmNvbnN0IE5hdmlnYXRpb24gPSAoKSA9PiB7XHJcbiAgY29uc3QgeyB0IH0gPSB1c2VJMThuKCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImQtZmxleCBmbGV4LWNvbHVtbiBmbGV4LW1kLXJvdyBhbGlnbi1pdGVtcy1jZW50ZXIgcC0zIHB4LW1kLTQgbWItMyBiZy13aGl0ZSBib3JkZXItYm90dG9tXCI+XHJcbiAgICAgIDxoNSBjbGFzc05hbWU9XCJteS0wIG1yLW1kLWF1dG8gZm9udC13ZWlnaHQtbm9ybWFsXCI+XHJcbiAgICAgICAgPExpbmsgaHJlZj1cIi9cIj5cclxuICAgICAgICAgIDxhIGNsYXNzTmFtZT1cInRleHQtZGFya1wiPlxyXG4gICAgICAgICAgICA8aW1nIHNyYz17YCR7cHVibGljVXJsfS9zY19sb2dvLnN2Z2B9IGFsdD1cIlNpdGVjb3JlXCIgLz5cclxuICAgICAgICAgIDwvYT5cclxuICAgICAgICA8L0xpbms+XHJcbiAgICAgIDwvaDU+XHJcbiAgICAgIDxuYXYgY2xhc3NOYW1lPVwibXktMiBteS1tZC0wIG1yLW1kLTNcIj5cclxuICAgICAgICA8YVxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwicC0yIHRleHQtZGFya1wiXHJcbiAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9qc3Muc2l0ZWNvcmUuY29tXCJcclxuICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXHJcbiAgICAgICAgICByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICB7dCgnRG9jdW1lbnRhdGlvbicpfVxyXG4gICAgICAgIDwvYT5cclxuICAgICAgICA8TGluayBocmVmPVwiL3N0eWxlZ3VpZGVcIj5cclxuICAgICAgICAgIDxhIGNsYXNzTmFtZT1cInAtMiB0ZXh0LWRhcmtcIj57dCgnU3R5bGVndWlkZScpfTwvYT5cclxuICAgICAgICA8L0xpbms+XHJcbiAgICAgICAgPExpbmsgaHJlZj1cIi9ncmFwaHFsXCI+XHJcbiAgICAgICAgICA8YSBjbGFzc05hbWU9XCJwLTIgdGV4dC1kYXJrXCI+e3QoJ0dyYXBoUUwnKX08L2E+XHJcbiAgICAgICAgPC9MaW5rPlxyXG4gICAgICA8L25hdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG50eXBlIExheW91dFByb3BzID0ge1xyXG4gIGNvbnRleHQ6IFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHRWYWx1ZTtcclxufTtcclxuXHJcbmNvbnN0IExheW91dCA9ICh7IGNvbnRleHQgfTogTGF5b3V0UHJvcHMpOiBKU1guRWxlbWVudCA9PiB7XHJcbiAgY29uc3QgeyB1cGRhdGVTaXRlY29yZUNvbnRleHQgfSA9IHVzZVNpdGVjb3JlQ29udGV4dCh7IHVwZGF0YWJsZTogdHJ1ZSB9KTtcclxuXHJcbiAgLy8gVXBkYXRlIFNpdGVjb3JlIENvbnRleHQgaWYgbGF5b3V0RGF0YSBoYXMgY2hhbmdlZCAoaS5lLiBvbiBjbGllbnQtc2lkZSByb3V0ZSBjaGFuZ2UpLlxyXG4gIC8vIE5vdGUgdGhlIGNvbnRleHQgb2JqZWN0IHR5cGUgaGVyZSBtYXRjaGVzIHRoZSBpbml0aWFsIHZhbHVlIGluIFtbLi4ucGF0aF1dLnRzeC5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgdXBkYXRlU2l0ZWNvcmVDb250ZXh0ICYmIHVwZGF0ZVNpdGVjb3JlQ29udGV4dChjb250ZXh0KTtcclxuICB9LCBbY29udGV4dF0pO1xyXG5cclxuICBjb25zdCB7IHJvdXRlIH0gPSBjb250ZXh0O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPD5cclxuICAgICAgPEhlYWQ+XHJcbiAgICAgICAgPHRpdGxlPntyb3V0ZT8uZmllbGRzPy5wYWdlVGl0bGU/LnZhbHVlIHx8ICdQYWdlJ308L3RpdGxlPlxyXG4gICAgICAgIDxsaW5rIHJlbD1cImljb25cIiBocmVmPXtgJHtwdWJsaWNVcmx9L2Zhdmljb24uaWNvYH0gLz5cclxuICAgICAgPC9IZWFkPlxyXG5cclxuICAgICAgey8qXHJcbiAgICAgICAgVmlzaXRvcklkZW50aWZpY2F0aW9uIGlzIG5lY2Vzc2FyeSBmb3IgU2l0ZWNvcmUgQW5hbHl0aWNzIHRvIGRldGVybWluZSBpZiB0aGUgdmlzaXRvciBpcyBhIHJvYm90LlxyXG4gICAgICAgIElmIFNpdGVjb3JlIFhQICh3aXRoIHhDb25uZWN0L3hEQikgaXMgdXNlZCwgdGhpcyBpcyByZXF1aXJlZCBvciBlbHNlIGFuYWx5dGljcyB3aWxsIG5vdCBiZSBjb2xsZWN0ZWQgZm9yIHRoZSBKU1MgYXBwLlxyXG4gICAgICAgIEZvciBYTSAoQ01TLW9ubHkpIGFwcHMsIHRoaXMgc2hvdWxkIGJlIHJlbW92ZWQuXHJcblxyXG4gICAgICAgIFZJIGRldGVjdGlvbiBvbmx5IHJ1bnMgb25jZSBmb3IgYSBnaXZlbiBhbmFseXRpY3MgSUQsIHNvIHRoaXMgaXMgbm90IGEgcmVjdXJyaW5nIG9wZXJhdGlvbiBvbmNlIGNvb2tpZXMgYXJlIGVzdGFibGlzaGVkLlxyXG4gICAgICAqL31cclxuICAgICAgPFZpc2l0b3JJZGVudGlmaWNhdGlvbiAvPlxyXG5cclxuICAgICAgPE5hdmlnYXRpb24gLz5cclxuXHJcbiAgICAgIHsvKiByb290IHBsYWNlaG9sZGVyIGZvciB0aGUgYXBwLCB3aGljaCB3ZSBhZGQgY29tcG9uZW50cyB0byB1c2luZyByb3V0ZSBkYXRhICovfVxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxyXG4gICAgICAgIDxQbGFjZWhvbGRlciBuYW1lPVwianNzLW1haW5cIiByZW5kZXJpbmc9e3JvdXRlfSAvPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMYXlvdXQ7XHJcbiIsImltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XHJcblxyXG4vKipcclxuICogUmVuZGVyZWQgaW4gY2FzZSBpZiB3ZSBoYXZlIDQwNCBlcnJvclxyXG4gKi9cclxuY29uc3QgTm90Rm91bmQgPSAoKTogSlNYLkVsZW1lbnQgPT4gKFxyXG4gIDw+XHJcbiAgICA8SGVhZD5cclxuICAgICAgPHRpdGxlPjQwNDogTm90Rm91bmQ8L3RpdGxlPlxyXG4gICAgPC9IZWFkPlxyXG4gICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAxMCB9fT5cclxuICAgICAgPGgxPlBhZ2Ugbm90IGZvdW5kPC9oMT5cclxuICAgICAgPHA+VGhpcyBwYWdlIGRvZXMgbm90IGV4aXN0LjwvcD5cclxuICAgICAgPGEgaHJlZj1cIi9cIj5HbyB0byB0aGUgSG9tZSBwYWdlPC9hPlxyXG4gICAgPC9kaXY+XHJcbiAgPC8+XHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOb3RGb3VuZDtcclxuIiwiaW1wb3J0IHsgVGV4dCwgUmljaFRleHQsIEZpZWxkIH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzIH0gZnJvbSAnbGliL2NvbXBvbmVudC1wcm9wcyc7XHJcblxyXG50eXBlIENvbnRlbnRCbG9ja1Byb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFByb3BzICYge1xyXG4gIGZpZWxkczoge1xyXG4gICAgaGVhZGluZzogRmllbGQ8c3RyaW5nPjtcclxuICAgIGNvbnRlbnQ6IEZpZWxkPHN0cmluZz47XHJcbiAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIHNpbXBsZSBDb250ZW50IEJsb2NrIGNvbXBvbmVudCwgd2l0aCBhIGhlYWRpbmcgYW5kIHJpY2ggdGV4dCBibG9jay5cclxuICogVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBidWlsZGluZyBibG9jayBvZiBhIGNvbnRlbnQgc2l0ZSwgYW5kIHRoZSBtb3N0IGJhc2ljXHJcbiAqIEpTUyBjb21wb25lbnQgdGhhdCdzIHVzZWZ1bC5cclxuICovXHJcbmNvbnN0IENvbnRlbnRCbG9jayA9ICh7IGZpZWxkcyB9OiBDb250ZW50QmxvY2tQcm9wcyk6IEpTWC5FbGVtZW50ID0+IChcclxuICA8PlxyXG4gICAgPFRleHQgdGFnPVwiaDJcIiBjbGFzc05hbWU9XCJkaXNwbGF5LTRcIiBmaWVsZD17ZmllbGRzLmhlYWRpbmd9IC8+XHJcblxyXG4gICAgPFJpY2hUZXh0IGNsYXNzTmFtZT1cImNvbnRlbnREZXNjcmlwdGlvblwiIGZpZWxkPXtmaWVsZHMuY29udGVudH0gLz5cclxuICA8Lz5cclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvbnRlbnRCbG9jaztcclxuIiwiaW1wb3J0IHsgVGV4dCwgRmllbGQgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgeyBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgSGVyb1Byb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFByb3BzICYge1xyXG4gIGZpZWxkczoge1xyXG4gICAgaGVhZGluZzogRmllbGQ8c3RyaW5nPjtcclxuICAgIHRlYXNlcjogRmllbGQ8c3RyaW5nPjtcclxuICAgIC8vIGltYWdlOiBGaWVsZDxpbWFnZVxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IEhlcm8gPSAocHJvcHM6IEhlcm9Qcm9wcyk6IEpTWC5FbGVtZW50ID0+IChcclxuICA8ZGl2PlxyXG4gICAgPHA+VGhpcyBpcyBvdXIgaGVybyBjb21wb25lbnRcclxuXHJcblxyXG4gICAgICBoYWxsb1xyXG4gICAgPC9wPlxyXG4gICAgXHJcbiAgICA8aDI+SGVhZGluZzogPFRleHQgZmllbGQ9e3Byb3BzLmZpZWxkcy5oZWFkaW5nfSAvPjwvaDI+XHJcbiAgICA8aDM+dGVhc2VyOiA8VGV4dCBmaWVsZD17cHJvcHMuZmllbGRzLnRlYXNlcn0gLz48L2gzPlxyXG5cclxuICA8L2Rpdj5cclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhlcm87XHJcbiIsImltcG9ydCB7IEZpZWxkLCBnZXRGaWVsZFZhbHVlIH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IFN0eWxlZ3VpZGVTcGVjaW1lbiBmcm9tICdjb21wb25lbnRzL3N0eWxlZ3VpZGUvU3R5bGVndWlkZS1TcGVjaW1lbic7XHJcbmltcG9ydCB7IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcywgU3R5bGVndWlkZVNwZWNpbWVuRmllbGRzIH0gZnJvbSAnbGliL2NvbXBvbmVudC1wcm9wcyc7XHJcblxyXG50eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3hQcm9wcyA9IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcyAmXHJcbiAgU3R5bGVndWlkZVNwZWNpbWVuRmllbGRzICYge1xyXG4gICAgZmllbGRzOiB7XHJcbiAgICAgIGNoZWNrYm94OiBGaWVsZDxib29sZWFuPjtcclxuICAgICAgY2hlY2tib3gyOiBGaWVsZDxib29sZWFuPjtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbi8qKlxyXG4gKiBEZW1vbnN0cmF0ZXMgdXNhZ2Ugb2YgYSBDaGVja2JveCAoYm9vbGVhbikgY29udGVudCBmaWVsZCB3aXRoaW4gSlNTLlxyXG4gKi9cclxuY29uc3QgU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCA9IChwcm9wczogU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveFByb3BzKTogSlNYLkVsZW1lbnQgPT4gKFxyXG4gIDxTdHlsZWd1aWRlU3BlY2ltZW4gey4uLnByb3BzfSBlMmVJZD1cInN0eWxlZ3VpZGUtZmllbGR1c2FnZS1jaGVja2JveFwiPlxyXG4gICAgey8qIENoZWNrYm94IGZpZWxkcyBkbyBub3QgaGF2ZSB0aGUgYWJpbGl0eSB0byBiZSBpbmxpbmUgZWRpdGVkLCBzbyB0aGV5IGFyZSBkaXJlY3RseSBhY2Nlc3NlZCB2aWEgdGhlaXIgdmFsdWU6ICovfVxyXG4gICAgPHVsPlxyXG4gICAgICB7LypcclxuICAgICAgICBUaGUgZ2V0RmllbGRWYWx1ZSBoZWxwZXIgYWxsb3dzIHNhZmVseSBleHRyYWN0aW5nIGEgZmllbGQgdmFsdWUgdGhhdCBjb3VsZCBiZSB1bmRlZmluZWQsXHJcbiAgICAgICAgd2l0aG91dCBuZWVkaW5nIHRvIGNoZWNrIHRoYXQgcHJvcHMuZmllbGRzIG9yIHByb3BzLmZpZWxkcy5jaGVja2JveCBhcmUgdHJhdmVyc2FibGUsXHJcbiAgICAgICAgYW5kIGFsbG93aW5nIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGFuIG9wdGlvbmFsIGRlZmF1bHQgdmFsdWUgKGRlZmF1bHQgaXMgdW5kZWZpbmVkIGlmIHVuc3BlY2lmaWVkKS5cclxuICAgICAgICovfVxyXG4gICAgICB7cHJvcHMuZmllbGRzICYmIHByb3BzLmZpZWxkcy5jaGVja2JveCAmJiBwcm9wcy5maWVsZHMuY2hlY2tib3gudmFsdWUgJiYgKFxyXG4gICAgICAgIDxsaT5cclxuICAgICAgICAgIDxjb2RlPmNoZWNrYm94PC9jb2RlPiBpcyB0cnVlXHJcbiAgICAgICAgPC9saT5cclxuICAgICAgKX1cclxuICAgICAgeyFwcm9wcy5maWVsZHMgfHxcclxuICAgICAgICAhcHJvcHMuZmllbGRzLmNoZWNrYm94IHx8XHJcbiAgICAgICAgKCFwcm9wcy5maWVsZHMuY2hlY2tib3gudmFsdWUgJiYgKFxyXG4gICAgICAgICAgPGxpPlxyXG4gICAgICAgICAgICA8Y29kZT5jaGVja2JveDwvY29kZT4gaXMgZmFsc2VcclxuICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgKSl9XHJcbiAgICAgIHtnZXRGaWVsZFZhbHVlKHByb3BzLmZpZWxkcywgJ2NoZWNrYm94MicsIGZhbHNlKSAmJiAoXHJcbiAgICAgICAgPGxpPlxyXG4gICAgICAgICAgPGNvZGU+Y2hlY2tib3gyPC9jb2RlPiBpcyB0cnVlXHJcbiAgICAgICAgPC9saT5cclxuICAgICAgKX1cclxuICAgICAgeyFnZXRGaWVsZFZhbHVlKHByb3BzLmZpZWxkcywgJ2NoZWNrYm94MicsIGZhbHNlKSAmJiAoXHJcbiAgICAgICAgPGxpPlxyXG4gICAgICAgICAgPGNvZGU+Y2hlY2tib3gyPC9jb2RlPiBpcyBmYWxzZVxyXG4gICAgICAgIDwvbGk+XHJcbiAgICAgICl9XHJcbiAgICA8L3VsPlxyXG4gIDwvU3R5bGVndWlkZVNwZWNpbWVuPlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveDtcclxuIiwiaW1wb3J0IHsgRmllbGQsIFRleHQsIEl0ZW0gfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJ2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLVNwZWNpbWVuJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLCBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdFByb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFByb3BzICZcclxuICBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgJiB7XHJcbiAgICBmaWVsZHM6IHtcclxuICAgICAgc2hhcmVkQ29udGVudExpc3Q6IEl0ZW1bXTtcclxuICAgICAgbG9jYWxDb250ZW50TGlzdDogSXRlbVtdO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuLyoqXHJcbiAqIERlbW9uc3RyYXRlcyB1c2FnZSBvZiBhIENvbnRlbnQgTGlzdCBmaWVsZCB0eXBlIHdpdGhpbiBKU1MuXHJcbiAqIENvbnRlbnQgTGlzdHMgYXJlIHJlZmVyZW5jZXMgdG8gMC4ubiBvdGhlciBjb250ZW50IGl0ZW1zLlxyXG4gKiBJbiBTaXRlY29yZSB0ZXJtcywgdGhpcyBtYXBzIGJ5IGRlZmF1bHQgdG8gYSBUcmVlbGlzdCBmaWVsZC5cclxuICovXHJcbmNvbnN0IFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QgPSAoXHJcbiAgcHJvcHM6IFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3RQcm9wc1xyXG4pOiBKU1guRWxlbWVudCA9PiB7XHJcbiAgY29uc3QgeyBzaGFyZWRDb250ZW50TGlzdCwgbG9jYWxDb250ZW50TGlzdCB9ID0gcHJvcHMuZmllbGRzO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFN0eWxlZ3VpZGVTcGVjaW1lbiB7Li4ucHJvcHN9IGUyZUlkPVwic3R5bGVndWlkZS1maWVsZHVzYWdlLWNvbnRlbnQtbGlzdFwiPlxyXG4gICAgICA8aDU+U2hhcmVkIENvbnRlbnQgTGlzdDwvaDU+XHJcbiAgICAgIHsvKlxyXG4gICAgICBDb250ZW50IGxpc3QgZmllbGRzIGFyZSByZXR1cm5lZCB3aXRoIHRoZWlyIHZhbHVlIGFzIGFuIGFycmF5IG9mIHRoZSByZWZlcmVuY2VkIGl0ZW1zLlxyXG4gICAgICBTbyB3ZSBjYW4gdXNlIHRoZSAubWFwKCkgYXJyYXkgZnVuY3Rpb24gdG8gdHJhdmVyc2UgdGhlbS4gRW5zdXJlIGEgYGtleWAgYXR0cmlidXRlIGlzIHNldFxyXG4gICAgICBvbiBlYWNoIGVsZW1lbnQgdG8gbWFrZSBSZWFjdCdzIERPTSB1cGRhdGluZyBoYXBweTpcclxuICAgICAqL31cclxuICAgICAge3NoYXJlZENvbnRlbnRMaXN0ICYmXHJcbiAgICAgICAgc2hhcmVkQ29udGVudExpc3QubWFwKChsaXN0SXRlbSwgaW5kZXgpID0+IChcclxuICAgICAgICAgIDxkaXYga2V5PXtgc2hhcmVkTGlzdEl0ZW0tJHtpbmRleH1gfT5cclxuICAgICAgICAgICAgey8qIFRoZSByZWZlcmVuY2VkIGl0ZW0ncyBmaWVsZHMgY2FuIGJlIHJlbmRlcmVkIGFuZCBlZGl0ZWQgdXNpbmcgbm9ybWFsIGhlbHBlciBjb21wb25lbnRzOiAqL31cclxuICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgRmllbGQ6IDxUZXh0IGZpZWxkPXtsaXN0SXRlbS5maWVsZHMudGV4dEZpZWxkIGFzIEZpZWxkPHN0cmluZz59IC8+XHJcbiAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICkpfVxyXG5cclxuICAgICAgPGg1PkxvY2FsIENvbnRlbnQgTGlzdDwvaDU+XHJcbiAgICAgIHtsb2NhbENvbnRlbnRMaXN0ICYmXHJcbiAgICAgICAgbG9jYWxDb250ZW50TGlzdC5tYXAoKGxpc3RJdGVtLCBpbmRleCkgPT4gKFxyXG4gICAgICAgICAgPGRpdiBrZXk9e2Bsb2NhbExpc3RJdGVtLSR7aW5kZXh9YH0+XHJcbiAgICAgICAgICAgIHsvKiBUaGUgcmVmZXJlbmNlZCBpdGVtJ3MgZmllbGRzIGNhbiBiZSByZW5kZXJlZCBhbmQgZWRpdGVkIHVzaW5nIG5vcm1hbCBoZWxwZXIgY29tcG9uZW50czogKi99XHJcbiAgICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICAgIEZpZWxkOiA8VGV4dCBmaWVsZD17bGlzdEl0ZW0uZmllbGRzLnRleHRGaWVsZCBhcyBGaWVsZDxzdHJpbmc+fSAvPlxyXG4gICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApKX1cclxuICAgIDwvU3R5bGVndWlkZVNwZWNpbWVuPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0O1xyXG4iLCJpbXBvcnQgeyBGaWVsZCwgVGV4dCB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcyc7XHJcbmltcG9ydCBTdHlsZWd1aWRlU3BlY2ltZW4gZnJvbSAnY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtU3BlY2ltZW4nO1xyXG5pbXBvcnQgeyBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMsIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyB9IGZyb20gJ2xpYi9jb21wb25lbnQtcHJvcHMnO1xyXG5cclxudHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbVByb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFByb3BzICZcclxuICBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgJiB7XHJcbiAgICBmaWVsZHM6IHtcclxuICAgICAgY3VzdG9tSW50RmllbGQ6IEZpZWxkPHN0cmluZz47XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4vKipcclxuICogRGVtb25zdHJhdGVzIHVzYWdlIG9mIGEgY3VzdG9tIGNvbnRlbnQgZmllbGQgdHlwZSB3aXRoaW4gSlNTLlxyXG4gKiBTZWUgL3NpdGVjb3JlL2RlZmluaXRpb25zL2NvbXBvbmVudHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUN1c3RvbS5zaXRlY29yZS5qc1xyXG4gKiBmb3IgdGhlIGRlZmluaXRpb24gb2YgdGhlIHN0cnVjdHVyZSBvZiB0aGUgY3VzdG9tIGZpZWxkLiBUaGlzIGNvZGUgaXMganVzdCBmb3IgZGlzcGxheS5cclxuICovXHJcbmNvbnN0IFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tID0gKHByb3BzOiBTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbVByb3BzKTogSlNYLkVsZW1lbnQgPT4gKFxyXG4gIDxTdHlsZWd1aWRlU3BlY2ltZW4gey4uLnByb3BzfSBlMmVJZD1cInN0eWxlZ3VpZGUtZmllbGR1c2FnZS1jdXN0b21cIj5cclxuICAgIHsvKiBCZWNhdXNlIHRoZSBpbnRlZ2VyIGZpZWxkIGlzIGVzc2VudGlhbGx5IHRleHQsIHdlIGNhbiByZW5kZXIgaXQgd2l0aCB0aGUgVGV4dCBoZWxwZXIgKi99XHJcbiAgICA8VGV4dCBmaWVsZD17cHJvcHMuZmllbGRzLmN1c3RvbUludEZpZWxkfSAvPlxyXG4gIDwvU3R5bGVndWlkZVNwZWNpbWVuPlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b207XHJcbiIsImltcG9ydCB7IERhdGVGaWVsZCwgRmllbGQgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJ2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLVNwZWNpbWVuJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLCBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlUHJvcHMgPSBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMgJlxyXG4gIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyAmIHtcclxuICAgIGZpZWxkczoge1xyXG4gICAgICBkYXRlOiBGaWVsZDxzdHJpbmc+O1xyXG4gICAgICBkYXRlVGltZTogRmllbGQ8c3RyaW5nPjtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbi8qKlxyXG4gKiBEZW1vbnN0cmF0ZXMgdXNhZ2Ugb2YgZGF0ZSBhbmQgdGltZSBjb250ZW50IGZpZWxkIHR5cGVzIHdpdGhpbiBKU1MuXHJcbiAqL1xyXG5jb25zdCBTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUgPSAocHJvcHM6IFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZVByb3BzKTogSlNYLkVsZW1lbnQgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8U3R5bGVndWlkZVNwZWNpbWVuIHsuLi5wcm9wc30gZTJlSWQ9XCJzdHlsZWd1aWRlLWZpZWxkdXNhZ2UtZGF0ZVwiPlxyXG4gICAgICA8dWw+XHJcbiAgICAgICAgPGxpPlxyXG4gICAgICAgICAgRGF0ZSBoZWxwZXI6IDxEYXRlRmllbGQgZmllbGQ9e3Byb3BzLmZpZWxkcy5kYXRlfSAvPlxyXG4gICAgICAgIDwvbGk+XHJcbiAgICAgICAgPGxpPlxyXG4gICAgICAgICAgRGF0ZSBoZWxwZXIgKGRhdGV0aW1lKTogPERhdGVGaWVsZCBmaWVsZD17cHJvcHMuZmllbGRzLmRhdGVUaW1lfSAvPlxyXG4gICAgICAgIDwvbGk+XHJcbiAgICAgICAgPGxpPlxyXG4gICAgICAgICAgVVRDIERhdGUgc3RyaW5nOiZuYnNwO1xyXG4gICAgICAgICAgey8qXHJcbiAgICAgICAgICAgIERhdGUgaGVscGVyIHN1cHBvcnRzIGEgcmVuZGVyIHByb3BzIEFQSSB0byBnaXZlIHlvdSBkaXJlY3QgYWNjZXNzIHRvIHRoZSBKUyBEYXRlIG9iamVjdCBmb3IgZm9ybWF0dGluZy5cclxuICAgICAgICAgICAgSU1QT1JUQU5UOiB0aGUgcmVuZGVyIHByb3AgaXMgaWdub3JlZCB3aGVuIGluIEV4cGVyaWVuY2UgRWRpdG9yIG1vZGUgdG8gc3VwcG9ydCBpbmxpbmUgZWRpdGluZy5cclxuICAgICAgICAgICovfVxyXG4gICAgICAgICAgPERhdGVGaWVsZCBmaWVsZD17cHJvcHMuZmllbGRzLmRhdGV9IHJlbmRlcj17KGRhdGUpID0+IGRhdGUgJiYgZGF0ZS50b1VUQ1N0cmluZygpfSAvPlxyXG4gICAgICAgIDwvbGk+XHJcbiAgICAgICAgPGxpPlxyXG4gICAgICAgICAgTG9jYWxpemVkIERhdGUgc3RyaW5nIChsb2NhbCB0aW1lem9uZSk6Jm5ic3A7XHJcbiAgICAgICAgICA8RGF0ZUZpZWxkXHJcbiAgICAgICAgICAgIGZpZWxkPXtwcm9wcy5maWVsZHMuZGF0ZX1cclxuICAgICAgICAgICAgcmVuZGVyPXsoZGF0ZSkgPT4gZGF0ZSAmJiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpfVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICA8L2xpPlxyXG4gICAgICAgIDxsaT5cclxuICAgICAgICAgIExvY2FsaXplZCBEYXRlVGltZSBzdHJpbmcgKGxvY2FsIHRpbWV6b25lKTombmJzcDtcclxuICAgICAgICAgIHsvKiBSZWFjdCBjb21wb25lbnRzIGNhbiBhbHNvIGJlIHJldHVybmVkIGZyb20gdGhlIHJlbmRlciBwcm9wcyBmb3Igd3JhcHBpbmcgKi99XHJcbiAgICAgICAgICA8RGF0ZUZpZWxkXHJcbiAgICAgICAgICAgIGZpZWxkPXtwcm9wcy5maWVsZHMuZGF0ZVRpbWV9XHJcbiAgICAgICAgICAgIHJlbmRlcj17KGRhdGUpID0+IDxlbT57ZGF0ZSAmJiBkYXRlLnRvTG9jYWxlU3RyaW5nKCl9PC9lbT59XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDwvbGk+XHJcbiAgICAgIDwvdWw+XHJcbiAgICA8L1N0eWxlZ3VpZGVTcGVjaW1lbj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlO1xyXG4iLCJpbXBvcnQgeyBGaWxlLCBGaWxlRmllbGQgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJ2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLVNwZWNpbWVuJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLCBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlUHJvcHMgPSBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMgJlxyXG4gIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyAmIHtcclxuICAgIGZpZWxkczoge1xyXG4gICAgICBmaWxlOiBGaWxlRmllbGQ7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4vKipcclxuICogRGVtb25zdHJhdGVzIHVzYWdlIG9mIGEgRmlsZSBjb250ZW50IGZpZWxkIHdpdGhpbiBKU1MuXHJcbiAqIEZpbGUgdHlwZXMgYXJlIHN0b3JlZCB3aXRoaW4gU2l0ZWNvcmUncyBNZWRpYSBMaWJyYXJ5IGRhdGEsIGFuZCBjYW4gYmUgZWRpdGVkLlxyXG4gKi9cclxuY29uc3QgU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlID0gKHByb3BzOiBTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGVQcm9wcyk6IEpTWC5FbGVtZW50ID0+IChcclxuICA8U3R5bGVndWlkZVNwZWNpbWVuIHsuLi5wcm9wc30gZTJlSWQ9XCJzdHlsZWd1aWRlLWZpZWxkdXNhZ2UtZmlsZVwiPlxyXG4gICAgey8qIFJlbmRlcnMgYSBmaWxlIGxpbmsgKi99XHJcbiAgICA8RmlsZSBmaWVsZD17cHJvcHMuZmllbGRzLmZpbGV9IC8+XHJcbiAgICA8YnIgLz5cclxuXHJcbiAgICB7LyogUmVuZGVycyBhIGZpbGUgbGluayB3aXRoIGEgY3VzdG9tIGJvZHkgYW5kIG9wZW5pbmcgaW4gYSBuZXcgdGFiICovfVxyXG4gICAgPEZpbGUgZmllbGQ9e3Byb3BzLmZpZWxkcy5maWxlfSB0YXJnZXQ9XCJfYmxhbmtcIj5cclxuICAgICAgQ3VzdG9tIGxpbmsgYm9keVxyXG4gICAgPC9GaWxlPlxyXG4gIDwvU3R5bGVndWlkZVNwZWNpbWVuPlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlO1xyXG4iLCJpbXBvcnQgeyBJbWFnZSwgSW1hZ2VGaWVsZCB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcyc7XHJcbmltcG9ydCBTdHlsZWd1aWRlU3BlY2ltZW4gZnJvbSAnY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtU3BlY2ltZW4nO1xyXG5pbXBvcnQgeyBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMsIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyB9IGZyb20gJ2xpYi9jb21wb25lbnQtcHJvcHMnO1xyXG5cclxudHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlUHJvcHMgPSBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMgJlxyXG4gIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyAmIHtcclxuICAgIGZpZWxkczoge1xyXG4gICAgICBzYW1wbGUxOiBJbWFnZUZpZWxkO1xyXG4gICAgICBzYW1wbGUyOiBJbWFnZUZpZWxkO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuLyoqXHJcbiAqIERlbW9uc3RyYXRlcyB1c2FnZSBvZiBhbiBJbWFnZSBjb250ZW50IGZpZWxkIHdpdGhpbiBKU1MuXHJcbiAqIEltYWdlIGZpZWxkIGRhdGEgaXMgdXBsb2FkZWQgaW50byB0aGUgU2l0ZWNvcmUgTWVkaWEgTGlicmFyeS5cclxuICovXHJcbmNvbnN0IFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UgPSAocHJvcHM6IFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2VQcm9wcyk6IEpTWC5FbGVtZW50ID0+IChcclxuICA8U3R5bGVndWlkZVNwZWNpbWVuIHsuLi5wcm9wc30gZTJlSWQ9XCJzdHlsZWd1aWRlLWZpZWxkdXNhZ2UtaW1hZ2VcIj5cclxuICAgIDxwPlBsYWluIGltYWdlPC9wPlxyXG4gICAgPEltYWdlIG1lZGlhPXtwcm9wcy5maWVsZHMuc2FtcGxlMX0gLz5cclxuXHJcbiAgICB7LypcclxuICAgICAgQWR2YW5jZWQgaW1hZ2UgdXNhZ2UgZXhhbXBsZVxyXG4gICAgICBlZGl0YWJsZTogY29udHJvbHMgd2hldGhlciBpbWFnZSBjYW4gYmUgZWRpdGVkIGluIFNpdGVjb3JlIEV4cGVyaWVuY2UgRWRpdG9yXHJcbiAgICAgIGltYWdlUGFyYW1zOiBwYXJhbWV0ZXJzIHRoYXQgYXJlIHBhc3NlZCB0byBTaXRlY29yZSB0byBwZXJmb3JtIHNlcnZlci1zaWRlIHJlc2l6aW5nIG9mIHRoZSBpbWFnZS5cclxuICAgICAgICBTYW1wbGUgcmVzY2FsZXMgaW1hZ2UgdG8gbWF4IDEwMHg1MCBkaW1lbnNpb25zIG9uIHRoZSBzZXJ2ZXIsIHJlc3BlY3RpbmcgYXNwZWN0IHJhdGlvXHJcbiAgICAgICAgSU1QT1JUQU5UOiBpbWFnZVBhcmFtcyBtdXN0IGJlIHdoaXRlbGlzdGVkIGZvciByZXNpemluZyB0byBvY2N1ci4gU2VlIC9zaXRlY29yZS9jb25maWcvKi5jb25maWcgKHNlYXJjaCBmb3IgJ2FsbG93ZWRNZWRpYVBhcmFtcycpXHJcbiAgICAgIGFueSBvdGhlciBhdHRyaWJ1dGVzOiBwYXNzIHRocm91Z2ggdG8gaW1nIHRhZ1xyXG4gICAgKi99XHJcbiAgICA8cD5BZHZhbmNlZCBpbWFnZSAobm90IGVkaXRhYmxlKTwvcD5cclxuICAgIDxJbWFnZVxyXG4gICAgICBmaWVsZD17cHJvcHMuZmllbGRzLnNhbXBsZTJ9XHJcbiAgICAgIGVkaXRhYmxlPXtmYWxzZX1cclxuICAgICAgaW1hZ2VQYXJhbXM9e3sgbXc6IDEwMCwgbWg6IDUwIH19XHJcbiAgICAgIGhlaWdodD1cIjUwXCJcclxuICAgICAgd2lkdGg9XCI5NFwiXHJcbiAgICAgIGRhdGEtc2FtcGxlPVwib3RoZXItYXR0cmlidXRlcy1wYXNzLXRocm91Z2hcIlxyXG4gICAgLz5cclxuXHJcbiAgICB7LypcclxuICAgICAgU3Jjc2V0IGFkYXB0aXZlIGltYWdlIHVzYWdlIGV4YW1wbGVcclxuICAgICAgQWRhcHRpdmUgc3Jjc2V0cyBhcmUgc3VwcG9ydGVkIHVzaW5nIFNpdGVjb3JlIHNlcnZlci1zaWRlIHJlc2l6aW5nLlxyXG4gICAgICBUaGUgYHNyY1NldGAgY2FuIHVzZSBTaXRlY29yZSBpbWFnZSByZXNpemluZyBwYXJhbWV0ZXJzIChpLmUuIHcsIGgsIG13LCBtaCkuXHJcbiAgICAgIFNhbXBsZSBjcmVhdGUgYSBzcmNzZXQgdXNpbmcgdHdvIHNpemVzIChzZXJ2ZXIgcmVzaXppbmcpLCAzMDAgYW5kIDEwMHB4IG1heCB3aWR0aHMsIHJlc3BlY3RpbmcgYXNwZWN0IHJhdGlvLlxyXG4gICAgICBJTVBPUlRBTlQ6IHNyY1NldCBwYXJhbXMgbXVzdCBiZSB3aGl0ZWxpc3RlZCBmb3IgYWRhcHRpdmUgcmVzaXppbmcgdG8gb2NjdXIuIFNlZSAvc2l0ZWNvcmUvY29uZmlnLyouY29uZmlnIChzZWFyY2ggZm9yICdhbGxvd2VkTWVkaWFQYXJhbXMnKVxyXG4gICAgKi99XHJcbiAgICA8cD5TcmNzZXQgcmVzcG9uc2l2ZSBpbWFnZTwvcD5cclxuICAgIDxJbWFnZVxyXG4gICAgICBmaWVsZD17cHJvcHMuZmllbGRzLnNhbXBsZTJ9XHJcbiAgICAgIHNyY1NldD17W3sgbXc6IDMwMCB9LCB7IG13OiAxMDAgfV19XHJcbiAgICAgIHNpemVzPVwiKG1pbi13aWR0aDogOTYwcHgpIDMwMHB4LCAxMDBweFwiXHJcbiAgICAgIGNsYXNzTmFtZT1cImltZy1mbHVpZFwiXHJcbiAgICAvPlxyXG4gIDwvU3R5bGVndWlkZVNwZWNpbWVuPlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZTtcclxuIiwiaW1wb3J0IHsgRmllbGQsIFRleHQsIEl0ZW0gfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJ2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLVNwZWNpbWVuJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLCBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGlua1Byb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFByb3BzICZcclxuICBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgJiB7XHJcbiAgICBmaWVsZHM6IHtcclxuICAgICAgc2hhcmVkSXRlbUxpbms6IEl0ZW07XHJcbiAgICAgIGxvY2FsSXRlbUxpbms6IEl0ZW07XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4vKipcclxuICogRGVtb25zdHJhdGVzIHVzYWdlIG9mIGEgQ29udGVudCBMaW5rIGNvbnRlbnQgZmllbGQgd2l0aGluIEpTUy5cclxuICogQ29udGVudCBsaW5rcyBhcmUgYSByZWZlcmVuY2UgdG8gYSBzaW5nbGUgb3RoZXIgcGllY2Ugb2YgY29udGVudC5cclxuICovXHJcbmNvbnN0IFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsgPSAocHJvcHM6IFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmtQcm9wcyk6IEpTWC5FbGVtZW50ID0+IHtcclxuICBjb25zdCB7IHNoYXJlZEl0ZW1MaW5rLCBsb2NhbEl0ZW1MaW5rIH0gPSBwcm9wcy5maWVsZHM7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U3R5bGVndWlkZVNwZWNpbWVuIHsuLi5wcm9wc30gZTJlSWQ9XCJzdHlsZWd1aWRlLWZpZWxkdXNhZ2UtaXRlbWxpbmtcIj5cclxuICAgICAgPGg1PlNoYXJlZCBJdGVtIExpbms8L2g1PlxyXG4gICAgICB7LypcclxuICAgICAgICBJdGVtIGxpbmsgZmllbGRzIGFyZSByZXR1cm5lZCB3aXRoIHRoZWlyIHZhbHVlIGFzIHRoZSByZWZlcmVuY2VkIGl0ZW0gdmFsdWUuXHJcbiAgICAgICovfVxyXG4gICAgICB7c2hhcmVkSXRlbUxpbmsgJiYgKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICB7LyogVGhlIHJlZmVyZW5jZWQgaXRlbSdzIGZpZWxkcyBjYW4gYmUgcmVuZGVyZWQgYW5kIGVkaXRlZCB1c2luZyBub3JtYWwgaGVscGVyIGNvbXBvbmVudHM6ICovfVxyXG4gICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgIEZpZWxkOiA8VGV4dCBmaWVsZD17c2hhcmVkSXRlbUxpbmsuZmllbGRzLnRleHRGaWVsZCBhcyBGaWVsZDxzdHJpbmc+fSAvPlxyXG4gICAgICAgICAgPC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICApfVxyXG5cclxuICAgICAgPGg1PkxvY2FsIEl0ZW0gTGluazwvaDU+XHJcbiAgICAgIHtsb2NhbEl0ZW1MaW5rICYmIChcclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgIEZpZWxkOiA8VGV4dCBmaWVsZD17bG9jYWxJdGVtTGluay5maWVsZHMudGV4dEZpZWxkIGFzIEZpZWxkPHN0cmluZz59IC8+XHJcbiAgICAgICAgICA8L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICl9XHJcbiAgICA8L1N0eWxlZ3VpZGVTcGVjaW1lbj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaztcclxuIiwiaW1wb3J0IHsgTGluaywgTGlua0ZpZWxkIH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IFN0eWxlZ3VpZGVTcGVjaW1lbiBmcm9tICdjb21wb25lbnRzL3N0eWxlZ3VpZGUvU3R5bGVndWlkZS1TcGVjaW1lbic7XHJcbmltcG9ydCB7IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcywgU3R5bGVndWlkZVNwZWNpbWVuRmllbGRzIH0gZnJvbSAnbGliL2NvbXBvbmVudC1wcm9wcyc7XHJcblxyXG50eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGlua1Byb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFByb3BzICZcclxuICBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgJiB7XHJcbiAgICBmaWVsZHM6IHtcclxuICAgICAgZXh0ZXJuYWxMaW5rOiBMaW5rRmllbGQ7XHJcbiAgICAgIGludGVybmFsTGluazogTGlua0ZpZWxkO1xyXG4gICAgICBlbWFpbExpbms6IExpbmtGaWVsZDtcclxuICAgICAgcGFyYW1zTGluazogTGlua0ZpZWxkO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuLyoqXHJcbiAqIERlbW9uc3RyYXRlcyB1c2FnZSBvZiBhIEdlbmVyYWwgTGluayAoaHlwZXJsaW5rKSBjb250ZW50IGZpZWxkIHdpdGhpbiBKU1MuXHJcbiAqL1xyXG5jb25zdCBTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsgPSAocHJvcHM6IFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGlua1Byb3BzKTogSlNYLkVsZW1lbnQgPT4gKFxyXG4gIDxTdHlsZWd1aWRlU3BlY2ltZW4gey4uLnByb3BzfSBlMmVJZD1cInN0eWxlZ3VpZGUtZmllbGR1c2FnZS1saW5rXCI+XHJcbiAgICBFeHRlcm5hbCBsaW5rOiZuYnNwO1xyXG4gICAgPExpbmsgZmllbGQ9e3Byb3BzLmZpZWxkcy5leHRlcm5hbExpbmt9IC8+XHJcbiAgICA8YnIgLz5cclxuICAgIEludGVybmFsIGxpbms6Jm5ic3A7XHJcbiAgICA8TGluayBmaWVsZD17cHJvcHMuZmllbGRzLmludGVybmFsTGlua30+XHJcbiAgICAgIDxlbT5IVE1MPC9lbT4gb3Igb3RoZXIgY29tcG9uZW50cyBjYW4gYmUgdXNlZCB3aXRoaW4gbGluayByZW5kZXJlcnMsIGZvciBleGFtcGxlIGxpbmtzIHRvXHJcbiAgICAgIGltYWdlcy5cclxuICAgIDwvTGluaz5cclxuICAgIDxiciAvPlxyXG4gICAgRW1haWwgbGluazombmJzcDtcclxuICAgIDxMaW5rIGZpZWxkPXtwcm9wcy5maWVsZHMuZW1haWxMaW5rfSAvPlxyXG4gICAgPGJyIC8+XHJcbiAgICBBbGwgcG9zc2libGUgY29udGVudCBwYXJhbXMgbGluazombmJzcDtcclxuICAgIDxMaW5rIGZpZWxkPXtwcm9wcy5maWVsZHMucGFyYW1zTGlua30gLz5cclxuICAgIDxiciAvPlxyXG4gICAgVGhlIGxpbmsgY29tcG9uZW50IGFjY2VwdHMgcGFyYW1zIG9mIGl0cyBvd246Jm5ic3A7XHJcbiAgICA8TGlua1xyXG4gICAgICBmaWVsZD17cHJvcHMuZmllbGRzLmV4dGVybmFsTGlua31cclxuICAgICAgc2hvd0xpbmtUZXh0V2l0aENoaWxkcmVuUHJlc2VudD17dHJ1ZX1cclxuICAgICAgY2xhc3NOYW1lPVwiZm9udC13ZWlnaHQtYm9sZFwiXHJcbiAgICAgIGRhdGEtb3RoZXJhdHRyaWJ1dGVzPVwicGFzcy10aHJvdWdoLXRvLWFuY2hvci10YWdcIlxyXG4gICAgLz5cclxuICA8L1N0eWxlZ3VpZGVTcGVjaW1lbj5cclxuKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaztcclxuIiwiaW1wb3J0IHsgVGV4dCwgRmllbGQsIGdldEZpZWxkVmFsdWUgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJ2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLVNwZWNpbWVuJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLCBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0UHJvcHMgPSBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMgJlxyXG4gIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyAmIHtcclxuICAgIGZpZWxkczoge1xyXG4gICAgICBzYW1wbGU6IEZpZWxkPHN0cmluZz47XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4vKipcclxuICogRGVtb25zdHJhdGVzIHVzYWdlIG9mIGEgTnVtYmVyIChkZWNpbWFsKSBjb250ZW50IGZpZWxkIHdpdGhpbiBKU1MuXHJcbiAqL1xyXG5jb25zdCBTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQgPSAocHJvcHM6IFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dFByb3BzKTogSlNYLkVsZW1lbnQgPT4ge1xyXG4gIGNvbnN0IGZpZWxkVmFsdWUgPSBnZXRGaWVsZFZhbHVlKHByb3BzLmZpZWxkcywgJ3NhbXBsZScpO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFN0eWxlZ3VpZGVTcGVjaW1lbiB7Li4ucHJvcHN9IGUyZUlkPVwic3R5bGVndWlkZS1maWVsZHVzYWdlLW51bWJlclwiPlxyXG4gICAgICB7LyogQmFzaWMgZW1pc3Npb24gb2YgYSBudW1iZXIgZmllbGQgZm9yIGVkaXRpbmcgY2FuIGJlIGRvbmUgd2l0aCB0aGUgPFRleHQ+IGNvbXBvbmVudC4gKi99XHJcbiAgICAgIDxUZXh0IGZpZWxkPXtwcm9wcy5maWVsZHMuc2FtcGxlfSAvPlxyXG5cclxuICAgICAgey8qIERpcmVjdCBhY2Nlc3MgdG8gdGhlIHZhbHVlLCB3aGljaCBpcyBhIEpTIG51bWJlciwgaXMgYWxzbyBzdXBwb3J0ZWQuICovfVxyXG4gICAgICA8cD5cclxuICAgICAgICBKUyB2YWx1ZSB0eXBlOiB7dHlwZW9mIGZpZWxkVmFsdWV9XHJcbiAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgSlMgdmFsdWU6IHtmaWVsZFZhbHVlfVxyXG4gICAgICA8L3A+XHJcbiAgICA8L1N0eWxlZ3VpZGVTcGVjaW1lbj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0O1xyXG4iLCJpbXBvcnQgeyBSaWNoVGV4dCwgRmllbGQgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJ2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLVNwZWNpbWVuJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLCBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dFByb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFByb3BzICZcclxuICBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgJiB7XHJcbiAgICBmaWVsZHM6IHtcclxuICAgICAgc2FtcGxlOiBGaWVsZDxzdHJpbmc+O1xyXG4gICAgICBzYW1wbGUyOiBGaWVsZDxzdHJpbmc+O1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuLyoqXHJcbiAqIERlbW9uc3RyYXRlcyB1c2FnZSBvZiBhIFJpY2ggVGV4dCAoSFRNTCkgY29udGVudCBmaWVsZCB3aXRoaW4gSlNTLlxyXG4gKi9cclxuY29uc3QgU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCA9IChwcm9wczogU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dFByb3BzKTogSlNYLkVsZW1lbnQgPT4gKFxyXG4gIDxTdHlsZWd1aWRlU3BlY2ltZW4gey4uLnByb3BzfSBlMmVJZD1cInN0eWxlZ3VpZGUtZmllbGR1c2FnZS1yaWNodGV4dFwiPlxyXG4gICAgey8qIEJhc2ljIHVzZSBvZiBhIHJpY2ggdGV4dCBmaWVsZC4gV3JhcHMgaW4gYSA8ZGl2Pi4gKi99XHJcbiAgICA8UmljaFRleHQgZmllbGQ9e3Byb3BzLmZpZWxkcy5zYW1wbGV9IC8+XHJcblxyXG4gICAgey8qIEFkdmFuY2VkIHVzYWdlIG9mIHJpY2ggdGV4dCBmaWVsZC4gU3BlY2lmaWVzIGEgY3VzdG9tIHdyYXBwZXIgdGFnLCB0dXJucyBvZmYgU2l0ZWNvcmUgZWRpdGluZywgYW5kIGhhcyBhIENTUyBjbGFzcyBvbiB0aGUgd3JhcHBlciAqL31cclxuICAgIDxSaWNoVGV4dFxyXG4gICAgICBmaWVsZD17cHJvcHMuZmllbGRzLnNhbXBsZTJ9XHJcbiAgICAgIHRhZz1cInNlY3Rpb25cIlxyXG4gICAgICBlZGl0YWJsZT17ZmFsc2V9XHJcbiAgICAgIGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCJcclxuICAgICAgZGF0YS1zYW1wbGU9XCJvdGhlci1hdHRyaWJ1dGVzLXBhc3MtdGhyb3VnaFwiXHJcbiAgICAvPlxyXG4gIDwvU3R5bGVndWlkZVNwZWNpbWVuPlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dDtcclxuIiwiaW1wb3J0IHsgVGV4dCwgRmllbGQsIGdldEZpZWxkVmFsdWUgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJ2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLVNwZWNpbWVuJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLCBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0UHJvcHMgPSBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMgJlxyXG4gIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyAmIHtcclxuICAgIGZpZWxkczoge1xyXG4gICAgICBzYW1wbGU6IEZpZWxkPHN0cmluZz47XHJcbiAgICAgIHNhbXBsZTI6IEZpZWxkPHN0cmluZz47XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4vKipcclxuICogRGVtb25zdHJhdGVzIHVzYWdlIG9mIGEgVGV4dCBjb250ZW50IGZpZWxkIHdpdGhpbiBKU1MuXHJcbiAqIFRleHQgZmllbGRzIGFyZSBIVE1MIGVuY29kZWQgYnkgZGVmYXVsdC5cclxuICovXHJcbmNvbnN0IFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCA9IChwcm9wczogU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0UHJvcHMpOiBKU1guRWxlbWVudCA9PiAoXHJcbiAgPFN0eWxlZ3VpZGVTcGVjaW1lbiB7Li4ucHJvcHN9IGUyZUlkPVwic3R5bGVndWlkZS1maWVsZHVzYWdlLXRleHRcIj5cclxuICAgIHsvKiBCYXNpYyB1c2Ugb2YgYSB0ZXh0IGZpZWxkLiBObyB3cmFwcGVyLiAqL31cclxuICAgIDxUZXh0IGZpZWxkPXtwcm9wcy5maWVsZHMuc2FtcGxlfSAvPlxyXG5cclxuICAgIHsvKiBBZHZhbmNlZCB1c2FnZSBvZiB0ZXh0IGZpZWxkLiBTcGVjaWZpZXMgYSB3cmFwcGVyIHRhZywgdHVybnMgb2ZmIFNpdGVjb3JlIGVkaXRpbmcsIHN1cHBvcnRzIHJhdyBIVE1MLCBhbmQgaGFzIGEgQ1NTIGNsYXNzIG9uIHRoZSB3cmFwcGVyICovfVxyXG4gICAgPFRleHRcclxuICAgICAgZmllbGQ9e3Byb3BzLmZpZWxkcy5zYW1wbGUyfVxyXG4gICAgICB0YWc9XCJzZWN0aW9uXCJcclxuICAgICAgZWRpdGFibGU9e2ZhbHNlfVxyXG4gICAgICBlbmNvZGU9e2ZhbHNlfVxyXG4gICAgICBjbGFzc05hbWU9XCJmb250LXdlaWdodC1ib2xkXCJcclxuICAgICAgZGF0YS1zYW1wbGU9XCJvdGhlci1hdHRyaWJ1dGVzLXBhc3MtdGhyb3VnaFwiXHJcbiAgICAvPlxyXG5cclxuICAgIHsvKlxyXG4gICAgICBVc2UgdGhpcyBBUEkgd2hlbiB5b3UgbmVlZCBkaXJlY3QgcHJvZ3JhbW1hdGljIGFjY2VzcyB0byBhIGZpZWxkIGFzIGEgdmFyaWFibGUuXHJcbiAgICAgIE5vdGU6IGVkaXRpbmcgc3VjaCBhIHZhbHVlIGluIEV4cGVyaWVuY2UgRWRpdG9yIGlzIG5vdCBwb3NzaWJsZSwgYW5kIGRpcmVjdCBmaWVsZFxyXG4gICAgICBlZGl0aW5nIG11c3QgYmUgdXNlZCB0byBlZGl0IGEgdmFsdWUgZW1pdHRlZCBsaWtlIHRoaXMgKHRoZSBwZW5jaWwgaWNvbiB3aGVuIHRoZSByZW5kZXJpbmdcclxuICAgICAgaXMgc2VsZWN0ZWQgaW4geEVkaXRvcilcclxuICAgICovfVxyXG4gICAgPGRpdj5SYXcgdmFsdWUgKG5vdCBlZGl0YWJsZSk6IHtnZXRGaWVsZFZhbHVlKHByb3BzLmZpZWxkcywgJ3NhbXBsZScpfTwvZGl2PlxyXG4gIDwvU3R5bGVndWlkZVNwZWNpbWVuPlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0O1xyXG4iLCIvKiBkNWJhNmRjNDlhNGE2MWQ0ZjliOGYxNDExZDMwM2U4ZWY0NGIzNjUyXG4gKiBUaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgZ3JhcGhxbC1sZXQuICovXG5cbmltcG9ydCB7IFR5cGVkRG9jdW1lbnROb2RlIGFzIERvY3VtZW50Tm9kZSB9IGZyb20gJ0BncmFwaHFsLXR5cGVkLWRvY3VtZW50LW5vZGUvY29yZSc7XG5leHBvcnQgdHlwZSBNYXliZTxUPiA9IFQgfCBudWxsO1xuZXhwb3J0IHR5cGUgRXhhY3Q8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogdW5rbm93biB9PiA9IHsgW0sgaW4ga2V5b2YgVF06IFRbS10gfTtcbmV4cG9ydCB0eXBlIE1ha2VPcHRpb25hbDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBPbWl0PFQsIEs+ICYgeyBbU3ViS2V5IGluIEtdPzogTWF5YmU8VFtTdWJLZXldPiB9O1xuZXhwb3J0IHR5cGUgTWFrZU1heWJlPFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IE9taXQ8VCwgSz4gJiB7IFtTdWJLZXkgaW4gS106IE1heWJlPFRbU3ViS2V5XT4gfTtcbi8qKiBBbGwgYnVpbHQtaW4gYW5kIGN1c3RvbSBzY2FsYXJzLCBtYXBwZWQgdG8gdGhlaXIgYWN0dWFsIHZhbHVlcyAqL1xuZXhwb3J0IHR5cGUgU2NhbGFycyA9IHtcbiAgSUQ6IHN0cmluZztcbiAgU3RyaW5nOiBzdHJpbmc7XG4gIEJvb2xlYW46IGJvb2xlYW47XG4gIEludDogbnVtYmVyO1xuICBGbG9hdDogbnVtYmVyO1xuICAvKiogVGhlIGBEYXRlYCBzY2FsYXIgdHlwZSByZXByZXNlbnRzIGEgeWVhciwgbW9udGggYW5kIGRheSBpbiBhY2NvcmRhbmNlIHdpdGggdGhlIFtJU08tODYwMV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEpIHN0YW5kYXJkLiAqL1xuICBEYXRlOiBhbnk7XG4gIC8qKiBUaGUgYERhdGVUaW1lYCBzY2FsYXIgdHlwZSByZXByZXNlbnRzIGEgZGF0ZSBhbmQgdGltZS4gYERhdGVUaW1lYCBleHBlY3RzIHRpbWVzdGFtcHMgdG8gYmUgZm9ybWF0dGVkIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgW0lTTy04NjAxXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSkgc3RhbmRhcmQuICovXG4gIERhdGVUaW1lOiBhbnk7XG4gIC8qKiBUaGUgYERhdGVUaW1lT2Zmc2V0YCBzY2FsYXIgdHlwZSByZXByZXNlbnRzIGEgZGF0ZSwgdGltZSBhbmQgb2Zmc2V0IGZyb20gVVRDLiBgRGF0ZVRpbWVPZmZzZXRgIGV4cGVjdHMgdGltZXN0YW1wcyB0byBiZSBmb3JtYXR0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBbSVNPLTg2MDFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxKSBzdGFuZGFyZC4gKi9cbiAgRGF0ZVRpbWVPZmZzZXQ6IGFueTtcbiAgLyoqIFRoZSBgU2Vjb25kc2Agc2NhbGFyIHR5cGUgcmVwcmVzZW50cyBhIHBlcmlvZCBvZiB0aW1lIHJlcHJlc2VudGVkIGFzIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2Vjb25kcy4gKi9cbiAgU2Vjb25kczogYW55O1xuICAvKiogVGhlIGBNaWxsaXNlY29uZHNgIHNjYWxhciB0eXBlIHJlcHJlc2VudHMgYSBwZXJpb2Qgb2YgdGltZSByZXByZXNlbnRlZCBhcyB0aGUgdG90YWwgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy4gKi9cbiAgTWlsbGlzZWNvbmRzOiBhbnk7XG4gIERlY2ltYWw6IGFueTtcbiAgSlNPTjogYW55O1xuICBMb25nOiBhbnk7XG59O1xuXG5cblxuXG5cblxuXG5leHBvcnQgdHlwZSBJdGVtVGVtcGxhdGVGaWVsZCA9IHtcbiAgX190eXBlbmFtZT86ICdJdGVtVGVtcGxhdGVGaWVsZCc7XG4gIGlkPzogTWF5YmU8U2NhbGFyc1snSUQnXT47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBzZWN0aW9uOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgc2VjdGlvblNvcnRPcmRlcjogU2NhbGFyc1snSW50J107XG4gIHNoYXJlZDogU2NhbGFyc1snQm9vbGVhbiddO1xuICBzb3J0T3JkZXI6IFNjYWxhcnNbJ0ludCddO1xuICBzb3VyY2U6IFNjYWxhcnNbJ1N0cmluZyddO1xuICB0aXRsZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHR5cGU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICB1bnZlcnNpb25lZDogU2NhbGFyc1snQm9vbGVhbiddO1xufTtcblxuXG5leHBvcnQgdHlwZSBJdGVtVGVtcGxhdGVGaWVsZElkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG5leHBvcnQgdHlwZSBJdGVtRmllbGQgPSB7XG4gIGRlZmluaXRpb24/OiBNYXliZTxJdGVtVGVtcGxhdGVGaWVsZD47XG4gIC8qKiBUaGUgR1VJRCBvZiB0aGlzIGZpZWxkLiAqL1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAganNvblZhbHVlOiBTY2FsYXJzWydKU09OJ107XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICB2YWx1ZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuZXhwb3J0IHR5cGUgSXRlbUZpZWxkSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5leHBvcnQgdHlwZSBQYWdlSW5mbyA9IHtcbiAgX190eXBlbmFtZT86ICdQYWdlSW5mbyc7XG4gIGVuZEN1cnNvcjogU2NhbGFyc1snU3RyaW5nJ107XG4gIGhhc05leHQ6IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbn07XG5cbmV4cG9ydCB0eXBlIEl0ZW1UZW1wbGF0ZSA9IHtcbiAgX190eXBlbmFtZT86ICdJdGVtVGVtcGxhdGUnO1xuICBiYXNlVGVtcGxhdGVzPzogTWF5YmU8QXJyYXk8TWF5YmU8SXRlbVRlbXBsYXRlPj4+O1xuICBmaWVsZHM/OiBNYXliZTxBcnJheTxNYXliZTxJdGVtVGVtcGxhdGVGaWVsZD4+PjtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBvd25GaWVsZHM/OiBNYXliZTxBcnJheTxNYXliZTxJdGVtVGVtcGxhdGVGaWVsZD4+Pjtcbn07XG5cblxuZXhwb3J0IHR5cGUgSXRlbVRlbXBsYXRlSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5leHBvcnQgdHlwZSBJdGVtVXJsID0ge1xuICBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnO1xuICAvKiogVGhlIGhvc3QgbmFtZSBvZiB0aGUgaXRlbeKAmXMgc2l0ZSwgYXMgcmVzb2x2ZWQgZHVyaW5nIGV4cG9ydCAqL1xuICBob3N0TmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIC8qKiBUaGUgVVJMIHBhdGggb2YgdGhlIGl0ZW0gKHdpdGhvdXQgVVJMIG9yIHNjaGVtZSkgKi9cbiAgcGF0aDogU2NhbGFyc1snU3RyaW5nJ107XG4gIC8qKiBUaGUgc2NoZW1lIChodHRwIG9yIGh0dHBzKSBvZiB0aGUgaXRlbeKAmXMgc2l0ZSwgYXMgcmVzb2x2ZWQgZHVyaW5nIGV4cG9ydCAqL1xuICBzY2hlbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogVGhlIG5hbWUgb2YgdGhlIHJlc29sdmVkIHNpdGUgb2YgdGhlIGl0ZW0gKi9cbiAgc2l0ZU5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogVGhlIGZ1bGwgVVJMIG9mIHRoZSBpdGVtLCBhcyByZXNvbHZlZCBkdXJpbmcgZXhwb3J0ICovXG4gIHVybDogU2NhbGFyc1snU3RyaW5nJ107XG59O1xuXG5leHBvcnQgdHlwZSBJdGVtTGFuZ3VhZ2UgPSB7XG4gIF9fdHlwZW5hbWU/OiAnSXRlbUxhbmd1YWdlJztcbiAgZGlzcGxheU5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBlbmdsaXNoTmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBuYXRpdmVOYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cbmV4cG9ydCB0eXBlIEl0ZW0gPSB7XG4gIC8qKiBDaGlsZCBpdGVtcyBpbiB0aGUgY29udGVudCBoaWVyYXJjaHkgKi9cbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIC8qKiBDaGlsZCBpdGVtcyBpbiB0aGUgY29udGVudCBoaWVyYXJjaHkgKi9cbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogRGlzcGxheSBuYW1lIG9mIHRoZSBpdGVtICovXG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICAvKiogU2luZ2xlIGZpZWxkIGJ5IG5hbWUgb3IgSUQgKi9cbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICAvKiogQWxsIGl0ZW0gZmllbGRzLiBGaWVsZHMgY2FuIGJlIHRyZWF0ZWQgYXMgdGhlaXIgdHlwZSB0byBnZXQgZGV0YWlsZWQgaW5mby4gKi9cbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIC8qKiBVbmlxdWVseSBpZGVudGlmaWVzIGlkLCBsYW5nLCB2ZXJzaW9uICovXG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICAvKiogUmV0dXJucyBvdGhlciBsYW5ndWFnZSB2ZXJzaW9ucyBvZiB0aGlzIGl0ZW0gKi9cbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogUGFyZW50IGluIHRoZSBjb250ZW50IGhpZXJhcmNoeS4gKi9cbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogUHJlc2VudGF0aW9uIG9mIHRoZSBpdGVtICovXG4gIHJlbmRlcmVkOiBTY2FsYXJzWydKU09OJ107XG4gIC8qKiBEZWZpbmVzIGl0ZW0gZmllbGRzICovXG4gIHRlbXBsYXRlOiBJdGVtVGVtcGxhdGU7XG4gIC8qKiBHZXRzIGEgVVJMIGxpbmsgdG8gdGhlIGl0ZW0gKi9cbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuZXhwb3J0IHR5cGUgSXRlbUFuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG5leHBvcnQgdHlwZSBJdGVtQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG5leHBvcnQgdHlwZSBJdGVtRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuZXhwb3J0IHR5cGUgSXRlbUZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbmV4cG9ydCB0eXBlIEl0ZW1IYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG5leHBvcnQgdHlwZSBJdGVtSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5leHBvcnQgdHlwZSBJdGVtU2VhcmNoUmVzdWx0cyA9IHtcbiAgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cyc7XG4gIHBhZ2VJbmZvOiBQYWdlSW5mbztcbiAgcmVzdWx0czogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICB0b3RhbDogU2NhbGFyc1snSW50J107XG59O1xuXG5leHBvcnQgdHlwZSBSaWNoVGV4dEZpZWxkID0gSXRlbUZpZWxkICYge1xuICBfX3R5cGVuYW1lPzogJ1JpY2hUZXh0RmllbGQnO1xuICBkZWZpbml0aW9uPzogTWF5YmU8SXRlbVRlbXBsYXRlRmllbGQ+O1xuICAvKiogVGhlIEdVSUQgb2YgdGhpcyBmaWVsZC4gKi9cbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGpzb25WYWx1ZTogU2NhbGFyc1snSlNPTiddO1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgdmFsdWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbmV4cG9ydCB0eXBlIFJpY2hUZXh0RmllbGRJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbmV4cG9ydCB0eXBlIE51bWJlckZpZWxkID0gSXRlbUZpZWxkICYge1xuICBfX3R5cGVuYW1lPzogJ051bWJlckZpZWxkJztcbiAgZGVmaW5pdGlvbj86IE1heWJlPEl0ZW1UZW1wbGF0ZUZpZWxkPjtcbiAgLyoqIFRoZSBHVUlEIG9mIHRoaXMgZmllbGQuICovXG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBqc29uVmFsdWU6IFNjYWxhcnNbJ0pTT04nXTtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIC8qKiBUaGUgZmllbGQncyB2YWx1ZSBhcyBhIGZsb2F0aW5nLXBvaW50IG51bWJlciAqL1xuICBudW1iZXJWYWx1ZT86IE1heWJlPFNjYWxhcnNbJ0Zsb2F0J10+O1xuICB2YWx1ZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuZXhwb3J0IHR5cGUgTnVtYmVyRmllbGRJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbmV4cG9ydCB0eXBlIE11bHRpbGlzdEZpZWxkID0gSXRlbUZpZWxkICYge1xuICBfX3R5cGVuYW1lPzogJ011bHRpbGlzdEZpZWxkJztcbiAgLyoqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCB0aGlzIGZpZWxkIHJlZmVyZW5jZXMgKi9cbiAgY291bnQ/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGRlZmluaXRpb24/OiBNYXliZTxJdGVtVGVtcGxhdGVGaWVsZD47XG4gIC8qKiBUaGUgR1VJRCBvZiB0aGlzIGZpZWxkLiAqL1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAganNvblZhbHVlOiBTY2FsYXJzWydKU09OJ107XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogVGhlIElEcyBvZiB0aGUgcmVmZXJlbmNlZCBpdGVtcyAqL1xuICB0YXJnZXRJZHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgLyoqIFRoZSBpdGVtKHMpIHRoYXQgdGhpcyBmaWVsZCByZWZlcmVuY2VzICovXG4gIHRhcmdldEl0ZW1zPzogTWF5YmU8QXJyYXk8TWF5YmU8SXRlbT4+PjtcbiAgdmFsdWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbmV4cG9ydCB0eXBlIE11bHRpbGlzdEZpZWxkSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5leHBvcnQgdHlwZSBMb29rdXBGaWVsZCA9IEl0ZW1GaWVsZCAmIHtcbiAgX190eXBlbmFtZT86ICdMb29rdXBGaWVsZCc7XG4gIGRlZmluaXRpb24/OiBNYXliZTxJdGVtVGVtcGxhdGVGaWVsZD47XG4gIC8qKiBUaGUgR1VJRCBvZiB0aGlzIGZpZWxkLiAqL1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAganNvblZhbHVlOiBTY2FsYXJzWydKU09OJ107XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogVGhlIGl0ZW0gSUQgdGhhdCB0aGlzIGZpZWxkIHJlZmVyZW5jZXMgKi9cbiAgdGFyZ2V0SWQ/OiBNYXliZTxTY2FsYXJzWydJRCddPjtcbiAgLyoqIFRoZSBpdGVtIHRoYXQgdGhpcyBmaWVsZCByZWZlcmVuY2VzICovXG4gIHRhcmdldEl0ZW0/OiBNYXliZTxJdGVtPjtcbiAgdmFsdWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbmV4cG9ydCB0eXBlIExvb2t1cEZpZWxkSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbmV4cG9ydCB0eXBlIExvb2t1cEZpZWxkVGFyZ2V0SWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5leHBvcnQgdHlwZSBMaW5rRmllbGQgPSBJdGVtRmllbGQgJiB7XG4gIF9fdHlwZW5hbWU/OiAnTGlua0ZpZWxkJztcbiAgLyoqIFRoZSBhbmNob3IgbmFtZSB0aGlzIGxpbmsgcG9pbnRzIHRvIChlLmcuICNmb28pICovXG4gIGFuY2hvcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgLyoqIFRoZSBDU1MgY2xhc3Mgb24gdGhpcyBsaW5rICovXG4gIGNsYXNzTmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZGVmaW5pdGlvbj86IE1heWJlPEl0ZW1UZW1wbGF0ZUZpZWxkPjtcbiAgLyoqIFRoZSBHVUlEIG9mIHRoaXMgZmllbGQuICovXG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBqc29uVmFsdWU6IFNjYWxhcnNbJ0pTT04nXTtcbiAgLyoqIFRoZSB0eXBlIG9mIGxpbmsgdGhpcyBpcyAoZS5nLiAnZXh0ZXJuYWwnKSAqL1xuICBsaW5rVHlwZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIC8qKiBUaGUgcXVlcnkgc3RyaW5nIG9uIHRoaXMgbGluayAqL1xuICBxdWVyeVN0cmluZz86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgLyoqIFRoZSBIVE1MIHRhcmdldCBhdHRyaWJ1dGUgb2YgdGhlIGxpbmsgKGUuZy4gX19ibGFuaykgKi9cbiAgdGFyZ2V0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICAvKiogVGhlIGludGVybmFsIGl0ZW0gdGhhdCB0aGlzIGxpbmsgdGFyZ2V0cyAobnVsbCBmb3IgZXh0ZXJuYWwgb3Igb3RoZXIgbGluayB0eXBlcykgKi9cbiAgdGFyZ2V0SXRlbT86IE1heWJlPEl0ZW0+O1xuICAvKiogVGhlIGJvZHkgdGV4dCBvZiB0aGUgbGluayAqL1xuICB0ZXh0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICAvKiogVGhlIFVSTC9ocmVmIG9mIHRoaXMgbGluayAqL1xuICB1cmw/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIHZhbHVlPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG5leHBvcnQgdHlwZSBMaW5rRmllbGRJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbmV4cG9ydCB0eXBlIFRleHRGaWVsZCA9IEl0ZW1GaWVsZCAmIHtcbiAgX190eXBlbmFtZT86ICdUZXh0RmllbGQnO1xuICBkZWZpbml0aW9uPzogTWF5YmU8SXRlbVRlbXBsYXRlRmllbGQ+O1xuICAvKiogVGhlIEdVSUQgb2YgdGhpcyBmaWVsZC4gKi9cbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGpzb25WYWx1ZTogU2NhbGFyc1snSlNPTiddO1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgdmFsdWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbmV4cG9ydCB0eXBlIFRleHRGaWVsZElkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuZXhwb3J0IHR5cGUgSW50ZWdlckZpZWxkID0gSXRlbUZpZWxkICYge1xuICBfX3R5cGVuYW1lPzogJ0ludGVnZXJGaWVsZCc7XG4gIGRlZmluaXRpb24/OiBNYXliZTxJdGVtVGVtcGxhdGVGaWVsZD47XG4gIC8qKiBUaGUgR1VJRCBvZiB0aGlzIGZpZWxkLiAqL1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgLyoqIFRoZSBmaWVsZCdzIHZhbHVlIGFzIGFuIGludGVnZXIgKi9cbiAgaW50VmFsdWU/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGpzb25WYWx1ZTogU2NhbGFyc1snSlNPTiddO1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgdmFsdWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbmV4cG9ydCB0eXBlIEludGVnZXJGaWVsZElkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuZXhwb3J0IHR5cGUgSW1hZ2VGaWVsZCA9IEl0ZW1GaWVsZCAmIHtcbiAgX190eXBlbmFtZT86ICdJbWFnZUZpZWxkJztcbiAgLyoqIFRoZSBhbHRlcm5hdGUgdGV4dCBmb3IgdGhlIGltYWdlICovXG4gIGFsdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZGVmaW5pdGlvbj86IE1heWJlPEl0ZW1UZW1wbGF0ZUZpZWxkPjtcbiAgLyoqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbWVkaWEgaXRlbSAqL1xuICBkZXNjcmlwdGlvbj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgLyoqIFRoZSBleHRlbnNpb24gb2YgdGhlIG1lZGlhIGl0ZW0gKGUuZy4gJ2pwZycsICdnaWYnKSAqL1xuICBleHRlbnNpb24/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIC8qKiBIZWlnaHQgb2YgdGhlIGltYWdlIGF0IGZ1bGwgc2l6ZSAqL1xuICBoZWlnaHQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIC8qKiBUaGUgR1VJRCBvZiB0aGlzIGZpZWxkLiAqL1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAganNvblZhbHVlOiBTY2FsYXJzWydKU09OJ107XG4gIC8qKiBUaGUga2V5d29yZHMgb2YgdGhlIG1lZGlhIGl0ZW0gKi9cbiAga2V5d29yZHM/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIC8qKiBUaGUgTUlNRSB0eXBlIG9mIHRoZSBtZWRpYSBpdGVtIChlLmcuICdpbWFnZS9qcGVnJykgKi9cbiAgbWltZVR5cGU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogVGhlIHNpemUsIGluIGJ5dGVzLCBvZiB0aGUgbWVkaWEgaXRlbSAqL1xuICBzaXplPzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICAvKiogVGhlIFVSTCB0byB0aGUgbWVkaWEgaXRlbSAqL1xuICBzcmM/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIC8qKiBUaGUgdGl0bGUgb2YgdGhlIG1lZGlhIGl0ZW0gKi9cbiAgdGl0bGU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIHZhbHVlPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICAvKiogV2lkdGggb2YgdGhlIGltYWdlIGF0IGZ1bGwgc2l6ZSAqL1xuICB3aWR0aD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuZXhwb3J0IHR5cGUgSW1hZ2VGaWVsZElkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG5leHBvcnQgdHlwZSBJbWFnZUZpZWxkU3JjQXJncyA9IHtcbiAgbWF4V2lkdGg/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIG1heEhlaWdodD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbn07XG5cblxuZXhwb3J0IHR5cGUgRGF0ZUZpZWxkID0gSXRlbUZpZWxkICYge1xuICBfX3R5cGVuYW1lPzogJ0RhdGVGaWVsZCc7XG4gIC8qKiBUaGUgZmllbGQncyB2YWx1ZSBhcyBhIFVUQyBlcG9jaCBkYXRlIHN1aXRhYmxlIGZvciBjb25zdHJ1Y3RpbmcgYSBKYXZhc2NyaXB0IERhdGUgKi9cbiAgZGF0ZVZhbHVlPzogTWF5YmU8U2NhbGFyc1snTG9uZyddPjtcbiAgZGVmaW5pdGlvbj86IE1heWJlPEl0ZW1UZW1wbGF0ZUZpZWxkPjtcbiAgLyoqIFRoZSBmaWVsZCdzIHZhbHVlIGFzIGEgcHJlZm9ybWF0dGVkIGRhdGUuICovXG4gIGZvcm1hdHRlZERhdGVWYWx1ZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgLyoqIFRoZSBHVUlEIG9mIHRoaXMgZmllbGQuICovXG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBqc29uVmFsdWU6IFNjYWxhcnNbJ0pTT04nXTtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHZhbHVlPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG5leHBvcnQgdHlwZSBEYXRlRmllbGRGb3JtYXR0ZWREYXRlVmFsdWVBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIG9mZnNldD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbn07XG5cblxuZXhwb3J0IHR5cGUgRGF0ZUZpZWxkSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5leHBvcnQgdHlwZSBDaGVja2JveEZpZWxkID0gSXRlbUZpZWxkICYge1xuICBfX3R5cGVuYW1lPzogJ0NoZWNrYm94RmllbGQnO1xuICBib29sVmFsdWU/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBkZWZpbml0aW9uPzogTWF5YmU8SXRlbVRlbXBsYXRlRmllbGQ+O1xuICAvKiogVGhlIEdVSUQgb2YgdGhpcyBmaWVsZC4gKi9cbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGpzb25WYWx1ZTogU2NhbGFyc1snSlNPTiddO1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgdmFsdWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbmV4cG9ydCB0eXBlIENoZWNrYm94RmllbGRJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbmV4cG9ydCB0eXBlIExheW91dERhdGEgPSB7XG4gIF9fdHlwZW5hbWU/OiAnTGF5b3V0RGF0YSc7XG4gIGl0ZW0/OiBNYXliZTxJdGVtPjtcbn07XG5cbi8qKiBSZXByZXNlbnRzIGEgU2l0ZWNvcmUgaXRlbSB3aG9zZSB0ZW1wbGF0ZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHNjaGVtYS4gSWYgeW91IHJlY2VpdmUgcmVzdWx0cyBvZiB0aGlzIHR5cGUsIGNvbnNpZGVyIGV4cGFuZGluZyB5b3VyIGluY2x1ZGVkIHRlbXBsYXRlcy4gKi9cbmV4cG9ydCB0eXBlIFVua25vd25JdGVtID0gSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdVbmtub3duSXRlbSc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBwYXJlbnQ/OiBNYXliZTxJdGVtPjtcbiAgcGF0aDogU2NhbGFyc1snU3RyaW5nJ107XG4gIHJlbmRlcmVkOiBTY2FsYXJzWydKU09OJ107XG4gIHRlbXBsYXRlOiBJdGVtVGVtcGxhdGU7XG4gIHVybDogSXRlbVVybDtcbiAgdmVyc2lvbjogU2NhbGFyc1snSW50J107XG59O1xuXG5cbi8qKiBSZXByZXNlbnRzIGEgU2l0ZWNvcmUgaXRlbSB3aG9zZSB0ZW1wbGF0ZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHNjaGVtYS4gSWYgeW91IHJlY2VpdmUgcmVzdWx0cyBvZiB0aGlzIHR5cGUsIGNvbnNpZGVyIGV4cGFuZGluZyB5b3VyIGluY2x1ZGVkIHRlbXBsYXRlcy4gKi9cbmV4cG9ydCB0eXBlIFVua25vd25JdGVtQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiBSZXByZXNlbnRzIGEgU2l0ZWNvcmUgaXRlbSB3aG9zZSB0ZW1wbGF0ZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHNjaGVtYS4gSWYgeW91IHJlY2VpdmUgcmVzdWx0cyBvZiB0aGlzIHR5cGUsIGNvbnNpZGVyIGV4cGFuZGluZyB5b3VyIGluY2x1ZGVkIHRlbXBsYXRlcy4gKi9cbmV4cG9ydCB0eXBlIFVua25vd25JdGVtQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogUmVwcmVzZW50cyBhIFNpdGVjb3JlIGl0ZW0gd2hvc2UgdGVtcGxhdGUgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBzY2hlbWEuIElmIHlvdSByZWNlaXZlIHJlc3VsdHMgb2YgdGhpcyB0eXBlLCBjb25zaWRlciBleHBhbmRpbmcgeW91ciBpbmNsdWRlZCB0ZW1wbGF0ZXMuICovXG5leHBvcnQgdHlwZSBVbmtub3duSXRlbUZpZWxkQXJncyA9IHtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG59O1xuXG5cbi8qKiBSZXByZXNlbnRzIGEgU2l0ZWNvcmUgaXRlbSB3aG9zZSB0ZW1wbGF0ZSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHNjaGVtYS4gSWYgeW91IHJlY2VpdmUgcmVzdWx0cyBvZiB0aGlzIHR5cGUsIGNvbnNpZGVyIGV4cGFuZGluZyB5b3VyIGluY2x1ZGVkIHRlbXBsYXRlcy4gKi9cbmV4cG9ydCB0eXBlIFVua25vd25JdGVtRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIFJlcHJlc2VudHMgYSBTaXRlY29yZSBpdGVtIHdob3NlIHRlbXBsYXRlIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgc2NoZW1hLiBJZiB5b3UgcmVjZWl2ZSByZXN1bHRzIG9mIHRoaXMgdHlwZSwgY29uc2lkZXIgZXhwYW5kaW5nIHlvdXIgaW5jbHVkZWQgdGVtcGxhdGVzLiAqL1xuZXhwb3J0IHR5cGUgVW5rbm93bkl0ZW1IYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogUmVwcmVzZW50cyBhIFNpdGVjb3JlIGl0ZW0gd2hvc2UgdGVtcGxhdGUgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBzY2hlbWEuIElmIHlvdSByZWNlaXZlIHJlc3VsdHMgb2YgdGhpcyB0eXBlLCBjb25zaWRlciBleHBhbmRpbmcgeW91ciBpbmNsdWRlZCB0ZW1wbGF0ZXMuICovXG5leHBvcnQgdHlwZSBVbmtub3duSXRlbUlkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtVHJhY2tpbmcgdGVtcGxhdGUgKElEOiB7QzI3NTEwNEYtRjExNy01QzkzLUJGQjAtRjYyMzI5QkZEQTNFfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlVHJhY2tpbmcgPSBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQgJiBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZyc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIC8qKiBkZXNjcmlwdGlvbiAoSUQ6IHtCMzg1MTBGRi04RDg4LTVDRDctQkEzRi0yMDE4MzE1RDZBQjJ9KS4gKi9cbiAgZGVzY3JpcHRpb24/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgLyoqIGhlYWRpbmcgKElEOiB7NUEzMDE5RjQtMDY0Ny01N0JBLUEzRjYtMDVDRUY2MzlCRTkxfSkuICovXG4gIGhlYWRpbmc/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1UcmFja2luZyB0ZW1wbGF0ZSAoSUQ6IHtDMjc1MTA0Ri1GMTE3LTVDOTMtQkZCMC1GNjIzMjlCRkRBM0V9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVUcmFja2luZ0FuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1UcmFja2luZyB0ZW1wbGF0ZSAoSUQ6IHtDMjc1MTA0Ri1GMTE3LTVDOTMtQkZCMC1GNjIzMjlCRkRBM0V9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVUcmFja2luZ0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtVHJhY2tpbmcgdGVtcGxhdGUgKElEOiB7QzI3NTEwNEYtRjExNy01QzkzLUJGQjAtRjYyMzI5QkZEQTNFfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlVHJhY2tpbmdGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1UcmFja2luZyB0ZW1wbGF0ZSAoSUQ6IHtDMjc1MTA0Ri1GMTE3LTVDOTMtQkZCMC1GNjIzMjlCRkRBM0V9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVUcmFja2luZ0ZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLVRyYWNraW5nIHRlbXBsYXRlIChJRDoge0MyNzUxMDRGLUYxMTctNUM5My1CRkIwLUY2MjMyOUJGREEzRX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVRyYWNraW5nSGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtVHJhY2tpbmcgdGVtcGxhdGUgKElEOiB7QzI3NTEwNEYtRjExNy01QzkzLUJGQjAtRjYyMzI5QkZEQTNFfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlVHJhY2tpbmdJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLVNpdGVjb3JlQ29udGV4dCB0ZW1wbGF0ZSAoSUQ6IHswQkUyM0E0NS01ODhFLTU1NkMtOTg4Qi02NkIyNzI5MjIwRTZ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQgPSBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQgJiBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogZGVzY3JpcHRpb24gKElEOiB7QjM4NTEwRkYtOEQ4OC01Q0Q3LUJBM0YtMjAxODMxNUQ2QUIyfSkuICovXG4gIGRlc2NyaXB0aW9uPzogTWF5YmU8UmljaFRleHRGaWVsZD47XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIC8qKiBoZWFkaW5nIChJRDogezVBMzAxOUY0LTA2NDctNTdCQS1BM0Y2LTA1Q0VGNjM5QkU5MX0pLiAqL1xuICBoZWFkaW5nPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtU2l0ZWNvcmVDb250ZXh0IHRlbXBsYXRlIChJRDogezBCRTIzQTQ1LTU4OEUtNTU2Qy05ODhCLTY2QjI3MjkyMjBFNn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dEFuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1TaXRlY29yZUNvbnRleHQgdGVtcGxhdGUgKElEOiB7MEJFMjNBNDUtNTg4RS01NTZDLTk4OEItNjZCMjcyOTIyMEU2fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0Q2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1TaXRlY29yZUNvbnRleHQgdGVtcGxhdGUgKElEOiB7MEJFMjNBNDUtNTg4RS01NTZDLTk4OEItNjZCMjcyOTIyMEU2fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0RmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtU2l0ZWNvcmVDb250ZXh0IHRlbXBsYXRlIChJRDogezBCRTIzQTQ1LTU4OEUtNTU2Qy05ODhCLTY2QjI3MjkyMjBFNn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dEZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLVNpdGVjb3JlQ29udGV4dCB0ZW1wbGF0ZSAoSUQ6IHswQkUyM0E0NS01ODhFLTU1NkMtOTg4Qi02NkIyNzI5MjIwRTZ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHRIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1TaXRlY29yZUNvbnRleHQgdGVtcGxhdGUgKElEOiB7MEJFMjNBNDUtNTg4RS01NTZDLTk4OEItNjZCMjcyOTIyMEU2fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0SWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1TZWN0aW9uIHRlbXBsYXRlIChJRDoge0ZDRDc2MkEwLTc1MzgtNTgwOS1BQUJDLTAyOTE0NjdFNTcwQX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVNlY3Rpb24gPSBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgLyoqIGhlYWRpbmcgKElEOiB7RjFCRDgzRjEtMjVFNi01OUQ5LUE3NjQtNDJFNTg3ODQ5MjdEfSkuICovXG4gIGhlYWRpbmc/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1TZWN0aW9uIHRlbXBsYXRlIChJRDoge0ZDRDc2MkEwLTc1MzgtNTgwOS1BQUJDLTAyOTE0NjdFNTcwQX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVNlY3Rpb25BbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtU2VjdGlvbiB0ZW1wbGF0ZSAoSUQ6IHtGQ0Q3NjJBMC03NTM4LTU4MDktQUFCQy0wMjkxNDY3RTU3MEF9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVTZWN0aW9uQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1TZWN0aW9uIHRlbXBsYXRlIChJRDoge0ZDRDc2MkEwLTc1MzgtNTgwOS1BQUJDLTAyOTE0NjdFNTcwQX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVNlY3Rpb25GaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1TZWN0aW9uIHRlbXBsYXRlIChJRDoge0ZDRDc2MkEwLTc1MzgtNTgwOS1BQUJDLTAyOTE0NjdFNTcwQX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVNlY3Rpb25GaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1TZWN0aW9uIHRlbXBsYXRlIChJRDoge0ZDRDc2MkEwLTc1MzgtNTgwOS1BQUJDLTAyOTE0NjdFNTcwQX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVNlY3Rpb25IYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1TZWN0aW9uIHRlbXBsYXRlIChJRDoge0ZDRDc2MkEwLTc1MzgtNTgwOS1BQUJDLTAyOTE0NjdFNTcwQX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVNlY3Rpb25JZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLVJvdXRlRmllbGRzIHRlbXBsYXRlIChJRDogezg4NDFBQUE4LTY4MDYtNUU4Ni1BNzA3LTgxRTc5NjgyMjFDMH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVJvdXRlRmllbGRzID0gU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50ICYgSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogZGVzY3JpcHRpb24gKElEOiB7QjM4NTEwRkYtOEQ4OC01Q0Q3LUJBM0YtMjAxODMxNUQ2QUIyfSkuICovXG4gIGRlc2NyaXB0aW9uPzogTWF5YmU8UmljaFRleHRGaWVsZD47XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIC8qKiBoZWFkaW5nIChJRDogezVBMzAxOUY0LTA2NDctNTdCQS1BM0Y2LTA1Q0VGNjM5QkU5MX0pLiAqL1xuICBoZWFkaW5nPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtUm91dGVGaWVsZHMgdGVtcGxhdGUgKElEOiB7ODg0MUFBQTgtNjgwNi01RTg2LUE3MDctODFFNzk2ODIyMUMwfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlUm91dGVGaWVsZHNBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtUm91dGVGaWVsZHMgdGVtcGxhdGUgKElEOiB7ODg0MUFBQTgtNjgwNi01RTg2LUE3MDctODFFNzk2ODIyMUMwfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlUm91dGVGaWVsZHNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xuICBmaXJzdD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbiAgYWZ0ZXI/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLVJvdXRlRmllbGRzIHRlbXBsYXRlIChJRDogezg4NDFBQUE4LTY4MDYtNUU4Ni1BNzA3LTgxRTc5NjgyMjFDMH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVJvdXRlRmllbGRzRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtUm91dGVGaWVsZHMgdGVtcGxhdGUgKElEOiB7ODg0MUFBQTgtNjgwNi01RTg2LUE3MDctODFFNzk2ODIyMUMwfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlUm91dGVGaWVsZHNGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Sb3V0ZUZpZWxkcyB0ZW1wbGF0ZSAoSUQ6IHs4ODQxQUFBOC02ODA2LTVFODYtQTcwNy04MUU3OTY4MjIxQzB9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVSb3V0ZUZpZWxkc0hhc0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLVJvdXRlRmllbGRzIHRlbXBsYXRlIChJRDogezg4NDFBQUE4LTY4MDYtNUU4Ni1BNzA3LTgxRTc5NjgyMjFDMH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZVJvdXRlRmllbGRzSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1NdWx0aWxpbmd1YWwgdGVtcGxhdGUgKElEOiB7NDE5REMxNjQtQUQ3Ri01MUYzLUFGQTEtMUU5REE0QjgyOTlEfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTXVsdGlsaW5ndWFsID0gU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50ICYgSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgLyoqIGRlc2NyaXB0aW9uIChJRDoge0IzODUxMEZGLThEODgtNUNENy1CQTNGLTIwMTgzMTVENkFCMn0pLiAqL1xuICBkZXNjcmlwdGlvbj86IE1heWJlPFJpY2hUZXh0RmllbGQ+O1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICBoYXNDaGlsZHJlbjogU2NhbGFyc1snQm9vbGVhbiddO1xuICAvKiogaGVhZGluZyAoSUQ6IHs1QTMwMTlGNC0wNjQ3LTU3QkEtQTNGNi0wNUNFRjYzOUJFOTF9KS4gKi9cbiAgaGVhZGluZz86IE1heWJlPFRleHRGaWVsZD47XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBwYXJlbnQ/OiBNYXliZTxJdGVtPjtcbiAgcGF0aDogU2NhbGFyc1snU3RyaW5nJ107XG4gIHJlbmRlcmVkOiBTY2FsYXJzWydKU09OJ107XG4gIC8qKiBUaGlzIGZpZWxkIGhhcyBhIHRyYW5zbGF0ZWQgdmFsdWUgKElEOiB7NDgxQUM5RTMtQjQ2Ni01RkRCLUI1RjYtQzc3RDc1Mzc5RjcxfSkuICovXG4gIHNhbXBsZT86IE1heWJlPFRleHRGaWVsZD47XG4gIHRlbXBsYXRlOiBJdGVtVGVtcGxhdGU7XG4gIHVybDogSXRlbVVybDtcbiAgdmVyc2lvbjogU2NhbGFyc1snSW50J107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLU11bHRpbGluZ3VhbCB0ZW1wbGF0ZSAoSUQ6IHs0MTlEQzE2NC1BRDdGLTUxRjMtQUZBMS0xRTlEQTRCODI5OUR9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWxBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtTXVsdGlsaW5ndWFsIHRlbXBsYXRlIChJRDogezQxOURDMTY0LUFEN0YtNTFGMy1BRkExLTFFOURBNEI4Mjk5RH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZU11bHRpbGluZ3VhbENoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtTXVsdGlsaW5ndWFsIHRlbXBsYXRlIChJRDogezQxOURDMTY0LUFEN0YtNTFGMy1BRkExLTFFOURBNEI4Mjk5RH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZU11bHRpbGluZ3VhbEZpZWxkQXJncyA9IHtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLU11bHRpbGluZ3VhbCB0ZW1wbGF0ZSAoSUQ6IHs0MTlEQzE2NC1BRDdGLTUxRjMtQUZBMS0xRTlEQTRCODI5OUR9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWxGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1NdWx0aWxpbmd1YWwgdGVtcGxhdGUgKElEOiB7NDE5REMxNjQtQUQ3Ri01MUYzLUFGQTEtMUU5REE0QjgyOTlEfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTXVsdGlsaW5ndWFsSGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtTXVsdGlsaW5ndWFsIHRlbXBsYXRlIChJRDogezQxOURDMTY0LUFEN0YtNTFGMy1BRkExLTFFOURBNEI4Mjk5RH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZU11bHRpbGluZ3VhbElkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtTGF5b3V0LVRhYnMtVGFiIHRlbXBsYXRlIChJRDogezFCMUE3N0ZBLUYzNTgtNTIwOC05MzVGLUQ3MDc0NEM0REEwOX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUxheW91dFRhYnNUYWIgPSBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgLyoqIGNvbnRlbnQgKElEOiB7N0QzNzc3ODMtRTNFOS01NkRELTgxNUYtRUNDRTY3NzU1RTI2fSkuICovXG4gIGNvbnRlbnQ/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgLyoqIHRpdGxlIChJRDoge0RFNkI3MDdGLTM2Q0QtNTY2Ny05MkE4LTZBRkQ1ODAwOEM4OX0pLiAqL1xuICB0aXRsZT86IE1heWJlPFRleHRGaWVsZD47XG4gIHVybDogSXRlbVVybDtcbiAgdmVyc2lvbjogU2NhbGFyc1snSW50J107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUxheW91dC1UYWJzLVRhYiB0ZW1wbGF0ZSAoSUQ6IHsxQjFBNzdGQS1GMzU4LTUyMDgtOTM1Ri1ENzA3NDRDNERBMDl9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUxheW91dC1UYWJzLVRhYiB0ZW1wbGF0ZSAoSUQ6IHsxQjFBNzdGQS1GMzU4LTUyMDgtOTM1Ri1ENzA3NDRDNERBMDl9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtVGFicy1UYWIgdGVtcGxhdGUgKElEOiB7MUIxQTc3RkEtRjM1OC01MjA4LTkzNUYtRDcwNzQ0QzREQTA5fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0VGFic1RhYkZpZWxkQXJncyA9IHtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUxheW91dC1UYWJzLVRhYiB0ZW1wbGF0ZSAoSUQ6IHsxQjFBNzdGQS1GMzU4LTUyMDgtOTM1Ri1ENzA3NDRDNERBMDl9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtTGF5b3V0LVRhYnMtVGFiIHRlbXBsYXRlIChJRDogezFCMUE3N0ZBLUYzNTgtNTIwOC05MzVGLUQ3MDc0NEM0REEwOX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUxheW91dFRhYnNUYWJIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtVGFicy1UYWIgdGVtcGxhdGUgKElEOiB7MUIxQTc3RkEtRjM1OC01MjA4LTkzNUYtRDcwNzQ0QzREQTA5fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0VGFic1RhYklkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtTGF5b3V0LVRhYnMgdGVtcGxhdGUgKElEOiB7QTU5QzdEQkYtQzk5NC01MjE5LThERjMtOTZFRDVDNjNFMDA0fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0VGFicyA9IFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCAmIEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogZGVzY3JpcHRpb24gKElEOiB7QjM4NTEwRkYtOEQ4OC01Q0Q3LUJBM0YtMjAxODMxNUQ2QUIyfSkuICovXG4gIGRlc2NyaXB0aW9uPzogTWF5YmU8UmljaFRleHRGaWVsZD47XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIC8qKiBoZWFkaW5nIChJRDogezVBMzAxOUY0LTA2NDctNTdCQS1BM0Y2LTA1Q0VGNjM5QkU5MX0pLiAqL1xuICBoZWFkaW5nPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtTGF5b3V0LVRhYnMgdGVtcGxhdGUgKElEOiB7QTU5QzdEQkYtQzk5NC01MjE5LThERjMtOTZFRDVDNjNFMDA0fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0VGFic0FuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtVGFicyB0ZW1wbGF0ZSAoSUQ6IHtBNTlDN0RCRi1DOTk0LTUyMTktOERGMy05NkVENUM2M0UwMDR9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVMYXlvdXRUYWJzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtVGFicyB0ZW1wbGF0ZSAoSUQ6IHtBNTlDN0RCRi1DOTk0LTUyMTktOERGMy05NkVENUM2M0UwMDR9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVMYXlvdXRUYWJzRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtTGF5b3V0LVRhYnMgdGVtcGxhdGUgKElEOiB7QTU5QzdEQkYtQzk5NC01MjE5LThERjMtOTZFRDVDNjNFMDA0fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0VGFic0ZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUxheW91dC1UYWJzIHRlbXBsYXRlIChJRDoge0E1OUM3REJGLUM5OTQtNTIxOS04REYzLTk2RUQ1QzYzRTAwNH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUxheW91dFRhYnNIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtVGFicyB0ZW1wbGF0ZSAoSUQ6IHtBNTlDN0RCRi1DOTk0LTUyMTktOERGMy05NkVENUM2M0UwMDR9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVMYXlvdXRUYWJzSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtUmV1c2UgdGVtcGxhdGUgKElEOiB7MTk3QTE5MTUtQ0JCQy01Njg5LUI1QkQtQTZBMTM0NjdGM0U3fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0UmV1c2UgPSBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQgJiBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZSc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIC8qKiBkZXNjcmlwdGlvbiAoSUQ6IHtCMzg1MTBGRi04RDg4LTVDRDctQkEzRi0yMDE4MzE1RDZBQjJ9KS4gKi9cbiAgZGVzY3JpcHRpb24/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgLyoqIGhlYWRpbmcgKElEOiB7NUEzMDE5RjQtMDY0Ny01N0JBLUEzRjYtMDVDRUY2MzlCRTkxfSkuICovXG4gIGhlYWRpbmc/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtUmV1c2UgdGVtcGxhdGUgKElEOiB7MTk3QTE5MTUtQ0JCQy01Njg5LUI1QkQtQTZBMTM0NjdGM0U3fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0UmV1c2VBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtTGF5b3V0LVJldXNlIHRlbXBsYXRlIChJRDogezE5N0ExOTE1LUNCQkMtNTY4OS1CNUJELUE2QTEzNDY3RjNFN30pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUxheW91dFJldXNlQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtUmV1c2UgdGVtcGxhdGUgKElEOiB7MTk3QTE5MTUtQ0JCQy01Njg5LUI1QkQtQTZBMTM0NjdGM0U3fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0UmV1c2VGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtUmV1c2UgdGVtcGxhdGUgKElEOiB7MTk3QTE5MTUtQ0JCQy01Njg5LUI1QkQtQTZBMTM0NjdGM0U3fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0UmV1c2VGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtUmV1c2UgdGVtcGxhdGUgKElEOiB7MTk3QTE5MTUtQ0JCQy01Njg5LUI1QkQtQTZBMTM0NjdGM0U3fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0UmV1c2VIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1MYXlvdXQtUmV1c2UgdGVtcGxhdGUgKElEOiB7MTk3QTE5MTUtQ0JCQy01Njg5LUI1QkQtQTZBMTM0NjdGM0U3fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlTGF5b3V0UmV1c2VJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUl0ZW1MaW5rLUl0ZW0tVGVtcGxhdGUgdGVtcGxhdGUgKElEOiB7QkRDMzNCMjAtMEM5Qy01RDlCLUI1MkMtNDc2MkZEM0I1OUVGfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUgPSBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBwYXJlbnQ/OiBNYXliZTxJdGVtPjtcbiAgcGF0aDogU2NhbGFyc1snU3RyaW5nJ107XG4gIHJlbmRlcmVkOiBTY2FsYXJzWydKU09OJ107XG4gIHRlbXBsYXRlOiBJdGVtVGVtcGxhdGU7XG4gIC8qKiB0ZXh0RmllbGQgKElEOiB7NDE0MTIzOTMtMjU3Qy01Mjg4LTg3NkYtMEU2N0ExQjUxMTkyfSkuICovXG4gIHRleHRGaWVsZD86IE1heWJlPFRleHRGaWVsZD47XG4gIHVybDogSXRlbVVybDtcbiAgdmVyc2lvbjogU2NhbGFyc1snSW50J107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUl0ZW1MaW5rLUl0ZW0tVGVtcGxhdGUgdGVtcGxhdGUgKElEOiB7QkRDMzNCMjAtMEM5Qy01RDlCLUI1MkMtNDc2MkZEM0I1OUVGfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGVBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtSXRlbUxpbmstSXRlbS1UZW1wbGF0ZSB0ZW1wbGF0ZSAoSUQ6IHtCREMzM0IyMC0wQzlDLTVEOUItQjUyQy00NzYyRkQzQjU5RUZ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZUNoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtSXRlbUxpbmstSXRlbS1UZW1wbGF0ZSB0ZW1wbGF0ZSAoSUQ6IHtCREMzM0IyMC0wQzlDLTVEOUItQjUyQy00NzYyRkQzQjU5RUZ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZUZpZWxkQXJncyA9IHtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUl0ZW1MaW5rLUl0ZW0tVGVtcGxhdGUgdGVtcGxhdGUgKElEOiB7QkRDMzNCMjAtMEM5Qy01RDlCLUI1MkMtNDc2MkZEM0I1OUVGfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGVGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1JdGVtTGluay1JdGVtLVRlbXBsYXRlIHRlbXBsYXRlIChJRDoge0JEQzMzQjIwLTBDOUMtNUQ5Qi1CNTJDLTQ3NjJGRDNCNTlFRn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlSGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtSXRlbUxpbmstSXRlbS1UZW1wbGF0ZSB0ZW1wbGF0ZSAoSUQ6IHtCREMzM0IyMC0wQzlDLTVEOUItQjUyQy00NzYyRkQzQjU5RUZ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZUlkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1UZXh0IHRlbXBsYXRlIChJRDogezM3NEMxOEYzLUQyNDctNTZBMC1CMDNBLTQyMUZDQzRBNzZBMn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0ID0gU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50ICYgSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogZGVzY3JpcHRpb24gKElEOiB7QjM4NTEwRkYtOEQ4OC01Q0Q3LUJBM0YtMjAxODMxNUQ2QUIyfSkuICovXG4gIGRlc2NyaXB0aW9uPzogTWF5YmU8UmljaFRleHRGaWVsZD47XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIC8qKiBoZWFkaW5nIChJRDogezVBMzAxOUY0LTA2NDctNTdCQS1BM0Y2LTA1Q0VGNjM5QkU5MX0pLiAqL1xuICBoZWFkaW5nPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgLyoqIHNhbXBsZSAoSUQ6IHtDODhGQTQ1QS02QjIxLTU5NTctQkFEQS0wRjM4Q0M1MEEwQ0N9KS4gKi9cbiAgc2FtcGxlPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgLyoqIEN1c3RvbWl6ZSBOYW1lIFNob3duIGluIFNpdGVjb3JlIChJRDogezFGOTM5REM3LTgwRUMtNUY0QS1CNDU1LTdBODgxQjUzMTBCNX0pLiAqL1xuICBzYW1wbGUyPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1UZXh0IHRlbXBsYXRlIChJRDogezM3NEMxOEYzLUQyNDctNTZBMC1CMDNBLTQyMUZDQzRBNzZBMn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0QW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtVGV4dCB0ZW1wbGF0ZSAoSUQ6IHszNzRDMThGMy1EMjQ3LTU2QTAtQjAzQS00MjFGQ0M0QTc2QTJ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dENoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1UZXh0IHRlbXBsYXRlIChJRDogezM3NEMxOEYzLUQyNDctNTZBMC1CMDNBLTQyMUZDQzRBNzZBMn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0RmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1UZXh0IHRlbXBsYXRlIChJRDogezM3NEMxOEYzLUQyNDctNTZBMC1CMDNBLTQyMUZDQzRBNzZBMn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0RmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1UZXh0IHRlbXBsYXRlIChJRDogezM3NEMxOEYzLUQyNDctNTZBMC1CMDNBLTQyMUZDQzRBNzZBMn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0SGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1UZXh0IHRlbXBsYXRlIChJRDogezM3NEMxOEYzLUQyNDctNTZBMC1CMDNBLTQyMUZDQzRBNzZBMn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0SWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLVJpY2hUZXh0IHRlbXBsYXRlIChJRDogezJEQ0UxMTNGLTA3MTctNUU4My1BODExLUM2NkQ5RTM3NUI2QX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCA9IFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCAmIEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIC8qKiBkZXNjcmlwdGlvbiAoSUQ6IHtCMzg1MTBGRi04RDg4LTVDRDctQkEzRi0yMDE4MzE1RDZBQjJ9KS4gKi9cbiAgZGVzY3JpcHRpb24/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgLyoqIGhlYWRpbmcgKElEOiB7NUEzMDE5RjQtMDY0Ny01N0JBLUEzRjYtMDVDRUY2MzlCRTkxfSkuICovXG4gIGhlYWRpbmc/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICAvKiogc2FtcGxlIChJRDoge0FBODQzRjdELTExQ0UtNTcxOS04QkIyLUEwNjQzODVDNDY4MX0pLiAqL1xuICBzYW1wbGU/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgLyoqIEN1c3RvbWl6ZSBOYW1lIFNob3duIGluIFNpdGVjb3JlIChJRDoge0Q0OTgwRTQxLURERjUtNUVBRC1BMTMzLUEyRDExQ0YwQTEwQn0pLiAqL1xuICBzYW1wbGUyPzogTWF5YmU8UmljaFRleHRGaWVsZD47XG4gIHRlbXBsYXRlOiBJdGVtVGVtcGxhdGU7XG4gIHVybDogSXRlbVVybDtcbiAgdmVyc2lvbjogU2NhbGFyc1snSW50J107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtUmljaFRleHQgdGVtcGxhdGUgKElEOiB7MkRDRTExM0YtMDcxNy01RTgzLUE4MTEtQzY2RDlFMzc1QjZBfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0QW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtUmljaFRleHQgdGVtcGxhdGUgKElEOiB7MkRDRTExM0YtMDcxNy01RTgzLUE4MTEtQzY2RDlFMzc1QjZBfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0Q2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLVJpY2hUZXh0IHRlbXBsYXRlIChJRDogezJEQ0UxMTNGLTA3MTctNUU4My1BODExLUM2NkQ5RTM3NUI2QX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dEZpZWxkQXJncyA9IHtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtUmljaFRleHQgdGVtcGxhdGUgKElEOiB7MkRDRTExM0YtMDcxNy01RTgzLUE4MTEtQzY2RDlFMzc1QjZBfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0RmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1SaWNoVGV4dCB0ZW1wbGF0ZSAoSUQ6IHsyRENFMTEzRi0wNzE3LTVFODMtQTgxMS1DNjZEOUUzNzVCNkF9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHRIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLVJpY2hUZXh0IHRlbXBsYXRlIChJRDogezJEQ0UxMTNGLTA3MTctNUU4My1BODExLUM2NkQ5RTM3NUI2QX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dElkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1OdW1iZXIgdGVtcGxhdGUgKElEOiB7NkY3MkZCNDYtRDEzRS01QjhGLTkyRUYtMkFCRDdDNUNFNjc4fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciA9IFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCAmIEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogZGVzY3JpcHRpb24gKElEOiB7QjM4NTEwRkYtOEQ4OC01Q0Q3LUJBM0YtMjAxODMxNUQ2QUIyfSkuICovXG4gIGRlc2NyaXB0aW9uPzogTWF5YmU8UmljaFRleHRGaWVsZD47XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIC8qKiBoZWFkaW5nIChJRDogezVBMzAxOUY0LTA2NDctNTdCQS1BM0Y2LTA1Q0VGNjM5QkU5MX0pLiAqL1xuICBoZWFkaW5nPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgLyoqIHNhbXBsZSAoSUQ6IHtCQkIwMTY4Qi1EQ0ZGLTU4MEEtQjdFQS1FQzY5RjkyNDEzMzV9KS4gKi9cbiAgc2FtcGxlPzogTWF5YmU8TnVtYmVyRmllbGQ+O1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLU51bWJlciB0ZW1wbGF0ZSAoSUQ6IHs2RjcyRkI0Ni1EMTNFLTVCOEYtOTJFRi0yQUJEN0M1Q0U2Nzh9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtTnVtYmVyIHRlbXBsYXRlIChJRDogezZGNzJGQjQ2LUQxM0UtNUI4Ri05MkVGLTJBQkQ3QzVDRTY3OH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXJDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xuICBmaXJzdD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbiAgYWZ0ZXI/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtTnVtYmVyIHRlbXBsYXRlIChJRDogezZGNzJGQjQ2LUQxM0UtNUI4Ri05MkVGLTJBQkQ3QzVDRTY3OH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXJGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLU51bWJlciB0ZW1wbGF0ZSAoSUQ6IHs2RjcyRkI0Ni1EMTNFLTVCOEYtOTJFRi0yQUJEN0M1Q0U2Nzh9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1OdW1iZXIgdGVtcGxhdGUgKElEOiB7NkY3MkZCNDYtRDEzRS01QjhGLTkyRUYtMkFCRDdDNUNFNjc4fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlckhhc0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtTnVtYmVyIHRlbXBsYXRlIChJRDogezZGNzJGQjQ2LUQxM0UtNUI4Ri05MkVGLTJBQkQ3QzVDRTY3OH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXJJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtTGluayB0ZW1wbGF0ZSAoSUQ6IHtDMjVGMTVEOC0zREU5LTUzQ0EtQUJFQy1ENjBBMjczMTAzMjR9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluayA9IFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCAmIEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgLyoqIGRlc2NyaXB0aW9uIChJRDoge0IzODUxMEZGLThEODgtNUNENy1CQTNGLTIwMTgzMTVENkFCMn0pLiAqL1xuICBkZXNjcmlwdGlvbj86IE1heWJlPFJpY2hUZXh0RmllbGQ+O1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgLyoqIGVtYWlsTGluayAoSUQ6IHswOTgxMjAwMi00NEE1LTUwMEQtQUNENC0yOEVGNUQwN0IyQUV9KS4gKi9cbiAgZW1haWxMaW5rPzogTWF5YmU8TGlua0ZpZWxkPjtcbiAgLyoqIGV4dGVybmFsTGluayAoSUQ6IHtDMTg0NDNDMi1EOTI2LTU0NkYtOTZFQi1DREE3MDIxMDcxRkF9KS4gKi9cbiAgZXh0ZXJuYWxMaW5rPzogTWF5YmU8TGlua0ZpZWxkPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICBoYXNDaGlsZHJlbjogU2NhbGFyc1snQm9vbGVhbiddO1xuICAvKiogaGVhZGluZyAoSUQ6IHs1QTMwMTlGNC0wNjQ3LTU3QkEtQTNGNi0wNUNFRjYzOUJFOTF9KS4gKi9cbiAgaGVhZGluZz86IE1heWJlPFRleHRGaWVsZD47XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICAvKiogaW50ZXJuYWxMaW5rIChJRDoge0VGMTdEMzNELUM4ODgtNTY2My04Rjk3LTgwMzZCMzg2ODM0MH0pLiAqL1xuICBpbnRlcm5hbExpbms/OiBNYXliZTxMaW5rRmllbGQ+O1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogcGFyYW1zTGluayAoSUQ6IHtDMUJBQjcwMS05MDQ5LTUzNDgtQkU1MC1BNTg3MTlFRTk1M0V9KS4gKi9cbiAgcGFyYW1zTGluaz86IE1heWJlPExpbmtGaWVsZD47XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1MaW5rIHRlbXBsYXRlIChJRDoge0MyNUYxNUQ4LTNERTktNTNDQS1BQkVDLUQ2MEEyNzMxMDMyNH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtTGluayB0ZW1wbGF0ZSAoSUQ6IHtDMjVGMTVEOC0zREU5LTUzQ0EtQUJFQy1ENjBBMjczMTAzMjR9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGlua0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1MaW5rIHRlbXBsYXRlIChJRDoge0MyNUYxNUQ4LTNERTktNTNDQS1BQkVDLUQ2MEEyNzMxMDMyNH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1MaW5rIHRlbXBsYXRlIChJRDoge0MyNUYxNUQ4LTNERTktNTNDQS1BQkVDLUQ2MEEyNzMxMDMyNH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1MaW5rIHRlbXBsYXRlIChJRDoge0MyNUYxNUQ4LTNERTktNTNDQS1BQkVDLUQ2MEEyNzMxMDMyNH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rSGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1MaW5rIHRlbXBsYXRlIChJRDoge0MyNUYxNUQ4LTNERTktNTNDQS1BQkVDLUQ2MEEyNzMxMDMyNH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUl0ZW1MaW5rIHRlbXBsYXRlIChJRDogezY2MDdGMjlDLUY0NTQtNTFFMS1BRkQwLURDQjQxNkVDQTE4Qn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluayA9IFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCAmIEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluayc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIC8qKiBkZXNjcmlwdGlvbiAoSUQ6IHtCMzg1MTBGRi04RDg4LTVDRDctQkEzRi0yMDE4MzE1RDZBQjJ9KS4gKi9cbiAgZGVzY3JpcHRpb24/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgLyoqIGhlYWRpbmcgKElEOiB7NUEzMDE5RjQtMDY0Ny01N0JBLUEzRjYtMDVDRUY2MzlCRTkxfSkuICovXG4gIGhlYWRpbmc/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICAvKiogbG9jYWxJdGVtTGluayAoSUQ6IHs3NzdDNTMxNS0yRDYyLTU3NEMtODEwQS1CNUUyMDNDMzhERDV9KS4gKi9cbiAgbG9jYWxJdGVtTGluaz86IE1heWJlPExvb2t1cEZpZWxkPjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgLyoqIHNoYXJlZEl0ZW1MaW5rIChJRDoge0I0OEI3MzAzLTA0RjUtNTAxNy1BMUMwLTJEQjBGMDhCQzJBRH0pLiAqL1xuICBzaGFyZWRJdGVtTGluaz86IE1heWJlPExvb2t1cEZpZWxkPjtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1JdGVtTGluayB0ZW1wbGF0ZSAoSUQ6IHs2NjA3RjI5Qy1GNDU0LTUxRTEtQUZEMC1EQ0I0MTZFQ0ExOEJ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmtBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1JdGVtTGluayB0ZW1wbGF0ZSAoSUQ6IHs2NjA3RjI5Qy1GNDU0LTUxRTEtQUZEMC1EQ0I0MTZFQ0ExOEJ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmtDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xuICBmaXJzdD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbiAgYWZ0ZXI/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtSXRlbUxpbmsgdGVtcGxhdGUgKElEOiB7NjYwN0YyOUMtRjQ1NC01MUUxLUFGRDAtRENCNDE2RUNBMThCfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1JdGVtTGluayB0ZW1wbGF0ZSAoSUQ6IHs2NjA3RjI5Qy1GNDU0LTUxRTEtQUZEMC1EQ0I0MTZFQ0ExOEJ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmtGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUl0ZW1MaW5rIHRlbXBsYXRlIChJRDogezY2MDdGMjlDLUY0NTQtNTFFMS1BRkQwLURDQjQxNkVDQTE4Qn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGlua0hhc0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtSXRlbUxpbmsgdGVtcGxhdGUgKElEOiB7NjYwN0YyOUMtRjQ1NC01MUUxLUFGRDAtRENCNDE2RUNBMThCfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUltYWdlIHRlbXBsYXRlIChJRDogezJFOTlFODRCLUVEN0YtNTFFQS1BOTAzLUUxRTIyRUYxM0U5Rn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSA9IFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCAmIEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIC8qKiBkZXNjcmlwdGlvbiAoSUQ6IHtCMzg1MTBGRi04RDg4LTVDRDctQkEzRi0yMDE4MzE1RDZBQjJ9KS4gKi9cbiAgZGVzY3JpcHRpb24/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgLyoqIGhlYWRpbmcgKElEOiB7NUEzMDE5RjQtMDY0Ny01N0JBLUEzRjYtMDVDRUY2MzlCRTkxfSkuICovXG4gIGhlYWRpbmc/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICAvKiogc2FtcGxlMSAoSUQ6IHszRjAyRTQ1Ny03RUI2LTVEMTUtQUM5NS01QTIyODdERDE0QTl9KS4gKi9cbiAgc2FtcGxlMT86IE1heWJlPEltYWdlRmllbGQ+O1xuICAvKiogc2FtcGxlMiAoSUQ6IHsxMzRDMTkwNy00MDQxLTUyQTYtOEJGNy00N0VERDFCOEQxNTl9KS4gKi9cbiAgc2FtcGxlMj86IE1heWJlPEltYWdlRmllbGQ+O1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUltYWdlIHRlbXBsYXRlIChJRDogezJFOTlFODRCLUVEN0YtNTFFQS1BOTAzLUUxRTIyRUYxM0U5Rn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZUFuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUltYWdlIHRlbXBsYXRlIChJRDogezJFOTlFODRCLUVEN0YtNTFFQS1BOTAzLUUxRTIyRUYxM0U5Rn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZUNoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1JbWFnZSB0ZW1wbGF0ZSAoSUQ6IHsyRTk5RTg0Qi1FRDdGLTUxRUEtQTkwMy1FMUUyMkVGMTNFOUZ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2VGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUltYWdlIHRlbXBsYXRlIChJRDogezJFOTlFODRCLUVEN0YtNTFFQS1BOTAzLUUxRTIyRUYxM0U5Rn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZUZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtSW1hZ2UgdGVtcGxhdGUgKElEOiB7MkU5OUU4NEItRUQ3Ri01MUVBLUE5MDMtRTFFMjJFRjEzRTlGfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlSGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1JbWFnZSB0ZW1wbGF0ZSAoSUQ6IHsyRTk5RTg0Qi1FRDdGLTUxRUEtQTkwMy1FMUUyMkVGMTNFOUZ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2VJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtRmlsZSB0ZW1wbGF0ZSAoSUQ6IHtGNEZFRjkzMy04MDQ3LTUxQjItOEE2Qy0yMDJCRDZBOTIxQTF9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSA9IFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCAmIEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgLyoqIGRlc2NyaXB0aW9uIChJRDoge0IzODUxMEZGLThEODgtNUNENy1CQTNGLTIwMTgzMTVENkFCMn0pLiAqL1xuICBkZXNjcmlwdGlvbj86IE1heWJlPFJpY2hUZXh0RmllbGQ+O1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICAvKiogZmlsZSAoSUQ6IHs3Q0JFNDBFQS1EQUVCLTU2N0ItQTc0Ni04MzYxRTlFOUEzODl9KS4gKi9cbiAgZmlsZT86IE1heWJlPFRleHRGaWVsZD47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIC8qKiBoZWFkaW5nIChJRDogezVBMzAxOUY0LTA2NDctNTdCQS1BM0Y2LTA1Q0VGNjM5QkU5MX0pLiAqL1xuICBoZWFkaW5nPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1GaWxlIHRlbXBsYXRlIChJRDoge0Y0RkVGOTMzLTgwNDctNTFCMi04QTZDLTIwMkJENkE5MjFBMX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtRmlsZSB0ZW1wbGF0ZSAoSUQ6IHtGNEZFRjkzMy04MDQ3LTUxQjItOEE2Qy0yMDJCRDZBOTIxQTF9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZUNoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1GaWxlIHRlbXBsYXRlIChJRDoge0Y0RkVGOTMzLTgwNDctNTFCMi04QTZDLTIwMkJENkE5MjFBMX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1GaWxlIHRlbXBsYXRlIChJRDoge0Y0RkVGOTMzLTgwNDctNTFCMi04QTZDLTIwMkJENkE5MjFBMX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1GaWxlIHRlbXBsYXRlIChJRDoge0Y0RkVGOTMzLTgwNDctNTFCMi04QTZDLTIwMkJENkE5MjFBMX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlSGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1GaWxlIHRlbXBsYXRlIChJRDoge0Y0RkVGOTMzLTgwNDctNTFCMi04QTZDLTIwMkJENkE5MjFBMX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLURhdGUgdGVtcGxhdGUgKElEOiB7QzMwODUyQzAtNEU4MC01QkRBLUE0MzUtRjdBMTFBNUY0NERFfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUgPSBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQgJiBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIC8qKiBkYXRlIChJRDogezc0MkQ1Mzc5LTIyQzgtNURFNy1CMUM4LTgwMkI3QUFBMjk2QX0pLiAqL1xuICBkYXRlPzogTWF5YmU8RGF0ZUZpZWxkPjtcbiAgLyoqIGRhdGVUaW1lIChJRDogezQ2QzJGQzczLUUyRjQtNTVEMy1CNEIyLUMwQzg4N0UzNUVFNH0pLiAqL1xuICBkYXRlVGltZT86IE1heWJlPERhdGVGaWVsZD47XG4gIC8qKiBkZXNjcmlwdGlvbiAoSUQ6IHtCMzg1MTBGRi04RDg4LTVDRDctQkEzRi0yMDE4MzE1RDZBQjJ9KS4gKi9cbiAgZGVzY3JpcHRpb24/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgLyoqIGhlYWRpbmcgKElEOiB7NUEzMDE5RjQtMDY0Ny01N0JBLUEzRjYtMDVDRUY2MzlCRTkxfSkuICovXG4gIGhlYWRpbmc/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLURhdGUgdGVtcGxhdGUgKElEOiB7QzMwODUyQzAtNEU4MC01QkRBLUE0MzUtRjdBMTFBNUY0NERFfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZURhdGVBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1EYXRlIHRlbXBsYXRlIChJRDoge0MzMDg1MkMwLTRFODAtNUJEQS1BNDM1LUY3QTExQTVGNDRERX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLURhdGUgdGVtcGxhdGUgKElEOiB7QzMwODUyQzAtNEU4MC01QkRBLUE0MzUtRjdBMTFBNUY0NERFfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZURhdGVGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLURhdGUgdGVtcGxhdGUgKElEOiB7QzMwODUyQzAtNEU4MC01QkRBLUE0MzUtRjdBMTFBNUY0NERFfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZURhdGVGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLURhdGUgdGVtcGxhdGUgKElEOiB7QzMwODUyQzAtNEU4MC01QkRBLUE0MzUtRjdBMTFBNUY0NERFfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZURhdGVIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLURhdGUgdGVtcGxhdGUgKElEOiB7QzMwODUyQzAtNEU4MC01QkRBLUE0MzUtRjdBMTFBNUY0NERFfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZURhdGVJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ3VzdG9tIHRlbXBsYXRlIChJRDogezZBNEIzRTQzLTEwMjMtNUFGNi04OUUzLTk5MTM3RDdEQjAzN30pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20gPSBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQgJiBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgLyoqIGN1c3RvbUludEZpZWxkIChJRDoge0E0OTkyMEE1LTJFMzYtNTRGRC04OEU5LUVFOURENkExQzFEQ30pLiAqL1xuICBjdXN0b21JbnRGaWVsZD86IE1heWJlPEludGVnZXJGaWVsZD47XG4gIC8qKiBkZXNjcmlwdGlvbiAoSUQ6IHtCMzg1MTBGRi04RDg4LTVDRDctQkEzRi0yMDE4MzE1RDZBQjJ9KS4gKi9cbiAgZGVzY3JpcHRpb24/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgLyoqIGhlYWRpbmcgKElEOiB7NUEzMDE5RjQtMDY0Ny01N0JBLUEzRjYtMDVDRUY2MzlCRTkxfSkuICovXG4gIGhlYWRpbmc/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUN1c3RvbSB0ZW1wbGF0ZSAoSUQ6IHs2QTRCM0U0My0xMDIzLTVBRjYtODlFMy05OTEzN0Q3REIwMzd9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ3VzdG9tIHRlbXBsYXRlIChJRDogezZBNEIzRTQzLTEwMjMtNUFGNi04OUUzLTk5MTM3RDdEQjAzN30pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b21DaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xuICBmaXJzdD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbiAgYWZ0ZXI/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ3VzdG9tIHRlbXBsYXRlIChJRDogezZBNEIzRTQzLTEwMjMtNUFGNi04OUUzLTk5MTM3RDdEQjAzN30pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b21GaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUN1c3RvbSB0ZW1wbGF0ZSAoSUQ6IHs2QTRCM0U0My0xMDIzLTVBRjYtODlFMy05OTEzN0Q3REIwMzd9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1DdXN0b20gdGVtcGxhdGUgKElEOiB7NkE0QjNFNDMtMTAyMy01QUY2LTg5RTMtOTkxMzdEN0RCMDM3fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbUhhc0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ3VzdG9tIHRlbXBsYXRlIChJRDogezZBNEIzRTQzLTEwMjMtNUFGNi04OUUzLTk5MTM3RDdEQjAzN30pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b21JZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ29udGVudExpc3QgdGVtcGxhdGUgKElEOiB7RkNGRTlGN0QtN0RDMy01MjdGLUIwREQtNjIwNkYyMEFDQzg4fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0ID0gU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50ICYgSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgLyoqIGRlc2NyaXB0aW9uIChJRDoge0IzODUxMEZGLThEODgtNUNENy1CQTNGLTIwMTgzMTVENkFCMn0pLiAqL1xuICBkZXNjcmlwdGlvbj86IE1heWJlPFJpY2hUZXh0RmllbGQ+O1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICBoYXNDaGlsZHJlbjogU2NhbGFyc1snQm9vbGVhbiddO1xuICAvKiogaGVhZGluZyAoSUQ6IHs1QTMwMTlGNC0wNjQ3LTU3QkEtQTNGNi0wNUNFRjYzOUJFOTF9KS4gKi9cbiAgaGVhZGluZz86IE1heWJlPFRleHRGaWVsZD47XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIC8qKiBsb2NhbENvbnRlbnRMaXN0IChJRDogezc4ODNDQTc5LUVDNUItNTdCNC05NEM2LUFDRDYzRTI5NTg0NX0pLiAqL1xuICBsb2NhbENvbnRlbnRMaXN0PzogTWF5YmU8TXVsdGlsaXN0RmllbGQ+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICAvKiogc2hhcmVkQ29udGVudExpc3QgKElEOiB7MTk1RkI3MzgtMEI3NS01QzkyLTlDOEQtQzVBNjEzQTM4OEU1fSkuICovXG4gIHNoYXJlZENvbnRlbnRMaXN0PzogTWF5YmU8TXVsdGlsaXN0RmllbGQ+O1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUNvbnRlbnRMaXN0IHRlbXBsYXRlIChJRDoge0ZDRkU5RjdELTdEQzMtNTI3Ri1CMERELTYyMDZGMjBBQ0M4OH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdEFuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUNvbnRlbnRMaXN0IHRlbXBsYXRlIChJRDoge0ZDRkU5RjdELTdEQzMtNTI3Ri1CMERELTYyMDZGMjBBQ0M4OH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdENoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1Db250ZW50TGlzdCB0ZW1wbGF0ZSAoSUQ6IHtGQ0ZFOUY3RC03REMzLTUyN0YtQjBERC02MjA2RjIwQUNDODh9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3RGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUNvbnRlbnRMaXN0IHRlbXBsYXRlIChJRDoge0ZDRkU5RjdELTdEQzMtNTI3Ri1CMERELTYyMDZGMjBBQ0M4OH0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdEZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ29udGVudExpc3QgdGVtcGxhdGUgKElEOiB7RkNGRTlGN0QtN0RDMy01MjdGLUIwREQtNjIwNkYyMEFDQzg4fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0SGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1Db250ZW50TGlzdCB0ZW1wbGF0ZSAoSUQ6IHtGQ0ZFOUY3RC03REMzLTUyN0YtQjBERC02MjA2RjIwQUNDODh9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3RJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ2hlY2tib3ggdGVtcGxhdGUgKElEOiB7OTNEODY1NkYtQTNCRC01MzRELUJERDYtRDJDNTVFNkExRUYyfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94ID0gU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50ICYgSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIC8qKiBjaGVja2JveCAoSUQ6IHtCOEE4MEI0Qy1FMDI5LTU4MEMtQURGMy0yNEExQ0NEQUE2RDl9KS4gKi9cbiAgY2hlY2tib3g/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIGNoZWNrYm94MiAoSUQ6IHtGN0U3ODBDQy1EQUI0LTU4NDUtOUNGNy02MTE5MTE1RDExRTF9KS4gKi9cbiAgY2hlY2tib3gyPzogTWF5YmU8Q2hlY2tib3hGaWVsZD47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgLyoqIGRlc2NyaXB0aW9uIChJRDoge0IzODUxMEZGLThEODgtNUNENy1CQTNGLTIwMTgzMTVENkFCMn0pLiAqL1xuICBkZXNjcmlwdGlvbj86IE1heWJlPFJpY2hUZXh0RmllbGQ+O1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICBoYXNDaGlsZHJlbjogU2NhbGFyc1snQm9vbGVhbiddO1xuICAvKiogaGVhZGluZyAoSUQ6IHs1QTMwMTlGNC0wNjQ3LTU3QkEtQTNGNi0wNUNFRjYzOUJFOTF9KS4gKi9cbiAgaGVhZGluZz86IE1heWJlPFRleHRGaWVsZD47XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBwYXJlbnQ/OiBNYXliZTxJdGVtPjtcbiAgcGF0aDogU2NhbGFyc1snU3RyaW5nJ107XG4gIHJlbmRlcmVkOiBTY2FsYXJzWydKU09OJ107XG4gIHRlbXBsYXRlOiBJdGVtVGVtcGxhdGU7XG4gIHVybDogSXRlbVVybDtcbiAgdmVyc2lvbjogU2NhbGFyc1snSW50J107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ2hlY2tib3ggdGVtcGxhdGUgKElEOiB7OTNEODY1NkYtQTNCRC01MzRELUJERDYtRDJDNTVFNkExRUYyfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94QW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ2hlY2tib3ggdGVtcGxhdGUgKElEOiB7OTNEODY1NkYtQTNCRC01MzRELUJERDYtRDJDNTVFNkExRUYyfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94Q2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUNoZWNrYm94IHRlbXBsYXRlIChJRDogezkzRDg2NTZGLUEzQkQtNTM0RC1CREQ2LUQyQzU1RTZBMUVGMn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveEZpZWxkQXJncyA9IHtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ2hlY2tib3ggdGVtcGxhdGUgKElEOiB7OTNEODY1NkYtQTNCRC01MzRELUJERDYtRDJDNTVFNkExRUYyfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94RmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1DaGVja2JveCB0ZW1wbGF0ZSAoSUQ6IHs5M0Q4NjU2Ri1BM0JELTUzNEQtQkRENi1EMkM1NUU2QTFFRjJ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3hIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUNoZWNrYm94IHRlbXBsYXRlIChJRDogezkzRDg2NTZGLUEzQkQtNTM0RC1CREQ2LUQyQzU1RTZBMUVGMn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveElkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRXhwbGFuYXRvcnktQ29tcG9uZW50IHRlbXBsYXRlIChJRDogezEyN0NGQUE0LTQ2ODktNTM2Qi1BRjk4LTY0OERCMURDMEZCRX0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCA9IFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCAmIEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgLyoqIGRlc2NyaXB0aW9uIChJRDoge0IzODUxMEZGLThEODgtNUNENy1CQTNGLTIwMTgzMTVENkFCMn0pLiAqL1xuICBkZXNjcmlwdGlvbj86IE1heWJlPFJpY2hUZXh0RmllbGQ+O1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICBoYXNDaGlsZHJlbjogU2NhbGFyc1snQm9vbGVhbiddO1xuICAvKiogaGVhZGluZyAoSUQ6IHs1QTMwMTlGNC0wNjQ3LTU3QkEtQTNGNi0wNUNFRjYzOUJFOTF9KS4gKi9cbiAgaGVhZGluZz86IE1heWJlPFRleHRGaWVsZD47XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBwYXJlbnQ/OiBNYXliZTxJdGVtPjtcbiAgcGF0aDogU2NhbGFyc1snU3RyaW5nJ107XG4gIHJlbmRlcmVkOiBTY2FsYXJzWydKU09OJ107XG4gIHRlbXBsYXRlOiBJdGVtVGVtcGxhdGU7XG4gIHVybDogSXRlbVVybDtcbiAgdmVyc2lvbjogU2NhbGFyc1snSW50J107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUV4cGxhbmF0b3J5LUNvbXBvbmVudCB0ZW1wbGF0ZSAoSUQ6IHsxMjdDRkFBNC00Njg5LTUzNkItQUY5OC02NDhEQjFEQzBGQkV9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50KSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnRBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRXhwbGFuYXRvcnktQ29tcG9uZW50IHRlbXBsYXRlIChJRDogezEyN0NGQUE0LTQ2ODktNTM2Qi1BRjk4LTY0OERCMURDMEZCRX0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudENoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRXhwbGFuYXRvcnktQ29tcG9uZW50IHRlbXBsYXRlIChJRDogezEyN0NGQUE0LTQ2ODktNTM2Qi1BRjk4LTY0OERCMURDMEZCRX0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudEZpZWxkQXJncyA9IHtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUV4cGxhbmF0b3J5LUNvbXBvbmVudCB0ZW1wbGF0ZSAoSUQ6IHsxMjdDRkFBNC00Njg5LTUzNkItQUY5OC02NDhEQjFEQzBGQkV9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50KSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnRGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1FeHBsYW5hdG9yeS1Db21wb25lbnQgdGVtcGxhdGUgKElEOiB7MTI3Q0ZBQTQtNDY4OS01MzZCLUFGOTgtNjQ4REIxREMwRkJFfSkuIE5PVEU6IFRoaXMgaXMgYSBjb25jcmV0ZSB0eXBlLiBGYXZvciB1c2luZyBpbnRlcmZhY2VzIGluc3RlYWQgb2YgdGhpcyB0eXBlIChlLmcuIFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCkgZm9yIHJlbGlhYmxlIHF1ZXJ5aW5nLiAqL1xuZXhwb3J0IHR5cGUgQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50SGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtRXhwbGFuYXRvcnktQ29tcG9uZW50IHRlbXBsYXRlIChJRDogezEyN0NGQUE0LTQ2ODktNTM2Qi1BRjk4LTY0OERCMURDMEZCRX0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudElkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtQ29udGVudExpc3QtSXRlbS1UZW1wbGF0ZSB0ZW1wbGF0ZSAoSUQ6IHtDREVDODZERS02NjE3LTU4QzItOTRCRS0wN0U5NUEwRkMwRUJ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSA9IEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgLyoqIHRleHRGaWVsZCAoSUQ6IHtDOUMxM0VFMS1EMDVCLTU3MUItODE4NC1FMDEzMUQyRDZGQUZ9KS4gKi9cbiAgdGV4dEZpZWxkPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtQ29udGVudExpc3QtSXRlbS1UZW1wbGF0ZSB0ZW1wbGF0ZSAoSUQ6IHtDREVDODZERS02NjE3LTU4QzItOTRCRS0wN0U5NUEwRkMwRUJ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZUFuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db250ZW50TGlzdC1JdGVtLVRlbXBsYXRlIHRlbXBsYXRlIChJRDoge0NERUM4NkRFLTY2MTctNThDMi05NEJFLTA3RTk1QTBGQzBFQn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db250ZW50TGlzdC1JdGVtLVRlbXBsYXRlIHRlbXBsYXRlIChJRDoge0NERUM4NkRFLTY2MTctNThDMi05NEJFLTA3RTk1QTBGQzBFQn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtQ29udGVudExpc3QtSXRlbS1UZW1wbGF0ZSB0ZW1wbGF0ZSAoSUQ6IHtDREVDODZERS02NjE3LTU4QzItOTRCRS0wN0U5NUEwRkMwRUJ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZUZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUNvbnRlbnRMaXN0LUl0ZW0tVGVtcGxhdGUgdGVtcGxhdGUgKElEOiB7Q0RFQzg2REUtNjYxNy01OEMyLTk0QkUtMDdFOTVBMEZDMEVCfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGVIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db250ZW50TGlzdC1JdGVtLVRlbXBsYXRlIHRlbXBsYXRlIChJRDoge0NERUM4NkRFLTY2MTctNThDMi05NEJFLTA3RTk1QTBGQzBFQn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db21wb25lbnRQYXJhbXMgUmVuZGVyaW5nIFBhcmFtZXRlcnMgdGVtcGxhdGUgKElEOiB7NTdGMUM0RDMtNjQ5NC01MzM5LUE3REQtQzY3NTg2QjVDRTRGfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycyA9IEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogY29sdW1ucyAoSUQ6IHs4MEJBOTIxRi1DRTU2LTU1NUUtQjlCNy0xQzZGNjA2N0QxMDJ9KS4gKi9cbiAgY29sdW1ucz86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBjc3NDbGFzcyAoSUQ6IHtFOEExOEYzRi02NTM3LTVCMjktODAxRS02QTZBODNDNDZGRTJ9KS4gKi9cbiAgY3NzQ2xhc3M/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICBoYXNDaGlsZHJlbjogU2NhbGFyc1snQm9vbGVhbiddO1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIC8qKiB1c2VDYWxsVG9BY3Rpb24gKElEOiB7RkQ5MzZDODEtRDJDRC01MDQ5LTg1QUUtRTkxREVCQjVCMzRCfSkuICovXG4gIHVzZUNhbGxUb0FjdGlvbj86IE1heWJlPFRleHRGaWVsZD47XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db21wb25lbnRQYXJhbXMgUmVuZGVyaW5nIFBhcmFtZXRlcnMgdGVtcGxhdGUgKElEOiB7NTdGMUM0RDMtNjQ5NC01MzM5LUE3REQtQzY3NTg2QjVDRTRGfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVyc0FuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db21wb25lbnRQYXJhbXMgUmVuZGVyaW5nIFBhcmFtZXRlcnMgdGVtcGxhdGUgKElEOiB7NTdGMUM0RDMtNjQ5NC01MzM5LUE3REQtQzY3NTg2QjVDRTRGfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVyc0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtQ29tcG9uZW50UGFyYW1zIFJlbmRlcmluZyBQYXJhbWV0ZXJzIHRlbXBsYXRlIChJRDogezU3RjFDNEQzLTY0OTQtNTMzOS1BN0RELUM2NzU4NkI1Q0U0Rn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnNGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db21wb25lbnRQYXJhbXMgUmVuZGVyaW5nIFBhcmFtZXRlcnMgdGVtcGxhdGUgKElEOiB7NTdGMUM0RDMtNjQ5NC01MzM5LUE3REQtQzY3NTg2QjVDRTRGfSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVyc0ZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUNvbXBvbmVudFBhcmFtcyBSZW5kZXJpbmcgUGFyYW1ldGVycyB0ZW1wbGF0ZSAoSUQ6IHs1N0YxQzREMy02NDk0LTUzMzktQTdERC1DNjc1ODZCNUNFNEZ9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzSGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtQ29tcG9uZW50UGFyYW1zIFJlbmRlcmluZyBQYXJhbWV0ZXJzIHRlbXBsYXRlIChJRDogezU3RjFDNEQzLTY0OTQtNTMzOS1BN0RELUM2NzU4NkI1Q0U0Rn0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnNJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUNvbXBvbmVudFBhcmFtcyB0ZW1wbGF0ZSAoSUQ6IHs0MjhDNjcyNC1DMTEyLTUyNTYtOTQ1Ny1CMkQ2NzdFMkFEOTl9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMgPSBTdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQgJiBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogZGVzY3JpcHRpb24gKElEOiB7QjM4NTEwRkYtOEQ4OC01Q0Q3LUJBM0YtMjAxODMxNUQ2QUIyfSkuICovXG4gIGRlc2NyaXB0aW9uPzogTWF5YmU8UmljaFRleHRGaWVsZD47XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIC8qKiBoZWFkaW5nIChJRDogezVBMzAxOUY0LTA2NDctNTdCQS1BM0Y2LTA1Q0VGNjM5QkU5MX0pLiAqL1xuICBoZWFkaW5nPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtQ29tcG9uZW50UGFyYW1zIHRlbXBsYXRlIChJRDogezQyOEM2NzI0LUMxMTItNTI1Ni05NDU3LUIyRDY3N0UyQUQ5OX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc0FuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db21wb25lbnRQYXJhbXMgdGVtcGxhdGUgKElEOiB7NDI4QzY3MjQtQzExMi01MjU2LTk0NTctQjJENjc3RTJBRDk5fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db21wb25lbnRQYXJhbXMgdGVtcGxhdGUgKElEOiB7NDI4QzY3MjQtQzExMi01MjU2LTk0NTctQjJENjc3RTJBRDk5fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL1N0eWxlZ3VpZGUtQ29tcG9uZW50UGFyYW1zIHRlbXBsYXRlIChJRDogezQyOEM2NzI0LUMxMTItNTI1Ni05NDU3LUIyRDY3N0UyQUQ5OX0pLiAqL1xuZXhwb3J0IHR5cGUgU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc0ZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUNvbXBvbmVudFBhcmFtcyB0ZW1wbGF0ZSAoSUQ6IHs0MjhDNjcyNC1DMTEyLTUyNTYtOTQ1Ny1CMkQ2NzdFMkFEOTl9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvU3R5bGVndWlkZS1Db21wb25lbnRQYXJhbXMgdGVtcGxhdGUgKElEOiB7NDI4QzY3MjQtQzExMi01MjU2LTk0NTctQjJENjc3RTJBRDk5fSkuICovXG5leHBvcnQgdHlwZSBTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9TeXN0ZW0vVGVtcGxhdGVzL1N0YW5kYXJkIHRlbXBsYXRlIHRlbXBsYXRlIChJRDogezE5MzBCQkVCLTc4MDUtNDcxQS1BM0JFLTQ4NThBQzdDRjY5Nn0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBTdGFuZGFyZFRlbXBsYXRlKSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19TdGFuZGFyZFRlbXBsYXRlID0gSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvU3lzdGVtL1RlbXBsYXRlcy9TdGFuZGFyZCB0ZW1wbGF0ZSB0ZW1wbGF0ZSAoSUQ6IHsxOTMwQkJFQi03ODA1LTQ3MUEtQTNCRS00ODU4QUM3Q0Y2OTZ9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gU3RhbmRhcmRUZW1wbGF0ZSkgZm9yIHJlbGlhYmxlIHF1ZXJ5aW5nLiAqL1xuZXhwb3J0IHR5cGUgQ19fU3RhbmRhcmRUZW1wbGF0ZUFuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9TeXN0ZW0vVGVtcGxhdGVzL1N0YW5kYXJkIHRlbXBsYXRlIHRlbXBsYXRlIChJRDogezE5MzBCQkVCLTc4MDUtNDcxQS1BM0JFLTQ4NThBQzdDRjY5Nn0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBTdGFuZGFyZFRlbXBsYXRlKSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19TdGFuZGFyZFRlbXBsYXRlQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9TeXN0ZW0vVGVtcGxhdGVzL1N0YW5kYXJkIHRlbXBsYXRlIHRlbXBsYXRlIChJRDogezE5MzBCQkVCLTc4MDUtNDcxQS1BM0JFLTQ4NThBQzdDRjY5Nn0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBTdGFuZGFyZFRlbXBsYXRlKSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19TdGFuZGFyZFRlbXBsYXRlRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvU3lzdGVtL1RlbXBsYXRlcy9TdGFuZGFyZCB0ZW1wbGF0ZSB0ZW1wbGF0ZSAoSUQ6IHsxOTMwQkJFQi03ODA1LTQ3MUEtQTNCRS00ODU4QUM3Q0Y2OTZ9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gU3RhbmRhcmRUZW1wbGF0ZSkgZm9yIHJlbGlhYmxlIHF1ZXJ5aW5nLiAqL1xuZXhwb3J0IHR5cGUgQ19fU3RhbmRhcmRUZW1wbGF0ZUZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1N5c3RlbS9UZW1wbGF0ZXMvU3RhbmRhcmQgdGVtcGxhdGUgdGVtcGxhdGUgKElEOiB7MTkzMEJCRUItNzgwNS00NzFBLUEzQkUtNDg1OEFDN0NGNjk2fSkuIE5PVEU6IFRoaXMgaXMgYSBjb25jcmV0ZSB0eXBlLiBGYXZvciB1c2luZyBpbnRlcmZhY2VzIGluc3RlYWQgb2YgdGhpcyB0eXBlIChlLmcuIFN0YW5kYXJkVGVtcGxhdGUpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX1N0YW5kYXJkVGVtcGxhdGVIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9TeXN0ZW0vVGVtcGxhdGVzL1N0YW5kYXJkIHRlbXBsYXRlIHRlbXBsYXRlIChJRDogezE5MzBCQkVCLTc4MDUtNDcxQS1BM0JFLTQ4NThBQzdDRjY5Nn0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBTdGFuZGFyZFRlbXBsYXRlKSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19TdGFuZGFyZFRlbXBsYXRlSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvUm91dGUgdGVtcGxhdGUgKElEOiB7QjM2QkE5RkQtMERDMC00OUM4LUJFQTItRTU1RDcwRTZBRjI4fSkuIE5PVEU6IFRoaXMgaXMgYSBjb25jcmV0ZSB0eXBlLiBGYXZvciB1c2luZyBpbnRlcmZhY2VzIGluc3RlYWQgb2YgdGhpcyB0eXBlIChlLmcuIFJvdXRlKSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19Sb3V0ZSA9IEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICBoYXNDaGlsZHJlbjogU2NhbGFyc1snQm9vbGVhbiddO1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvUm91dGUgdGVtcGxhdGUgKElEOiB7QjM2QkE5RkQtMERDMC00OUM4LUJFQTItRTU1RDcwRTZBRjI4fSkuIE5PVEU6IFRoaXMgaXMgYSBjb25jcmV0ZSB0eXBlLiBGYXZvciB1c2luZyBpbnRlcmZhY2VzIGluc3RlYWQgb2YgdGhpcyB0eXBlIChlLmcuIFJvdXRlKSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19Sb3V0ZUFuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvUm91dGUgdGVtcGxhdGUgKElEOiB7QjM2QkE5RkQtMERDMC00OUM4LUJFQTItRTU1RDcwRTZBRjI4fSkuIE5PVEU6IFRoaXMgaXMgYSBjb25jcmV0ZSB0eXBlLiBGYXZvciB1c2luZyBpbnRlcmZhY2VzIGluc3RlYWQgb2YgdGhpcyB0eXBlIChlLmcuIFJvdXRlKSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19Sb3V0ZUNoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL1JvdXRlIHRlbXBsYXRlIChJRDoge0IzNkJBOUZELTBEQzAtNDlDOC1CRUEyLUU1NUQ3MEU2QUYyOH0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBSb3V0ZSkgZm9yIHJlbGlhYmxlIHF1ZXJ5aW5nLiAqL1xuZXhwb3J0IHR5cGUgQ19fUm91dGVGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvUm91dGUgdGVtcGxhdGUgKElEOiB7QjM2QkE5RkQtMERDMC00OUM4LUJFQTItRTU1RDcwRTZBRjI4fSkuIE5PVEU6IFRoaXMgaXMgYSBjb25jcmV0ZSB0eXBlLiBGYXZvciB1c2luZyBpbnRlcmZhY2VzIGluc3RlYWQgb2YgdGhpcyB0eXBlIChlLmcuIFJvdXRlKSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19Sb3V0ZUZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9Sb3V0ZSB0ZW1wbGF0ZSAoSUQ6IHtCMzZCQTlGRC0wREMwLTQ5QzgtQkVBMi1FNTVENzBFNkFGMjh9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gUm91dGUpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX1JvdXRlSGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL1JvdXRlIHRlbXBsYXRlIChJRDoge0IzNkJBOUZELTBEQzAtNDlDOC1CRUEyLUU1NUQ3MEU2QUYyOH0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBSb3V0ZSkgZm9yIHJlbGlhYmxlIHF1ZXJ5aW5nLiAqL1xuZXhwb3J0IHR5cGUgQ19fUm91dGVJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9SZW5kZXIgRW5naW5lIFR5cGUgdGVtcGxhdGUgKElEOiB7N0ZFQzM5NjMtMEFDNi00NzQzLUIwMkMtMzVFNjk3MTMwMEVEfSkuICovXG5leHBvcnQgdHlwZSBSZW5kZXJFbmdpbmVUeXBlID0gSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIC8qKiBFbmdpbmUgVHlwZSBOYW1lIChJRDogezkwQzZBQUYxLTk5NjItNERDOS1BNzMwLTVFNTk1MkIzQUU1MX0pLiAqL1xuICBlbmdpbmVUeXBlTmFtZT86IE1heWJlPFRleHRGaWVsZD47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL1JlbmRlciBFbmdpbmUgVHlwZSB0ZW1wbGF0ZSAoSUQ6IHs3RkVDMzk2My0wQUM2LTQ3NDMtQjAyQy0zNUU2OTcxMzAwRUR9KS4gKi9cbmV4cG9ydCB0eXBlIFJlbmRlckVuZ2luZVR5cGVBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL1JlbmRlciBFbmdpbmUgVHlwZSB0ZW1wbGF0ZSAoSUQ6IHs3RkVDMzk2My0wQUM2LTQ3NDMtQjAyQy0zNUU2OTcxMzAwRUR9KS4gKi9cbmV4cG9ydCB0eXBlIFJlbmRlckVuZ2luZVR5cGVDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xuICBmaXJzdD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbiAgYWZ0ZXI/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9SZW5kZXIgRW5naW5lIFR5cGUgdGVtcGxhdGUgKElEOiB7N0ZFQzM5NjMtMEFDNi00NzQzLUIwMkMtMzVFNjk3MTMwMEVEfSkuICovXG5leHBvcnQgdHlwZSBSZW5kZXJFbmdpbmVUeXBlRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL1JlbmRlciBFbmdpbmUgVHlwZSB0ZW1wbGF0ZSAoSUQ6IHs3RkVDMzk2My0wQUM2LTQ3NDMtQjAyQy0zNUU2OTcxMzAwRUR9KS4gKi9cbmV4cG9ydCB0eXBlIFJlbmRlckVuZ2luZVR5cGVGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvUmVuZGVyIEVuZ2luZSBUeXBlIHRlbXBsYXRlIChJRDogezdGRUMzOTYzLTBBQzYtNDc0My1CMDJDLTM1RTY5NzEzMDBFRH0pLiAqL1xuZXhwb3J0IHR5cGUgUmVuZGVyRW5naW5lVHlwZUhhc0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9SZW5kZXIgRW5naW5lIFR5cGUgdGVtcGxhdGUgKElEOiB7N0ZFQzM5NjMtMEFDNi00NzQzLUIwMkMtMzVFNjk3MTMwMEVEfSkuICovXG5leHBvcnQgdHlwZSBSZW5kZXJFbmdpbmVUeXBlSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvSnNvbiBSZW5kZXJpbmcgdGVtcGxhdGUgKElEOiB7MDQ2NDZBODktOTk2Ri00RUU3LTg3OEEtRkZEQkYxRjBFRjBEfSkuICovXG5leHBvcnQgdHlwZSBKc29uUmVuZGVyaW5nID0gUmVuZGVyaW5nT3B0aW9ucyAmIENhY2hpbmcgJiBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnO1xuICAvKiogQWRkRmllbGRFZGl0b3JCdXR0b24gKElEOiB7QzM5QTkwQ0UtMDAzNS00MUJCLTkwRjYtM0M4QTZFQTg3Nzk3fSkuICovXG4gIGFkZEZpZWxkRWRpdG9yQnV0dG9uPzogTWF5YmU8Q2hlY2tib3hGaWVsZD47XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICAvKiogQ2FjaGVhYmxlIChJRDogezNEMDhEQjQ2LTIyNjctNDFCMC1CQzUyLUJFNjlGRDYxODYzM30pLiAqL1xuICBjYWNoZWFibGU/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIENhY2hlQ2xlYXJpbmdCZWhhdmlvciAoSUQ6IHtBNkQ0RkMxRC0wODAzLTRFMEEtOTE0NS1COEM2MTIxRDZGMjZ9KS4gKi9cbiAgY2FjaGVDbGVhcmluZ0JlaGF2aW9yPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogQ2xlYXJPbkluZGV4VXBkYXRlIChJRDoge0YzRTdFNTUyLUQ3QzgtNDY5Qi1BMTUwLTY5RTRFMTRBQjM1Q30pLiAqL1xuICBjbGVhck9uSW5kZXhVcGRhdGU/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIENvbXBhdGlibGUgUmVuZGVyaW5ncyAoSUQ6IHtFNDQxQUJFNy0yQ0EzLTQ2NDAtQUUyNi0zNzg5OTY3OTI1RDd9KS4gKi9cbiAgY29tcGF0aWJsZVJlbmRlcmluZ3M/OiBNYXliZTxNdWx0aWxpc3RGaWVsZD47XG4gIC8qKiBjb21wb25lbnROYW1lIChJRDogezAzN0ZFNDA0LUREMTktNEJGNy04RTMwLTREQURGNjhCMjdCMH0pLiAqL1xuICBjb21wb25lbnROYW1lPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgLyoqIENvbXBvbmVudFF1ZXJ5IChJRDogezE3QkIwNDZBLUEzMkEtNDFCMy04MzE1LTgxMjE3OTQ3NjExQn0pLiAqL1xuICBjb21wb25lbnRRdWVyeT86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBDdXN0b21pemUgUGFnZSAoSUQ6IHs3MDVBNDM2NS0wNjVBLTQxMDQtQjc1NS03MzYzRjQ1NUVCQzZ9KS4gKi9cbiAgY3VzdG9taXplUGFnZT86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBEYXRhIHNvdXJjZSAoSUQ6IHswMDNBNzJDRC00Q0Q2LTQzOTItOTg2Mi00MUQ0MTU5OTI5Q0R9KS4gKi9cbiAgZGF0YVNvdXJjZT86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBEYXRhc291cmNlIExvY2F0aW9uIChJRDoge0I1QjI3QUYxLTI1RUYtNDA1Qy04N0NFLTM2OUIzQTAwNDAxNn0pLiAqL1xuICBkYXRhc291cmNlTG9jYXRpb24/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogRGF0YXNvdXJjZSBUZW1wbGF0ZSAoSUQ6IHsxQTdDODVFNS1EQzBCLTQ5MEQtOTE4Ny1CQjFEQkNCNEM3MkZ9KS4gKi9cbiAgZGF0YXNvdXJjZVRlbXBsYXRlPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgLyoqIERlc2NyaXB0aW9uIChJRDogezU2RTQ2MThBLUYzRjItNENCNS1CNjlBLThBNDVERTU3ODkwMn0pLiAqL1xuICBkZXNjcmlwdGlvbj86IE1heWJlPFJpY2hUZXh0RmllbGQ+O1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgLyoqIEVkaXRhYmxlIChJRDogezMwOEU4OEY1LUNENkUtNEY4Ri1CQUZFLTk1QTQ3REVERUZEQ30pLiAqL1xuICBlZGl0YWJsZT86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICAvKiogRW5hYmxlIERhdGFzb3VyY2UgUXVlcnkgKElEOiB7RjE3MkI3ODctN0I4OC00QkQ1LUFFNEQtNjMwOEUxMDJFRjExfSkuICovXG4gIGVuYWJsZURhdGFzb3VyY2VRdWVyeT86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIC8qKiBGaWVsZEVkaXRvckZpZWxkcyAoSUQ6IHtDN0I3MjExNC0zRjA0LTQ1QTAtQkE0My0zODU2QTlDOUZFQjN9KS4gKi9cbiAgZmllbGRFZGl0b3JGaWVsZHM/OiBNYXliZTxNdWx0aWxpc3RGaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogT3BlbiBQcm9wZXJ0aWVzIGFmdGVyIEFkZCAoSUQ6IHs3RDhBRTM1Ri05RUQxLTQzQjUtOTZBMi0wQTVGMDQwRDRFNEV9KS4gKi9cbiAgb3BlblByb3BlcnRpZXNBZnRlckFkZD86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBQYWdlIEVkaXRvciBCdXR0b25zIChJRDoge0EyRjVEOURGLThDQkEtNEExRC05OUVCLTUxQUNCOTRDQjA1N30pLiAqL1xuICBwYWdlRWRpdG9yQnV0dG9ucz86IE1heWJlPE11bHRpbGlzdEZpZWxkPjtcbiAgLyoqIFBhcmFtZXRlcnMgKElEOiB7RDAxREY2MjYtMjI4NC00QkM2LUE2Q0EtQzBBM0U2RDJFODQ0fSkuICovXG4gIHBhcmFtZXRlcnM/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogUGFyYW1ldGVycyBUZW1wbGF0ZSAoSUQ6IHtBNzdFODU2OC0xQUIzLTQ0RjEtQTY2NC1CN0MzN0VDNzgxMER9KS4gKi9cbiAgcGFyYW1ldGVyc1RlbXBsYXRlPzogTWF5YmU8TG9va3VwRmllbGQ+O1xuICBwYXJlbnQ/OiBNYXliZTxJdGVtPjtcbiAgcGF0aDogU2NhbGFyc1snU3RyaW5nJ107XG4gIC8qKiBQbGFjZWhvbGRlciAoSUQ6IHs1OTJBMUNFNy1BQkUwLTQ5ODYtOTc4My0wQTM0RjM5NjFEQzB9KS4gKi9cbiAgcGxhY2Vob2xkZXI/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogUGxhY2Vob2xkZXJzIChJRDogezA2OUE4MzYxLUIxQ0QtNDM3Qy04QzMyLUEzQkU3ODk0MTQ0Nn0pLiAqL1xuICBwbGFjZWhvbGRlcnM/OiBNYXliZTxNdWx0aWxpc3RGaWVsZD47XG4gIHJlbmRlcmVkOiBTY2FsYXJzWydKU09OJ107XG4gIC8qKiBSZW5kZXJpbmcgQ29udGVudHMgUmVzb2x2ZXIgKElEOiB7QjBCMTU1MTAtQjEzOC00NzBFLThGMzMtOERBMkUyMjhBQUZFfSkuICovXG4gIHJlbmRlcmluZ0NvbnRlbnRzUmVzb2x2ZXI/OiBNYXliZTxMb29rdXBGaWVsZD47XG4gIHRlbXBsYXRlOiBJdGVtVGVtcGxhdGU7XG4gIHVybDogSXRlbVVybDtcbiAgLyoqIFZhcnlCeURhdGEgKElEOiB7OEI2RDUzMkItNjEyOC00NDg2LUEwNDQtQ0EwNkQ5MDk0OEJBfSkuICovXG4gIHZhcnlCeURhdGE/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIFZhcnlCeURldmljZSAoSUQ6IHtDOThDRjk2OS1CQTcxLTQyREEtODMzRC1CM0ZDMTM2OEJBMjd9KS4gKi9cbiAgdmFyeUJ5RGV2aWNlPzogTWF5YmU8Q2hlY2tib3hGaWVsZD47XG4gIC8qKiBWYXJ5QnlMb2dpbiAoSUQ6IHs4RDkyMzJCMC02MTNGLTQ0MEItQTJGQS1EQ0REODBGQkQzM0V9KS4gKi9cbiAgdmFyeUJ5TG9naW4/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIFZhcnlCeVBhcm0gKElEOiB7M0FEMjUwNkEtREMzOS00QjFFLTk1OUYtOUQ1MjRBRERCRjUwfSkuICovXG4gIHZhcnlCeVBhcm0/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIFZhcnlCeVF1ZXJ5U3RyaW5nIChJRDogezEwODREM0QyLTA0NTctNDU2QS1BQkJDLUVCNENDMDk2NjA3Mn0pLiAqL1xuICB2YXJ5QnlRdWVyeVN0cmluZz86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICAvKiogVmFyeUJ5VXNlciAoSUQ6IHswRTU0QThEQy03MkFELTQzNzItQTdDNy1CQjQ3NzNGQUQ0NER9KS4gKi9cbiAgdmFyeUJ5VXNlcj86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL0pzb24gUmVuZGVyaW5nIHRlbXBsYXRlIChJRDogezA0NjQ2QTg5LTk5NkYtNEVFNy04NzhBLUZGREJGMUYwRUYwRH0pLiAqL1xuZXhwb3J0IHR5cGUgSnNvblJlbmRlcmluZ0FuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvSnNvbiBSZW5kZXJpbmcgdGVtcGxhdGUgKElEOiB7MDQ2NDZBODktOTk2Ri00RUU3LTg3OEEtRkZEQkYxRjBFRjBEfSkuICovXG5leHBvcnQgdHlwZSBKc29uUmVuZGVyaW5nQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvSnNvbiBSZW5kZXJpbmcgdGVtcGxhdGUgKElEOiB7MDQ2NDZBODktOTk2Ri00RUU3LTg3OEEtRkZEQkYxRjBFRjBEfSkuICovXG5leHBvcnQgdHlwZSBKc29uUmVuZGVyaW5nRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL0pzb24gUmVuZGVyaW5nIHRlbXBsYXRlIChJRDogezA0NjQ2QTg5LTk5NkYtNEVFNy04NzhBLUZGREJGMUYwRUYwRH0pLiAqL1xuZXhwb3J0IHR5cGUgSnNvblJlbmRlcmluZ0ZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9Kc29uIFJlbmRlcmluZyB0ZW1wbGF0ZSAoSUQ6IHswNDY0NkE4OS05OTZGLTRFRTctODc4QS1GRkRCRjFGMEVGMER9KS4gKi9cbmV4cG9ydCB0eXBlIEpzb25SZW5kZXJpbmdIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvSnNvbiBSZW5kZXJpbmcgdGVtcGxhdGUgKElEOiB7MDQ2NDZBODktOTk2Ri00RUU3LTg3OEEtRkZEQkYxRjBFRjBEfSkuICovXG5leHBvcnQgdHlwZSBKc29uUmVuZGVyaW5nSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvSmF2YVNjcmlwdCBSZW5kZXJpbmcgdGVtcGxhdGUgKElEOiB7QjFDODBDOTQtNzkyRC00NERBLTg2MUUtNTU3QzZFMTkxNUYyfSkuICovXG5leHBvcnQgdHlwZSBKYXZhU2NyaXB0UmVuZGVyaW5nID0gUmVuZGVyaW5nT3B0aW9ucyAmIENhY2hpbmcgJiBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnO1xuICAvKiogQWRkRmllbGRFZGl0b3JCdXR0b24gKElEOiB7MTlEMDk1QjQtNzYyMS00MjIyLUE4OUItNTA1Mjg5NjUwNzkyfSkuICovXG4gIGFkZEZpZWxkRWRpdG9yQnV0dG9uPzogTWF5YmU8Q2hlY2tib3hGaWVsZD47XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICAvKiogQ2FjaGVhYmxlIChJRDogezNEMDhEQjQ2LTIyNjctNDFCMC1CQzUyLUJFNjlGRDYxODYzM30pLiAqL1xuICBjYWNoZWFibGU/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIENhY2hlQ2xlYXJpbmdCZWhhdmlvciAoSUQ6IHtBNkQ0RkMxRC0wODAzLTRFMEEtOTE0NS1COEM2MTIxRDZGMjZ9KS4gKi9cbiAgY2FjaGVDbGVhcmluZ0JlaGF2aW9yPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICAvKiogQ2xlYXJPbkluZGV4VXBkYXRlIChJRDoge0YzRTdFNTUyLUQ3QzgtNDY5Qi1BMTUwLTY5RTRFMTRBQjM1Q30pLiAqL1xuICBjbGVhck9uSW5kZXhVcGRhdGU/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIENsaWVudCBTY3JpcHQgUGF0aCAoSUQ6IHsxMjVCQjdCNy01RDdELTQyRjMtQTMxNC00ODA3OTlBOTY0M0V9KS4gKi9cbiAgY2xpZW50U2NyaXB0UGF0aD86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBDb21wYXRpYmxlIFJlbmRlcmluZ3MgKElEOiB7RTQ0MUFCRTctMkNBMy00NjQwLUFFMjYtMzc4OTk2NzkyNUQ3fSkuICovXG4gIGNvbXBhdGlibGVSZW5kZXJpbmdzPzogTWF5YmU8TXVsdGlsaXN0RmllbGQ+O1xuICAvKiogQ29tcG9uZW50IE5hbWUgKElEOiB7RTY3NzlGMjQtQTQ3NC00RjI5LUE2MEYtODMxODJDRDE5OTNBfSkuICovXG4gIGNvbXBvbmVudE5hbWU/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogQ29tcG9uZW50UXVlcnkgKElEOiB7NDUyOEI4MkItRTc5RS00QkQ5LTgyMEQtMUJBRDI2MjYwMzQyfSkuICovXG4gIGNvbXBvbmVudFF1ZXJ5PzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgLyoqIEN1c3RvbWl6ZSBQYWdlIChJRDoge0RBRjA5NkI0LUJCRTMtNEZCMS05QjJFLTc3NEEzN0ZDQ0VDNn0pLiAqL1xuICBjdXN0b21pemVQYWdlPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgLyoqIERhdGEgc291cmNlIChJRDogezM1Rjc4NTlDLTFFN0YtNEU4Ni04N0JELTY1QkZDRjg2NzlEOH0pLiAqL1xuICBkYXRhU291cmNlPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgLyoqIERhdGFzb3VyY2UgTG9jYXRpb24gKElEOiB7QjVCMjdBRjEtMjVFRi00MDVDLTg3Q0UtMzY5QjNBMDA0MDE2fSkuICovXG4gIGRhdGFzb3VyY2VMb2NhdGlvbj86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBEYXRhc291cmNlIFRlbXBsYXRlIChJRDogezFBN0M4NUU1LURDMEItNDkwRC05MTg3LUJCMURCQ0I0QzcyRn0pLiAqL1xuICBkYXRhc291cmNlVGVtcGxhdGU/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogRGVzY3JpcHRpb24gKElEOiB7MTEyN0RGRUUtMDE4My00QTEwLTk2NEEtMDBDQ0VBMjEyMUFDfSkuICovXG4gIGRlc2NyaXB0aW9uPzogTWF5YmU8UmljaFRleHRGaWVsZD47XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICAvKiogRWRpdGFibGUgKElEOiB7MzA4RTg4RjUtQ0Q2RS00RjhGLUJBRkUtOTVBNDdERURFRkRDfSkuICovXG4gIGVkaXRhYmxlPzogTWF5YmU8Q2hlY2tib3hGaWVsZD47XG4gIC8qKiBFbmFibGUgRGF0YXNvdXJjZSBRdWVyeSAoSUQ6IHtGMTcyQjc4Ny03Qjg4LTRCRDUtQUU0RC02MzA4RTEwMkVGMTF9KS4gKi9cbiAgZW5hYmxlRGF0YXNvdXJjZVF1ZXJ5PzogTWF5YmU8Q2hlY2tib3hGaWVsZD47XG4gIC8qKiBFeHBvcnRlZCBGdW5jdGlvbiBOYW1lIChJRDoge0U2MUY2RkVBLUJBMDEtNDRDRi1BNTBCLTM2OUQ3QjE4QUREQX0pLiAqL1xuICBleHBvcnRlZEZ1bmN0aW9uTmFtZT86IE1heWJlPFRleHRGaWVsZD47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgLyoqIEZpZWxkRWRpdG9yRmllbGRzIChJRDogezlGMDY5QUY3LUE1QTEtNDE0My1BNjQxLTE0NzM1RDUwQjFFOH0pLiAqL1xuICBmaWVsZEVkaXRvckZpZWxkcz86IE1heWJlPE11bHRpbGlzdEZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIC8qKiBPcGVuIFByb3BlcnRpZXMgYWZ0ZXIgQWRkIChJRDoge0M2MEUyRDAyLTVGNjItNERDRi1BMjgxLTI5MDA1MjcyQzEwMX0pLiAqL1xuICBvcGVuUHJvcGVydGllc0FmdGVyQWRkPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgLyoqIFBhZ2UgRWRpdG9yIEJ1dHRvbnMgKElEOiB7QTJGNUQ5REYtOENCQS00QTFELTk5RUItNTFBQ0I5NENCMDU3fSkuICovXG4gIHBhZ2VFZGl0b3JCdXR0b25zPzogTWF5YmU8TXVsdGlsaXN0RmllbGQ+O1xuICAvKiogUGFyYW1ldGVycyAoSUQ6IHtCRUUxRDRCMy1DREZDLTRBMkQtQUExOS02Nzc1QzU5Q0FFN0J9KS4gKi9cbiAgcGFyYW1ldGVycz86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBQYXJhbWV0ZXJzIFRlbXBsYXRlIChJRDogezUzOTFGQUFDLTZDMTYtNDJCMy1BNDExLTQ5MTA5QTg1MDJBM30pLiAqL1xuICBwYXJhbWV0ZXJzVGVtcGxhdGU/OiBNYXliZTxMb29rdXBGaWVsZD47XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgLyoqIFBsYWNlaG9sZGVyIChJRDoge0RBMjk4QTYxLThDRUItNEZBNS05QTU2LTkwRjUzMUIxQzEwNX0pLiAqL1xuICBwbGFjZWhvbGRlcj86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBQbGFjZWhvbGRlcnMgKElEOiB7MDY5QTgzNjEtQjFDRC00MzdDLThDMzItQTNCRTc4OTQxNDQ2fSkuICovXG4gIHBsYWNlaG9sZGVycz86IE1heWJlPE11bHRpbGlzdEZpZWxkPjtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgLyoqIFJlbmRlciBFbmdpbmUgSW5zdGFuY2UgQ29uZmlndXJhdGlvbiBJZCAoSUQ6IHsxRTBFQkFBMi1ERUM0LTQ3NTYtQTUxMC0yQTIwQTQ5NTFFMkR9KS4gKi9cbiAgcmVuZGVyRW5naW5lSW5zdGFuY2VDb25maWd1cmF0aW9uSWQ/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogUmVuZGVyIEVuZ2luZSBUeXBlIChJRDogezEzNUM4QjhBLTlGNTUtNEIyRC05RUExLTMzMzMyMEJBREUwQ30pLiAqL1xuICByZW5kZXJFbmdpbmVUeXBlPzogTWF5YmU8TG9va3VwRmllbGQ+O1xuICAvKiogUmVuZGVyaW5nIENvbnRlbnRzIFJlc29sdmVyIChJRDoge0IwQjE1NTEwLUIxMzgtNDcwRS04RjMzLThEQTJFMjI4QUFGRX0pLiAqL1xuICByZW5kZXJpbmdDb250ZW50c1Jlc29sdmVyPzogTWF5YmU8TG9va3VwRmllbGQ+O1xuICAvKiogU2VydmVyIFNjcmlwdCBQYXRoIChJRDogezdFREFDQkY0LUNENjUtNDRENi1CNTI0LTNBNUVENDExQUUwNX0pLiAqL1xuICBzZXJ2ZXJTY3JpcHRQYXRoPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICAvKiogVmFyeUJ5RGF0YSAoSUQ6IHs4QjZENTMyQi02MTI4LTQ0ODYtQTA0NC1DQTA2RDkwOTQ4QkF9KS4gKi9cbiAgdmFyeUJ5RGF0YT86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICAvKiogVmFyeUJ5RGV2aWNlIChJRDoge0M5OENGOTY5LUJBNzEtNDJEQS04MzNELUIzRkMxMzY4QkEyN30pLiAqL1xuICB2YXJ5QnlEZXZpY2U/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIFZhcnlCeUxvZ2luIChJRDogezhEOTIzMkIwLTYxM0YtNDQwQi1BMkZBLURDREQ4MEZCRDMzRX0pLiAqL1xuICB2YXJ5QnlMb2dpbj86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICAvKiogVmFyeUJ5UGFybSAoSUQ6IHszQUQyNTA2QS1EQzM5LTRCMUUtOTU5Ri05RDUyNEFEREJGNTB9KS4gKi9cbiAgdmFyeUJ5UGFybT86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICAvKiogVmFyeUJ5UXVlcnlTdHJpbmcgKElEOiB7MTA4NEQzRDItMDQ1Ny00NTZBLUFCQkMtRUI0Q0MwOTY2MDcyfSkuICovXG4gIHZhcnlCeVF1ZXJ5U3RyaW5nPzogTWF5YmU8Q2hlY2tib3hGaWVsZD47XG4gIC8qKiBWYXJ5QnlVc2VyIChJRDogezBFNTRBOERDLTcyQUQtNDM3Mi1BN0M3LUJCNDc3M0ZBRDQ0RH0pLiAqL1xuICB2YXJ5QnlVc2VyPzogTWF5YmU8Q2hlY2tib3hGaWVsZD47XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvSmF2YVNjcmlwdCBSZW5kZXJpbmcgdGVtcGxhdGUgKElEOiB7QjFDODBDOTQtNzkyRC00NERBLTg2MUUtNTU3QzZFMTkxNUYyfSkuICovXG5leHBvcnQgdHlwZSBKYXZhU2NyaXB0UmVuZGVyaW5nQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9KYXZhU2NyaXB0IFJlbmRlcmluZyB0ZW1wbGF0ZSAoSUQ6IHtCMUM4MEM5NC03OTJELTQ0REEtODYxRS01NTdDNkUxOTE1RjJ9KS4gKi9cbmV4cG9ydCB0eXBlIEphdmFTY3JpcHRSZW5kZXJpbmdDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xuICBmaXJzdD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbiAgYWZ0ZXI/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9KYXZhU2NyaXB0IFJlbmRlcmluZyB0ZW1wbGF0ZSAoSUQ6IHtCMUM4MEM5NC03OTJELTQ0REEtODYxRS01NTdDNkUxOTE1RjJ9KS4gKi9cbmV4cG9ydCB0eXBlIEphdmFTY3JpcHRSZW5kZXJpbmdGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvSmF2YVNjcmlwdCBSZW5kZXJpbmcgdGVtcGxhdGUgKElEOiB7QjFDODBDOTQtNzkyRC00NERBLTg2MUUtNTU3QzZFMTkxNUYyfSkuICovXG5leHBvcnQgdHlwZSBKYXZhU2NyaXB0UmVuZGVyaW5nRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL0phdmFTY3JpcHQgUmVuZGVyaW5nIHRlbXBsYXRlIChJRDoge0IxQzgwQzk0LTc5MkQtNDREQS04NjFFLTU1N0M2RTE5MTVGMn0pLiAqL1xuZXhwb3J0IHR5cGUgSmF2YVNjcmlwdFJlbmRlcmluZ0hhc0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9KYXZhU2NyaXB0IFJlbmRlcmluZyB0ZW1wbGF0ZSAoSUQ6IHtCMUM4MEM5NC03OTJELTQ0REEtODYxRS01NTdDNkUxOTE1RjJ9KS4gKi9cbmV4cG9ydCB0eXBlIEphdmFTY3JpcHRSZW5kZXJpbmdJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9KU1MgTGF5b3V0IHRlbXBsYXRlIChJRDogezM1QzYxRTkwLTQ3REQtNDNERC04M0E4LUQxQzRENTExOTcyMH0pLiAqL1xuZXhwb3J0IHR5cGUgSnNzTGF5b3V0ID0gTGF5b3V0XzNhNDVhNzIzNjRlZTQ5MTk5ZDQxMDJmZDQwZmQxNDY2ICYgSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgLyoqIEFyZWEgKElEOiB7NzBEQzA4RDktQ0RBMi00RjA0LUFBMzUtQzExRkQ3MTM4MDY2fSkuICovXG4gIGFyZWE/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIC8qKiBNb2RlbCAoSUQ6IHtFOUNDNUE3My0zQzhBLTREN0QtOTJBQy0zQjg4QzE4QTk5NkF9KS4gKi9cbiAgbW9kZWw/OiBNYXliZTxUZXh0RmllbGQ+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogUGF0aCAoSUQ6IHtBMDM2QjJCQy1CQTA0LTQ0RjYtQTc1Ri1CQUU2Q0QyNDJBQkZ9KS4gKi9cbiAgcGF0aF9hMDM2YjJiY2JhMDQ0NGY2YTc1ZmJhZTZjZDI0MmFiZj86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBQbGFjZWhvbGRlcnMgKElEOiB7ODAzMzQ4NjktODZEQy00NDcyLUFBODktNDRDRjFCMkY2QzlCfSkuICovXG4gIHBsYWNlaG9sZGVycz86IE1heWJlPE11bHRpbGlzdEZpZWxkPjtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL0pTUyBMYXlvdXQgdGVtcGxhdGUgKElEOiB7MzVDNjFFOTAtNDdERC00M0RELTgzQTgtRDFDNEQ1MTE5NzIwfSkuICovXG5leHBvcnQgdHlwZSBKc3NMYXlvdXRBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL0pTUyBMYXlvdXQgdGVtcGxhdGUgKElEOiB7MzVDNjFFOTAtNDdERC00M0RELTgzQTgtRDFDNEQ1MTE5NzIwfSkuICovXG5leHBvcnQgdHlwZSBKc3NMYXlvdXRDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xuICBmaXJzdD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbiAgYWZ0ZXI/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9KU1MgTGF5b3V0IHRlbXBsYXRlIChJRDogezM1QzYxRTkwLTQ3REQtNDNERC04M0E4LUQxQzRENTExOTcyMH0pLiAqL1xuZXhwb3J0IHR5cGUgSnNzTGF5b3V0RmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL0pTUyBMYXlvdXQgdGVtcGxhdGUgKElEOiB7MzVDNjFFOTAtNDdERC00M0RELTgzQTgtRDFDNEQ1MTE5NzIwfSkuICovXG5leHBvcnQgdHlwZSBKc3NMYXlvdXRGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvSlNTIExheW91dCB0ZW1wbGF0ZSAoSUQ6IHszNUM2MUU5MC00N0RELTQzREQtODNBOC1EMUM0RDUxMTk3MjB9KS4gKi9cbmV4cG9ydCB0eXBlIEpzc0xheW91dEhhc0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9KU1MgTGF5b3V0IHRlbXBsYXRlIChJRDogezM1QzYxRTkwLTQ3REQtNDNERC04M0E4LUQxQzRENTExOTcyMH0pLiAqL1xuZXhwb3J0IHR5cGUgSnNzTGF5b3V0SWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvR3JhcGhRTC1JbnRlZ3JhdGVkRGVtbyB0ZW1wbGF0ZSAoSUQ6IHtBOTEyQTcyMS03RjVFLTVFNTQtQUEwRS1CQkIxOTY0OTE5QUN9KS4gKi9cbmV4cG9ydCB0eXBlIEdyYXBoUWxJbnRlZ3JhdGVkRGVtbyA9IEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgLyoqIHNhbXBsZTEgKElEOiB7MDI4RkEyRjItM0I3Ny01Q0Q5LUJEOTAtQTI0ODNBNDQ5QUFGfSkuICovXG4gIHNhbXBsZTE/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogc2FtcGxlMiAoSUQ6IHs3QTkwMTIxMS04OTlGLTVDNEQtODU1MC0xNzlGQ0MyRTRENzR9KS4gKi9cbiAgc2FtcGxlMj86IE1heWJlPExpbmtGaWVsZD47XG4gIHRlbXBsYXRlOiBJdGVtVGVtcGxhdGU7XG4gIHVybDogSXRlbVVybDtcbiAgdmVyc2lvbjogU2NhbGFyc1snSW50J107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9HcmFwaFFMLUludGVncmF0ZWREZW1vIHRlbXBsYXRlIChJRDoge0E5MTJBNzIxLTdGNUUtNUU1NC1BQTBFLUJCQjE5NjQ5MTlBQ30pLiAqL1xuZXhwb3J0IHR5cGUgR3JhcGhRbEludGVncmF0ZWREZW1vQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9HcmFwaFFMLUludGVncmF0ZWREZW1vIHRlbXBsYXRlIChJRDoge0E5MTJBNzIxLTdGNUUtNUU1NC1BQTBFLUJCQjE5NjQ5MTlBQ30pLiAqL1xuZXhwb3J0IHR5cGUgR3JhcGhRbEludGVncmF0ZWREZW1vQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvR3JhcGhRTC1JbnRlZ3JhdGVkRGVtbyB0ZW1wbGF0ZSAoSUQ6IHtBOTEyQTcyMS03RjVFLTVFNTQtQUEwRS1CQkIxOTY0OTE5QUN9KS4gKi9cbmV4cG9ydCB0eXBlIEdyYXBoUWxJbnRlZ3JhdGVkRGVtb0ZpZWxkQXJncyA9IHtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9HcmFwaFFMLUludGVncmF0ZWREZW1vIHRlbXBsYXRlIChJRDoge0E5MTJBNzIxLTdGNUUtNUU1NC1BQTBFLUJCQjE5NjQ5MTlBQ30pLiAqL1xuZXhwb3J0IHR5cGUgR3JhcGhRbEludGVncmF0ZWREZW1vRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0dyYXBoUUwtSW50ZWdyYXRlZERlbW8gdGVtcGxhdGUgKElEOiB7QTkxMkE3MjEtN0Y1RS01RTU0LUFBMEUtQkJCMTk2NDkxOUFDfSkuICovXG5leHBvcnQgdHlwZSBHcmFwaFFsSW50ZWdyYXRlZERlbW9IYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvR3JhcGhRTC1JbnRlZ3JhdGVkRGVtbyB0ZW1wbGF0ZSAoSUQ6IHtBOTEyQTcyMS03RjVFLTVFNTQtQUEwRS1CQkIxOTY0OTE5QUN9KS4gKi9cbmV4cG9ydCB0eXBlIEdyYXBoUWxJbnRlZ3JhdGVkRGVtb0lkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0dyYXBoUUwtQ29ubmVjdGVkRGVtbyB0ZW1wbGF0ZSAoSUQ6IHs4RTJBNEVBMS1DOEY1LTU2RTYtQjA5Ny1FMDA4Qzk5NEQ5NTN9KS4gKi9cbmV4cG9ydCB0eXBlIEdyYXBoUWxDb25uZWN0ZWREZW1vID0gSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbyc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBwYXJlbnQ/OiBNYXliZTxJdGVtPjtcbiAgcGF0aDogU2NhbGFyc1snU3RyaW5nJ107XG4gIHJlbmRlcmVkOiBTY2FsYXJzWydKU09OJ107XG4gIC8qKiBzYW1wbGUxIChJRDogezc3RUMwNTdFLTkxQkItNTc2Qy05NDg4LTY0NzA1Njg0OTA3Nn0pLiAqL1xuICBzYW1wbGUxPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgLyoqIHNhbXBsZTIgKElEOiB7NjY1NEY3MkYtQ0U0RC01NjUxLThERTMtODYyODU3QTQ4NDQ3fSkuICovXG4gIHNhbXBsZTI/OiBNYXliZTxMaW5rRmllbGQ+O1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvR3JhcGhRTC1Db25uZWN0ZWREZW1vIHRlbXBsYXRlIChJRDogezhFMkE0RUExLUM4RjUtNTZFNi1CMDk3LUUwMDhDOTk0RDk1M30pLiAqL1xuZXhwb3J0IHR5cGUgR3JhcGhRbENvbm5lY3RlZERlbW9BbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0dyYXBoUUwtQ29ubmVjdGVkRGVtbyB0ZW1wbGF0ZSAoSUQ6IHs4RTJBNEVBMS1DOEY1LTU2RTYtQjA5Ny1FMDA4Qzk5NEQ5NTN9KS4gKi9cbmV4cG9ydCB0eXBlIEdyYXBoUWxDb25uZWN0ZWREZW1vQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvR3JhcGhRTC1Db25uZWN0ZWREZW1vIHRlbXBsYXRlIChJRDogezhFMkE0RUExLUM4RjUtNTZFNi1CMDk3LUUwMDhDOTk0RDk1M30pLiAqL1xuZXhwb3J0IHR5cGUgR3JhcGhRbENvbm5lY3RlZERlbW9GaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvR3JhcGhRTC1Db25uZWN0ZWREZW1vIHRlbXBsYXRlIChJRDogezhFMkE0RUExLUM4RjUtNTZFNi1CMDk3LUUwMDhDOTk0RDk1M30pLiAqL1xuZXhwb3J0IHR5cGUgR3JhcGhRbENvbm5lY3RlZERlbW9GaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvR3JhcGhRTC1Db25uZWN0ZWREZW1vIHRlbXBsYXRlIChJRDogezhFMkE0RUExLUM4RjUtNTZFNi1CMDk3LUUwMDhDOTk0RDk1M30pLiAqL1xuZXhwb3J0IHR5cGUgR3JhcGhRbENvbm5lY3RlZERlbW9IYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvR3JhcGhRTC1Db25uZWN0ZWREZW1vIHRlbXBsYXRlIChJRDogezhFMkE0RUExLUM4RjUtNTZFNi1CMDk3LUUwMDhDOTk0RDk1M30pLiAqL1xuZXhwb3J0IHR5cGUgR3JhcGhRbENvbm5lY3RlZERlbW9JZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9FeGFtcGxlQ3VzdG9tUm91dGVUeXBlIHRlbXBsYXRlIChJRDogezA3NDdDMzUzLTBBN0QtNUNBQS05NjFFLTQzMUFCMzU3OTg2M30pLiAqL1xuZXhwb3J0IHR5cGUgRXhhbXBsZUN1c3RvbVJvdXRlVHlwZSA9IEFwcFJvdXRlICYgSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJztcbiAgYW5jZXN0b3JzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIC8qKiBhdXRob3IgKElEOiB7QjlDM0I1MkYtRDI2My01NTZGLUJFN0EtODI4NURDNjlGNkM0fSkuICovXG4gIGF1dGhvcj86IE1heWJlPFRleHRGaWVsZD47XG4gIGNoaWxkcmVuOiBJdGVtU2VhcmNoUmVzdWx0cztcbiAgLyoqIGNvbnRlbnQgKElEOiB7NjUxRTIyODAtQjlGMi01NDJBLTgzN0MtQThDOEVDNTQwQTM1fSkuICovXG4gIGNvbnRlbnQ/OiBNYXliZTxSaWNoVGV4dEZpZWxkPjtcbiAgZGlzcGxheU5hbWU/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGZpZWxkPzogTWF5YmU8SXRlbUZpZWxkPjtcbiAgZmllbGRzOiBBcnJheTxNYXliZTxJdGVtRmllbGQ+PjtcbiAgaGFzQ2hpbGRyZW46IFNjYWxhcnNbJ0Jvb2xlYW4nXTtcbiAgLyoqIGhlYWRsaW5lIChJRDoge0RGRDc5QjU2LTFFNEItNTczQy05RDZCLTdFQzE4QTFEM0JCQn0pLiAqL1xuICBoZWFkbGluZT86IE1heWJlPFRleHRGaWVsZD47XG4gIGlkOiBTY2FsYXJzWydJRCddO1xuICBpdGVtVXJpOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IEl0ZW1MYW5ndWFnZTtcbiAgbGFuZ3VhZ2VzOiBBcnJheTxNYXliZTxJdGVtPj47XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogUGFnZSBUaXRsZSAoSUQ6IHtGODE3MUVDQi0zN0M1LTU0RUUtQkZFRC1GNjg5Qzg3OEI2RTJ9KS4gKi9cbiAgcGFnZVRpdGxlPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvRXhhbXBsZUN1c3RvbVJvdXRlVHlwZSB0ZW1wbGF0ZSAoSUQ6IHswNzQ3QzM1My0wQTdELTVDQUEtOTYxRS00MzFBQjM1Nzk4NjN9KS4gKi9cbmV4cG9ydCB0eXBlIEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGVBbmNlc3RvcnNBcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUgdGVtcGxhdGUgKElEOiB7MDc0N0MzNTMtMEE3RC01Q0FBLTk2MUUtNDMxQUIzNTc5ODYzfSkuICovXG5leHBvcnQgdHlwZSBFeGFtcGxlQ3VzdG9tUm91dGVUeXBlQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvRXhhbXBsZUN1c3RvbVJvdXRlVHlwZSB0ZW1wbGF0ZSAoSUQ6IHswNzQ3QzM1My0wQTdELTVDQUEtOTYxRS00MzFBQjM1Nzk4NjN9KS4gKi9cbmV4cG9ydCB0eXBlIEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGVGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvRXhhbXBsZUN1c3RvbVJvdXRlVHlwZSB0ZW1wbGF0ZSAoSUQ6IHswNzQ3QzM1My0wQTdELTVDQUEtOTYxRS00MzFBQjM1Nzk4NjN9KS4gKi9cbmV4cG9ydCB0eXBlIEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGVGaWVsZHNBcmdzID0ge1xuICBvd25GaWVsZHM/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvRXhhbXBsZUN1c3RvbVJvdXRlVHlwZSB0ZW1wbGF0ZSAoSUQ6IHswNzQ3QzM1My0wQTdELTVDQUEtOTYxRS00MzFBQjM1Nzk4NjN9KS4gKi9cbmV4cG9ydCB0eXBlIEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGVIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvRXhhbXBsZUN1c3RvbVJvdXRlVHlwZSB0ZW1wbGF0ZSAoSUQ6IHswNzQ3QzM1My0wQTdELTVDQUEtOTYxRS00MzFBQjM1Nzk4NjN9KS4gKi9cbmV4cG9ydCB0eXBlIEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGVJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9Db250ZW50QmxvY2sgdGVtcGxhdGUgKElEOiB7RkYxN0RERDgtN0Q1RS01MDYyLUE2MDgtQjM0QUEzNDQzMkVBfSkuICovXG5leHBvcnQgdHlwZSBDb250ZW50QmxvY2sgPSBJdGVtICYge1xuICBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jayc7XG4gIGFuY2VzdG9yczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XG4gIC8qKiBjb250ZW50IChJRDogezg4MEQzRTI0LTZERkQtNTM0My04Mzc2LTFFM0E0MTY2RDdDM30pLiAqL1xuICBjb250ZW50PzogTWF5YmU8UmljaFRleHRGaWVsZD47XG4gIGRpc3BsYXlOYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICBmaWVsZD86IE1heWJlPEl0ZW1GaWVsZD47XG4gIGZpZWxkczogQXJyYXk8TWF5YmU8SXRlbUZpZWxkPj47XG4gIGhhc0NoaWxkcmVuOiBTY2FsYXJzWydCb29sZWFuJ107XG4gIC8qKiBoZWFkaW5nIChJRDoge0UxMkFFMkE0LTgyOTYtNUI1Ny05QzM1LThEM0M0NzA3RkY3QX0pLiAqL1xuICBoZWFkaW5nPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgaWQ6IFNjYWxhcnNbJ0lEJ107XG4gIGl0ZW1Vcmk6IFNjYWxhcnNbJ1N0cmluZyddO1xuICBsYW5ndWFnZTogSXRlbUxhbmd1YWdlO1xuICBsYW5ndWFnZXM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgbmFtZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0NvbnRlbnRCbG9jayB0ZW1wbGF0ZSAoSUQ6IHtGRjE3REREOC03RDVFLTUwNjItQTYwOC1CMzRBQTM0NDMyRUF9KS4gKi9cbmV4cG9ydCB0eXBlIENvbnRlbnRCbG9ja0FuY2VzdG9yc0FyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvQ29udGVudEJsb2NrIHRlbXBsYXRlIChJRDoge0ZGMTdEREQ4LTdENUUtNTA2Mi1BNjA4LUIzNEFBMzQ0MzJFQX0pLiAqL1xuZXhwb3J0IHR5cGUgQ29udGVudEJsb2NrQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+PjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIGFmdGVyPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvQ29udGVudEJsb2NrIHRlbXBsYXRlIChJRDoge0ZGMTdEREQ4LTdENUUtNTA2Mi1BNjA4LUIzNEFBMzQ0MzJFQX0pLiAqL1xuZXhwb3J0IHR5cGUgQ29udGVudEJsb2NrRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0NvbnRlbnRCbG9jayB0ZW1wbGF0ZSAoSUQ6IHtGRjE3REREOC03RDVFLTUwNjItQTYwOC1CMzRBQTM0NDMyRUF9KS4gKi9cbmV4cG9ydCB0eXBlIENvbnRlbnRCbG9ja0ZpZWxkc0FyZ3MgPSB7XG4gIG93bkZpZWxkcz86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9Db250ZW50QmxvY2sgdGVtcGxhdGUgKElEOiB7RkYxN0RERDgtN0Q1RS01MDYyLUE2MDgtQjM0QUEzNDQzMkVBfSkuICovXG5leHBvcnQgdHlwZSBDb250ZW50QmxvY2tIYXNDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvQ29udGVudEJsb2NrIHRlbXBsYXRlIChJRDoge0ZGMTdEREQ4LTdENUUtNTA2Mi1BNjA4LUIzNEFBMzQ0MzJFQX0pLiAqL1xuZXhwb3J0IHR5cGUgQ29udGVudEJsb2NrSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Qcm9qZWN0L0pzc05leHRXZWIvQXBwIFJvdXRlIHRlbXBsYXRlIChJRDogezc4NzU4NEMwLUEwNTctNTg3Ni05ODM2LUY4QjM3MDhGMENBRn0pLiBOT1RFOiBUaGlzIGlzIGEgY29uY3JldGUgdHlwZS4gRmF2b3IgdXNpbmcgaW50ZXJmYWNlcyBpbnN0ZWFkIG9mIHRoaXMgdHlwZSAoZS5nLiBBcHBSb3V0ZSkgZm9yIHJlbGlhYmxlIHF1ZXJ5aW5nLiAqL1xuZXhwb3J0IHR5cGUgQ19fQXBwUm91dGUgPSBBcHBSb3V0ZSAmIEl0ZW0gJiB7XG4gIF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICBoYXNDaGlsZHJlbjogU2NhbGFyc1snQm9vbGVhbiddO1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgLyoqIFBhZ2UgVGl0bGUgKElEOiB7RjgxNzFFQ0ItMzdDNS01NEVFLUJGRUQtRjY4OUM4NzhCNkUyfSkuICovXG4gIHBhZ2VUaXRsZT86IE1heWJlPFRleHRGaWVsZD47XG4gIHBhcmVudD86IE1heWJlPEl0ZW0+O1xuICBwYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcmVuZGVyZWQ6IFNjYWxhcnNbJ0pTT04nXTtcbiAgdGVtcGxhdGU6IEl0ZW1UZW1wbGF0ZTtcbiAgdXJsOiBJdGVtVXJsO1xuICB2ZXJzaW9uOiBTY2FsYXJzWydJbnQnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0FwcCBSb3V0ZSB0ZW1wbGF0ZSAoSUQ6IHs3ODc1ODRDMC1BMDU3LTU4NzYtOTgzNi1GOEIzNzA4RjBDQUZ9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gQXBwUm91dGUpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX0FwcFJvdXRlQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9BcHAgUm91dGUgdGVtcGxhdGUgKElEOiB7Nzg3NTg0QzAtQTA1Ny01ODc2LTk4MzYtRjhCMzcwOEYwQ0FGfSkuIE5PVEU6IFRoaXMgaXMgYSBjb25jcmV0ZSB0eXBlLiBGYXZvciB1c2luZyBpbnRlcmZhY2VzIGluc3RlYWQgb2YgdGhpcyB0eXBlIChlLmcuIEFwcFJvdXRlKSBmb3IgcmVsaWFibGUgcXVlcnlpbmcuICovXG5leHBvcnQgdHlwZSBDX19BcHBSb3V0ZUNoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG4gIGZpcnN0PzogTWF5YmU8U2NhbGFyc1snSW50J10+O1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0FwcCBSb3V0ZSB0ZW1wbGF0ZSAoSUQ6IHs3ODc1ODRDMC1BMDU3LTU4NzYtOTgzNi1GOEIzNzA4RjBDQUZ9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gQXBwUm91dGUpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX0FwcFJvdXRlRmllbGRBcmdzID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0FwcCBSb3V0ZSB0ZW1wbGF0ZSAoSUQ6IHs3ODc1ODRDMC1BMDU3LTU4NzYtOTgzNi1GOEIzNzA4RjBDQUZ9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gQXBwUm91dGUpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX0FwcFJvdXRlRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0FwcCBSb3V0ZSB0ZW1wbGF0ZSAoSUQ6IHs3ODc1ODRDMC1BMDU3LTU4NzYtOTgzNi1GOEIzNzA4RjBDQUZ9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gQXBwUm91dGUpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX0FwcFJvdXRlSGFzQ2hpbGRyZW5BcmdzID0ge1xuICBoYXNMYXlvdXQ/OiBNYXliZTxTY2FsYXJzWydCb29sZWFuJ10+O1xuICBpbmNsdWRlVGVtcGxhdGVJRHM/OiBNYXliZTxBcnJheTxNYXliZTxTY2FsYXJzWydTdHJpbmcnXT4+Pjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0FwcCBSb3V0ZSB0ZW1wbGF0ZSAoSUQ6IHs3ODc1ODRDMC1BMDU3LTU4NzYtOTgzNi1GOEIzNzA4RjBDQUZ9KS4gTk9URTogVGhpcyBpcyBhIGNvbmNyZXRlIHR5cGUuIEZhdm9yIHVzaW5nIGludGVyZmFjZXMgaW5zdGVhZCBvZiB0aGlzIHR5cGUgKGUuZy4gQXBwUm91dGUpIGZvciByZWxpYWJsZSBxdWVyeWluZy4gKi9cbmV4cG9ydCB0eXBlIENfX0FwcFJvdXRlSWRBcmdzID0ge1xuICBmb3JtYXQ/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvQXBwIHRlbXBsYXRlIChJRDogezA2MUNCQTE1LTU0NzQtNEI5MS04QTA2LTE3OTAzQjEwMkI4Mn0pLiAqL1xuZXhwb3J0IHR5cGUgQXBwID0gSXRlbSAmIHtcbiAgX190eXBlbmFtZT86ICdBcHAnO1xuICBhbmNlc3RvcnM6IEFycmF5PE1heWJlPEl0ZW0+PjtcbiAgY2hpbGRyZW46IEl0ZW1TZWFyY2hSZXN1bHRzO1xuICBkaXNwbGF5TmFtZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmllbGQ/OiBNYXliZTxJdGVtRmllbGQ+O1xuICBmaWVsZHM6IEFycmF5PE1heWJlPEl0ZW1GaWVsZD4+O1xuICBoYXNDaGlsZHJlbjogU2NhbGFyc1snQm9vbGVhbiddO1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAgaXRlbVVyaTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGxhbmd1YWdlOiBJdGVtTGFuZ3VhZ2U7XG4gIGxhbmd1YWdlczogQXJyYXk8TWF5YmU8SXRlbT4+O1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcGFyZW50PzogTWF5YmU8SXRlbT47XG4gIHBhdGg6IFNjYWxhcnNbJ1N0cmluZyddO1xuICByZW5kZXJlZDogU2NhbGFyc1snSlNPTiddO1xuICB0ZW1wbGF0ZTogSXRlbVRlbXBsYXRlO1xuICB1cmw6IEl0ZW1Vcmw7XG4gIHZlcnNpb246IFNjYWxhcnNbJ0ludCddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvQXBwIHRlbXBsYXRlIChJRDogezA2MUNCQTE1LTU0NzQtNEI5MS04QTA2LTE3OTAzQjEwMkI4Mn0pLiAqL1xuZXhwb3J0IHR5cGUgQXBwQW5jZXN0b3JzQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9BcHAgdGVtcGxhdGUgKElEOiB7MDYxQ0JBMTUtNTQ3NC00QjkxLThBMDYtMTc5MDNCMTAyQjgyfSkuICovXG5leHBvcnQgdHlwZSBBcHBDaGlsZHJlbkFyZ3MgPSB7XG4gIGhhc0xheW91dD86IE1heWJlPFNjYWxhcnNbJ0Jvb2xlYW4nXT47XG4gIGluY2x1ZGVUZW1wbGF0ZUlEcz86IE1heWJlPEFycmF5PE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPj4+O1xuICBmaXJzdD86IE1heWJlPFNjYWxhcnNbJ0ludCddPjtcbiAgYWZ0ZXI/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9BcHAgdGVtcGxhdGUgKElEOiB7MDYxQ0JBMTUtNTQ3NC00QjkxLThBMDYtMTc5MDNCMTAyQjgyfSkuICovXG5leHBvcnQgdHlwZSBBcHBGaWVsZEFyZ3MgPSB7XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9Gb3VuZGF0aW9uL0phdmFTY3JpcHQgU2VydmljZXMvQXBwIHRlbXBsYXRlIChJRDogezA2MUNCQTE1LTU0NzQtNEI5MS04QTA2LTE3OTAzQjEwMkI4Mn0pLiAqL1xuZXhwb3J0IHR5cGUgQXBwRmllbGRzQXJncyA9IHtcbiAgb3duRmllbGRzPzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbn07XG5cblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvRm91bmRhdGlvbi9KYXZhU2NyaXB0IFNlcnZpY2VzL0FwcCB0ZW1wbGF0ZSAoSUQ6IHswNjFDQkExNS01NDc0LTRCOTEtOEEwNi0xNzkwM0IxMDJCODJ9KS4gKi9cbmV4cG9ydCB0eXBlIEFwcEhhc0NoaWxkcmVuQXJncyA9IHtcbiAgaGFzTGF5b3V0PzogTWF5YmU8U2NhbGFyc1snQm9vbGVhbiddPjtcbiAgaW5jbHVkZVRlbXBsYXRlSURzPzogTWF5YmU8QXJyYXk8TWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+Pj47XG59O1xuXG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL0ZvdW5kYXRpb24vSmF2YVNjcmlwdCBTZXJ2aWNlcy9BcHAgdGVtcGxhdGUgKElEOiB7MDYxQ0JBMTUtNTQ3NC00QjkxLThBMDYtMTc5MDNCMTAyQjgyfSkuICovXG5leHBvcnQgdHlwZSBBcHBJZEFyZ3MgPSB7XG4gIGZvcm1hdD86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1Byb2plY3QvSnNzTmV4dFdlYi9TdHlsZWd1aWRlLUV4cGxhbmF0b3J5LUNvbXBvbmVudCB0ZW1wbGF0ZSAoSUQ6IHsxMjdDRkFBNC00Njg5LTUzNkItQUY5OC02NDhEQjFEQzBGQkV9KS4gKi9cbmV4cG9ydCB0eXBlIFN0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCA9IHtcbiAgLyoqIGRlc2NyaXB0aW9uIChJRDoge0IzODUxMEZGLThEODgtNUNENy1CQTNGLTIwMTgzMTVENkFCMn0pLiAqL1xuICBkZXNjcmlwdGlvbj86IE1heWJlPFJpY2hUZXh0RmllbGQ+O1xuICAvKiogaGVhZGluZyAoSUQ6IHs1QTMwMTlGNC0wNjQ3LTU3QkEtQTNGNi0wNUNFRjYzOUJFOTF9KS4gKi9cbiAgaGVhZGluZz86IE1heWJlPFRleHRGaWVsZD47XG59O1xuXG4vKiogL3NpdGVjb3JlL3RlbXBsYXRlcy9TeXN0ZW0vTGF5b3V0L1NlY3Rpb25zL1JlbmRlcmluZyBPcHRpb25zIHRlbXBsYXRlIChJRDoge0QxNTkyMjI2LTM4OTgtNENFMi1CMTkwLTA5MEZENUY4NEE0Q30pLiAqL1xuZXhwb3J0IHR5cGUgUmVuZGVyaW5nT3B0aW9ucyA9IHtcbiAgLyoqIENvbXBhdGlibGUgUmVuZGVyaW5ncyAoSUQ6IHtFNDQxQUJFNy0yQ0EzLTQ2NDAtQUUyNi0zNzg5OTY3OTI1RDd9KS4gKi9cbiAgY29tcGF0aWJsZVJlbmRlcmluZ3M/OiBNYXliZTxNdWx0aWxpc3RGaWVsZD47XG4gIC8qKiBEYXRhc291cmNlIExvY2F0aW9uIChJRDoge0I1QjI3QUYxLTI1RUYtNDA1Qy04N0NFLTM2OUIzQTAwNDAxNn0pLiAqL1xuICBkYXRhc291cmNlTG9jYXRpb24/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogRGF0YXNvdXJjZSBUZW1wbGF0ZSAoSUQ6IHsxQTdDODVFNS1EQzBCLTQ5MEQtOTE4Ny1CQjFEQkNCNEM3MkZ9KS4gKi9cbiAgZGF0YXNvdXJjZVRlbXBsYXRlPzogTWF5YmU8VGV4dEZpZWxkPjtcbiAgLyoqIEVkaXRhYmxlIChJRDogezMwOEU4OEY1LUNENkUtNEY4Ri1CQUZFLTk1QTQ3REVERUZEQ30pLiAqL1xuICBlZGl0YWJsZT86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICAvKiogRW5hYmxlIERhdGFzb3VyY2UgUXVlcnkgKElEOiB7RjE3MkI3ODctN0I4OC00QkQ1LUFFNEQtNjMwOEUxMDJFRjExfSkuICovXG4gIGVuYWJsZURhdGFzb3VyY2VRdWVyeT86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICAvKiogUGFnZSBFZGl0b3IgQnV0dG9ucyAoSUQ6IHtBMkY1RDlERi04Q0JBLTRBMUQtOTlFQi01MUFDQjk0Q0IwNTd9KS4gKi9cbiAgcGFnZUVkaXRvckJ1dHRvbnM/OiBNYXliZTxNdWx0aWxpc3RGaWVsZD47XG4gIC8qKiBQbGFjZWhvbGRlcnMgKElEOiB7MDY5QTgzNjEtQjFDRC00MzdDLThDMzItQTNCRTc4OTQxNDQ2fSkuICovXG4gIHBsYWNlaG9sZGVycz86IE1heWJlPE11bHRpbGlzdEZpZWxkPjtcbiAgLyoqIFJlbmRlcmluZyBDb250ZW50cyBSZXNvbHZlciAoSUQ6IHtCMEIxNTUxMC1CMTM4LTQ3MEUtOEYzMy04REEyRTIyOEFBRkV9KS4gKi9cbiAgcmVuZGVyaW5nQ29udGVudHNSZXNvbHZlcj86IE1heWJlPExvb2t1cEZpZWxkPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1N5c3RlbS9MYXlvdXQvTGF5b3V0IHRlbXBsYXRlIChJRDogezNBNDVBNzIzLTY0RUUtNDkxOS05RDQxLTAyRkQ0MEZEMTQ2Nn0pLiAqL1xuZXhwb3J0IHR5cGUgTGF5b3V0XzNhNDVhNzIzNjRlZTQ5MTk5ZDQxMDJmZDQwZmQxNDY2ID0ge1xuICAvKiogQXJlYSAoSUQ6IHs3MERDMDhEOS1DREEyLTRGMDQtQUEzNS1DMTFGRDcxMzgwNjZ9KS4gKi9cbiAgYXJlYT86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBNb2RlbCAoSUQ6IHtFOUNDNUE3My0zQzhBLTREN0QtOTJBQy0zQjg4QzE4QTk5NkF9KS4gKi9cbiAgbW9kZWw/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogUGF0aCAoSUQ6IHtBMDM2QjJCQy1CQTA0LTQ0RjYtQTc1Ri1CQUU2Q0QyNDJBQkZ9KS4gKi9cbiAgcGF0aF9hMDM2YjJiY2JhMDQ0NGY2YTc1ZmJhZTZjZDI0MmFiZj86IE1heWJlPFRleHRGaWVsZD47XG4gIC8qKiBQbGFjZWhvbGRlcnMgKElEOiB7ODAzMzQ4NjktODZEQy00NDcyLUFBODktNDRDRjFCMkY2QzlCfSkuICovXG4gIHBsYWNlaG9sZGVycz86IE1heWJlPE11bHRpbGlzdEZpZWxkPjtcbn07XG5cbi8qKiAvc2l0ZWNvcmUvdGVtcGxhdGVzL1N5c3RlbS9MYXlvdXQvU2VjdGlvbnMvQ2FjaGluZyB0ZW1wbGF0ZSAoSUQ6IHtFOEQyREQxOS0xMzQ3LTQ1NjItQUUzRi0zMTBEQzBCMjFBNkN9KS4gKi9cbmV4cG9ydCB0eXBlIENhY2hpbmcgPSB7XG4gIC8qKiBDYWNoZWFibGUgKElEOiB7M0QwOERCNDYtMjI2Ny00MUIwLUJDNTItQkU2OUZENjE4NjMzfSkuICovXG4gIGNhY2hlYWJsZT86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICAvKiogQ2FjaGVDbGVhcmluZ0JlaGF2aW9yIChJRDoge0E2RDRGQzFELTA4MDMtNEUwQS05MTQ1LUI4QzYxMjFENkYyNn0pLiAqL1xuICBjYWNoZUNsZWFyaW5nQmVoYXZpb3I/OiBNYXliZTxUZXh0RmllbGQ+O1xuICAvKiogQ2xlYXJPbkluZGV4VXBkYXRlIChJRDoge0YzRTdFNTUyLUQ3QzgtNDY5Qi1BMTUwLTY5RTRFMTRBQjM1Q30pLiAqL1xuICBjbGVhck9uSW5kZXhVcGRhdGU/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIFZhcnlCeURhdGEgKElEOiB7OEI2RDUzMkItNjEyOC00NDg2LUEwNDQtQ0EwNkQ5MDk0OEJBfSkuICovXG4gIHZhcnlCeURhdGE/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIFZhcnlCeURldmljZSAoSUQ6IHtDOThDRjk2OS1CQTcxLTQyREEtODMzRC1CM0ZDMTM2OEJBMjd9KS4gKi9cbiAgdmFyeUJ5RGV2aWNlPzogTWF5YmU8Q2hlY2tib3hGaWVsZD47XG4gIC8qKiBWYXJ5QnlMb2dpbiAoSUQ6IHs4RDkyMzJCMC02MTNGLTQ0MEItQTJGQS1EQ0REODBGQkQzM0V9KS4gKi9cbiAgdmFyeUJ5TG9naW4/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIFZhcnlCeVBhcm0gKElEOiB7M0FEMjUwNkEtREMzOS00QjFFLTk1OUYtOUQ1MjRBRERCRjUwfSkuICovXG4gIHZhcnlCeVBhcm0/OiBNYXliZTxDaGVja2JveEZpZWxkPjtcbiAgLyoqIFZhcnlCeVF1ZXJ5U3RyaW5nIChJRDogezEwODREM0QyLTA0NTctNDU2QS1BQkJDLUVCNENDMDk2NjA3Mn0pLiAqL1xuICB2YXJ5QnlRdWVyeVN0cmluZz86IE1heWJlPENoZWNrYm94RmllbGQ+O1xuICAvKiogVmFyeUJ5VXNlciAoSUQ6IHswRTU0QThEQy03MkFELTQzNzItQTdDNy1CQjQ3NzNGQUQ0NER9KS4gKi9cbiAgdmFyeUJ5VXNlcj86IE1heWJlPENoZWNrYm94RmllbGQ+O1xufTtcblxuLyoqIC9zaXRlY29yZS90ZW1wbGF0ZXMvUHJvamVjdC9Kc3NOZXh0V2ViL0FwcCBSb3V0ZSB0ZW1wbGF0ZSAoSUQ6IHs3ODc1ODRDMC1BMDU3LTU4NzYtOTgzNi1GOEIzNzA4RjBDQUZ9KS4gQWxzbyBpbXBsZW1lbnRzIFJvdXRlLiAqL1xuZXhwb3J0IHR5cGUgQXBwUm91dGUgPSB7XG4gIC8qKiBQYWdlIFRpdGxlIChJRDoge0Y4MTcxRUNCLTM3QzUtNTRFRS1CRkVELUY2ODlDODc4QjZFMn0pLiAqL1xuICBwYWdlVGl0bGU/OiBNYXliZTxUZXh0RmllbGQ+O1xufTtcblxuZXhwb3J0IHR5cGUgTmFtZVZhbHVlTGlzdFZhbHVlID0ge1xuICBfX3R5cGVuYW1lPzogJ05hbWVWYWx1ZUxpc3RWYWx1ZSc7XG4gIC8qKiBUaGUgbmFtZSBvZiB0aGUgbmFtZS12YWx1ZSBwYWlyICovXG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICAvKiogVGhlIHZhbHVlIG9mIHRoZSBuYW1lLXZhbHVlIHBhaXIgKi9cbiAgdmFsdWU6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuZXhwb3J0IHR5cGUgTmFtZVZhbHVlTGlzdEZpZWxkID0gSXRlbUZpZWxkICYge1xuICBfX3R5cGVuYW1lPzogJ05hbWVWYWx1ZUxpc3RGaWVsZCc7XG4gIGRlZmluaXRpb24/OiBNYXliZTxJdGVtVGVtcGxhdGVGaWVsZD47XG4gIC8qKiBUaGUgR1VJRCBvZiB0aGlzIGZpZWxkLiAqL1xuICBpZDogU2NhbGFyc1snSUQnXTtcbiAganNvblZhbHVlOiBTY2FsYXJzWydKU09OJ107XG4gIG5hbWU6IFNjYWxhcnNbJ1N0cmluZyddO1xuICB2YWx1ZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgLyoqIFRoZSBrZXktdmFsdWUgcGFpcnMgaW4gdGhpcyBmaWVsZCAqL1xuICB2YWx1ZXM/OiBNYXliZTxBcnJheTxNYXliZTxOYW1lVmFsdWVMaXN0VmFsdWU+Pj47XG59O1xuXG5cbmV4cG9ydCB0eXBlIE5hbWVWYWx1ZUxpc3RGaWVsZElkQXJncyA9IHtcbiAgZm9ybWF0PzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xufTtcblxuZXhwb3J0IHR5cGUgUXVlcnkgPSB7XG4gIF9fdHlwZW5hbWU/OiAnUXVlcnknO1xuICAvKiogQWxsb3dzIHF1ZXJ5aW5nIGl0ZW1zIGZyb20gdGhlIGNvbnRlbnQgdHJlZSAqL1xuICBpdGVtPzogTWF5YmU8SXRlbT47XG4gIC8qKiBBbGxvd3MgcXVlcnlpbmcgbGF5b3V0IGRhdGEgZm9yIHRoZSBpdGVtICovXG4gIGxheW91dD86IE1heWJlPExheW91dERhdGE+O1xuICAvKiogQWxsb3dzIHRvIHF1ZXJ5IGl0ZW1zIHRocm91Z2ggdGhlIHNlYXJjaCAqL1xuICBzZWFyY2g/OiBNYXliZTxJdGVtU2VhcmNoUmVzdWx0cz47XG59O1xuXG5cbmV4cG9ydCB0eXBlIFF1ZXJ5SXRlbUFyZ3MgPSB7XG4gIHBhdGg/OiBNYXliZTxTY2FsYXJzWydTdHJpbmcnXT47XG4gIGxhbmd1YWdlOiBTY2FsYXJzWydTdHJpbmcnXTtcbn07XG5cblxuZXhwb3J0IHR5cGUgUXVlcnlMYXlvdXRBcmdzID0ge1xuICBzaXRlOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgcm91dGVQYXRoOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IFNjYWxhcnNbJ1N0cmluZyddO1xufTtcblxuXG5leHBvcnQgdHlwZSBRdWVyeVNlYXJjaEFyZ3MgPSB7XG4gIHdoZXJlOiBJdGVtU2VhcmNoUHJlZGljYXRlR3JhcGhUeXBlO1xuICBhZnRlcj86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgZmlyc3Q/OiBNYXliZTxTY2FsYXJzWydJbnQnXT47XG4gIG9yZGVyQnk/OiBNYXliZTxJdGVtU2VhcmNoT3JkZXJCeT47XG59O1xuXG5leHBvcnQgdHlwZSBJdGVtU2VhcmNoUHJlZGljYXRlR3JhcGhUeXBlID0ge1xuICBuYW1lPzogTWF5YmU8U2NhbGFyc1snU3RyaW5nJ10+O1xuICB2YWx1ZT86IE1heWJlPFNjYWxhcnNbJ1N0cmluZyddPjtcbiAgQU5EPzogTWF5YmU8QXJyYXk8TWF5YmU8SXRlbVNlYXJjaFByZWRpY2F0ZUdyYXBoVHlwZT4+PjtcbiAgT1I/OiBNYXliZTxBcnJheTxNYXliZTxJdGVtU2VhcmNoUHJlZGljYXRlR3JhcGhUeXBlPj4+O1xuICBvcGVyYXRvcj86IE1heWJlPEl0ZW1TZWFyY2hPcGVyYXRvcj47XG59O1xuXG5leHBvcnQgZW51bSBJdGVtU2VhcmNoT3BlcmF0b3Ige1xuICBFcSA9ICdFUScsXG4gIENvbnRhaW5zID0gJ0NPTlRBSU5TJyxcbiAgTmVxID0gJ05FUScsXG4gIE5jb250YWlucyA9ICdOQ09OVEFJTlMnXG59XG5cbmV4cG9ydCB0eXBlIEl0ZW1TZWFyY2hPcmRlckJ5ID0ge1xuICBuYW1lOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgZGlyZWN0aW9uPzogTWF5YmU8T3JkZXJpbmc+O1xufTtcblxuZXhwb3J0IGVudW0gT3JkZXJpbmcge1xuICBBc2MgPSAnQVNDJyxcbiAgRGVzYyA9ICdERVNDJ1xufVxuXG5leHBvcnQgdHlwZSBDb25uZWN0ZWREZW1vUXVlcnlRdWVyeVZhcmlhYmxlcyA9IEV4YWN0PHtcbiAgZGF0YXNvdXJjZTogU2NhbGFyc1snU3RyaW5nJ107XG4gIGNvbnRleHRJdGVtOiBTY2FsYXJzWydTdHJpbmcnXTtcbiAgbGFuZ3VhZ2U6IFNjYWxhcnNbJ1N0cmluZyddO1xufT47XG5cblxuZXhwb3J0IHR5cGUgQ29ubmVjdGVkRGVtb1F1ZXJ5UXVlcnkgPSAoXG4gIHsgX190eXBlbmFtZT86ICdRdWVyeScgfVxuICAmIHsgZGF0YXNvdXJjZT86IE1heWJlPChcbiAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnIHwgJ25hbWUnPlxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJyB8ICduYW1lJz5cbiAgICAmIHsgc2FtcGxlMT86IE1heWJlPChcbiAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICApPiwgc2FtcGxlMj86IE1heWJlPChcbiAgICAgIHsgX190eXBlbmFtZT86ICdMaW5rRmllbGQnIH1cbiAgICAgICYgUGljazxMaW5rRmllbGQsICdqc29uVmFsdWUnIHwgJ3RleHQnIHwgJ3RhcmdldCcgfCAndXJsJz5cbiAgICAgICYgeyBkZWZpbml0aW9uPzogTWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVRlbXBsYXRlRmllbGQnIH1cbiAgICAgICAgJiBQaWNrPEl0ZW1UZW1wbGF0ZUZpZWxkLCAndHlwZScgfCAnc2hhcmVkJz5cbiAgICAgICk+IH1cbiAgICApPiB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJyB8ICduYW1lJz5cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCcgfCAnbmFtZSc+XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICYgUGljazxBcHAsICdpZCcgfCAnbmFtZSc+XG4gICk+LCBjb250ZXh0SXRlbT86IE1heWJlPChcbiAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAmIHsgY2hpbGRyZW46IChcbiAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cycgfVxuICAgICAgJiB7IHJlc3VsdHM6IEFycmF5PE1heWJlPChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1Vua25vd25JdGVtJyB9XG4gICAgICAgICYgUGljazxVbmtub3duSXRlbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2VjdGlvbiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlcicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JyB9XG4gICAgICAgICYgUGljazxDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnUmVuZGVyRW5naW5lVHlwZScgfVxuICAgICAgICAmIFBpY2s8UmVuZGVyRW5naW5lVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSlNTTGF5b3V0JyB9XG4gICAgICAgICYgUGljazxKc3NMYXlvdXQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX0FwcFJvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19BcHBSb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdBcHAnIH1cbiAgICAgICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApPj4gfVxuICAgICkgfVxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAmIHsgY2hpbGRyZW46IChcbiAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cycgfVxuICAgICAgJiB7IHJlc3VsdHM6IEFycmF5PE1heWJlPChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1Vua25vd25JdGVtJyB9XG4gICAgICAgICYgUGljazxVbmtub3duSXRlbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2VjdGlvbiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlcicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JyB9XG4gICAgICAgICYgUGljazxDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnUmVuZGVyRW5naW5lVHlwZScgfVxuICAgICAgICAmIFBpY2s8UmVuZGVyRW5naW5lVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSlNTTGF5b3V0JyB9XG4gICAgICAgICYgUGljazxKc3NMYXlvdXQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX0FwcFJvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19BcHBSb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdBcHAnIH1cbiAgICAgICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApPj4gfVxuICAgICkgfVxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAmIHsgY2hpbGRyZW46IChcbiAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cycgfVxuICAgICAgJiB7IHJlc3VsdHM6IEFycmF5PE1heWJlPChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1Vua25vd25JdGVtJyB9XG4gICAgICAgICYgUGljazxVbmtub3duSXRlbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2VjdGlvbiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlcicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JyB9XG4gICAgICAgICYgUGljazxDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnUmVuZGVyRW5naW5lVHlwZScgfVxuICAgICAgICAmIFBpY2s8UmVuZGVyRW5naW5lVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSlNTTGF5b3V0JyB9XG4gICAgICAgICYgUGljazxKc3NMYXlvdXQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX0FwcFJvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19BcHBSb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdBcHAnIH1cbiAgICAgICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApPj4gfVxuICAgICkgfVxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAmIHsgY2hpbGRyZW46IChcbiAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cycgfVxuICAgICAgJiB7IHJlc3VsdHM6IEFycmF5PE1heWJlPChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1Vua25vd25JdGVtJyB9XG4gICAgICAgICYgUGljazxVbmtub3duSXRlbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2VjdGlvbiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlcicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JyB9XG4gICAgICAgICYgUGljazxDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnUmVuZGVyRW5naW5lVHlwZScgfVxuICAgICAgICAmIFBpY2s8UmVuZGVyRW5naW5lVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSlNTTGF5b3V0JyB9XG4gICAgICAgICYgUGljazxKc3NMYXlvdXQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX0FwcFJvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19BcHBSb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdBcHAnIH1cbiAgICAgICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApPj4gfVxuICAgICkgfVxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAmIHsgY2hpbGRyZW46IChcbiAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cycgfVxuICAgICAgJiB7IHJlc3VsdHM6IEFycmF5PE1heWJlPChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1Vua25vd25JdGVtJyB9XG4gICAgICAgICYgUGljazxVbmtub3duSXRlbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2VjdGlvbiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlcicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JyB9XG4gICAgICAgICYgUGljazxDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnUmVuZGVyRW5naW5lVHlwZScgfVxuICAgICAgICAmIFBpY2s8UmVuZGVyRW5naW5lVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSlNTTGF5b3V0JyB9XG4gICAgICAgICYgUGljazxKc3NMYXlvdXQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX0FwcFJvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19BcHBSb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdBcHAnIH1cbiAgICAgICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApPj4gfVxuICAgICkgfVxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAmIHsgY2hpbGRyZW46IChcbiAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cycgfVxuICAgICAgJiB7IHJlc3VsdHM6IEFycmF5PE1heWJlPChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1Vua25vd25JdGVtJyB9XG4gICAgICAgICYgUGljazxVbmtub3duSXRlbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2VjdGlvbiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlcicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JyB9XG4gICAgICAgICYgUGljazxDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnUmVuZGVyRW5naW5lVHlwZScgfVxuICAgICAgICAmIFBpY2s8UmVuZGVyRW5naW5lVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSlNTTGF5b3V0JyB9XG4gICAgICAgICYgUGljazxKc3NMYXlvdXQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX0FwcFJvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19BcHBSb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdBcHAnIH1cbiAgICAgICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApPj4gfVxuICAgICkgfVxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAmIHsgY2hpbGRyZW46IChcbiAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cycgfVxuICAgICAgJiB7IHJlc3VsdHM6IEFycmF5PE1heWJlPChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1Vua25vd25JdGVtJyB9XG4gICAgICAgICYgUGljazxVbmtub3duSXRlbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2VjdGlvbiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlcicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JyB9XG4gICAgICAgICYgUGljazxDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnUmVuZGVyRW5naW5lVHlwZScgfVxuICAgICAgICAmIFBpY2s8UmVuZGVyRW5naW5lVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSlNTTGF5b3V0JyB9XG4gICAgICAgICYgUGljazxKc3NMYXlvdXQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX0FwcFJvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19BcHBSb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdBcHAnIH1cbiAgICAgICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApPj4gfVxuICAgICkgfVxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAmIHsgY2hpbGRyZW46IChcbiAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cycgfVxuICAgICAgJiB7IHJlc3VsdHM6IEFycmF5PE1heWJlPChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1Vua25vd25JdGVtJyB9XG4gICAgICAgICYgUGljazxVbmtub3duSXRlbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2VjdGlvbiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlcicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JyB9XG4gICAgICAgICYgUGljazxDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnUmVuZGVyRW5naW5lVHlwZScgfVxuICAgICAgICAmIFBpY2s8UmVuZGVyRW5naW5lVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSlNTTGF5b3V0JyB9XG4gICAgICAgICYgUGljazxKc3NMYXlvdXQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX0FwcFJvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19BcHBSb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdBcHAnIH1cbiAgICAgICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApPj4gfVxuICAgICkgfVxuICApIHwgKFxuICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICYgeyBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAmIFBpY2s8VGV4dEZpZWxkLCAndmFsdWUnPlxuICAgICk+LCBjaGlsZHJlbjogKFxuICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1TZWFyY2hSZXN1bHRzJyB9XG4gICAgICAmIHsgcmVzdWx0czogQXJyYXk8TWF5YmU8KFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVW5rbm93bkl0ZW0nIH1cbiAgICAgICAgJiBQaWNrPFVua25vd25JdGVtLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlVHJhY2tpbmcnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVUcmFja2luZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVNlY3Rpb24nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTZWN0aW9uLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlUm91dGVGaWVsZHMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZU11bHRpbGluZ3VhbCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZU11bHRpbGluZ3VhbCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnNUYWInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFicycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRSZXVzZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFJldXNlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlciwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20nIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNvbnRlbnRMaXN0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3RhbmRhcmRUZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fU3RhbmRhcmRUZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1JvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdSZW5kZXJFbmdpbmVUeXBlJyB9XG4gICAgICAgICYgUGljazxSZW5kZXJFbmdpbmVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKc29uUmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKc29uUmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKYXZhU2NyaXB0UmVuZGVyaW5nJyB9XG4gICAgICAgICYgUGljazxKYXZhU2NyaXB0UmVuZGVyaW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdKU1NMYXlvdXQnIH1cbiAgICAgICAgJiBQaWNrPEpzc0xheW91dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTEludGVncmF0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsSW50ZWdyYXRlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxDb25uZWN0ZWREZW1vJyB9XG4gICAgICAgICYgUGljazxHcmFwaFFsQ29ubmVjdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnRXhhbXBsZUN1c3RvbVJvdXRlVHlwZScgfVxuICAgICAgICAmIFBpY2s8RXhhbXBsZUN1c3RvbVJvdXRlVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDb250ZW50QmxvY2snIH1cbiAgICAgICAgJiBQaWNrPENvbnRlbnRCbG9jaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAgICAgJiBQaWNrPENfX0FwcFJvdXRlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0FwcCcgfVxuICAgICAgICAmIFBpY2s8QXBwLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICk+PiB9XG4gICAgKSB9XG4gICkgfCAoXG4gICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgJiB7IGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnQ19fQXBwUm91dGUnIH1cbiAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICYgUGljazxUZXh0RmllbGQsICd2YWx1ZSc+XG4gICAgKT4sIGNoaWxkcmVuOiAoXG4gICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVNlYXJjaFJlc3VsdHMnIH1cbiAgICAgICYgeyByZXN1bHRzOiBBcnJheTxNYXliZTwoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdVbmtub3duSXRlbScgfVxuICAgICAgICAmIFBpY2s8VW5rbm93bkl0ZW0sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVUcmFja2luZycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVRyYWNraW5nLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlU2VjdGlvbicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVNlY3Rpb24sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVSb3V0ZUZpZWxkcycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZVJvdXRlRmllbGRzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTXVsdGlsaW5ndWFsJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTXVsdGlsaW5ndWFsLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0VGFic1RhYicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUxheW91dFRhYnNUYWIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFicywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFJldXNlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0UmV1c2UsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVJdGVtTGlua0l0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXInIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTnVtYmVyLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUxpbmsnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluaywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VJbWFnZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDdXN0b20sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ29udGVudExpc3QsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ2hlY2tib3gsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0eWxlZ3VpZGVFeHBsYW5hdG9yeUNvbXBvbmVudCcgfVxuICAgICAgICAmIFBpY2s8Q19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29udGVudExpc3RJdGVtVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNSZW5kZXJpbmdQYXJhbWV0ZXJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19TdGFuZGFyZFRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxDX19TdGFuZGFyZFRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19Sb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fUm91dGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1JlbmRlckVuZ2luZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPFJlbmRlckVuZ2luZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pzb25SZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEpzb25SZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0phdmFTY3JpcHRSZW5kZXJpbmcnIH1cbiAgICAgICAgJiBQaWNrPEphdmFTY3JpcHRSZW5kZXJpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0pTU0xheW91dCcgfVxuICAgICAgICAmIFBpY2s8SnNzTGF5b3V0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMSW50ZWdyYXRlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxJbnRlZ3JhdGVkRGVtbywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnR3JhcGhRTENvbm5lY3RlZERlbW8nIH1cbiAgICAgICAgJiBQaWNrPEdyYXBoUWxDb25uZWN0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdFeGFtcGxlQ3VzdG9tUm91dGVUeXBlJyB9XG4gICAgICAgICYgUGljazxFeGFtcGxlQ3VzdG9tUm91dGVUeXBlLCAnaWQnPlxuICAgICAgICAmIHsgcGFnZVRpdGxlPzogTWF5YmU8KFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdUZXh0RmllbGQnIH1cbiAgICAgICAgICAmIFBpY2s8VGV4dEZpZWxkLCAnanNvblZhbHVlJyB8ICd2YWx1ZSc+XG4gICAgICAgICk+LCB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NvbnRlbnRCbG9jaycgfVxuICAgICAgICAmIFBpY2s8Q29udGVudEJsb2NrLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdDX19BcHBSb3V0ZScgfVxuICAgICAgICAmIFBpY2s8Q19fQXBwUm91dGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgICAgICYgUGljazxBcHAsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKT4+IH1cbiAgICApIH1cbiAgKSB8IChcbiAgICB7IF9fdHlwZW5hbWU/OiAnQXBwJyB9XG4gICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAmIHsgY2hpbGRyZW46IChcbiAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtU2VhcmNoUmVzdWx0cycgfVxuICAgICAgJiB7IHJlc3VsdHM6IEFycmF5PE1heWJlPChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1Vua25vd25JdGVtJyB9XG4gICAgICAgICYgUGljazxVbmtub3duSXRlbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVRyYWNraW5nJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlVHJhY2tpbmcsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVTZWN0aW9uJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlU2VjdGlvbiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZVJvdXRlRmllbGRzJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlUm91dGVGaWVsZHMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVNdWx0aWxpbmd1YWwnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUxheW91dFRhYnMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRUYWJzLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlTGF5b3V0UmV1c2UnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUl0ZW1MaW5rSXRlbVRlbXBsYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlSXRlbUxpbmtJdGVtVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0JyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZVJpY2hUZXh0LCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZU51bWJlcicgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlTGluaycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUl0ZW1MaW5rLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVGaWVsZFVzYWdlRmlsZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VEYXRlJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZURhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tJyB9XG4gICAgICAgICYgUGljazxTdHlsZWd1aWRlRmllbGRVc2FnZUN1c3RvbSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCcgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ19fU3R5bGVndWlkZUV4cGxhbmF0b3J5Q29tcG9uZW50JyB9XG4gICAgICAgICYgUGljazxDX19TdHlsZWd1aWRlRXhwbGFuYXRvcnlDb21wb25lbnQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb250ZW50TGlzdEl0ZW1UZW1wbGF0ZScgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbnRlbnRMaXN0SXRlbVRlbXBsYXRlLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zUmVuZGVyaW5nUGFyYW1ldGVycycgfVxuICAgICAgICAmIFBpY2s8U3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1JlbmRlcmluZ1BhcmFtZXRlcnMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1N0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMnIH1cbiAgICAgICAgJiBQaWNrPFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1N0YW5kYXJkVGVtcGxhdGUnIH1cbiAgICAgICAgJiBQaWNrPENfX1N0YW5kYXJkVGVtcGxhdGUsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX1JvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19Sb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnUmVuZGVyRW5naW5lVHlwZScgfVxuICAgICAgICAmIFBpY2s8UmVuZGVyRW5naW5lVHlwZSwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSnNvblJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SnNvblJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSmF2YVNjcmlwdFJlbmRlcmluZycgfVxuICAgICAgICAmIFBpY2s8SmF2YVNjcmlwdFJlbmRlcmluZywgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSlNTTGF5b3V0JyB9XG4gICAgICAgICYgUGljazxKc3NMYXlvdXQsICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0dyYXBoUUxJbnRlZ3JhdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbEludGVncmF0ZWREZW1vLCAnaWQnPlxuICAgICAgICAmIHsgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdHcmFwaFFMQ29ubmVjdGVkRGVtbycgfVxuICAgICAgICAmIFBpY2s8R3JhcGhRbENvbm5lY3RlZERlbW8sICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0V4YW1wbGVDdXN0b21Sb3V0ZVR5cGUnIH1cbiAgICAgICAgJiBQaWNrPEV4YW1wbGVDdXN0b21Sb3V0ZVR5cGUsICdpZCc+XG4gICAgICAgICYgeyBwYWdlVGl0bGU/OiBNYXliZTwoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ1RleHRGaWVsZCcgfVxuICAgICAgICAgICYgUGljazxUZXh0RmllbGQsICdqc29uVmFsdWUnIHwgJ3ZhbHVlJz5cbiAgICAgICAgKT4sIHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApIHwgKFxuICAgICAgICB7IF9fdHlwZW5hbWU/OiAnQ29udGVudEJsb2NrJyB9XG4gICAgICAgICYgUGljazxDb250ZW50QmxvY2ssICdpZCc+XG4gICAgICAgICYgeyB1cmw6IChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnSXRlbVVybCcgfVxuICAgICAgICAgICYgUGljazxJdGVtVXJsLCAncGF0aCc+XG4gICAgICAgICkgfVxuICAgICAgKSB8IChcbiAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0NfX0FwcFJvdXRlJyB9XG4gICAgICAgICYgUGljazxDX19BcHBSb3V0ZSwgJ2lkJz5cbiAgICAgICAgJiB7IHBhZ2VUaXRsZT86IE1heWJlPChcbiAgICAgICAgICB7IF9fdHlwZW5hbWU/OiAnVGV4dEZpZWxkJyB9XG4gICAgICAgICAgJiBQaWNrPFRleHRGaWVsZCwgJ2pzb25WYWx1ZScgfCAndmFsdWUnPlxuICAgICAgICApPiwgdXJsOiAoXG4gICAgICAgICAgeyBfX3R5cGVuYW1lPzogJ0l0ZW1VcmwnIH1cbiAgICAgICAgICAmIFBpY2s8SXRlbVVybCwgJ3BhdGgnPlxuICAgICAgICApIH1cbiAgICAgICkgfCAoXG4gICAgICAgIHsgX190eXBlbmFtZT86ICdBcHAnIH1cbiAgICAgICAgJiBQaWNrPEFwcCwgJ2lkJz5cbiAgICAgICAgJiB7IHVybDogKFxuICAgICAgICAgIHsgX190eXBlbmFtZT86ICdJdGVtVXJsJyB9XG4gICAgICAgICAgJiBQaWNrPEl0ZW1VcmwsICdwYXRoJz5cbiAgICAgICAgKSB9XG4gICAgICApPj4gfVxuICAgICkgfVxuICApPiB9XG4pO1xuXG5cbmV4cG9ydCBjb25zdCBDb25uZWN0ZWREZW1vUXVlcnlEb2N1bWVudDogRG9jdW1lbnROb2RlPENvbm5lY3RlZERlbW9RdWVyeVF1ZXJ5LCBDb25uZWN0ZWREZW1vUXVlcnlRdWVyeVZhcmlhYmxlcz4gPSB7XCJraW5kXCI6XCJEb2N1bWVudFwiLFwiZGVmaW5pdGlvbnNcIjpbe1wia2luZFwiOlwiT3BlcmF0aW9uRGVmaW5pdGlvblwiLFwib3BlcmF0aW9uXCI6XCJxdWVyeVwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJDb25uZWN0ZWREZW1vUXVlcnlcIn0sXCJ2YXJpYWJsZURlZmluaXRpb25zXCI6W3tcImtpbmRcIjpcIlZhcmlhYmxlRGVmaW5pdGlvblwiLFwidmFyaWFibGVcIjp7XCJraW5kXCI6XCJWYXJpYWJsZVwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJkYXRhc291cmNlXCJ9fSxcInR5cGVcIjp7XCJraW5kXCI6XCJOb25OdWxsVHlwZVwiLFwidHlwZVwiOntcImtpbmRcIjpcIk5hbWVkVHlwZVwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJTdHJpbmdcIn19fX0se1wia2luZFwiOlwiVmFyaWFibGVEZWZpbml0aW9uXCIsXCJ2YXJpYWJsZVwiOntcImtpbmRcIjpcIlZhcmlhYmxlXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImNvbnRleHRJdGVtXCJ9fSxcInR5cGVcIjp7XCJraW5kXCI6XCJOb25OdWxsVHlwZVwiLFwidHlwZVwiOntcImtpbmRcIjpcIk5hbWVkVHlwZVwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJTdHJpbmdcIn19fX0se1wia2luZFwiOlwiVmFyaWFibGVEZWZpbml0aW9uXCIsXCJ2YXJpYWJsZVwiOntcImtpbmRcIjpcIlZhcmlhYmxlXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImxhbmd1YWdlXCJ9fSxcInR5cGVcIjp7XCJraW5kXCI6XCJOb25OdWxsVHlwZVwiLFwidHlwZVwiOntcImtpbmRcIjpcIk5hbWVkVHlwZVwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJTdHJpbmdcIn19fX1dLFwic2VsZWN0aW9uU2V0XCI6e1wia2luZFwiOlwiU2VsZWN0aW9uU2V0XCIsXCJzZWxlY3Rpb25zXCI6W3tcImtpbmRcIjpcIkZpZWxkXCIsXCJhbGlhc1wiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJkYXRhc291cmNlXCJ9LFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJpdGVtXCJ9LFwiYXJndW1lbnRzXCI6W3tcImtpbmRcIjpcIkFyZ3VtZW50XCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcInBhdGhcIn0sXCJ2YWx1ZVwiOntcImtpbmRcIjpcIlZhcmlhYmxlXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImRhdGFzb3VyY2VcIn19fSx7XCJraW5kXCI6XCJBcmd1bWVudFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJsYW5ndWFnZVwifSxcInZhbHVlXCI6e1wia2luZFwiOlwiVmFyaWFibGVcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwibGFuZ3VhZ2VcIn19fV0sXCJzZWxlY3Rpb25TZXRcIjp7XCJraW5kXCI6XCJTZWxlY3Rpb25TZXRcIixcInNlbGVjdGlvbnNcIjpbe1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwiaWRcIn19LHtcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcIm5hbWVcIn19LHtcImtpbmRcIjpcIklubGluZUZyYWdtZW50XCIsXCJ0eXBlQ29uZGl0aW9uXCI6e1wia2luZFwiOlwiTmFtZWRUeXBlXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcIkdyYXBoUUxDb25uZWN0ZWREZW1vXCJ9fSxcInNlbGVjdGlvblNldFwiOntcImtpbmRcIjpcIlNlbGVjdGlvblNldFwiLFwic2VsZWN0aW9uc1wiOlt7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJzYW1wbGUxXCJ9LFwic2VsZWN0aW9uU2V0XCI6e1wia2luZFwiOlwiU2VsZWN0aW9uU2V0XCIsXCJzZWxlY3Rpb25zXCI6W3tcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImpzb25WYWx1ZVwifX0se1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwidmFsdWVcIn19XX19LHtcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcInNhbXBsZTJcIn0sXCJzZWxlY3Rpb25TZXRcIjp7XCJraW5kXCI6XCJTZWxlY3Rpb25TZXRcIixcInNlbGVjdGlvbnNcIjpbe1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwianNvblZhbHVlXCJ9fSx7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJ0ZXh0XCJ9fSx7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJ0YXJnZXRcIn19LHtcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcInVybFwifX0se1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwiZGVmaW5pdGlvblwifSxcInNlbGVjdGlvblNldFwiOntcImtpbmRcIjpcIlNlbGVjdGlvblNldFwiLFwic2VsZWN0aW9uc1wiOlt7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJ0eXBlXCJ9fSx7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJzaGFyZWRcIn19XX19XX19XX19XX19LHtcImtpbmRcIjpcIkZpZWxkXCIsXCJhbGlhc1wiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJjb250ZXh0SXRlbVwifSxcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwiaXRlbVwifSxcImFyZ3VtZW50c1wiOlt7XCJraW5kXCI6XCJBcmd1bWVudFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJwYXRoXCJ9LFwidmFsdWVcIjp7XCJraW5kXCI6XCJWYXJpYWJsZVwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJjb250ZXh0SXRlbVwifX19LHtcImtpbmRcIjpcIkFyZ3VtZW50XCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImxhbmd1YWdlXCJ9LFwidmFsdWVcIjp7XCJraW5kXCI6XCJWYXJpYWJsZVwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJsYW5ndWFnZVwifX19XSxcInNlbGVjdGlvblNldFwiOntcImtpbmRcIjpcIlNlbGVjdGlvblNldFwiLFwic2VsZWN0aW9uc1wiOlt7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJpZFwifX0se1wia2luZFwiOlwiSW5saW5lRnJhZ21lbnRcIixcInR5cGVDb25kaXRpb25cIjp7XCJraW5kXCI6XCJOYW1lZFR5cGVcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwiQXBwUm91dGVcIn19LFwic2VsZWN0aW9uU2V0XCI6e1wia2luZFwiOlwiU2VsZWN0aW9uU2V0XCIsXCJzZWxlY3Rpb25zXCI6W3tcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcInBhZ2VUaXRsZVwifSxcInNlbGVjdGlvblNldFwiOntcImtpbmRcIjpcIlNlbGVjdGlvblNldFwiLFwic2VsZWN0aW9uc1wiOlt7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJ2YWx1ZVwifX1dfX1dfX0se1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwiY2hpbGRyZW5cIn0sXCJhcmd1bWVudHNcIjpbe1wia2luZFwiOlwiQXJndW1lbnRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwiaGFzTGF5b3V0XCJ9LFwidmFsdWVcIjp7XCJraW5kXCI6XCJCb29sZWFuVmFsdWVcIixcInZhbHVlXCI6dHJ1ZX19XSxcInNlbGVjdGlvblNldFwiOntcImtpbmRcIjpcIlNlbGVjdGlvblNldFwiLFwic2VsZWN0aW9uc1wiOlt7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJyZXN1bHRzXCJ9LFwic2VsZWN0aW9uU2V0XCI6e1wia2luZFwiOlwiU2VsZWN0aW9uU2V0XCIsXCJzZWxlY3Rpb25zXCI6W3tcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImlkXCJ9fSx7XCJraW5kXCI6XCJJbmxpbmVGcmFnbWVudFwiLFwidHlwZUNvbmRpdGlvblwiOntcImtpbmRcIjpcIk5hbWVkVHlwZVwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJBcHBSb3V0ZVwifX0sXCJzZWxlY3Rpb25TZXRcIjp7XCJraW5kXCI6XCJTZWxlY3Rpb25TZXRcIixcInNlbGVjdGlvbnNcIjpbe1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwicGFnZVRpdGxlXCJ9LFwic2VsZWN0aW9uU2V0XCI6e1wia2luZFwiOlwiU2VsZWN0aW9uU2V0XCIsXCJzZWxlY3Rpb25zXCI6W3tcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcImpzb25WYWx1ZVwifX0se1wia2luZFwiOlwiRmllbGRcIixcIm5hbWVcIjp7XCJraW5kXCI6XCJOYW1lXCIsXCJ2YWx1ZVwiOlwidmFsdWVcIn19XX19XX19LHtcImtpbmRcIjpcIkZpZWxkXCIsXCJuYW1lXCI6e1wia2luZFwiOlwiTmFtZVwiLFwidmFsdWVcIjpcInVybFwifSxcInNlbGVjdGlvblNldFwiOntcImtpbmRcIjpcIlNlbGVjdGlvblNldFwiLFwic2VsZWN0aW9uc1wiOlt7XCJraW5kXCI6XCJGaWVsZFwiLFwibmFtZVwiOntcImtpbmRcIjpcIk5hbWVcIixcInZhbHVlXCI6XCJwYXRoXCJ9fV19fV19fV19fV19fV19fV19OyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7XHJcbiAgVGV4dCxcclxuICBMaW5rLFxyXG4gIEdldFNlcnZlclNpZGVDb21wb25lbnRQcm9wcyxcclxuICBHZXRTdGF0aWNDb21wb25lbnRQcm9wcyxcclxuICB1c2VDb21wb25lbnRQcm9wcyxcclxuICBKU1NfTU9ERV9ESVNDT05ORUNURUQsXHJcbiAgR3JhcGhRTFJlcXVlc3RDbGllbnQsXHJcbn0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IE5leHRMaW5rIGZyb20gJ25leHQvbGluayc7XHJcbmltcG9ydCB7XHJcbiAgQ29ubmVjdGVkRGVtb1F1ZXJ5RG9jdW1lbnQsXHJcbiAgQXBwUm91dGUsXHJcbiAgSXRlbSxcclxuICBHcmFwaFFsQ29ubmVjdGVkRGVtbyBhcyBHcmFwUUxDb25uZWN0ZWREZW1vRGF0YXNvdXJjZSxcclxufSBmcm9tICcuL0dyYXBoUUwtQ29ubmVjdGVkRGVtby5ncmFwaHFsJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzIH0gZnJvbSAnbGliL2NvbXBvbmVudC1wcm9wcyc7XHJcbmltcG9ydCBjb25maWcgZnJvbSAndGVtcC9jb25maWcnO1xyXG5cclxudHlwZSBSb3V0ZUl0ZW0gPSBBcHBSb3V0ZSAmIEl0ZW07XHJcblxyXG50eXBlIEdyYXBoUUxDb25uZWN0ZWREZW1vRGF0YSA9IHtcclxuICBkYXRhc291cmNlOiBHcmFwUUxDb25uZWN0ZWREZW1vRGF0YXNvdXJjZTtcclxuICBjb250ZXh0SXRlbTogUm91dGVJdGVtO1xyXG59O1xyXG5cclxuY29uc3QgR3JhcGhRTENvbm5lY3RlZERlbW8gPSAocHJvcHM6IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcyk6IEpTWC5FbGVtZW50ID0+IHtcclxuICBjb25zdCBkYXRhID0gcHJvcHMucmVuZGVyaW5nLnVpZFxyXG4gICAgPyB1c2VDb21wb25lbnRQcm9wczxHcmFwaFFMQ29ubmVjdGVkRGVtb0RhdGE+KHByb3BzLnJlbmRlcmluZy51aWQpXHJcbiAgICA6IHVuZGVmaW5lZDtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgZGF0YS1lMmUtaWQ9XCJncmFwaHFsLWNvbm5lY3RlZFwiPlxyXG4gICAgICA8aDI+R3JhcGhRTCBDb25uZWN0ZWQgRGVtbzwvaDI+XHJcblxyXG4gICAgICA8cD5cclxuICAgICAgICBDb25uZWN0ZWQgR3JhcGhRTCBleGVjdXRlcyBHcmFwaFFMIHF1ZXJpZXMgZGlyZWN0bHkgYWdhaW5zdCB0aGUgU2l0ZWNvcmUgR3JhcGhRTCBlbmRwb2ludC5cclxuICAgICAgICBUaGlzIGV4YW1wbGUgcnVucyB0aGUgcXVlcnkgc2VydmVyLXNpZGUgdXNpbmcgY29tcG9uZW50LWxldmVsIDxjb2RlPmdldFN0YXRpY1Byb3BzPC9jb2RlPi9cclxuICAgICAgICA8Y29kZT5nZXRTZXJ2ZXJTaWRlUHJvcHM8L2NvZGU+LCBhIGZlYXR1cmUgb2YgdGhlIFNpdGVjb3JlIEpTUyBOZXh0LmpzIFNESy4gVGhlc2UgYXJlXHJcbiAgICAgICAgYWdncmVnYXRlZCBkdXJpbmcgdGhlIHRoZSBOZXh0LmpzIHBhZ2UtbGV2ZWwgPGNvZGU+Z2V0U3RhdGljUHJvcHM8L2NvZGU+L1xyXG4gICAgICAgIDxjb2RlPmdldFNlcnZlclNpZGVQcm9wczwvY29kZT4gZXhlY3V0aW9uLlxyXG4gICAgICA8L3A+XHJcblxyXG4gICAgICB7ZGF0YSAmJiBkYXRhLmRhdGFzb3VyY2UgJiYgKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICA8aDQ+RGF0YXNvdXJjZSBJdGVtICh2aWEgQ29ubmVjdGVkIEdyYXBoUUwpPC9oND5cclxuICAgICAgICAgIGlkOiB7ZGF0YS5kYXRhc291cmNlLmlkfVxyXG4gICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICBuYW1lOiB7ZGF0YS5kYXRhc291cmNlLm5hbWV9XHJcbiAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgIHNhbXBsZTE6IHtkYXRhLmRhdGFzb3VyY2Uuc2FtcGxlMT8udmFsdWV9XHJcbiAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgIHNhbXBsZTEgKGVkaXRhYmxlKTogPFRleHQgZmllbGQ9e2RhdGEuZGF0YXNvdXJjZS5zYW1wbGUxPy5qc29uVmFsdWV9IC8+XHJcbiAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgIHNhbXBsZTI6XHJcbiAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgPGxpPnRleHQ6IHtkYXRhLmRhdGFzb3VyY2Uuc2FtcGxlMj8udGV4dH08L2xpPlxyXG4gICAgICAgICAgICA8bGk+dXJsOiB7ZGF0YS5kYXRhc291cmNlLnNhbXBsZTI/LnVybH08L2xpPlxyXG4gICAgICAgICAgICA8bGk+dGFyZ2V0OiB7ZGF0YS5kYXRhc291cmNlLnNhbXBsZTI/LnRhcmdldH08L2xpPlxyXG4gICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgZWRpdGFibGU6IDxMaW5rIGZpZWxkPXtkYXRhLmRhdGFzb3VyY2Uuc2FtcGxlMj8uanNvblZhbHVlfSAvPlxyXG4gICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICA8bGk+ZmllbGQgdHlwZToge2RhdGEuZGF0YXNvdXJjZS5zYW1wbGUyPy5kZWZpbml0aW9uPy50eXBlfTwvbGk+XHJcbiAgICAgICAgICAgIDxsaT5maWVsZCBpcyBzaGFyZWQ/OiB7ZGF0YS5kYXRhc291cmNlLnNhbXBsZTI/LmRlZmluaXRpb24/LnNoYXJlZC50b1N0cmluZygpfTwvbGk+XHJcbiAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICApfVxyXG4gICAgICB7ZGF0YSAmJiBkYXRhLmNvbnRleHRJdGVtICYmIChcclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgPGg0PlJvdXRlIEl0ZW0gKHZpYSBDb25uZWN0ZWQgR3JhcGhRTCk8L2g0PlxyXG4gICAgICAgICAgaWQ6IHtkYXRhLmNvbnRleHRJdGVtLmlkfVxyXG4gICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICBwYWdlIHRpdGxlOiB7ZGF0YS5jb250ZXh0SXRlbS5wYWdlVGl0bGU/LnZhbHVlfVxyXG4gICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICBjaGlsZHJlbjpcclxuICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAge2RhdGEuY29udGV4dEl0ZW0uY2hpbGRyZW4ucmVzdWx0cy5tYXAoKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgcm91dGVJdGVtID0gY2hpbGQgYXMgUm91dGVJdGVtO1xyXG5cclxuICAgICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPGxpIGtleT17cm91dGVJdGVtLmlkfT5cclxuICAgICAgICAgICAgICAgICAgPE5leHRMaW5rIGhyZWY9e3JvdXRlSXRlbS51cmwucGF0aH0+e3JvdXRlSXRlbS5wYWdlVGl0bGU/LnZhbHVlfTwvTmV4dExpbms+XHJcbiAgICAgICAgICAgICAgICAgIChlZGl0YWJsZSB0aXRsZSB0b28hIDxUZXh0IGZpZWxkPXtyb3V0ZUl0ZW0ucGFnZVRpdGxlPy5qc29uVmFsdWV9IC8+KVxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KX1cclxuICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICl9XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpbGwgYmUgY2FsbGVkIGR1cmluZyBTU0dcclxuICogQHBhcmFtIHtDb21wb25lbnRSZW5kZXJpbmd9IHJlbmRlcmluZ1xyXG4gKiBAcGFyYW0ge0xheW91dFNlcnZpY2VEYXRhfSBsYXlvdXREYXRhXHJcbiAqIEBwYXJhbSB7R2V0U3RhdGljUHJvcHNDb250ZXh0fSBjb250ZXh0XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0U3RhdGljUHJvcHM6IEdldFN0YXRpY0NvbXBvbmVudFByb3BzID0gYXN5bmMgKHJlbmRlcmluZywgbGF5b3V0RGF0YSkgPT4ge1xyXG4gIGlmIChwcm9jZXNzLmVudi5KU1NfTU9ERSA9PT0gSlNTX01PREVfRElTQ09OTkVDVEVEKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGdyYXBoUUxDbGllbnQgPSBuZXcgR3JhcGhRTFJlcXVlc3RDbGllbnQoY29uZmlnLmdyYXBoUUxFbmRwb2ludCwge1xyXG4gICAgYXBpS2V5OiBjb25maWcuc2l0ZWNvcmVBcGlLZXksXHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdyYXBoUUxDbGllbnQucmVxdWVzdDxHcmFwaFFMQ29ubmVjdGVkRGVtb0RhdGE+KENvbm5lY3RlZERlbW9RdWVyeURvY3VtZW50LCB7XHJcbiAgICBkYXRhc291cmNlOiByZW5kZXJpbmcuZGF0YVNvdXJjZSxcclxuICAgIGNvbnRleHRJdGVtOiBsYXlvdXREYXRhPy5zaXRlY29yZT8ucm91dGU/Lml0ZW1JZCxcclxuICAgIGxhbmd1YWdlOiBsYXlvdXREYXRhPy5zaXRlY29yZT8uY29udGV4dD8ubGFuZ3VhZ2UsXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogV2lsbCBiZSBjYWxsZWQgZHVyaW5nIFNTUlxyXG4gKiBAcGFyYW0ge0NvbXBvbmVudFJlbmRlcmluZ30gcmVuZGVyaW5nXHJcbiAqIEBwYXJhbSB7TGF5b3V0U2VydmljZURhdGF9IGxheW91dERhdGFcclxuICogQHBhcmFtIHtHZXRTZXJ2ZXJTaWRlUHJvcHNDb250ZXh0fSBjb250ZXh0XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0U2VydmVyU2lkZVByb3BzOiBHZXRTZXJ2ZXJTaWRlQ29tcG9uZW50UHJvcHMgPSBhc3luYyAocmVuZGVyaW5nLCBsYXlvdXREYXRhKSA9PiB7XHJcbiAgaWYgKHByb2Nlc3MuZW52LkpTU19NT0RFID09PSBKU1NfTU9ERV9ESVNDT05ORUNURUQpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZ3JhcGhRTENsaWVudCA9IG5ldyBHcmFwaFFMUmVxdWVzdENsaWVudChjb25maWcuZ3JhcGhRTEVuZHBvaW50LCB7XHJcbiAgICBhcGlLZXk6IGNvbmZpZy5zaXRlY29yZUFwaUtleSxcclxuICB9KTtcclxuXHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3JhcGhRTENsaWVudC5yZXF1ZXN0PEdyYXBoUUxDb25uZWN0ZWREZW1vRGF0YT4oQ29ubmVjdGVkRGVtb1F1ZXJ5RG9jdW1lbnQsIHtcclxuICAgIGRhdGFzb3VyY2U6IHJlbmRlcmluZy5kYXRhU291cmNlLFxyXG4gICAgY29udGV4dEl0ZW06IGxheW91dERhdGE/LnNpdGVjb3JlPy5yb3V0ZT8uaXRlbUlkLFxyXG4gICAgbGFuZ3VhZ2U6IGxheW91dERhdGE/LnNpdGVjb3JlPy5jb250ZXh0Py5sYW5ndWFnZSxcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdyYXBoUUxDb25uZWN0ZWREZW1vO1xyXG4iLCJpbXBvcnQgeyBUZXh0LCBMaW5rIH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IE5leHRMaW5rIGZyb20gJ25leHQvbGluayc7XHJcblxyXG5pbnRlcmZhY2UgRGF0YVNvdXJjZSB7XHJcbiAgc2FtcGxlMToge1xyXG4gICAganNvblZhbHVlOiB7XHJcbiAgICAgIHZhbHVlOiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgdmFsdWU6IHN0cmluZztcclxuICB9O1xyXG4gIHNhbXBsZTI6IHtcclxuICAgIGRlZmluaXRpb246IHtcclxuICAgICAgdHlwZTogc3RyaW5nO1xyXG4gICAgICBzaGFyZWQ6IGJvb2xlYW47XHJcbiAgICB9O1xyXG4gICAganNvblZhbHVlOiB7XHJcbiAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgaHJlZjogc3RyaW5nO1xyXG4gICAgICAgIGxpbmt0eXBlOiBzdHJpbmc7XHJcbiAgICAgICAgdGFyZ2V0OiBzdHJpbmc7XHJcbiAgICAgICAgdGV4dDogc3RyaW5nO1xyXG4gICAgICAgIHVybDogc3RyaW5nO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIHRhcmdldDogc3RyaW5nO1xyXG4gICAgdGV4dDogc3RyaW5nO1xyXG4gICAgdXJsOiBzdHJpbmc7XHJcbiAgfTtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgaWQ6IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIEl0ZW0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdXJsOiB7XHJcbiAgICBwYXRoOiBzdHJpbmc7XHJcbiAgfTtcclxuICBwYWdlVGl0bGU6IHtcclxuICAgIHZhbHVlOiBzdHJpbmc7XHJcbiAgICBqc29uVmFsdWU6IHtcclxuICAgICAgdmFsdWU6IHN0cmluZztcclxuICAgIH07XHJcbiAgfTtcclxufVxyXG5cclxuaW50ZXJmYWNlIEl0ZW1TZWFyY2hSZXN1bHRzIHtcclxuICByZXN1bHRzOiBJdGVtW107XHJcbn1cclxuXHJcbmludGVyZmFjZSBHcmFwaFFsSW50ZWdyYXRlZERlbW9Qcm9wcyB7XHJcbiAgZmllbGRzOiB7XHJcbiAgICBkYXRhOiB7XHJcbiAgICAgIGRhdGFzb3VyY2U6IERhdGFTb3VyY2U7XHJcbiAgICAgIGNvbnRleHRJdGVtOiB7XHJcbiAgICAgICAgaWQ6IHN0cmluZztcclxuICAgICAgICBjaGlsZHJlbjogSXRlbVNlYXJjaFJlc3VsdHM7XHJcbiAgICAgICAgcGFnZVRpdGxlOiB7XHJcbiAgICAgICAgICB2YWx1ZTogc3RyaW5nO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IEdyYXBoUUxJbnRlZ3JhdGVkRGVtbyA9IChwcm9wczogR3JhcGhRbEludGVncmF0ZWREZW1vUHJvcHMpOiBKU1guRWxlbWVudCA9PiB7XHJcbiAgLy8gUXVlcnkgcmVzdWx0cyBpbiBpbnRlZ3JhdGVkIEdyYXBoUUwgcmVwbGFjZSB0aGUgbm9ybWFsIGBmaWVsZHNgIGRhdGFcclxuICAvLyBpLmUuIHdpdGggeyBkYXRhLCB9XHJcblxyXG4gIGNvbnNvbGUuZXJyb3IoSlNPTi5zdHJpbmdpZnkocHJvcHMpKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgZGF0YS1lMmUtaWQ9XCJncmFwaHFsLWludGVncmF0ZWRcIj5cclxuICAgICAgey8qIGtpamtlbiB3ZSBsYXRlciBuYWFyICovfVxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEdyYXBoUUxJbnRlZ3JhdGVkRGVtbztcclxuIiwiaW1wb3J0IHsgUGxhY2Vob2xkZXIsIHVzZVNpdGVjb3JlQ29udGV4dCB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcyc7XHJcbmltcG9ydCB7IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcywgU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dFZhbHVlIH0gZnJvbSAnbGliL2NvbXBvbmVudC1wcm9wcyc7XHJcblxyXG5jb25zdCBHcmFwaFFMTGF5b3V0ID0gKHsgcmVuZGVyaW5nIH06IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcyk6IEpTWC5FbGVtZW50ID0+IHtcclxuICBjb25zdCB7IHNpdGVjb3JlQ29udGV4dCB9ID0gdXNlU2l0ZWNvcmVDb250ZXh0PFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHRWYWx1ZT4oKTtcclxuXHJcbiAgY29uc3QgZGlzY29ubmVjdGVkTW9kZSA9XHJcbiAgICBzaXRlY29yZUNvbnRleHQucm91dGUgJiYgc2l0ZWNvcmVDb250ZXh0LnJvdXRlLmxheW91dElkID09PSAnYXZhaWxhYmxlLWluLWNvbm5lY3RlZC1tb2RlJztcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgZGF0YS1lMmUtaWQ9XCJncmFwaHFsLWxheW91dFwiPlxyXG4gICAgICB7ZGlzY29ubmVjdGVkTW9kZSAmJiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICBUaGlzIGFwcCBpcyBydW5uaW5nIGluIGRpc2Nvbm5lY3RlZCBtb2RlLiBHcmFwaFFMIHJlcXVpcmVzIGNvbm5lY3RlZCBtb2RlLCBoZWFkbGVzc1xyXG4gICAgICAgICAgICBjb25uZWN0ZWQgbW9kZSwgb3IgaW50ZWdyYXRlZCBtb2RlIHRvIHdvcmsuXHJcbiAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgTGlicmFyaWVzIHN1Y2ggYXMgPGNvZGU+Z3JhcGhxbC10b29sczwvY29kZT4gY2FuIHByb3ZpZGUgR3JhcGhRTCBBUEkgbW9ja2luZ1xyXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXMsIHdoaWNoIGNvdWxkIGVuYWJsZSBkaXNjb25uZWN0ZWQgR3JhcGhRTC4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIG91dCBvZiB0aGVcclxuICAgICAgICAgICAgYm94LCBob3dldmVyLlxyXG4gICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgIFRvIHZpZXcgdGhlIEdyYXBoUUwgc2FtcGxlcywgcmVzdGFydCB0aGUgYXBwIHVzaW5nIDxjb2RlPmpzcyBzdGFydDpjb25uZWN0ZWQ8L2NvZGU+XHJcbiAgICAgICAgICAgICZuYnNwOyBvciBkZXBsb3kgdGhlIGFwcCB0byBTaXRlY29yZSB0byBydW4gaW4gaW50ZWdyYXRlZCBtb2RlIHBlciB0aGUgSlNTXHJcbiAgICAgICAgICAgIGRvY3VtZW50YXRpb24uXHJcbiAgICAgICAgICA8L3A+XHJcbiAgICAgICAgPC8+XHJcbiAgICAgICl9XHJcbiAgICAgIHshZGlzY29ubmVjdGVkTW9kZSAmJiA8UGxhY2Vob2xkZXIgbmFtZT1cImpzcy1ncmFwaHFsLWxheW91dFwiIHJlbmRlcmluZz17cmVuZGVyaW5nfSAvPn1cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHcmFwaFFMTGF5b3V0O1xyXG4iLCJpbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJy4vU3R5bGVndWlkZS1TcGVjaW1lbic7XHJcbmltcG9ydCB7IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcywgU3R5bGVndWlkZVNwZWNpbWVuRmllbGRzIH0gZnJvbSAnbGliL2NvbXBvbmVudC1wcm9wcyc7XHJcblxyXG50eXBlIFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXNQcm9wcyA9IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcyAmXHJcbiAgU3R5bGVndWlkZVNwZWNpbWVuRmllbGRzICYge1xyXG4gICAgcGFyYW1zOiB7XHJcbiAgICAgIGNzc0NsYXNzOiBzdHJpbmc7XHJcbiAgICAgIGNvbHVtbnM6IHN0cmluZztcclxuICAgICAgdXNlQ2FsbFRvQWN0aW9uOiAnZmFsc2UnIHwgJ3RydWUnO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuY29uc3QgU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcyA9IChwcm9wczogU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtc1Byb3BzKTogSlNYLkVsZW1lbnQgPT4ge1xyXG4gIC8vIHByb3BzLnBhcmFtcyAoaS5lLiBwcm9wcy5wYXJhbXMuY3NzQ2xhc3Mgd2l0aG91dCBkZXN0cnVjdHVyaW5nKSBjb250YWlucyB0aGUgY29tcG9uZW50J3MgcGFyYW1zXHJcbiAgY29uc3QgeyBjc3NDbGFzcywgY29sdW1ucywgdXNlQ2FsbFRvQWN0aW9uIH0gPSBwcm9wcy5wYXJhbXM7XHJcblxyXG4gIGNvbnN0IGNvbHVtbnNBcnJheSA9IGNvbHVtbnMgJiYgWy4uLkFycmF5KHBhcnNlSW50KGNvbHVtbnMpKV07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U3R5bGVndWlkZVNwZWNpbWVuIHsuLi5wcm9wc30gZTJlSWQ9XCJzdHlsZWd1aWRlLWNvbXBvbmVudHBhcmFtc1wiPlxyXG4gICAgICA8cCBjbGFzc05hbWU9e2Nzc0NsYXNzfT5cclxuICAgICAgICBUaGUgQ1NTIGNsYXNzIG9mIHRoaXMgcGFyYWdyYXBoICg8Y29kZT57Y3NzQ2xhc3N9PC9jb2RlPikgaXMgc2V0IHVzaW5nIGEgcGFyYW1cclxuICAgICAgPC9wPlxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIHsvKiBOb3RlIHRoYXQgYWxsIHBhcmFtcyBjb21lIGluIGFzIHN0cmluZyB2YWx1ZXMsIGxpa2UgdGhpcyBib29sZWFuLWxpa2UgcGFyYW0gaGVyZTogKi99XHJcbiAgICAgICAgdXNlQ2FsbFRvQWN0aW9uIHBhcmFtOiA8Y29kZT57dXNlQ2FsbFRvQWN0aW9ufTwvY29kZT5cclxuICAgICAgICA8YnIgLz5cclxuICAgICAgICBwYXJhbSB0eXBlOiA8Y29kZT57dHlwZW9mIHVzZUNhbGxUb0FjdGlvbn08L2NvZGU+XHJcbiAgICAgICAge3VzZUNhbGxUb0FjdGlvbiA9PT0gJ3RydWUnICYmIChcclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWxlcnQgYWxlcnQtaW5mb1wiPnRoZSBjYWxsIHRvIGFjdGlvbiBpcyBzaG93bjwvZGl2PlxyXG4gICAgICAgICl9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8cD5jb2x1bW5zIHBhcmFtOiB7Y29sdW1uc308L3A+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XHJcbiAgICAgICAge2NvbHVtbnNBcnJheSAmJlxyXG4gICAgICAgICAgY29sdW1uc0FycmF5Lm1hcCgoXywgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgPGRpdiBrZXk9e2Bjb2wtJHtpbmRleH1gfSBjbGFzc05hbWU9XCJjb2wtc21cIj5cclxuICAgICAgICAgICAgICBDb2x1bW4ge2luZGV4fVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICkpfVxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvU3R5bGVndWlkZVNwZWNpbWVuPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHlsZWd1aWRlQ29tcG9uZW50UGFyYW1zO1xyXG4iLCJpbXBvcnQgTGluayBmcm9tICduZXh0L2xpbmsnO1xyXG5pbXBvcnQgeyB1c2VTaXRlY29yZUNvbnRleHQsIFRleHQsIFJpY2hUZXh0LCBGaWVsZCB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcyc7XHJcbmltcG9ydCB7IFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHRWYWx1ZSB9IGZyb20gJ2xpYi9jb21wb25lbnQtcHJvcHMnO1xyXG5cclxudHlwZSBTdHlsZWd1aWRlQ3VzdG9tUm91dGVUeXBlQ29udGV4dCA9IFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHRWYWx1ZSAmIHtcclxuICByb3V0ZToge1xyXG4gICAgZmllbGRzOiB7XHJcbiAgICAgIGhlYWRsaW5lOiBGaWVsZDxzdHJpbmc+O1xyXG4gICAgICBhdXRob3I6IEZpZWxkPHN0cmluZz47XHJcbiAgICAgIGNvbnRlbnQ6IEZpZWxkPHN0cmluZz47XHJcbiAgICB9O1xyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCBTdHlsZWd1aWRlQ3VzdG9tUm91dGVUeXBlID0gKCk6IEpTWC5FbGVtZW50ID0+IHtcclxuICAvLyB1c2VTaXRlY29yZUNvbnRleHQoKSBpcyB0aGUgbWFnaWNhbCBnbHVlIHRoYXQgZ2l2ZXMgeW91IHJvdXRlLWxldmVsIGNvbnRleHQgYWNjZXNzXHJcbiAgLy8gc2VlIHRoZSBjb250ZXh0IGV4YW1wbGVzIGluIHRoZSBzdHlsZWd1aWRlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgLy8gdGhpcyBmYW5jeSBkZXN0cnVjdHVyZSBzeW50YXggaXMgZXNzZW50aWFsbHkgZXF1aXZhbGVudCB0b1xyXG4gIC8vIGNvbnN0IGZpZWxkcyA9IHByb3BzLnNpdGVjb3JlQ29udGV4dC5yb3V0ZS5maWVsZHNcclxuICBjb25zdCB7XHJcbiAgICBzaXRlY29yZUNvbnRleHQ6IHtcclxuICAgICAgcm91dGU6IHsgZmllbGRzIH0sXHJcbiAgICB9LFxyXG4gIH0gPSB1c2VTaXRlY29yZUNvbnRleHQ8U3R5bGVndWlkZUN1c3RvbVJvdXRlVHlwZUNvbnRleHQ+KCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGRhdGEtZTJlLWlkPVwic3R5bGVndWlkZS1jdXN0b21yb3V0ZXR5cGVcIj5cclxuICAgICAgPFRleHQgdGFnPVwiaDNcIiBmaWVsZD17ZmllbGRzLmhlYWRsaW5lfSAvPlxyXG5cclxuICAgICAgPHA+XHJcbiAgICAgICAgPGVtPlxyXG4gICAgICAgICAgQnkgPFRleHQgZmllbGQ9e2ZpZWxkcy5hdXRob3J9IC8+XHJcbiAgICAgICAgPC9lbT5cclxuICAgICAgPC9wPlxyXG5cclxuICAgICAgPFJpY2hUZXh0IGZpZWxkPXtmaWVsZHMuY29udGVudH0gLz5cclxuXHJcbiAgICAgIDxMaW5rIGhyZWY9XCIvc3R5bGVndWlkZVwiPlxyXG4gICAgICAgIDxhPlJldHVybiB0byB0aGUgU3R5bGVndWlkZTwvYT5cclxuICAgICAgPC9MaW5rPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZ3VpZGVDdXN0b21Sb3V0ZVR5cGU7XHJcbiIsImltcG9ydCB7IFBsYWNlaG9sZGVyIH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IFN0eWxlZ3VpZGVTcGVjaW1lbiBmcm9tICcuL1N0eWxlZ3VpZGUtU3BlY2ltZW4nO1xyXG5pbXBvcnQgeyBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMsIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyB9IGZyb20gJ2xpYi9jb21wb25lbnQtcHJvcHMnO1xyXG5cclxudHlwZSBTdHlsZWd1aWRlTGF5b3V0UmV1c2VQcm9wcyA9IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcyAmIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcztcclxuXHJcbi8qKlxyXG4gKiBEZW1vbnN0cmF0ZXMgaG93IHRvIHJldXNlIGNvbnRlbnQgd2l0aGluIEpTUy4gU2VlIC9kYXRhL3JvdXRlcy9zdHlsZWd1aWRlL2VuLnltbFxyXG4gKiBmb3IgdGhlIHJldXNlZCBjb250ZW50IGRlZmluaXRpb24gc2FtcGxlLiBUaGlzIGNvbXBvbmVudCBhbHNvIGRlbW9uc3RyYXRlcyBob3cgdG8gdXNlXHJcbiAqIHRoZSBQbGFjZWhvbGRlciBjb21wb25lbnQncyByZW5kZXIgcHJvcHMgQVBJIHRvIHdyYXAgYWxsIGNvbXBvbmVudHMgaW4gdGhlIHBsYWNlaG9sZGVyXHJcbiAqIGluIGEgY29sdW1uIHRhZyAodGh1cyBjcmVhdGluZyBhIGhvcml6b250YWxseSBsYWlkIG91dCBwbGFjZWhvbGRlcilcclxuICovXHJcbmNvbnN0IFN0eWxlZ3VpZGVMYXlvdXRSZXVzZSA9IChwcm9wczogU3R5bGVndWlkZUxheW91dFJldXNlUHJvcHMpOiBKU1guRWxlbWVudCA9PiAoXHJcbiAgPFN0eWxlZ3VpZGVTcGVjaW1lbiB7Li4ucHJvcHN9IGUyZUlkPVwic3R5bGVndWlkZS1sYXlvdXQtcmV1c2VcIj5cclxuICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XHJcbiAgICAgIHsvKlxyXG4gICAgICAgIFRoaXMgcGxhY2Vob2xkZXIgaXMgdXNpbmcgX3JlbmRlciBwcm9wc18gdG8gZW5hYmxlIGN1c3RvbWl6aW5nIHRoZSBtYXJrdXAgZm9yIGVhY2ggY29tcG9uZW50IHdpdGhpbi5cclxuICAgICAgICBJbiB0aGlzIGNhc2UsIGl0J3MgcGxhY2luZyBlYWNoIGNvbXBvbmVudCBpbiBpdHMgb3duIGNvbHVtbiBvZiBhIGZsZXhib3ggbGF5b3V0IC0gZ2l2aW5nIGFuIG4tdXAgY29sdW1uYXIgbGF5b3V0LlxyXG4gICAgICAgIFRoZSBjb21wb25lbnQgaXRzZWxmIGRvZXMgbm90IG5lZWQgdG8ga25vdyBpdCdzIGxpdmluZyBpbiBhIGNvbHVtbmFyIGxheW91dC5cclxuXHJcbiAgICAgICAgVGhlcmUgYXJlIHRocmVlIHJlbmRlciBwcm9wcyBhdmFpbGFibGU6XHJcbiAgICAgICAgcmVuZGVyRWFjaCAtIGNhbGxlZCBvbmNlIGZvciBlYWNoIGNvbnRlbnQgY29tcG9uZW50XHJcbiAgICAgICAgICBTaXRlY29yZSBFeHBlcmllbmNlIEVkaXRvciBtYXJrdXAgaXMgYXV0b21hdGljYWxseSByZW5kZXJlZCBpbiBiZXR3ZWVuIGNvbnRlbnQgY29tcG9uZW50cyB3aGVuIHByZXNlbnRcclxuICAgICAgICByZW5kZXJFbXB0eSAtIGNhbGxlZCB3aGVuIHRoZSBwbGFjZWhvbGRlciBjb250YWlucyBubyBjb250ZW50IGNvbXBvbmVudHMuIENhbiBiZSB1c2VkIHRvIHdyYXAgdGhlIFNpdGVjb3JlIEVFIGVtcHR5IHBsYWNlaG9sZGVyXHJcbiAgICAgICAgICBtYXJrdXAgaW4gc29tZXRoaW5nIHRoYXQncyB2aXN1YWxseSBjb3JyZWN0LCBsaWtlIGhlcmUgd2hlcmUgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgY29sdW1uIGRpdiB0byBtYWtlIGl0IHNlbGVjdGFibGUuXHJcbiAgICAgICAgcmVuZGVyIC0gY2FsbGVkIG9uY2UgYW5kIHBhc3NlZCBfYWxsXyBjb21wb25lbnRzIGluIHRoZSBwbGFjZWhvbGRlci4gQWxsb3dzIGN1c3RvbSBpdGVyYXRpb24uIEVFIGNvZGUgbWFya3VwIG11c3QgYmUgYWNjb3VudGVkIGZvci5cclxuXHJcbiAgICAgICAgR2VuZXJhbGx5IHNwZWFraW5nIHN0aWNrIHRvIHJlbmRlckVhY2ggYW5kIHJlbmRlckVtcHR5IHVubGVzcyBkb2luZyBzb21ldGhpbmcgcmVhbGx5IGN1c3RvbS5cclxuICAgICAgICovfVxyXG4gICAgICA8UGxhY2Vob2xkZXJcclxuICAgICAgICByZW5kZXJpbmc9e3Byb3BzLnJlbmRlcmluZ31cclxuICAgICAgICBuYW1lPVwianNzLXJldXNlLWV4YW1wbGVcIlxyXG4gICAgICAgIHJlbmRlckVhY2g9eyhjb21wb25lbnQsIGluZGV4KSA9PiAoXHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbVwiIGtleT17aW5kZXh9PlxyXG4gICAgICAgICAgICB7Y29tcG9uZW50fVxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKX1cclxuICAgICAgICByZW5kZXJFbXB0eT17KGNvbXBvbmVudHMpID0+IDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtXCI+e2NvbXBvbmVudHN9PC9kaXY+fVxyXG4gICAgICAvPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9TdHlsZWd1aWRlU3BlY2ltZW4+XHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHlsZWd1aWRlTGF5b3V0UmV1c2U7XHJcbiIsImltcG9ydCB7IFRleHQsIFJpY2hUZXh0LCB1c2VTaXRlY29yZUNvbnRleHQsIEZpZWxkIH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLCBTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0VmFsdWUgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZUxheW91dFRhYnNUYWJQcm9wcyA9IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcyAmIHtcclxuICBmaWVsZHM6IHtcclxuICAgIGNvbnRlbnQ6IEZpZWxkPHN0cmluZz47XHJcbiAgICB0aXRsZTogRmllbGQ8c3RyaW5nPjtcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYSBzaW5nbGUgdGFiIHdpdGhpbiB0aGUgdGFicyBzYW1wbGUgY29tcG9uZW50LiBUaGVzZSBhcmUgYWRkZWQgdG8gdGhlIHRhYnMgcGxhY2Vob2xkZXIuXHJcbiAqIFRoaXMgY29tcG9uZW50IGRlbW9uc3RyYXRlcyBjb25kaXRpb25hbGx5IGFsdGVyaW5nIHJlbmRlcmluZyB3aGVuIGluIHRoZSBTaXRlY29yZSBFeHBlcmllbmNlIEVkaXRvciB0byBpbXByb3ZlXHJcbiAqIGF1dGhvciBleHBlcmllbmNlLlxyXG4gKi9cclxuY29uc3QgU3R5bGVndWlkZUxheW91dFRhYnNUYWIgPSAocHJvcHM6IFN0eWxlZ3VpZGVMYXlvdXRUYWJzVGFiUHJvcHMpOiBKU1guRWxlbWVudCA9PiB7XHJcbiAgY29uc3QgeyBzaXRlY29yZUNvbnRleHQgfSA9IHVzZVNpdGVjb3JlQ29udGV4dDxTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0VmFsdWU+KCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGRhdGEtZTJlLWNsYXNzPVwic3R5bGVndWlkZS1sYXlvdXQtdGFicy10YWJcIj5cclxuICAgICAgey8qXHJcbiAgICAgICAgICBXaGVuIHdlJ3JlIGVkaXRpbmcgdGhlIHRhYnMgd2Ugc3RhY2sgZWFjaCB0YWIgdmVydGljYWxseSxcclxuICAgICAgICAgIHdoaWNoIG1lYW5zIHRoZXJlJ3Mgbm8gcmVndWxhciB0YWIgdGl0bGVzIHJlbmRlcmVkLlxyXG4gICAgICAgICAgU28gd2UgY29uZGl0aW9uYWxseSByZW5kZXIgdGhlIHRhYiB0aXRsZSBoZXJlLCB3aGVuIGVkaXRpbmcuICovfVxyXG4gICAgICB7c2l0ZWNvcmVDb250ZXh0ICYmIHNpdGVjb3JlQ29udGV4dC5wYWdlRWRpdGluZyAmJiAoXHJcbiAgICAgICAgPFRleHQgdGFnPVwiaDVcIiBmaWVsZD17cHJvcHMuZmllbGRzLnRpdGxlfSAvPlxyXG4gICAgICApfVxyXG5cclxuICAgICAgey8qIFJlYWN0LkZyYWdtZW50IHRlbGxzIFJlYWN0IHRvIG5vdCB1c2UgYW55IHdyYXBwaW5nIHRhZyBmb3IgdGhlIGNvbXBvbmVudCAqL31cclxuICAgICAgPFJpY2hUZXh0IGZpZWxkPXtwcm9wcy5maWVsZHMuY29udGVudH0gLz5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHlsZWd1aWRlTGF5b3V0VGFic1RhYjtcclxuIiwiaW1wb3J0IFJlYWN0LCB7IFJlYWN0RWxlbWVudCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgd2l0aFBsYWNlaG9sZGVyLCB3aXRoU2l0ZWNvcmVDb250ZXh0LCBUZXh0IH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IFN0eWxlZ3VpZGVTcGVjaW1lbiBmcm9tICcuL1N0eWxlZ3VpZGUtU3BlY2ltZW4nO1xyXG5pbXBvcnQgeyBTdHlsZWd1aWRlQ29tcG9uZW50V2l0aENvbnRleHRQcm9wcywgU3R5bGVndWlkZVNwZWNpbWVuRmllbGRzIH0gZnJvbSAnbGliL2NvbXBvbmVudC1wcm9wcyc7XHJcblxyXG5pbnRlcmZhY2UgU3R5bGVndWlkZUxheW91dFRhYnNTdGF0ZSB7XHJcbiAgYWN0aXZlVGFiSW5kZXg6IG51bWJlcjtcclxufVxyXG5cclxudHlwZSBTdHlsZWd1aWRlTGF5b3V0VGFic1Byb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFdpdGhDb250ZXh0UHJvcHMgJlxyXG4gIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyAmIHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHRhYnNQbGFjZWhvbGRlcjogUmVhY3RFbGVtZW50W107XHJcbiAgfTtcclxuXHJcbi8qKlxyXG4gKiBEZW1vbnN0cmF0ZXMgYWR2YW5jZWQgY29tcG9uZW50IHRlY2huaXF1ZXMgaW4gSlNTLlxyXG4gKiBUaGlzIGV4YW1wbGUgaW1wbGVtZW50cyBhIHNpbXBsZS1sb29raW5nIHRhYnMgY29tcG9uZW50LlxyXG4gKiBFYWNoIHRhYiBpcyBpdHNlbGYgYSBjaGlsZCBjb21wb25lbnQgYWRkZWQgdG8gYSBwbGFjZWhvbGRlciBkZWZpbmVkIG9uIHRoZSB0YWJzIGNvbXBvbmVudC5cclxuICogVGhlIHRhYiBjb21wb25lbnQgaW50cm9zcGVjdHMgaXRzIGNoaWxkIGNvbXBvbmVudHMgdG8gcmVuZGVyIHRoZSB0YWIgaGVhZGluZ3MgKGkuZS4gdGhlIHRhYiBjaGlsZHJlbiByZW5kZXIgcGFydGlhbCBjb250ZW50IGluIHR3byBwbGFjZXMpLlxyXG4gKiBXaGVuIHRoaXMgY29tcG9uZW50IGlzIGVkaXRlZCBpbiBTaXRlY29yZSBFeHBlcmllbmNlIEVkaXRvciwgdGhlIHRhYmJpbmcgYmVoYXZpb3IgaXMgdHVybmVkIG9mZiBhbmQgZWFjaCB0YWIgc3RhY2tzIG9uIHRvcCBvZiBlYWNoIG90aGVyXHJcbiAqIGZvciBlYXN5IGlubGluZSBlZGl0aW5nLlxyXG4gKi9cclxuY2xhc3MgU3R5bGVndWlkZUxheW91dFRhYnMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XHJcbiAgU3R5bGVndWlkZUxheW91dFRhYnNQcm9wcyxcclxuICBTdHlsZWd1aWRlTGF5b3V0VGFic1N0YXRlXHJcbj4ge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBTdHlsZWd1aWRlTGF5b3V0VGFic1Byb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgYWN0aXZlVGFiSW5kZXg6IDAsXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2V0QWN0aXZlVGFiID0gdGhpcy5zZXRBY3RpdmVUYWIuYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIHNldEFjdGl2ZVRhYihpbmRleDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnNldFN0YXRlKHsgYWN0aXZlVGFiSW5kZXg6IGluZGV4IH0pO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgY29uc3QgeyB0YWJzUGxhY2Vob2xkZXIsIHNpdGVjb3JlQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICBsZXQgdmFsaWRUYWJJbmRleCA9IDA7XHJcbiAgICBjb25zdCBpc0VkaXRpbmcgPSBzaXRlY29yZUNvbnRleHQgJiYgc2l0ZWNvcmVDb250ZXh0LnBhZ2VFZGl0aW5nO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxTdHlsZWd1aWRlU3BlY2ltZW4gey4uLnRoaXMucHJvcHN9IGUyZUlkPVwic3R5bGVndWlkZS1sYXlvdXQtdGFic1wiPlxyXG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJuYXYgbmF2LXRhYnNcIj5cclxuICAgICAgICAgIHsvKlxyXG4gICAgICAgICAgICBXaGVuIHRoZSBwYWdlIGlzIGVkaXRpbmcsIHdlIGhpZGUgdGhlIHRhYiBoZWFkaW5ncywgYmVjYXVzZSB0aGV5IGFyZSBub3QgdXBkYXRlZCB3aGVuIHhFZGl0b3IgYWRkcyBvciByZW1vdmVzIGEgdGFiIHJlbmRlcmluZy5cclxuICAgICAgICAgICAgSW5zdGVhZCwgd2Ugc2hvdyB0aGUgdGFiIGhlYWRlciBpbmxpbmUgd2l0aCB0aGUgdGFiIGNvbnRlbnRzIChzZWUgU3R5bGVndWlkZS1MYXlvdXQtVGFicy1UYWIpLlxyXG4gICAgICAgICAgKi99XHJcbiAgICAgICAgICB7IWlzRWRpdGluZyAmJlxyXG4gICAgICAgICAgICAodGFic1BsYWNlaG9sZGVyIHx8IFtdKVxyXG4gICAgICAgICAgICAgIC5maWx0ZXIoKHRhYjogUmVhY3RFbGVtZW50KSA9PiB0YWIucHJvcHMgJiYgdGFiLnByb3BzLmZpZWxkcylcclxuICAgICAgICAgICAgICAubWFwKCh0YWI6IFJlYWN0RWxlbWVudCwgaW5kZXg6IG51bWJlcikgPT4gKFxyXG4gICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCIga2V5PXtgdGFiJHtpbmRleH1gfT5cclxuICAgICAgICAgICAgICAgICAgPGFcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BuYXYtbGluayAke2luZGV4ID09PSB0aGlzLnN0YXRlLmFjdGl2ZVRhYkluZGV4ID8gJ2FjdGl2ZScgOiBudWxsfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gdGhpcy5zZXRBY3RpdmVUYWIoaW5kZXgpfVxyXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCIjdFwiXHJcbiAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICA8VGV4dCBmaWVsZD17dGFiLnByb3BzLmZpZWxkcy50aXRsZX0gLz5cclxuICAgICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICApKX1cclxuICAgICAgICA8L3VsPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC0zIGJvcmRlci1sZWZ0IGJvcmRlci1yaWdodCBib3JkZXItYm90dG9tXCI+XHJcbiAgICAgICAgICB7KHRhYnNQbGFjZWhvbGRlciB8fCBbXSkubWFwKCh0YWI6IFJlYWN0RWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdGFiLnByb3BzICYmIHRhYi5wcm9wcy5maWVsZHM7XHJcblxyXG4gICAgICAgICAgICAvLyBhbGxvdyBleHBlcmllbmNlIGVkaXRvciBtYXJrdXAgY29tcG9uZW50cyB0byByZW5kZXJcclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkICYmIGlzRWRpdGluZykgcmV0dXJuIHRhYjtcclxuXHJcbiAgICAgICAgICAgIHZhbGlkVGFiSW5kZXggKz0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIHdlIHJlbmRlciB0aGUgdGFiIGVpdGhlciBpZiBpdCdzIGFjdGl2ZSAtIG9yIHdlJ3JlIGVkaXRpbmcsXHJcbiAgICAgICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2Ugc3RhY2sgYWxsIHRhYnMgZm9yIHZpc3VhbCBlZGl0aW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmFjdGl2ZVRhYkluZGV4ID09PSB2YWxpZFRhYkluZGV4IC0gMSB8fCBpc0VkaXRpbmcpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdGFiO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgIH0pfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L1N0eWxlZ3VpZGVTcGVjaW1lbj5cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUaGlzIGlzIGEgX2hpZ2hlciBvcmRlciBjb21wb25lbnRfIHRoYXQgd2lsbCB3cmFwIG91ciBjb21wb25lbnQgYW5kIGluamVjdCBwbGFjZWhvbGRlclxyXG4vLyBkYXRhIGludG8gaXQgYXMgYSBwcm9wIChpbiB0aGlzIGNhc2UsIHByb3BzLnRhYnNQbGFjZWhvbGRlcikuXHJcbi8vIHRoaXMgYW5vdGhlciBvcHRpb24gY29tcGFyZWQgdG8gdXNpbmcgdGhlIDxQbGFjZWhvbGRlcj4gY29tcG9uZW50O1xyXG4vLyBpbiB0aGlzIGNhc2UsIGNob3NlbiBiZWNhdXNlIHdlIHByaW1hcmlseSBuZWVkIGFjY2VzcyB0byB0aGUgX2RhdGFfXHJcbi8vIG9mIHRoZSBwbGFjZWhvbGRlci5cclxuY29uc3QgdGFic0NvbXBvbmVudFdpdGhQbGFjZWhvbGRlckluamVjdGVkID0gd2l0aFBsYWNlaG9sZGVyKHtcclxuICBwbGFjZWhvbGRlcjogJ2pzcy10YWJzJyxcclxuICBwcm9wOiAndGFic1BsYWNlaG9sZGVyJyxcclxufSkoU3R5bGVndWlkZUxheW91dFRhYnMpO1xyXG5cclxuLy8gV2UgbmVlZCB0byBrbm93IGlmIGV4cGVyaWVuY2UgZWRpdG9yIGlzIGFjdGl2ZSwgdG8gZGlzYWJsZSB0aGUgZHluYW1pYyB0YWIgYmVoYXZpb3IgZm9yIGVkaXRpbmcuXHJcbi8vIFVzaW5nIHRoZSBzYW1lIHRlY2huaXF1ZSBhcyBpbmplY3RpbmcgdGhlIHBsYWNlaG9sZGVyLCB3ZSB3cmFwIHRoZSBjb21wb25lbnQgYWdhaW4gdG8gaW5qZWN0IHRoZVxyXG4vLyBgc2l0ZWNvcmVDb250ZXh0YCBwcm9wLlxyXG5jb25zdCB0YWJzV2l0aFBsYWNlaG9sZGVyQW5kU2l0ZWNvcmVDb250ZXh0ID0gd2l0aFNpdGVjb3JlQ29udGV4dCgpPFN0eWxlZ3VpZGVMYXlvdXRUYWJzUHJvcHM+KFxyXG4gIHRhYnNDb21wb25lbnRXaXRoUGxhY2Vob2xkZXJJbmplY3RlZFxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgdGFic1dpdGhQbGFjZWhvbGRlckFuZFNpdGVjb3JlQ29udGV4dDtcclxuIiwiaW1wb3J0IHtcclxuICBQbGFjZWhvbGRlcixcclxuICBnZXRDaGlsZFBsYWNlaG9sZGVyLFxyXG4gIGdldEZpZWxkVmFsdWUsXHJcbiAgQ29tcG9uZW50UmVuZGVyaW5nLFxyXG4gIEh0bWxFbGVtZW50UmVuZGVyaW5nLFxyXG59IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcyc7XHJcbmltcG9ydCB7IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcyB9IGZyb20gJ2xpYi9jb21wb25lbnQtcHJvcHMnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBtYWluIGxheW91dCAoY29sdW1ucykgb2YgdGhlIHN0eWxlZ3VpZGUuXHJcbiAqIE5hdmlnYXRpb24gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYmFzZWQgb24gdGhlIGNvbXBvbmVudHMgYWRkZWQgdG8gdGhlIGxheW91dCxcclxuICogYW5kIGRvZXMgbm90IG5lZWQgdG8gYmUgbWFudWFsbHkgbWFpbnRhaW5lZC5cclxuICovXHJcbmNvbnN0IFN0eWxlZ3VpZGVMYXlvdXQgPSAocHJvcHM6IFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcyk6IEpTWC5FbGVtZW50ID0+IHtcclxuICBjb25zdCBnZXRSZW5kZXJpbmcgPSAoc2VjdGlvbjogQ29tcG9uZW50UmVuZGVyaW5nIHwgSHRtbEVsZW1lbnRSZW5kZXJpbmcpID0+XHJcbiAgICBzZWN0aW9uIGFzIENvbXBvbmVudFJlbmRlcmluZztcclxuXHJcbiAgY29uc3QgY29udmVydFVJRCA9ICh1aWQ/OiBzdHJpbmcpID0+IHtcclxuICAgIGlmICghdWlkKSByZXR1cm4gJyc7XHJcbiAgICByZXR1cm4gdWlkLnJlcGxhY2UoL1t7fV0vZywgJycpO1xyXG4gIH07XHJcblxyXG4gIC8vIHRoaXMgY29kZSByZWFkcyB0aGUgY29tcG9uZW50cyBpbiB0aGUgY2hpbGQgcGxhY2Vob2xkZXJzIG9mIHRoaXMgY29tcG9uZW50LFxyXG4gIC8vIGFuZCBwcm9qZWN0cyB0aGVtIGludG8gdGhlIGxlZnQgbmF2aWdhdGlvbiBjb2x1bW4gZm9yIHRoZSBzdHlsZWd1aWRlXHJcbiAgY29uc3Qgc2VjdGlvbnMgPSBnZXRDaGlsZFBsYWNlaG9sZGVyKHByb3BzLnJlbmRlcmluZywgJ2pzcy1zdHlsZWd1aWRlLWxheW91dCcpXHJcbiAgICAuZmlsdGVyKChzZWN0aW9uKSA9PiBnZXRGaWVsZFZhbHVlKGdldFJlbmRlcmluZyhzZWN0aW9uKSwgJ2hlYWRpbmcnKSlcclxuICAgIC5tYXAoKHNlY3Rpb24pID0+ICh7XHJcbiAgICAgIGhlYWRpbmc6IGdldEZpZWxkVmFsdWU8c3RyaW5nPihnZXRSZW5kZXJpbmcoc2VjdGlvbiksICdoZWFkaW5nJyksXHJcbiAgICAgIGlkOiBgaSR7Y29udmVydFVJRChnZXRSZW5kZXJpbmcoc2VjdGlvbikudWlkKX1gLFxyXG4gICAgICBjaGlsZHJlbjogZ2V0Q2hpbGRQbGFjZWhvbGRlcihnZXRSZW5kZXJpbmcoc2VjdGlvbiksICdqc3Mtc3R5bGVndWlkZS1zZWN0aW9uJylcclxuICAgICAgICAuZmlsdGVyKChjb21wb25lbnQpID0+IGdldEZpZWxkVmFsdWUoZ2V0UmVuZGVyaW5nKGNvbXBvbmVudCksICdoZWFkaW5nJykpXHJcbiAgICAgICAgLm1hcCgoY29tcG9uZW50KSA9PiAoe1xyXG4gICAgICAgICAgaGVhZGluZzogZ2V0RmllbGRWYWx1ZTxzdHJpbmc+KGdldFJlbmRlcmluZyhjb21wb25lbnQpLCAnaGVhZGluZycpLFxyXG4gICAgICAgICAgaWQ6IGBpJHtjb252ZXJ0VUlEKGdldFJlbmRlcmluZyhjb21wb25lbnQpLnVpZCl9YCxcclxuICAgICAgICB9KSksXHJcbiAgICB9KSlcclxuICAgIC5tYXAoKHNlY3Rpb24pID0+IChcclxuICAgICAgPG5hdiBrZXk9e3NlY3Rpb24uaGVhZGluZ30gY2xhc3NOYW1lPVwibmF2IGZsZXgtY29sdW1uIHB0LTJcIj5cclxuICAgICAgICA8YSBocmVmPXtgIyR7c2VjdGlvbi5pZH1gfSBjbGFzc05hbWU9XCJuYXYtaXRlbSBmb250LXdlaWdodC1ib2xkXCI+XHJcbiAgICAgICAgICB7c2VjdGlvbi5oZWFkaW5nfVxyXG4gICAgICAgIDwvYT5cclxuICAgICAgICB7c2VjdGlvbi5jaGlsZHJlbiAmJiAoXHJcbiAgICAgICAgICA8bmF2IGNsYXNzTmFtZT1cIm5hdiBmbGV4LWNvbHVtblwiPlxyXG4gICAgICAgICAgICB7c2VjdGlvbi5jaGlsZHJlbi5tYXAoXHJcbiAgICAgICAgICAgICAgKGNoaWxkKSA9PlxyXG4gICAgICAgICAgICAgICAgY2hpbGQuaGVhZGluZyAmJiAoXHJcbiAgICAgICAgICAgICAgICAgIDxhIGtleT17Y2hpbGQuaWR9IGhyZWY9e2AjJHtjaGlsZC5pZH1gfT5cclxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGQuaGVhZGluZ31cclxuICAgICAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApfVxyXG4gICAgICAgICAgPC9uYXY+XHJcbiAgICAgICAgKX1cclxuICAgICAgPC9uYXY+XHJcbiAgICApKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTggY29sLWxnLTEwXCI+XHJcbiAgICAgICAgPFBsYWNlaG9sZGVyIG5hbWU9XCJqc3Mtc3R5bGVndWlkZS1sYXlvdXRcIiByZW5kZXJpbmc9e3Byb3BzLnJlbmRlcmluZ30gLz5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTQgY29sLWxnLTIgb3JkZXItc20tZmlyc3QgcHQtMlwiPntzZWN0aW9uc308L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHlsZWd1aWRlTGF5b3V0O1xyXG4iLCJpbXBvcnQgeyBUZXh0LCBGaWVsZCB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcyc7XHJcbmltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluayc7XHJcbmltcG9ydCB7IHVzZUkxOG4gfSBmcm9tICduZXh0LWxvY2FsaXphdGlvbic7XHJcbmltcG9ydCBTdHlsZWd1aWRlU3BlY2ltZW4gZnJvbSAnLi9TdHlsZWd1aWRlLVNwZWNpbWVuJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFdpdGhDb250ZXh0UHJvcHMsIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyB9IGZyb20gJ2xpYi9jb21wb25lbnQtcHJvcHMnO1xyXG5cclxudHlwZSBTdHlsZWd1aWRlTXVsdGlsaW5ndWFsUHJvcHMgPSBTdHlsZWd1aWRlQ29tcG9uZW50V2l0aENvbnRleHRQcm9wcyAmXHJcbiAgU3R5bGVndWlkZVNwZWNpbWVuRmllbGRzICYge1xyXG4gICAgZmllbGRzOiB7XHJcbiAgICAgIHNhbXBsZTogRmllbGQ8c3RyaW5nPjtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbi8qKlxyXG4gKiBEZW1vbnN0cmF0ZXMgdXNpbmcgdGhlIGRpY3Rpb25hcnkgZnVuY3Rpb25hbGl0eSBhbmQgZGVmaW5pbmcgcm91dGUgZGF0YSBpblxyXG4gKiBtdWx0aXBsZSBsYW5ndWFnZXMuXHJcbiAqL1xyXG5jb25zdCBTdHlsZWd1aWRlTXVsdGlsaW5ndWFsID0gKHByb3BzOiBTdHlsZWd1aWRlTXVsdGlsaW5ndWFsUHJvcHMpOiBKU1guRWxlbWVudCA9PiB7XHJcbiAgY29uc3QgeyB0LCBsb2NhbGUgfSA9IHVzZUkxOG4oKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxTdHlsZWd1aWRlU3BlY2ltZW4gey4uLnByb3BzfSBlMmVJZD1cInN0eWxlZ3VpZGUtbXVsdGlsaW5ndWFsXCI+XHJcbiAgICAgIDxUZXh0IGZpZWxkPXtwcm9wcy5maWVsZHMuc2FtcGxlfSBlbmNvZGU9e2ZhbHNlfSB0YWc9XCJwXCIgLz5cclxuXHJcbiAgICAgIDxwPlxyXG4gICAgICAgIFRoaXMgaXMgYSBzdGF0aWMgZGljdGlvbmFyeSBlbnRyeSBmcm9tIDxjb2RlPi9kYXRhL2RpY3Rpb25hcnk8L2NvZGU+XHJcbiAgICAgICAgOiZuYnNwO1xyXG4gICAgICAgIHt0KCdzdHlsZWd1aWRlLXNhbXBsZScpfVxyXG4gICAgICA8L3A+XHJcblxyXG4gICAgICA8cD5cclxuICAgICAgICB7LyogSW4gY2FzZSBpZiBocmVmIGFscmVhZHkgaW5jbHVkZXMgbG9jYWxlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hZHZhbmNlZC1mZWF0dXJlcy9pMThuLXJvdXRpbmcjdHJhbnNpdGlvbi1iZXR3ZWVuLWxvY2FsZXMgKi99XHJcbiAgICAgICAgPExpbmsgaHJlZj1cIi9lbi9zdHlsZWd1aWRlXCIgbG9jYWxlPXtmYWxzZX0+XHJcbiAgICAgICAgICA8YT5TaG93IGluIEVuZ2xpc2g8L2E+XHJcbiAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgIDxiciAvPlxyXG4gICAgICAgIDxMaW5rIGhyZWY9XCIvc3R5bGVndWlkZVwiIGxvY2FsZT1cImRhLURLXCI+XHJcbiAgICAgICAgICA8YT5TaG93IGluIERhbmlzaDwvYT5cclxuICAgICAgICA8L0xpbms+XHJcbiAgICAgIDwvcD5cclxuXHJcbiAgICAgIDxwPlRoZSBjdXJyZW50IGxhbmd1YWdlIGlzOiB7bG9jYWxlKCl9PC9wPlxyXG4gICAgPC9TdHlsZWd1aWRlU3BlY2ltZW4+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWw7XHJcbiIsImltcG9ydCBMaW5rIGZyb20gJ25leHQvbGluayc7XHJcbmltcG9ydCB7IFRleHQsIEZpZWxkLCB1c2VTaXRlY29yZUNvbnRleHQgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJy4vU3R5bGVndWlkZS1TcGVjaW1lbic7XHJcbmltcG9ydCB7XHJcbiAgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLFxyXG4gIFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHRWYWx1ZSxcclxuICBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMsXHJcbn0gZnJvbSAnbGliL2NvbXBvbmVudC1wcm9wcyc7XHJcblxyXG50eXBlIFN0eWxlZ3VpZGVSb3V0ZUZpZWxkc1Byb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFByb3BzICYgU3R5bGVndWlkZVNwZWNpbWVuRmllbGRzO1xyXG5cclxudHlwZSBTdHlsZWd1aWRlUm91dGVGaWVsZHNDb250ZXh0ID0gU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dFZhbHVlICYge1xyXG4gIHJvdXRlOiB7XHJcbiAgICBmaWVsZHM6IHtcclxuICAgICAgcGFnZVRpdGxlOiBGaWVsZDxzdHJpbmc+O1xyXG4gICAgfTtcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlbW9uc3RyYXRlcyBnYWluaW5nIGFjY2VzcyB0byByb3V0ZS1sZXZlbCBmaWVsZHMuXHJcbiAqIFRoaXMgdGVjaG5pcXVlIGJ1aWxkcyBvbiB0aGUgU3R5bGVndWlkZS1TaXRlY29yZUNvbnRleHQgdGVjaG5pcXVlLFxyXG4gKiB0byBhbHNvIGdldCB0aGUgcm91dGUgbGV2ZWwgZmllbGQgZGF0YSBhbmQgbWFrZSBpdCBlZGl0YWJsZS5cclxuICovXHJcbmNvbnN0IFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcyA9IChwcm9wczogU3R5bGVndWlkZVJvdXRlRmllbGRzUHJvcHMpOiBKU1guRWxlbWVudCA9PiB7XHJcbiAgY29uc3QgeyBzaXRlY29yZUNvbnRleHQgfSA9IHVzZVNpdGVjb3JlQ29udGV4dDxTdHlsZWd1aWRlUm91dGVGaWVsZHNDb250ZXh0PigpO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFN0eWxlZ3VpZGVTcGVjaW1lbiB7Li4ucHJvcHN9IGUyZUlkPVwic3R5bGVndWlkZS1yb3V0ZS1maWVsZHNcIj5cclxuICAgICAgPHA+XHJcbiAgICAgICAgUm91dGUgbGV2ZWwgPGNvZGU+cGFnZVRpdGxlPC9jb2RlPiBmaWVsZDp7JyAnfVxyXG4gICAgICAgIHtzaXRlY29yZUNvbnRleHQucm91dGUgJiYgPFRleHQgZmllbGQ9e3NpdGVjb3JlQ29udGV4dC5yb3V0ZS5maWVsZHMucGFnZVRpdGxlfSAvPn1cclxuICAgICAgPC9wPlxyXG4gICAgICA8cD5cclxuICAgICAgICA8TGluayBocmVmPVwiL3N0eWxlZ3VpZGUvY3VzdG9tLXJvdXRlLXR5cGVcIj5cclxuICAgICAgICAgIDxhPlNhbXBsZSBvZiB1c2luZyBhIGN1c3RvbSByb3V0ZSB0eXBlPC9hPlxyXG4gICAgICAgIDwvTGluaz5cclxuICAgICAgPC9wPlxyXG4gICAgPC9TdHlsZWd1aWRlU3BlY2ltZW4+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcztcclxuIiwiaW1wb3J0IHsgRmllbGQsIFBsYWNlaG9sZGVyLCBUZXh0IH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzIH0gZnJvbSAnbGliL2NvbXBvbmVudC1wcm9wcyc7XHJcblxyXG50eXBlIFN0eWxlZ3VpZGVTZWN0aW9uUHJvcHMgPSBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMgJiB7XHJcbiAgZmllbGRzOiB7XHJcbiAgICBoZWFkaW5nOiBGaWVsZDxzdHJpbmc+O1xyXG4gIH07XHJcbn07XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGNhdGVnb3J5IG9mIHN0eWxlZ3VpZGUgc3BlY2ltZW5zIHdpdGhpbiB0aGUgU3R5bGVndWlkZS1MYXlvdXQuXHJcbiAqIFVzYWdlIGV4YW1wbGVzIGFyZSBhZGRlZCB0byB0aGUgYHN0eWxlZ3VpZGUtc2VjdGlvbmAgcGxhY2Vob2xkZXIgdGhhdCB0aGlzXHJcbiAqIGV4cG9zZXMuXHJcbiAqL1xyXG5jb25zdCBTdHlsZWd1aWRlU2VjdGlvbiA9IChwcm9wczogU3R5bGVndWlkZVNlY3Rpb25Qcm9wcyk6IEpTWC5FbGVtZW50ID0+IChcclxuICA8ZGl2IGNsYXNzTmFtZT1cInB0LTNcIiBpZD17YGkke3Byb3BzLnJlbmRlcmluZy51aWQgJiYgcHJvcHMucmVuZGVyaW5nLnVpZC5yZXBsYWNlKC9be31dL2csICcnKX1gfT5cclxuICAgIDxUZXh0IGNsYXNzTmFtZT1cImJvcmRlci1ib3R0b21cIiBmaWVsZD17cHJvcHMuZmllbGRzLmhlYWRpbmd9IHRhZz1cImgzXCIgLz5cclxuICAgIDxQbGFjZWhvbGRlciBuYW1lPVwianNzLXN0eWxlZ3VpZGUtc2VjdGlvblwiIHJlbmRlcmluZz17cHJvcHMucmVuZGVyaW5nfSAvPlxyXG4gIDwvZGl2PlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZVNlY3Rpb247XHJcbiIsImltcG9ydCB7IHVzZVNpdGVjb3JlQ29udGV4dCB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcyc7XHJcbmltcG9ydCBTdHlsZWd1aWRlU3BlY2ltZW4gZnJvbSAnLi9TdHlsZWd1aWRlLVNwZWNpbWVuJztcclxuaW1wb3J0IHtcclxuICBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMsXHJcbiAgU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dFZhbHVlLFxyXG4gIFN0eWxlZ3VpZGVDb21wb25lbnRQcm9wcyxcclxufSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dFByb3BzID0gU3R5bGVndWlkZUNvbXBvbmVudFByb3BzICYgU3R5bGVndWlkZVNwZWNpbWVuRmllbGRzO1xyXG5cclxuLyoqXHJcbiAqIERlbW9uc3RyYXRlcyBnYWluaW5nIGFjY2VzcyB0byB0aGUgcm91dGUtbGV2ZWwgU2l0ZWNvcmUgQ29udGV4dCBmcm9tXHJcbiAqIHdpdGhpbiBvdGhlciBjb21wb25lbnRzLlxyXG4gKi9cclxuY29uc3QgU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCA9IChwcm9wczogU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dFByb3BzKTogSlNYLkVsZW1lbnQgPT4ge1xyXG4gIGNvbnN0IHsgc2l0ZWNvcmVDb250ZXh0IH0gPSB1c2VTaXRlY29yZUNvbnRleHQ8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dFZhbHVlPigpO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFN0eWxlZ3VpZGVTcGVjaW1lbiB7Li4ucHJvcHN9IGUyZUlkPVwic3R5bGVndWlkZS1zaXRlY29yZS1jb250ZXh0XCI+XHJcbiAgICAgIDxwPlRoZSBjdXJyZW50IFNpdGVjb3JlIENvbnRleHQgaXMuLi48L3A+XHJcbiAgICAgIDxwcmUgc3R5bGU9e3sgbWF4SGVpZ2h0OiAnNDAwcHgnLCBvdmVyZmxvdzogJ3Njcm9sbCcgfX0+XHJcbiAgICAgICAge0pTT04uc3RyaW5naWZ5KHNpdGVjb3JlQ29udGV4dCwgbnVsbCwgMil9XHJcbiAgICAgIDwvcHJlPlxyXG4gICAgPC9TdHlsZWd1aWRlU3BlY2ltZW4+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQ7XHJcbiIsIi8vIGltcG9ydCB7IFRleHQsIFJpY2hUZXh0IH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFByb3BzLCBTdHlsZWd1aWRlU3BlY2ltZW5GaWVsZHMgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuXHJcbnR5cGUgU3R5bGVndWlkZVNwZWNpbWVuUHJvcHMgPSBTdHlsZWd1aWRlQ29tcG9uZW50UHJvcHMgJlxyXG4gIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyAmIHtcclxuICAgIGUyZUlkOiBzdHJpbmc7XHJcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xyXG4gIH07XHJcblxyXG4vKipcclxuICogSGVscGVyIGNvbXBvbmVudCB0aGF0IGRpc3BsYXlzIGV4cGxhbmF0b3J5IGluZm9ybWF0aW9uIGFuZCB3aGVyZSB0byBmaW5kIHRoZSBkZWZpbml0aW9uc1xyXG4gKiBvZiBzdHlsZWd1aWRlIHNwZWNpbWVucy5cclxuICovXHJcbmNvbnN0IFN0eWxlZ3VpZGVTcGVjaW1lbiA9ICh7XHJcbiAgLy8gZmllbGRzOiB7IGhlYWRpbmcsIGRlc2NyaXB0aW9uIH0sXHJcbiAgY2hpbGRyZW4sXHJcbiAgLy8gcmVuZGVyaW5nLFxyXG4gIGUyZUlkLFxyXG59OiBTdHlsZWd1aWRlU3BlY2ltZW5Qcm9wcyk6IEpTWC5FbGVtZW50ID0+IChcclxuICA8ZGl2XHJcbiAgICBjbGFzc05hbWU9XCJwdC0zXCJcclxuICAgIC8vIGlkPXtgaSR7cmVuZGVyaW5nLnVpZCAmJiByZW5kZXJpbmcudWlkLnJlcGxhY2UoL1t7fV0vZywgJycpfWB9XHJcbiAgICBkYXRhLWUyZS1pZD17ZTJlSWR9XHJcbiAgPlxyXG4gICAgey8qIDxUZXh0IHRhZz1cImg0XCIgZmllbGQ9e2hlYWRpbmd9IC8+ICovfVxyXG4gICAgey8qIDxSaWNoVGV4dCBmaWVsZD17ZGVzY3JpcHRpb259IC8+ICovfVxyXG5cclxuICAgIDxwPlxyXG4gICAgICA8c21hbGw+XHJcbiAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgRGVmaW5pdGlvbjp7JyAnfVxyXG4gICAgICA8L3NtYWxsPlxyXG4gICAgPC9wPlxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXIgcC0yXCI+e2NoaWxkcmVufTwvZGl2PlxyXG4gIDwvZGl2PlxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3R5bGVndWlkZVNwZWNpbWVuO1xyXG4iLCJpbXBvcnQgUmVhY3QsIHsgUmVmT2JqZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB3aXRoU2l0ZWNvcmVDb250ZXh0IH0gZnJvbSAnQHNpdGVjb3JlLWpzcy9zaXRlY29yZS1qc3MtbmV4dGpzJztcclxuaW1wb3J0IHsgdHJhY2tpbmdBcGkgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy10cmFja2luZyc7XHJcbmltcG9ydCB7IGRhdGFGZXRjaGVyIH0gZnJvbSAnbGliL2RhdGEtZmV0Y2hlcic7XHJcbmltcG9ydCBjb25maWcgZnJvbSAndGVtcC9jb25maWcnO1xyXG5pbXBvcnQgU3R5bGVndWlkZVNwZWNpbWVuIGZyb20gJy4vU3R5bGVndWlkZS1TcGVjaW1lbic7XHJcbmltcG9ydCB7IFRyYWNraW5nUmVxdWVzdE9wdGlvbnMgfSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy10cmFja2luZy90eXBlcy90cmFja2luZ1JlcXVlc3RPcHRpb25zJztcclxuaW1wb3J0IHsgU3R5bGVndWlkZUNvbXBvbmVudFdpdGhDb250ZXh0UHJvcHMsIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcyB9IGZyb20gJ2xpYi9jb21wb25lbnQtcHJvcHMnO1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbm8tYWxlcnQsbm8tdW5kZWYgKi9cclxuXHJcbnR5cGUgU3R5bGVndWlkZVRyYWNraW5nUHJvcHMgPSBTdHlsZWd1aWRlQ29tcG9uZW50V2l0aENvbnRleHRQcm9wcyAmIFN0eWxlZ3VpZGVTcGVjaW1lbkZpZWxkcztcclxuXHJcbi8qKlxyXG4gKiBEZW1vbnN0cmF0ZXMgYW5hbHl0aWNzIHRyYWNraW5nIHBhdHRlcm5zICh4REIpXHJcbiAqL1xyXG5jbGFzcyBTdHlsZWd1aWRlVHJhY2tpbmcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8U3R5bGVndWlkZVRyYWNraW5nUHJvcHM+IHtcclxuICBwcml2YXRlIGV2ZW50OiBSZWZPYmplY3Q8SFRNTElucHV0RWxlbWVudD47XHJcbiAgcHJpdmF0ZSBnb2FsOiBSZWZPYmplY3Q8SFRNTElucHV0RWxlbWVudD47XHJcbiAgcHJpdmF0ZSBvdXRjb21lTmFtZTogUmVmT2JqZWN0PEhUTUxJbnB1dEVsZW1lbnQ+O1xyXG4gIHByaXZhdGUgb3V0Y29tZVZhbHVlOiBSZWZPYmplY3Q8SFRNTElucHV0RWxlbWVudD47XHJcbiAgcHJpdmF0ZSBjYW1wYWlnbjogUmVmT2JqZWN0PEhUTUxJbnB1dEVsZW1lbnQ+O1xyXG4gIHByaXZhdGUgcGFnZUlkOiBSZWZPYmplY3Q8SFRNTElucHV0RWxlbWVudD47XHJcbiAgcHJpdmF0ZSBwYWdlVXJsOiBSZWZPYmplY3Q8SFRNTElucHV0RWxlbWVudD47XHJcblxyXG4gIHByaXZhdGUgdHJhY2tpbmdBcGlPcHRpb25zOiBUcmFja2luZ1JlcXVlc3RPcHRpb25zO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9wczogU3R5bGVndWlkZVRyYWNraW5nUHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICB0aGlzLmV2ZW50ID0gUmVhY3QuY3JlYXRlUmVmKCk7XHJcbiAgICB0aGlzLmdvYWwgPSBSZWFjdC5jcmVhdGVSZWYoKTtcclxuICAgIHRoaXMub3V0Y29tZU5hbWUgPSBSZWFjdC5jcmVhdGVSZWYoKTtcclxuICAgIHRoaXMub3V0Y29tZVZhbHVlID0gUmVhY3QuY3JlYXRlUmVmKCk7XHJcbiAgICB0aGlzLmNhbXBhaWduID0gUmVhY3QuY3JlYXRlUmVmKCk7XHJcbiAgICB0aGlzLnBhZ2VJZCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xyXG4gICAgdGhpcy5wYWdlVXJsID0gUmVhY3QuY3JlYXRlUmVmKCk7XHJcblxyXG4gICAgdGhpcy50cmFja2luZ0FwaU9wdGlvbnMgPSB7XHJcbiAgICAgIGhvc3Q6IGNvbmZpZy5zaXRlY29yZUFwaUhvc3QsXHJcbiAgICAgIHF1ZXJ5c3RyaW5nUGFyYW1zOiB7XHJcbiAgICAgICAgc2NfYXBpa2V5OiBjb25maWcuc2l0ZWNvcmVBcGlLZXksXHJcbiAgICAgIH0sXHJcbiAgICAgIGZldGNoZXI6IGRhdGFGZXRjaGVyLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN1Ym1pdEV2ZW50KCkge1xyXG4gICAgaWYgKCF0aGlzLmV2ZW50LmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICB0cmFja2luZ0FwaVxyXG4gICAgICAudHJhY2tFdmVudChbeyBldmVudElkOiB0aGlzLmV2ZW50LmN1cnJlbnQudmFsdWUgfV0sIHRoaXMudHJhY2tpbmdBcGlPcHRpb25zKVxyXG4gICAgICAudGhlbigoKSA9PiBhbGVydCgnUGFnZSBldmVudCBwdXNoZWQnKSlcclxuICAgICAgLmNhdGNoKChlcnJvcikgPT4gYWxlcnQoZXJyb3IpKTtcclxuICB9XHJcblxyXG4gIHN1Ym1pdEdvYWwoKSB7XHJcbiAgICBpZiAoIXRoaXMuZ29hbC5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgdHJhY2tpbmdBcGlcclxuICAgICAgLnRyYWNrRXZlbnQoW3sgZ29hbElkOiB0aGlzLmdvYWwuY3VycmVudC52YWx1ZSB9XSwgdGhpcy50cmFja2luZ0FwaU9wdGlvbnMpXHJcbiAgICAgIC50aGVuKCgpID0+IGFsZXJ0KCdHb2FsIHB1c2hlZCcpKVxyXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiBhbGVydChlcnJvcikpO1xyXG4gIH1cclxuXHJcbiAgc3VibWl0T3V0Y29tZSgpIHtcclxuICAgIGlmIChcclxuICAgICAgIXRoaXMucGFnZVVybC5jdXJyZW50IHx8XHJcbiAgICAgICF0aGlzLnBhZ2VJZC5jdXJyZW50IHx8XHJcbiAgICAgICF0aGlzLm91dGNvbWVOYW1lLmN1cnJlbnQgfHxcclxuICAgICAgIXRoaXMub3V0Y29tZVZhbHVlLmN1cnJlbnRcclxuICAgICkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdHJhY2tpbmdBcGlcclxuICAgICAgLnRyYWNrRXZlbnQoXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB1cmw6IHRoaXMucGFnZVVybC5jdXJyZW50LnZhbHVlLFxyXG4gICAgICAgICAgICBwYWdlSWQ6IHRoaXMucGFnZUlkLmN1cnJlbnQudmFsdWUsXHJcbiAgICAgICAgICAgIG91dGNvbWVJZDogdGhpcy5vdXRjb21lTmFtZS5jdXJyZW50LnZhbHVlLFxyXG4gICAgICAgICAgICBjdXJyZW5jeUNvZGU6ICdVU0QnLFxyXG4gICAgICAgICAgICBtb25ldGFyeVZhbHVlOiB0aGlzLm91dGNvbWVWYWx1ZS5jdXJyZW50LnZhbHVlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHRoaXMudHJhY2tpbmdBcGlPcHRpb25zXHJcbiAgICAgIClcclxuICAgICAgLnRoZW4oKCkgPT4gYWxlcnQoJ091dGNvbWUgcHVzaGVkJykpXHJcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGFsZXJ0KGVycm9yKSk7XHJcbiAgfVxyXG5cclxuICB0cmlnZ2VyQ2FtcGFpZ24oKSB7XHJcbiAgICBpZiAoIXRoaXMuY2FtcGFpZ24uY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgIHRyYWNraW5nQXBpXHJcbiAgICAgIC50cmFja0V2ZW50KFt7IGNhbXBhaWduSWQ6IHRoaXMuY2FtcGFpZ24uY3VycmVudC52YWx1ZSB9XSwgdGhpcy50cmFja2luZ0FwaU9wdGlvbnMpXHJcbiAgICAgIC50aGVuKCgpID0+IGFsZXJ0KCdDYW1wYWlnbiBzZXQnKSlcclxuICAgICAgLmNhdGNoKChlcnJvcikgPT4gYWxlcnQoZXJyb3IpKTtcclxuICB9XHJcblxyXG4gIHN1Ym1pdFBhZ2VWaWV3KCkge1xyXG4gICAgaWYgKCF0aGlzLnBhZ2VJZC5jdXJyZW50IHx8ICF0aGlzLnBhZ2VVcmwuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgIHRyYWNraW5nQXBpXHJcbiAgICAgIC50cmFja0V2ZW50KFxyXG4gICAgICAgIFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgcGFnZUlkOiB0aGlzLnBhZ2VJZC5jdXJyZW50LnZhbHVlLFxyXG4gICAgICAgICAgICB1cmw6IHRoaXMucGFnZVVybC5jdXJyZW50LnZhbHVlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHRoaXMudHJhY2tpbmdBcGlPcHRpb25zXHJcbiAgICAgIClcclxuICAgICAgLnRoZW4oKCkgPT4gYWxlcnQoJ1BhZ2UgdmlldyBwdXNoZWQnKSlcclxuICAgICAgLmNhdGNoKChlcnJvcikgPT4gYWxlcnQoZXJyb3IpKTtcclxuICB9XHJcblxyXG4gIGFiYW5kb25TZXNzaW9uKCkge1xyXG4gICAgY29uc3QgYWJhbmRvbk9wdGlvbnMgPSB7XHJcbiAgICAgIGFjdGlvbjogJ2ZsdXNoJyxcclxuICAgICAgLi4udGhpcy50cmFja2luZ0FwaU9wdGlvbnMsXHJcbiAgICB9O1xyXG5cclxuICAgIHRyYWNraW5nQXBpXHJcbiAgICAgIC50cmFja0V2ZW50KFtdLCBhYmFuZG9uT3B0aW9ucylcclxuICAgICAgLnRoZW4oKCkgPT4gYWxlcnQoJ0ludGVyYWN0aW9uIGhhcyBiZWVuIHRlcm1pbmF0ZWQgYW5kIGl0cyBkYXRhIHB1c2hlZCB0byB4Q29ubmVjdC4nKSlcclxuICAgICAgLmNhdGNoKChlcnJvcikgPT4gYWxlcnQoZXJyb3IpKTtcclxuICB9XHJcblxyXG4gIHN1Ym1pdEJhdGNoaW5nKCkge1xyXG4gICAgdHJhY2tpbmdBcGlcclxuICAgICAgLnRyYWNrRXZlbnQoXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgeyBldmVudElkOiAnRG93bmxvYWQnIH0sXHJcbiAgICAgICAgICB7IGdvYWxJZDogJ0luc3RhbnQgRGVtbycgfSxcclxuICAgICAgICAgIHsgb3V0Y29tZUlkOiAnT3Bwb3J0dW5pdHknIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHBhZ2VJZDogJ3sxMTBENTU5Ri1ERUE1LTQyRUEtOUMxQy04QTVERjdFNzBFRjl9JyxcclxuICAgICAgICAgICAgdXJsOiAnL2FyYml0cmFyeS91cmwveW91L293bicsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgLy8gdGhpcyBnb2FsIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG5ldyBwYWdlL3JvdXRlIElEIHNldCBhYm92ZSwgbm90IHRoZSBjdXJyZW50IHJvdXRlXHJcbiAgICAgICAgICB7IGdvYWxJZDogJ1JlZ2lzdGVyJyB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgdGhpcy50cmFja2luZ0FwaU9wdGlvbnNcclxuICAgICAgKVxyXG4gICAgICAudGhlbigoKSA9PiBhbGVydCgnQmF0Y2ggb2YgZXZlbnRzIHB1c2hlZCcpKVxyXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiBhbGVydChlcnJvcikpO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgY29uc3QgZGlzY29ubmVjdGVkTW9kZSA9IHRoaXMucHJvcHMuc2l0ZWNvcmVDb250ZXh0Lml0ZW1JZCA9PT0gJ2F2YWlsYWJsZS1pbi1jb25uZWN0ZWQtbW9kZSc7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPFN0eWxlZ3VpZGVTcGVjaW1lbiB7Li4udGhpcy5wcm9wc30gZTJlSWQ9XCJzdHlsZWd1aWRlLXRyYWNraW5nXCI+XHJcbiAgICAgICAge2Rpc2Nvbm5lY3RlZE1vZGUgJiYgKFxyXG4gICAgICAgICAgPHA+VGhlIHRyYWNraW5nIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBjb25uZWN0ZWQsIGludGVncmF0ZWQsIG9yIGhlYWRsZXNzIG1vZGVzLjwvcD5cclxuICAgICAgICApfVxyXG4gICAgICAgIHshZGlzY29ubmVjdGVkTW9kZSAmJiAoXHJcbiAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJhbGVydCBhbGVydC13YXJuaW5nXCI+XHJcbiAgICAgICAgICAgICAgTm90ZTogVGhlIEpTUyB0cmFja2VyIEFQSSBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LiBDb25zdWx0IHRoZXsnICd9XHJcbiAgICAgICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vanNzLnNpdGVjb3JlLmNvbS9kb2NzL2Z1bmRhbWVudGFscy9zZXJ2aWNlcy90cmFja2luZ1wiPlxyXG4gICAgICAgICAgICAgICAgdHJhY2tpbmcgZG9jdW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgIDwvYT57JyAnfVxyXG4gICAgICAgICAgICAgIHRvIGVuYWJsZSBpdC5cclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxyXG4gICAgICAgICAgICAgIDxmaWVsZHNldCBjbGFzc05hbWU9XCJmb3JtLWdyb3VwIGNvbC1zbVwiPlxyXG4gICAgICAgICAgICAgICAgPGxlZ2VuZD5FdmVudDwvbGVnZW5kPlxyXG4gICAgICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICAgIEV2ZW50cyBhcmUgZGVmaW5lZCBpbiA8Y29kZT4vc2l0ZWNvcmUvc3lzdGVtL1NldHRpbmdzL0FuYWx5dGljcy9QYWdlIEV2ZW50czwvY29kZT5cclxuICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiZXZlbnRcIj5FdmVudCBHVUlEIG9yIE5hbWU8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCJldmVudFwiIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIHJlZj17dGhpcy5ldmVudH0gLz5cclxuICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0biBidG4tcHJpbWFyeSBtdC0zXCJcclxuICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5zdWJtaXRFdmVudC5iaW5kKHRoaXMpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICBTdWJtaXRcclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgIDwvZmllbGRzZXQ+XHJcblxyXG4gICAgICAgICAgICAgIDxmaWVsZHNldCBjbGFzc05hbWU9XCJmb3JtLWdyb3VwIGNvbC1zbVwiPlxyXG4gICAgICAgICAgICAgICAgPGxlZ2VuZD5Hb2FsPC9sZWdlbmQ+XHJcbiAgICAgICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgICAgR29hbHMgYXJlIGRlZmluZWQgaW4gPGNvZGU+L3NpdGVjb3JlL3N5c3RlbS9NYXJrZXRpbmcgQ29udHJvbCBQYW5lbC9Hb2FsczwvY29kZT5cclxuICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiZ29hbFwiPkdvYWwgR1VJRCBvciBOYW1lPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXHJcbiAgICAgICAgICAgICAgICAgIGlkPVwiZ29hbFwiXHJcbiAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5nb2FsfVxyXG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cImkuZS4gUmVnaXN0ZXJcIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0biBidG4tcHJpbWFyeSBtdC0zXCJcclxuICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5zdWJtaXRHb2FsLmJpbmQodGhpcyl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgIFN1Ym1pdFxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XHJcbiAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXAgY29sLXNtXCI+XHJcbiAgICAgICAgICAgICAgICA8bGVnZW5kPk91dGNvbWU8L2xlZ2VuZD5cclxuICAgICAgICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICAgICAgICBPdXRjb21lcyBhcmUgZGVmaW5lZCBpbnsnICd9XHJcbiAgICAgICAgICAgICAgICAgIDxjb2RlPi9zaXRlY29yZS9zeXN0ZW0vTWFya2V0aW5nIENvbnRyb2wgUGFuZWwvT3V0Y29tZXM8L2NvZGU+XHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cIm91dGNvbWVOYW1lXCI+T3V0Y29tZSBHVUlEIG9yIE5hbWU8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcclxuICAgICAgICAgICAgICAgICAgaWQ9XCJvdXRjb21lTmFtZVwiXHJcbiAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5vdXRjb21lTmFtZX1cclxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJpLmUuIE1hcmtldGluZyBMZWFkXCJcclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwib3V0Y29tZVZhbHVlXCI+TW9uZXRhcnkgVmFsdWUgKG9wdGlvbmFsKTwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXHJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXHJcbiAgICAgICAgICAgICAgICAgIGlkPVwib3V0Y29tZVZhbHVlXCJcclxuICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLm91dGNvbWVWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJpLmUuIDEzMzcuMDBcIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0biBidG4tcHJpbWFyeSBtdC0zXCJcclxuICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5zdWJtaXRPdXRjb21lLmJpbmQodGhpcyl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgIFN1Ym1pdFxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuXHJcbiAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXAgY29sLXNtXCI+XHJcbiAgICAgICAgICAgICAgICA8bGVnZW5kPkNhbXBhaWduPC9sZWdlbmQ+XHJcbiAgICAgICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgICAgQ2FtcGFpZ25zIGFyZSBkZWZpbmVkIGlueycgJ31cclxuICAgICAgICAgICAgICAgICAgPGNvZGU+L3NpdGVjb3JlL3N5c3RlbS9NYXJrZXRpbmcgQ29udHJvbCBQYW5lbC9DYW1wYWlnbnM8L2NvZGU+XHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cImNhbXBhaWduXCI+Q2FtcGFpZ24gR1VJRCBvciBOYW1lPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIGlkPVwiY2FtcGFpZ25cIiByZWY9e3RoaXMuY2FtcGFpZ259IC8+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnkgbXQtM1wiXHJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMudHJpZ2dlckNhbXBhaWduLmJpbmQodGhpcyl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgIFN1Ym1pdFxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XHJcbiAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXAgY29sLXNtXCI+XHJcbiAgICAgICAgICAgICAgICA8bGVnZW5kPlBhZ2UgVmlldzwvbGVnZW5kPlxyXG4gICAgICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICAgIFRyYWNrIGFyYml0cmFyeSBwYWdlIHZpZXdzIGZvciBjdXN0b20gcm91dGluZyBvciBvZmZsaW5lIHVzZS4gTm90ZSB0aGF0IExheW91dFxyXG4gICAgICAgICAgICAgICAgICBTZXJ2aWNlIHRyYWNrcyBwYWdlIHZpZXdzIGJ5IGRlZmF1bHQgdW5sZXNzIDxjb2RlPnRyYWNraW5nPWZhbHNlPC9jb2RlPiBpcyBwYXNzZWRcclxuICAgICAgICAgICAgICAgICAgaW4gaXRzIHF1ZXJ5IHN0cmluZy5cclxuICAgICAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwicGFnZUlkXCI+UGFnZSBJdGVtIEdVSUQ8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcclxuICAgICAgICAgICAgICAgICAgaWQ9XCJwYWdlSWRcIlxyXG4gICAgICAgICAgICAgICAgICByZWY9e3RoaXMucGFnZUlkfVxyXG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cImkuZS4gezExMTExMTExLTExMTEtMTExMS0xMTExLTExMTExMTExMTExMX1cIlxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJwYWdlVXJsXCI+UGFnZSBVUkw8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcclxuICAgICAgICAgICAgICAgICAgaWQ9XCJwYWdlVXJsXCJcclxuICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLnBhZ2VVcmx9XHJcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiaS5lLiAvZm9vL2JhclwiXHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuIGJ0bi1wcmltYXJ5IG10LTNcIlxyXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLnN1Ym1pdFBhZ2VWaWV3LmJpbmQodGhpcyl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgIFN1Ym1pdFxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuXHJcbiAgICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXAgY29sLXNtXCI+XHJcbiAgICAgICAgICAgICAgICA8bGVnZW5kPkJhdGNoaW5nPC9sZWdlbmQ+XHJcbiAgICAgICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgICAgVGhlIHRyYWNraW5nIEFQSSBzdXBwb3J0cyBwdXNoaW5nIGEgd2hvbGUgYmF0Y2ggb2YgZXZlbnRzIGluIGEgc2luZ2xlIHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAgICAgIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgcXVldWluZyBzdHJhdGVnaWVzIG9yIG9mZmxpbmUgUFdBIHVzYWdlLlxyXG4gICAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuIGJ0bi1wcmltYXJ5XCJcclxuICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5zdWJtaXRCYXRjaGluZy5iaW5kKHRoaXMpfVxyXG4gICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICBTdWJtaXQgQmF0Y2ggb2YgRXZlbnRzXHJcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICA8L2ZpZWxkc2V0PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cclxuICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3NOYW1lPVwiZm9ybS1ncm91cCBjb2wtc21cIj5cclxuICAgICAgICAgICAgICAgIDxsZWdlbmQ+SW50ZXJhY3Rpb24gQ29udHJvbDwvbGVnZW5kPlxyXG4gICAgICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICAgIFRyYWNraW5nIGRhdGEgaXMgbm90IHB1c2hlZCBpbnRvIHRoZSB4Q29ubmVjdCBzZXJ2aWNlIHVudGlsIHlvdXIgc2Vzc2lvbiBlbmRzIG9uXHJcbiAgICAgICAgICAgICAgICAgIHRoZSBTaXRlY29yZSBzZXJ2ZXIuIENsaWNrIHRoaXMgYnV0dG9uIHRvIGluc3RhbnRseSBlbmQgeW91ciBzZXNzaW9uIGFuZCBmbHVzaCB0aGVcclxuICAgICAgICAgICAgICAgICAgZGF0YSAtIGdyZWF0IGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmcuXHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJhbGVydCBhbGVydC13YXJuaW5nXCI+XHJcbiAgICAgICAgICAgICAgICAgIE5vdGU6IEJ5IGRlZmF1bHQgPGVtPmFub255bW91czwvZW0+IGNvbnRhY3RzIHdpbGwgbm90IGJlIHNob3duIGluIEV4cGVyaWVuY2VcclxuICAgICAgICAgICAgICAgICAgUHJvZmlsZS4gSWYgeW91ciBpbnRlcmFjdGlvbnMgYXJlIG5vdCBzaG93aW5nIHVwIGluIEV4cGVyaWVuY2UgUHJvZmlsZSwgeW91IG1heVxyXG4gICAgICAgICAgICAgICAgICBuZWVkIHRveycgJ31cclxuICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cImh0dHBzOi8vZG9jLnNpdGVjb3JlLm5ldC9kZXZlbG9wZXJzL3hwL3hjb25uZWN0L3hjb25uZWN0LXNlYXJjaC1pbmRleGVyL2VuYWJsZS1hbm9ueW1vdXMtY29udGFjdC1pbmRleGluZy5odG1sXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlIGFub255bW91cyBjb250YWN0IGluZGV4aW5nLlxyXG4gICAgICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnlcIlxyXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmFiYW5kb25TZXNzaW9uLmJpbmQodGhpcyl9XHJcbiAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgIEVuZCBJbnRlcmFjdGlvblxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgPC9maWVsZHNldD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApfVxyXG4gICAgICA8L1N0eWxlZ3VpZGVTcGVjaW1lbj5cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB3aXRoU2l0ZWNvcmVDb250ZXh0KCkoU3R5bGVndWlkZVRyYWNraW5nKTtcclxuIiwiaW1wb3J0IHsgQXhpb3NSZXNwb25zZSB9IGZyb20gJ2F4aW9zJztcclxuaW1wb3J0IHsgQXhpb3NEYXRhRmV0Y2hlciB9IGZyb20gJ0BzaXRlY29yZS1qc3Mvc2l0ZWNvcmUtanNzLW5leHRqcyc7XHJcblxyXG4vKipcclxuICogSW1wbGVtZW50cyBhIGRhdGEgZmV0Y2hlciB1c2luZyBBeGlvcyAtIHJlcGxhY2Ugd2l0aCB5b3VyIGZhdm9yaXRlXHJcbiAqIFNTUi1jYXBhYmxlIEhUVFAgb3IgZmV0Y2ggbGlicmFyeSBpZiB5b3UgbGlrZS4gU2VlIEh0dHBEYXRhRmV0Y2hlcjxUPiB0eXBlXHJcbiAqIGluIHNpdGVjb3JlLWpzcyBsaWJyYXJ5IGZvciBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzL25vdGVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gcmVxdWVzdDsgbWF5IGluY2x1ZGUgcXVlcnkgc3RyaW5nXHJcbiAqIEBwYXJhbSB7YW55fSBkYXRhIE9wdGlvbmFsIGRhdGEgdG8gUE9TVCB3aXRoIHRoZSByZXF1ZXN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRhdGFGZXRjaGVyPFJlc3BvbnNlVHlwZT4oXHJcbiAgdXJsOiBzdHJpbmcsXHJcbiAgZGF0YT86IHVua25vd25cclxuKTogUHJvbWlzZTxBeGlvc1Jlc3BvbnNlPFJlc3BvbnNlVHlwZT4+IHtcclxuICByZXR1cm4gbmV3IEF4aW9zRGF0YUZldGNoZXIoKS5mZXRjaDxSZXNwb25zZVR5cGU+KHVybCwgZGF0YSk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEdldCB0aGUgcHVibGljVXJsLlxyXG4gKiBUaGlzIGlzIHVzZWQgcHJpbWFyaWx5IHRvIGVuYWJsZSBjb21wYXRpYmlsaXR5IHdpdGggdGhlIFNpdGVjb3JlIEV4cGVyaWVuY2UgRWRpdG9yLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFB1YmxpY1VybCA9ICgpOiBzdHJpbmcgPT4ge1xyXG4gIHJldHVybiBwcm9jZXNzLmVudi5QVUJMSUNfVVJMIHx8ICcnO1xyXG59O1xyXG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEdldFN0YXRpY1BhdGhzLCBHZXRTdGF0aWNQcm9wcyB9IGZyb20gJ25leHQnO1xyXG5pbXBvcnQgTm90Rm91bmQgZnJvbSAnc3JjL05vdEZvdW5kJztcclxuaW1wb3J0IExheW91dCBmcm9tICdzcmMvTGF5b3V0JztcclxuaW1wb3J0IHtcclxuICBTaXRlY29yZUNvbnRleHQsXHJcbiAgQ29tcG9uZW50UHJvcHNDb250ZXh0LFxyXG4gIGhhbmRsZUV4cGVyaWVuY2VFZGl0b3JGYXN0UmVmcmVzaCxcclxufSBmcm9tICdAc2l0ZWNvcmUtanNzL3NpdGVjb3JlLWpzcy1uZXh0anMnO1xyXG5pbXBvcnQgeyBTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0VmFsdWUgfSBmcm9tICdsaWIvY29tcG9uZW50LXByb3BzJztcclxuaW1wb3J0IHsgU2l0ZWNvcmVQYWdlUHJvcHMgfSBmcm9tICdsaWIvcGFnZS1wcm9wcyc7XHJcbmltcG9ydCB7IHNpdGVjb3JlUGFnZVByb3BzRmFjdG9yeSB9IGZyb20gJ2xpYi9wYWdlLXByb3BzLWZhY3RvcnknO1xyXG5pbXBvcnQgeyBjb21wb25lbnRGYWN0b3J5IH0gZnJvbSAndGVtcC9jb21wb25lbnRGYWN0b3J5JztcclxuaW1wb3J0IHsgc2l0ZW1hcEZldGNoZXIgfSBmcm9tICdsaWIvc2l0ZW1hcC1mZXRjaGVyJztcclxuXHJcbmNvbnN0IFNpdGVjb3JlUGFnZSA9ICh7IG5vdEZvdW5kLCBsYXlvdXREYXRhLCBjb21wb25lbnRQcm9wcyB9OiBTaXRlY29yZVBhZ2VQcm9wcyk6IEpTWC5FbGVtZW50ID0+IHtcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgLy8gU2luY2UgRXhwZXJpZW5jZSBFZGl0b3IgZG9lcyBub3Qgc3VwcG9ydCBGYXN0IFJlZnJlc2ggbmVlZCB0byByZWZyZXNoIEVFIGNocm9tZXMgYWZ0ZXIgRmFzdCBSZWZyZXNoIGZpbmlzaGVkXHJcbiAgICBoYW5kbGVFeHBlcmllbmNlRWRpdG9yRmFzdFJlZnJlc2goKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIGlmIChub3RGb3VuZCB8fCAhbGF5b3V0RGF0YT8uc2l0ZWNvcmU/LnJvdXRlKSB7XHJcbiAgICAvLyBTaG91bGRuJ3QgaGl0IHRoaXMgKGFzIGxvbmcgYXMgJ25vdEZvdW5kJyBpcyBiZWluZyByZXR1cm5lZCBiZWxvdyksIGJ1dCBqdXN0IHRvIGJlIHNhZmVcclxuICAgIHJldHVybiA8Tm90Rm91bmQgLz47XHJcbiAgfVxyXG5cclxuICBjb25zdCBjb250ZXh0OiBTdHlsZWd1aWRlU2l0ZWNvcmVDb250ZXh0VmFsdWUgPSB7XHJcbiAgICByb3V0ZTogbGF5b3V0RGF0YS5zaXRlY29yZS5yb3V0ZSxcclxuICAgIGl0ZW1JZDogbGF5b3V0RGF0YS5zaXRlY29yZS5yb3V0ZT8uaXRlbUlkLFxyXG4gICAgLi4ubGF5b3V0RGF0YS5zaXRlY29yZS5jb250ZXh0LFxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8Q29tcG9uZW50UHJvcHNDb250ZXh0IHZhbHVlPXtjb21wb25lbnRQcm9wc30+XHJcbiAgICAgIDxTaXRlY29yZUNvbnRleHQ8U3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dFZhbHVlPlxyXG4gICAgICAgIGNvbXBvbmVudEZhY3Rvcnk9e2NvbXBvbmVudEZhY3Rvcnl9XHJcbiAgICAgICAgY29udGV4dD17Y29udGV4dH1cclxuICAgICAgPlxyXG4gICAgICAgIDxMYXlvdXQgY29udGV4dD17Y29udGV4dH0gLz5cclxuICAgICAgPC9TaXRlY29yZUNvbnRleHQ+XHJcbiAgICA8L0NvbXBvbmVudFByb3BzQ29udGV4dD5cclxuICApO1xyXG59O1xyXG5cclxuLy8gVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBhdCBidWlsZCBhbmQgZXhwb3J0IHRpbWUgdG8gZGV0ZXJtaW5lXHJcbi8vIHBhZ2VzIGZvciBTU0cgKFwicGF0aHNcIiwgYXMgdG9rZW5pemVkIGFycmF5KS5cclxuZXhwb3J0IGNvbnN0IGdldFN0YXRpY1BhdGhzOiBHZXRTdGF0aWNQYXRocyA9IGFzeW5jIChjb250ZXh0KSA9PiB7XHJcbiAgLy8gRmFsbGJhY2ssIGFsb25nIHdpdGggcmV2YWxpZGF0ZSBpbiBnZXRTdGF0aWNQcm9wcyAoYmVsb3cpLFxyXG4gIC8vIGVuYWJsZXMgSW5jcmVtZW50YWwgU3RhdGljIFJlZ2VuZXJhdGlvbi4gVGhpcyBhbGxvd3MgdXMgdG9cclxuICAvLyBsZWF2ZSBjZXJ0YWluIChvciBhbGwpIHBhdGhzIGVtcHR5IGlmIGRlc2lyZWQgYW5kIHN0YXRpYyBwYWdlc1xyXG4gIC8vIHdpbGwgYmUgZ2VuZXJhdGVkIG9uIHJlcXVlc3QgKGRldmVsb3BtZW50IG1vZGUgaW4gdGhpcyBleGFtcGxlKS5cclxuICAvLyBBbHRlcm5hdGl2ZWx5LCB0aGUgZW50aXJlIHNpdGVtYXAgY291bGQgYmUgcHJlLXJlbmRlcmVkXHJcbiAgLy8gYWhlYWQgb2YgdGltZSAobm9uLWRldmVsb3BtZW50IG1vZGUgaW4gdGhpcyBleGFtcGxlKS5cclxuICAvLyBTZWUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYmFzaWMtZmVhdHVyZXMvZGF0YS1mZXRjaGluZyNpbmNyZW1lbnRhbC1zdGF0aWMtcmVnZW5lcmF0aW9uXHJcblxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xyXG4gICAgLy8gTm90ZTogTmV4dC5qcyBydW5zIGV4cG9ydCBpbiBwcm9kdWN0aW9uIG1vZGVcclxuICAgIGNvbnN0IHBhdGhzID0gYXdhaXQgc2l0ZW1hcEZldGNoZXIuZmV0Y2goY29udGV4dCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcGF0aHMsXHJcbiAgICAgIGZhbGxiYWNrOiBwcm9jZXNzLmVudi5FWFBPUlRfTU9ERSA/IGZhbHNlIDogJ2Jsb2NraW5nJyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcGF0aHM6IFtdLFxyXG4gICAgZmFsbGJhY2s6ICdibG9ja2luZycsXHJcbiAgfTtcclxufTtcclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgYXQgYnVpbGQgdGltZSBvbiBzZXJ2ZXItc2lkZS5cclxuLy8gSXQgbWF5IGJlIGNhbGxlZCBhZ2Fpbiwgb24gYSBzZXJ2ZXJsZXNzIGZ1bmN0aW9uLCBpZlxyXG4vLyByZXZhbGlkYXRpb24gKG9yIGZhbGxiYWNrKSBpcyBlbmFibGVkIGFuZCBhIG5ldyByZXF1ZXN0IGNvbWVzIGluLlxyXG5leHBvcnQgY29uc3QgZ2V0U3RhdGljUHJvcHM6IEdldFN0YXRpY1Byb3BzID0gYXN5bmMgKGNvbnRleHQpID0+IHtcclxuICBjb25zdCBwcm9wcyA9IGF3YWl0IHNpdGVjb3JlUGFnZVByb3BzRmFjdG9yeS5jcmVhdGUoY29udGV4dCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBwcm9wcyxcclxuICAgIC8vIE5leHQuanMgd2lsbCBhdHRlbXB0IHRvIHJlLWdlbmVyYXRlIHRoZSBwYWdlOlxyXG4gICAgLy8gLSBXaGVuIGEgcmVxdWVzdCBjb21lcyBpblxyXG4gICAgLy8gLSBBdCBtb3N0IG9uY2UgZXZlcnkgNSBzZWNvbmRzXHJcbiAgICByZXZhbGlkYXRlOiA1LCAvLyBJbiBzZWNvbmRzXHJcbiAgICBub3RGb3VuZDogcHJvcHMubm90Rm91bmQsIC8vIFJldHVybnMgY3VzdG9tIDQwNCBwYWdlIHdpdGggYSBzdGF0dXMgY29kZSBvZiA0MDQgd2hlbiB0cnVlXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNpdGVjb3JlUGFnZTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSwgaXQgaXMgYXV0by1nZW5lcmF0ZWQgYXQgYnVpbGQgdGltZSFcbi8vIFNlZSBzY3JpcHRzL2dlbmVyYXRlLWNvbXBvbmVudC1mYWN0b3J5LnRzIHRvIG1vZGlmeSB0aGUgZ2VuZXJhdGlvbiBvZiB0aGlzIGZpbGUuXG5pbXBvcnQgKiBhcyBDb250ZW50QmxvY2sgZnJvbSAnc3JjL2NvbXBvbmVudHMvQ29udGVudEJsb2NrJztcbmltcG9ydCAqIGFzIEhlcm8gZnJvbSAnc3JjL2NvbXBvbmVudHMvSGVybyc7XG5pbXBvcnQgKiBhcyBTdHlsZWd1aWRlRmllbGRVc2FnZUNoZWNrYm94IGZyb20gJ3NyYy9jb21wb25lbnRzL2ZpZWxkcy9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ2hlY2tib3gnO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCBmcm9tICdzcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUNvbnRlbnRMaXN0JztcbmltcG9ydCAqIGFzIFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tIGZyb20gJ3NyYy9jb21wb25lbnRzL2ZpZWxkcy9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtQ3VzdG9tJztcbmltcG9ydCAqIGFzIFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSBmcm9tICdzcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLURhdGUnO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZUZpZWxkVXNhZ2VGaWxlIGZyb20gJ3NyYy9jb21wb25lbnRzL2ZpZWxkcy9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtRmlsZSc7XG5pbXBvcnQgKiBhcyBTdHlsZWd1aWRlRmllbGRVc2FnZUltYWdlIGZyb20gJ3NyYy9jb21wb25lbnRzL2ZpZWxkcy9TdHlsZWd1aWRlLUZpZWxkVXNhZ2UtSW1hZ2UnO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZUZpZWxkVXNhZ2VJdGVtTGluayBmcm9tICdzcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUl0ZW1MaW5rJztcbmltcG9ydCAqIGFzIFN0eWxlZ3VpZGVGaWVsZFVzYWdlTGluayBmcm9tICdzcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLUxpbmsnO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIgZnJvbSAnc3JjL2NvbXBvbmVudHMvZmllbGRzL1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1OdW1iZXInO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZUZpZWxkVXNhZ2VSaWNoVGV4dCBmcm9tICdzcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLVJpY2hUZXh0JztcbmltcG9ydCAqIGFzIFN0eWxlZ3VpZGVGaWVsZFVzYWdlVGV4dCBmcm9tICdzcmMvY29tcG9uZW50cy9maWVsZHMvU3R5bGVndWlkZS1GaWVsZFVzYWdlLVRleHQnO1xuaW1wb3J0ICogYXMgR3JhcGhRTENvbm5lY3RlZERlbW8gZnJvbSAnc3JjL2NvbXBvbmVudHMvZ3JhcGhxbC9HcmFwaFFMLUNvbm5lY3RlZERlbW8nO1xuaW1wb3J0ICogYXMgR3JhcGhRTEludGVncmF0ZWREZW1vIGZyb20gJ3NyYy9jb21wb25lbnRzL2dyYXBocWwvR3JhcGhRTC1JbnRlZ3JhdGVkRGVtbyc7XG5pbXBvcnQgKiBhcyBHcmFwaFFMTGF5b3V0IGZyb20gJ3NyYy9jb21wb25lbnRzL2dyYXBocWwvR3JhcGhRTC1MYXlvdXQnO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZUNvbXBvbmVudFBhcmFtcyBmcm9tICdzcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtQ29tcG9uZW50UGFyYW1zJztcbmltcG9ydCAqIGFzIFN0eWxlZ3VpZGVDdXN0b21Sb3V0ZVR5cGUgZnJvbSAnc3JjL2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLUN1c3RvbVJvdXRlVHlwZSc7XG5pbXBvcnQgKiBhcyBTdHlsZWd1aWRlTGF5b3V0UmV1c2UgZnJvbSAnc3JjL2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLUxheW91dC1SZXVzZSc7XG5pbXBvcnQgKiBhcyBTdHlsZWd1aWRlTGF5b3V0VGFic1RhYiBmcm9tICdzcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtTGF5b3V0LVRhYnMtVGFiJztcbmltcG9ydCAqIGFzIFN0eWxlZ3VpZGVMYXlvdXRUYWJzIGZyb20gJ3NyYy9jb21wb25lbnRzL3N0eWxlZ3VpZGUvU3R5bGVndWlkZS1MYXlvdXQtVGFicyc7XG5pbXBvcnQgKiBhcyBTdHlsZWd1aWRlTGF5b3V0IGZyb20gJ3NyYy9jb21wb25lbnRzL3N0eWxlZ3VpZGUvU3R5bGVndWlkZS1MYXlvdXQnO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZU11bHRpbGluZ3VhbCBmcm9tICdzcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtTXVsdGlsaW5ndWFsJztcbmltcG9ydCAqIGFzIFN0eWxlZ3VpZGVSb3V0ZUZpZWxkcyBmcm9tICdzcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtUm91dGVGaWVsZHMnO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZVNlY3Rpb24gZnJvbSAnc3JjL2NvbXBvbmVudHMvc3R5bGVndWlkZS9TdHlsZWd1aWRlLVNlY3Rpb24nO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZVNpdGVjb3JlQ29udGV4dCBmcm9tICdzcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtU2l0ZWNvcmVDb250ZXh0JztcbmltcG9ydCAqIGFzIFN0eWxlZ3VpZGVTcGVjaW1lbiBmcm9tICdzcmMvY29tcG9uZW50cy9zdHlsZWd1aWRlL1N0eWxlZ3VpZGUtU3BlY2ltZW4nO1xuaW1wb3J0ICogYXMgU3R5bGVndWlkZVRyYWNraW5nIGZyb20gJ3NyYy9jb21wb25lbnRzL3N0eWxlZ3VpZGUvU3R5bGVndWlkZS1UcmFja2luZyc7XG5cbmNvbnN0IGNvbXBvbmVudHMgPSBuZXcgTWFwKCk7XG5jb21wb25lbnRzLnNldCgnQ29udGVudEJsb2NrJywgQ29udGVudEJsb2NrKTtcbmNvbXBvbmVudHMuc2V0KCdIZXJvJywgSGVybyk7XG5jb21wb25lbnRzLnNldCgnU3R5bGVndWlkZS1GaWVsZFVzYWdlLUNoZWNrYm94JywgU3R5bGVndWlkZUZpZWxkVXNhZ2VDaGVja2JveCk7XG5jb21wb25lbnRzLnNldCgnU3R5bGVndWlkZS1GaWVsZFVzYWdlLUNvbnRlbnRMaXN0JywgU3R5bGVndWlkZUZpZWxkVXNhZ2VDb250ZW50TGlzdCk7XG5jb21wb25lbnRzLnNldCgnU3R5bGVndWlkZS1GaWVsZFVzYWdlLUN1c3RvbScsIFN0eWxlZ3VpZGVGaWVsZFVzYWdlQ3VzdG9tKTtcbmNvbXBvbmVudHMuc2V0KCdTdHlsZWd1aWRlLUZpZWxkVXNhZ2UtRGF0ZScsIFN0eWxlZ3VpZGVGaWVsZFVzYWdlRGF0ZSk7XG5jb21wb25lbnRzLnNldCgnU3R5bGVndWlkZS1GaWVsZFVzYWdlLUZpbGUnLCBTdHlsZWd1aWRlRmllbGRVc2FnZUZpbGUpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1JbWFnZScsIFN0eWxlZ3VpZGVGaWVsZFVzYWdlSW1hZ2UpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1JdGVtTGluaycsIFN0eWxlZ3VpZGVGaWVsZFVzYWdlSXRlbUxpbmspO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1MaW5rJywgU3R5bGVndWlkZUZpZWxkVXNhZ2VMaW5rKTtcbmNvbXBvbmVudHMuc2V0KCdTdHlsZWd1aWRlLUZpZWxkVXNhZ2UtTnVtYmVyJywgU3R5bGVndWlkZUZpZWxkVXNhZ2VOdW1iZXIpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1SaWNoVGV4dCcsIFN0eWxlZ3VpZGVGaWVsZFVzYWdlUmljaFRleHQpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtRmllbGRVc2FnZS1UZXh0JywgU3R5bGVndWlkZUZpZWxkVXNhZ2VUZXh0KTtcbmNvbXBvbmVudHMuc2V0KCdHcmFwaFFMLUNvbm5lY3RlZERlbW8nLCBHcmFwaFFMQ29ubmVjdGVkRGVtbyk7XG5jb21wb25lbnRzLnNldCgnR3JhcGhRTC1JbnRlZ3JhdGVkRGVtbycsIEdyYXBoUUxJbnRlZ3JhdGVkRGVtbyk7XG5jb21wb25lbnRzLnNldCgnR3JhcGhRTC1MYXlvdXQnLCBHcmFwaFFMTGF5b3V0KTtcbmNvbXBvbmVudHMuc2V0KCdTdHlsZWd1aWRlLUNvbXBvbmVudFBhcmFtcycsIFN0eWxlZ3VpZGVDb21wb25lbnRQYXJhbXMpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtQ3VzdG9tUm91dGVUeXBlJywgU3R5bGVndWlkZUN1c3RvbVJvdXRlVHlwZSk7XG5jb21wb25lbnRzLnNldCgnU3R5bGVndWlkZS1MYXlvdXQtUmV1c2UnLCBTdHlsZWd1aWRlTGF5b3V0UmV1c2UpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtTGF5b3V0LVRhYnMtVGFiJywgU3R5bGVndWlkZUxheW91dFRhYnNUYWIpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtTGF5b3V0LVRhYnMnLCBTdHlsZWd1aWRlTGF5b3V0VGFicyk7XG5jb21wb25lbnRzLnNldCgnU3R5bGVndWlkZS1MYXlvdXQnLCBTdHlsZWd1aWRlTGF5b3V0KTtcbmNvbXBvbmVudHMuc2V0KCdTdHlsZWd1aWRlLU11bHRpbGluZ3VhbCcsIFN0eWxlZ3VpZGVNdWx0aWxpbmd1YWwpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtUm91dGVGaWVsZHMnLCBTdHlsZWd1aWRlUm91dGVGaWVsZHMpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtU2VjdGlvbicsIFN0eWxlZ3VpZGVTZWN0aW9uKTtcbmNvbXBvbmVudHMuc2V0KCdTdHlsZWd1aWRlLVNpdGVjb3JlQ29udGV4dCcsIFN0eWxlZ3VpZGVTaXRlY29yZUNvbnRleHQpO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtU3BlY2ltZW4nLCBTdHlsZWd1aWRlU3BlY2ltZW4pO1xuY29tcG9uZW50cy5zZXQoJ1N0eWxlZ3VpZGUtVHJhY2tpbmcnLCBTdHlsZWd1aWRlVHJhY2tpbmcpO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50TW9kdWxlKGNvbXBvbmVudE5hbWU6IHN0cmluZykge1xuICByZXR1cm4gY29tcG9uZW50cy5nZXQoY29tcG9uZW50TmFtZSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50RmFjdG9yeShjb21wb25lbnROYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGNvbXBvbmVudHMuZ2V0KGNvbXBvbmVudE5hbWUpPy5kZWZhdWx0O1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUsIGl0IGlzIGF1dG8tZ2VuZXJhdGVkIGF0IGJ1aWxkIHRpbWUhXG4vLyBTZWUgc2NyaXB0cy9ib290c3RyYXAudHMgdG8gbW9kaWZ5IHRoZSBnZW5lcmF0aW9uIG9mIHRoaXMgZmlsZS5cbmNvbnN0IGNvbmZpZyA9IHt9O1xuY29uZmlnLnNpdGVjb3JlQXBpS2V5ID0gcHJvY2Vzcy5lbnYuU0lURUNPUkVfQVBJX0tFWSB8fCBcIkM5QTFDNDA0LTIzMUItNERDRS04ODJGLTc3NzU3ODg1RUVBMVwiLFxuY29uZmlnLnNpdGVjb3JlQXBpSG9zdCA9IHByb2Nlc3MuZW52LlNJVEVDT1JFX0FQSV9IT1NUIHx8IFwiaHR0cHM6Ly9qc3NzYW5kYm94LnNjL1wiLFxuY29uZmlnLmpzc0FwcE5hbWUgPSBwcm9jZXNzLmVudi5KU1NfQVBQX05BTUUgfHwgXCJqc3MtbmV4dGpzLWFwcFwiLFxuY29uZmlnLmdyYXBoUUxFbmRwb2ludFBhdGggPSBwcm9jZXNzLmVudi5HUkFQSF9RTF9FTkRQT0lOVF9QQVRIIHx8IFwiL3NpdGVjb3JlL2FwaS9ncmFwaC9lZGdlXCIsXG5jb25maWcuZ3JhcGhRTEVuZHBvaW50ID0gcHJvY2Vzcy5lbnYuR1JBUEhfUUxfRU5EUE9JTlQgfHwgYCR7Y29uZmlnLnNpdGVjb3JlQXBpSG9zdH0ke2NvbmZpZy5ncmFwaFFMRW5kcG9pbnRQYXRofWA7XG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZzsiXSwic291cmNlUm9vdCI6IiJ9